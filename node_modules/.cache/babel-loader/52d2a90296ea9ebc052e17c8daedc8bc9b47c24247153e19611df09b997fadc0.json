{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/events/Target\n */\nimport Disposable from '../Disposable.js';\nimport Event from './Event.js';\nimport { VOID } from '../functions.js';\nimport { clear } from '../obj.js';\n/**\n * @typedef {EventTarget|Target} EventTargetLike\n */\n/**\n * @classdesc\n * A simplified implementation of the W3C DOM Level 2 EventTarget interface.\n * See https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget.\n *\n * There are two important simplifications compared to the specification:\n *\n * 1. The handling of `useCapture` in `addEventListener` and\n *    `removeEventListener`. There is no real capture model.\n * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.\n *    There is no event target hierarchy. When a listener calls\n *    `stopPropagation` or `preventDefault` on an event object, it means that no\n *    more listeners after this one will be called. Same as when the listener\n *    returns false.\n */\nvar Target = /** @class */function (_super) {\n  __extends(Target, _super);\n  /**\n   * @param {*=} opt_target Default event target for dispatched events.\n   */\n  function Target(opt_target) {\n    var _this = _super.call(this) || this;\n    /**\n     * @private\n     * @type {*}\n     */\n    _this.eventTarget_ = opt_target;\n    /**\n     * @private\n     * @type {Object<string, number>}\n     */\n    _this.pendingRemovals_ = null;\n    /**\n     * @private\n     * @type {Object<string, number>}\n     */\n    _this.dispatching_ = null;\n    /**\n     * @private\n     * @type {Object<string, Array<import(\"../events.js\").Listener>>}\n     */\n    _this.listeners_ = null;\n    return _this;\n  }\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../events.js\").Listener} listener Listener.\n   */\n  Target.prototype.addEventListener = function (type, listener) {\n    if (!type || !listener) {\n      return;\n    }\n    var listeners = this.listeners_ || (this.listeners_ = {});\n    var listenersForType = listeners[type] || (listeners[type] = []);\n    if (listenersForType.indexOf(listener) === -1) {\n      listenersForType.push(listener);\n    }\n  };\n  /**\n   * Dispatches an event and calls all listeners listening for events\n   * of this type. The event parameter can either be a string or an\n   * Object with a `type` property.\n   *\n   * @param {import(\"./Event.js\").default|string} event Event object.\n   * @return {boolean|undefined} `false` if anyone called preventDefault on the\n   *     event object or if any of the listeners returned false.\n   * @api\n   */\n  Target.prototype.dispatchEvent = function (event) {\n    /** @type {import(\"./Event.js\").default|Event} */\n    var evt = typeof event === 'string' ? new Event(event) : event;\n    var type = evt.type;\n    if (!evt.target) {\n      evt.target = this.eventTarget_ || this;\n    }\n    var listeners = this.listeners_ && this.listeners_[type];\n    var propagate;\n    if (listeners) {\n      var dispatching = this.dispatching_ || (this.dispatching_ = {});\n      var pendingRemovals = this.pendingRemovals_ || (this.pendingRemovals_ = {});\n      if (!(type in dispatching)) {\n        dispatching[type] = 0;\n        pendingRemovals[type] = 0;\n      }\n      ++dispatching[type];\n      for (var i = 0, ii = listeners.length; i < ii; ++i) {\n        if ('handleEvent' in listeners[i]) {\n          propagate = /** @type {import(\"../events.js\").ListenerObject} */listeners[i].handleEvent(evt);\n        } else {\n          propagate = /** @type {import(\"../events.js\").ListenerFunction} */listeners[i].call(this, evt);\n        }\n        if (propagate === false || evt.propagationStopped) {\n          propagate = false;\n          break;\n        }\n      }\n      --dispatching[type];\n      if (dispatching[type] === 0) {\n        var pr = pendingRemovals[type];\n        delete pendingRemovals[type];\n        while (pr--) {\n          this.removeEventListener(type, VOID);\n        }\n        delete dispatching[type];\n      }\n      return propagate;\n    }\n  };\n  /**\n   * Clean up.\n   */\n  Target.prototype.disposeInternal = function () {\n    this.listeners_ && clear(this.listeners_);\n  };\n  /**\n   * Get the listeners for a specified event type. Listeners are returned in the\n   * order that they will be called in.\n   *\n   * @param {string} type Type.\n   * @return {Array<import(\"../events.js\").Listener>|undefined} Listeners.\n   */\n  Target.prototype.getListeners = function (type) {\n    return this.listeners_ && this.listeners_[type] || undefined;\n  };\n  /**\n   * @param {string=} opt_type Type. If not provided,\n   *     `true` will be returned if this event target has any listeners.\n   * @return {boolean} Has listeners.\n   */\n  Target.prototype.hasListener = function (opt_type) {\n    if (!this.listeners_) {\n      return false;\n    }\n    return opt_type ? opt_type in this.listeners_ : Object.keys(this.listeners_).length > 0;\n  };\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../events.js\").Listener} listener Listener.\n   */\n  Target.prototype.removeEventListener = function (type, listener) {\n    var listeners = this.listeners_ && this.listeners_[type];\n    if (listeners) {\n      var index = listeners.indexOf(listener);\n      if (index !== -1) {\n        if (this.pendingRemovals_ && type in this.pendingRemovals_) {\n          // make listener a no-op, and remove later in #dispatchEvent()\n          listeners[index] = VOID;\n          ++this.pendingRemovals_[type];\n        } else {\n          listeners.splice(index, 1);\n          if (listeners.length === 0) {\n            delete this.listeners_[type];\n          }\n        }\n      }\n    }\n  };\n  return Target;\n}(Disposable);\nexport default Target;","map":{"version":3,"names":["Disposable","Event","VOID","clear","Target","_super","__extends","opt_target","_this","call","eventTarget_","pendingRemovals_","dispatching_","listeners_","prototype","addEventListener","type","listener","listeners","listenersForType","indexOf","push","dispatchEvent","event","evt","target","propagate","dispatching","pendingRemovals","i","ii","length","handleEvent","propagationStopped","pr","removeEventListener","disposeInternal","getListeners","undefined","hasListener","opt_type","Object","keys","index","splice"],"sources":["/Users/mariovicky/Skripsi_OpenLayers/node_modules/ol/src/events/Target.js"],"sourcesContent":["/**\n * @module ol/events/Target\n */\nimport Disposable from '../Disposable.js';\nimport Event from './Event.js';\nimport {VOID} from '../functions.js';\nimport {clear} from '../obj.js';\n\n/**\n * @typedef {EventTarget|Target} EventTargetLike\n */\n\n/**\n * @classdesc\n * A simplified implementation of the W3C DOM Level 2 EventTarget interface.\n * See https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget.\n *\n * There are two important simplifications compared to the specification:\n *\n * 1. The handling of `useCapture` in `addEventListener` and\n *    `removeEventListener`. There is no real capture model.\n * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.\n *    There is no event target hierarchy. When a listener calls\n *    `stopPropagation` or `preventDefault` on an event object, it means that no\n *    more listeners after this one will be called. Same as when the listener\n *    returns false.\n */\nclass Target extends Disposable {\n  /**\n   * @param {*=} opt_target Default event target for dispatched events.\n   */\n  constructor(opt_target) {\n    super();\n\n    /**\n     * @private\n     * @type {*}\n     */\n    this.eventTarget_ = opt_target;\n\n    /**\n     * @private\n     * @type {Object<string, number>}\n     */\n    this.pendingRemovals_ = null;\n\n    /**\n     * @private\n     * @type {Object<string, number>}\n     */\n    this.dispatching_ = null;\n\n    /**\n     * @private\n     * @type {Object<string, Array<import(\"../events.js\").Listener>>}\n     */\n    this.listeners_ = null;\n  }\n\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../events.js\").Listener} listener Listener.\n   */\n  addEventListener(type, listener) {\n    if (!type || !listener) {\n      return;\n    }\n    const listeners = this.listeners_ || (this.listeners_ = {});\n    const listenersForType = listeners[type] || (listeners[type] = []);\n    if (listenersForType.indexOf(listener) === -1) {\n      listenersForType.push(listener);\n    }\n  }\n\n  /**\n   * Dispatches an event and calls all listeners listening for events\n   * of this type. The event parameter can either be a string or an\n   * Object with a `type` property.\n   *\n   * @param {import(\"./Event.js\").default|string} event Event object.\n   * @return {boolean|undefined} `false` if anyone called preventDefault on the\n   *     event object or if any of the listeners returned false.\n   * @api\n   */\n  dispatchEvent(event) {\n    /** @type {import(\"./Event.js\").default|Event} */\n    const evt = typeof event === 'string' ? new Event(event) : event;\n    const type = evt.type;\n    if (!evt.target) {\n      evt.target = this.eventTarget_ || this;\n    }\n    const listeners = this.listeners_ && this.listeners_[type];\n    let propagate;\n    if (listeners) {\n      const dispatching = this.dispatching_ || (this.dispatching_ = {});\n      const pendingRemovals =\n        this.pendingRemovals_ || (this.pendingRemovals_ = {});\n      if (!(type in dispatching)) {\n        dispatching[type] = 0;\n        pendingRemovals[type] = 0;\n      }\n      ++dispatching[type];\n      for (let i = 0, ii = listeners.length; i < ii; ++i) {\n        if ('handleEvent' in listeners[i]) {\n          propagate = /** @type {import(\"../events.js\").ListenerObject} */ (listeners[\n            i\n          ]).handleEvent(evt);\n        } else {\n          propagate = /** @type {import(\"../events.js\").ListenerFunction} */ (listeners[\n            i\n          ]).call(this, evt);\n        }\n        if (propagate === false || evt.propagationStopped) {\n          propagate = false;\n          break;\n        }\n      }\n      --dispatching[type];\n      if (dispatching[type] === 0) {\n        let pr = pendingRemovals[type];\n        delete pendingRemovals[type];\n        while (pr--) {\n          this.removeEventListener(type, VOID);\n        }\n        delete dispatching[type];\n      }\n      return propagate;\n    }\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    this.listeners_ && clear(this.listeners_);\n  }\n\n  /**\n   * Get the listeners for a specified event type. Listeners are returned in the\n   * order that they will be called in.\n   *\n   * @param {string} type Type.\n   * @return {Array<import(\"../events.js\").Listener>|undefined} Listeners.\n   */\n  getListeners(type) {\n    return (this.listeners_ && this.listeners_[type]) || undefined;\n  }\n\n  /**\n   * @param {string=} opt_type Type. If not provided,\n   *     `true` will be returned if this event target has any listeners.\n   * @return {boolean} Has listeners.\n   */\n  hasListener(opt_type) {\n    if (!this.listeners_) {\n      return false;\n    }\n    return opt_type\n      ? opt_type in this.listeners_\n      : Object.keys(this.listeners_).length > 0;\n  }\n\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../events.js\").Listener} listener Listener.\n   */\n  removeEventListener(type, listener) {\n    const listeners = this.listeners_ && this.listeners_[type];\n    if (listeners) {\n      const index = listeners.indexOf(listener);\n      if (index !== -1) {\n        if (this.pendingRemovals_ && type in this.pendingRemovals_) {\n          // make listener a no-op, and remove later in #dispatchEvent()\n          listeners[index] = VOID;\n          ++this.pendingRemovals_[type];\n        } else {\n          listeners.splice(index, 1);\n          if (listeners.length === 0) {\n            delete this.listeners_[type];\n          }\n        }\n      }\n    }\n  }\n}\n\nexport default Target;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
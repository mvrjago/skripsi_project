{"ast":null,"code":"'use strict';\n\n// Load modules\nconst Net = require('net');\nconst Hoek = require('hoek');\nlet Isemail; // Loaded on demand\nconst Any = require('../any');\nconst Ref = require('../../ref');\nconst JoiDate = require('../date');\nconst Uri = require('./uri');\nconst Ip = require('./ip');\n\n// Declare internals\n\nconst internals = {\n  uriRegex: Uri.createUriRegex(),\n  ipRegex: Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], 'optional'),\n  guidBrackets: {\n    '{': '}',\n    '[': ']',\n    '(': ')',\n    '': ''\n  },\n  guidVersions: {\n    uuidv1: '1',\n    uuidv2: '2',\n    uuidv3: '3',\n    uuidv4: '4',\n    uuidv5: '5'\n  },\n  cidrPresences: ['required', 'optional', 'forbidden'],\n  normalizationForms: ['NFC', 'NFD', 'NFKC', 'NFKD']\n};\ninternals.String = class extends Any {\n  constructor() {\n    super();\n    this._type = 'string';\n    this._invalids.add('');\n  }\n  _base(value, state, options) {\n    if (typeof value === 'string' && options.convert) {\n      if (this._flags.normalize) {\n        value = value.normalize(this._flags.normalize);\n      }\n      if (this._flags.case) {\n        value = this._flags.case === 'upper' ? value.toLocaleUpperCase() : value.toLocaleLowerCase();\n      }\n      if (this._flags.trim) {\n        value = value.trim();\n      }\n      if (this._inner.replacements) {\n        for (let i = 0; i < this._inner.replacements.length; ++i) {\n          const replacement = this._inner.replacements[i];\n          value = value.replace(replacement.pattern, replacement.replacement);\n        }\n      }\n      if (this._flags.truncate) {\n        for (let i = 0; i < this._tests.length; ++i) {\n          const test = this._tests[i];\n          if (test.name === 'max') {\n            value = value.slice(0, test.arg);\n            break;\n          }\n        }\n      }\n      if (this._flags.byteAligned && value.length % 2 !== 0) {\n        value = `0${value}`;\n      }\n    }\n    return {\n      value,\n      errors: typeof value === 'string' ? null : this.createError('string.base', {\n        value\n      }, state, options)\n    };\n  }\n  insensitive() {\n    if (this._flags.insensitive) {\n      return this;\n    }\n    const obj = this.clone();\n    obj._flags.insensitive = true;\n    return obj;\n  }\n  creditCard() {\n    return this._test('creditCard', undefined, function (value, state, options) {\n      let i = value.length;\n      let sum = 0;\n      let mul = 1;\n      while (i--) {\n        const char = value.charAt(i) * mul;\n        sum = sum + (char - (char > 9) * 9);\n        mul = mul ^ 3;\n      }\n      const check = sum % 10 === 0 && sum > 0;\n      return check ? value : this.createError('string.creditCard', {\n        value\n      }, state, options);\n    });\n  }\n  regex(pattern, patternOptions) {\n    Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');\n    const patternObject = {\n      pattern: new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined) // Future version should break this and forbid unsupported regex flags\n    };\n\n    if (typeof patternOptions === 'string') {\n      patternObject.name = patternOptions;\n    } else if (typeof patternOptions === 'object') {\n      patternObject.invert = !!patternOptions.invert;\n      if (patternOptions.name) {\n        patternObject.name = patternOptions.name;\n      }\n    }\n    const errorCode = ['string.regex', patternObject.invert ? '.invert' : '', patternObject.name ? '.name' : '.base'].join('');\n    return this._test('regex', patternObject, function (value, state, options) {\n      const patternMatch = patternObject.pattern.test(value);\n      if (patternMatch ^ patternObject.invert) {\n        return value;\n      }\n      return this.createError(errorCode, {\n        name: patternObject.name,\n        pattern: patternObject.pattern,\n        value\n      }, state, options);\n    });\n  }\n  alphanum() {\n    return this._test('alphanum', undefined, function (value, state, options) {\n      if (/^[a-zA-Z0-9]+$/.test(value)) {\n        return value;\n      }\n      return this.createError('string.alphanum', {\n        value\n      }, state, options);\n    });\n  }\n  token() {\n    return this._test('token', undefined, function (value, state, options) {\n      if (/^\\w+$/.test(value)) {\n        return value;\n      }\n      return this.createError('string.token', {\n        value\n      }, state, options);\n    });\n  }\n  email(isEmailOptions) {\n    if (isEmailOptions) {\n      Hoek.assert(typeof isEmailOptions === 'object', 'email options must be an object');\n      Hoek.assert(typeof isEmailOptions.checkDNS === 'undefined', 'checkDNS option is not supported');\n      Hoek.assert(typeof isEmailOptions.tldWhitelist === 'undefined' || typeof isEmailOptions.tldWhitelist === 'object', 'tldWhitelist must be an array or object');\n      Hoek.assert(typeof isEmailOptions.minDomainAtoms === 'undefined' || Number.isSafeInteger(isEmailOptions.minDomainAtoms) && isEmailOptions.minDomainAtoms > 0, 'minDomainAtoms must be a positive integer');\n      Hoek.assert(typeof isEmailOptions.errorLevel === 'undefined' || typeof isEmailOptions.errorLevel === 'boolean' || Number.isSafeInteger(isEmailOptions.errorLevel) && isEmailOptions.errorLevel >= 0, 'errorLevel must be a non-negative integer or boolean');\n    }\n    return this._test('email', isEmailOptions, function (value, state, options) {\n      Isemail = Isemail || require('isemail');\n      try {\n        const result = Isemail.validate(value, isEmailOptions);\n        if (result === true || result === 0) {\n          return value;\n        }\n      } catch (e) {}\n      return this.createError('string.email', {\n        value\n      }, state, options);\n    });\n  }\n  ip() {\n    let ipOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let regex = internals.ipRegex;\n    Hoek.assert(typeof ipOptions === 'object', 'options must be an object');\n    if (ipOptions.cidr) {\n      Hoek.assert(typeof ipOptions.cidr === 'string', 'cidr must be a string');\n      ipOptions.cidr = ipOptions.cidr.toLowerCase();\n      Hoek.assert(Hoek.contain(internals.cidrPresences, ipOptions.cidr), 'cidr must be one of ' + internals.cidrPresences.join(', '));\n\n      // If we only received a `cidr` setting, create a regex for it. But we don't need to create one if `cidr` is \"optional\" since that is the default\n      if (!ipOptions.version && ipOptions.cidr !== 'optional') {\n        regex = Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], ipOptions.cidr);\n      }\n    } else {\n      // Set our default cidr strategy\n      ipOptions.cidr = 'optional';\n    }\n    let versions;\n    if (ipOptions.version) {\n      if (!Array.isArray(ipOptions.version)) {\n        ipOptions.version = [ipOptions.version];\n      }\n      Hoek.assert(ipOptions.version.length >= 1, 'version must have at least 1 version specified');\n      versions = [];\n      for (let i = 0; i < ipOptions.version.length; ++i) {\n        let version = ipOptions.version[i];\n        Hoek.assert(typeof version === 'string', 'version at position ' + i + ' must be a string');\n        version = version.toLowerCase();\n        Hoek.assert(Ip.versions[version], 'version at position ' + i + ' must be one of ' + Object.keys(Ip.versions).join(', '));\n        versions.push(version);\n      }\n\n      // Make sure we have a set of versions\n      versions = Hoek.unique(versions);\n      regex = Ip.createIpRegex(versions, ipOptions.cidr);\n    }\n    return this._test('ip', ipOptions, function (value, state, options) {\n      if (regex.test(value)) {\n        return value;\n      }\n      if (versions) {\n        return this.createError('string.ipVersion', {\n          value,\n          cidr: ipOptions.cidr,\n          version: versions\n        }, state, options);\n      }\n      return this.createError('string.ip', {\n        value,\n        cidr: ipOptions.cidr\n      }, state, options);\n    });\n  }\n  uri(uriOptions) {\n    let customScheme = '';\n    let allowRelative = false;\n    let relativeOnly = false;\n    let allowQuerySquareBrackets = false;\n    let regex = internals.uriRegex;\n    if (uriOptions) {\n      Hoek.assert(typeof uriOptions === 'object', 'options must be an object');\n      const unknownOptions = Object.keys(uriOptions).filter(key => !['scheme', 'allowRelative', 'relativeOnly', 'allowQuerySquareBrackets'].includes(key));\n      Hoek.assert(unknownOptions.length === 0, `options contain unknown keys: ${unknownOptions}`);\n      if (uriOptions.scheme) {\n        Hoek.assert(uriOptions.scheme instanceof RegExp || typeof uriOptions.scheme === 'string' || Array.isArray(uriOptions.scheme), 'scheme must be a RegExp, String, or Array');\n        if (!Array.isArray(uriOptions.scheme)) {\n          uriOptions.scheme = [uriOptions.scheme];\n        }\n        Hoek.assert(uriOptions.scheme.length >= 1, 'scheme must have at least 1 scheme specified');\n\n        // Flatten the array into a string to be used to match the schemes.\n        for (let i = 0; i < uriOptions.scheme.length; ++i) {\n          const scheme = uriOptions.scheme[i];\n          Hoek.assert(scheme instanceof RegExp || typeof scheme === 'string', 'scheme at position ' + i + ' must be a RegExp or String');\n\n          // Add OR separators if a value already exists\n          customScheme = customScheme + (customScheme ? '|' : '');\n\n          // If someone wants to match HTTP or HTTPS for example then we need to support both RegExp and String so we don't escape their pattern unknowingly.\n          if (scheme instanceof RegExp) {\n            customScheme = customScheme + scheme.source;\n          } else {\n            Hoek.assert(/[a-zA-Z][a-zA-Z0-9+-\\.]*/.test(scheme), 'scheme at position ' + i + ' must be a valid scheme');\n            customScheme = customScheme + Hoek.escapeRegex(scheme);\n          }\n        }\n      }\n      if (uriOptions.allowRelative) {\n        allowRelative = true;\n      }\n      if (uriOptions.relativeOnly) {\n        relativeOnly = true;\n      }\n      if (uriOptions.allowQuerySquareBrackets) {\n        allowQuerySquareBrackets = true;\n      }\n    }\n    if (customScheme || allowRelative || relativeOnly || allowQuerySquareBrackets) {\n      regex = Uri.createUriRegex(customScheme, allowRelative, relativeOnly, allowQuerySquareBrackets);\n    }\n    return this._test('uri', uriOptions, function (value, state, options) {\n      if (regex.test(value)) {\n        return value;\n      }\n      if (relativeOnly) {\n        return this.createError('string.uriRelativeOnly', {\n          value\n        }, state, options);\n      }\n      if (customScheme) {\n        return this.createError('string.uriCustomScheme', {\n          scheme: customScheme,\n          value\n        }, state, options);\n      }\n      return this.createError('string.uri', {\n        value\n      }, state, options);\n    });\n  }\n  isoDate() {\n    return this._test('isoDate', undefined, function (value, state, options) {\n      if (JoiDate._isIsoDate(value)) {\n        if (!options.convert) {\n          return value;\n        }\n        const d = new Date(value);\n        if (!isNaN(d.getTime())) {\n          return d.toISOString();\n        }\n      }\n      return this.createError('string.isoDate', {\n        value\n      }, state, options);\n    });\n  }\n  guid(guidOptions) {\n    let versionNumbers = '';\n    if (guidOptions && guidOptions.version) {\n      if (!Array.isArray(guidOptions.version)) {\n        guidOptions.version = [guidOptions.version];\n      }\n      Hoek.assert(guidOptions.version.length >= 1, 'version must have at least 1 valid version specified');\n      const versions = new Set();\n      for (let i = 0; i < guidOptions.version.length; ++i) {\n        let version = guidOptions.version[i];\n        Hoek.assert(typeof version === 'string', 'version at position ' + i + ' must be a string');\n        version = version.toLowerCase();\n        const versionNumber = internals.guidVersions[version];\n        Hoek.assert(versionNumber, 'version at position ' + i + ' must be one of ' + Object.keys(internals.guidVersions).join(', '));\n        Hoek.assert(!versions.has(versionNumber), 'version at position ' + i + ' must not be a duplicate.');\n        versionNumbers += versionNumber;\n        versions.add(versionNumber);\n      }\n    }\n    const guidRegex = new RegExp(`^([\\\\[{\\\\(]?)[0-9A-F]{8}([:-]?)[0-9A-F]{4}\\\\2?[${versionNumbers || '0-9A-F'}][0-9A-F]{3}\\\\2?[${versionNumbers ? '89AB' : '0-9A-F'}][0-9A-F]{3}\\\\2?[0-9A-F]{12}([\\\\]}\\\\)]?)$`, 'i');\n    return this._test('guid', guidOptions, function (value, state, options) {\n      const results = guidRegex.exec(value);\n      if (!results) {\n        return this.createError('string.guid', {\n          value\n        }, state, options);\n      }\n\n      // Matching braces\n      if (internals.guidBrackets[results[1]] !== results[results.length - 1]) {\n        return this.createError('string.guid', {\n          value\n        }, state, options);\n      }\n      return value;\n    });\n  }\n  hex() {\n    let hexOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    Hoek.assert(typeof hexOptions === 'object', 'hex options must be an object');\n    Hoek.assert(typeof hexOptions.byteAligned === 'undefined' || typeof hexOptions.byteAligned === 'boolean', 'byteAligned must be boolean');\n    const byteAligned = hexOptions.byteAligned === true;\n    const regex = /^[a-f0-9]+$/i;\n    const obj = this._test('hex', regex, function (value, state, options) {\n      if (regex.test(value)) {\n        if (byteAligned && value.length % 2 !== 0) {\n          return this.createError('string.hexAlign', {\n            value\n          }, state, options);\n        }\n        return value;\n      }\n      return this.createError('string.hex', {\n        value\n      }, state, options);\n    });\n    if (byteAligned) {\n      obj._flags.byteAligned = true;\n    }\n    return obj;\n  }\n  base64() {\n    let base64Options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // Validation.\n    Hoek.assert(typeof base64Options === 'object', 'base64 options must be an object');\n    Hoek.assert(typeof base64Options.paddingRequired === 'undefined' || typeof base64Options.paddingRequired === 'boolean', 'paddingRequired must be boolean');\n\n    // Determine if padding is required.\n    const paddingRequired = base64Options.paddingRequired === false ? base64Options.paddingRequired : base64Options.paddingRequired || true;\n\n    // Set validation based on preference.\n    const regex = paddingRequired ?\n    // Padding is required.\n    /^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=)?$/\n    // Padding is optional.\n    : /^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}(==)?|[A-Za-z0-9+\\/]{3}=?)?$/;\n    return this._test('base64', regex, function (value, state, options) {\n      if (regex.test(value)) {\n        return value;\n      }\n      return this.createError('string.base64', {\n        value\n      }, state, options);\n    });\n  }\n  dataUri() {\n    let dataUriOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const regex = /^data:[\\w\\/\\+]+;((charset=[\\w-]+|base64),)?(.*)$/;\n\n    // Determine if padding is required.\n    const paddingRequired = dataUriOptions.paddingRequired === false ? dataUriOptions.paddingRequired : dataUriOptions.paddingRequired || true;\n    const base64regex = paddingRequired ? /^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=)?$/ : /^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}(==)?|[A-Za-z0-9+\\/]{3}=?)?$/;\n    return this._test('dataUri', regex, function (value, state, options) {\n      const matches = value.match(regex);\n      if (matches) {\n        if (!matches[2]) {\n          return value;\n        }\n        if (matches[2] !== 'base64') {\n          return value;\n        }\n        if (base64regex.test(matches[3])) {\n          return value;\n        }\n      }\n      return this.createError('string.dataUri', {\n        value\n      }, state, options);\n    });\n  }\n  hostname() {\n    const regex = /^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$/;\n    return this._test('hostname', undefined, function (value, state, options) {\n      if (value.length <= 255 && regex.test(value) || Net.isIPv6(value)) {\n        return value;\n      }\n      return this.createError('string.hostname', {\n        value\n      }, state, options);\n    });\n  }\n  normalize() {\n    let form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'NFC';\n    Hoek.assert(Hoek.contain(internals.normalizationForms, form), 'normalization form must be one of ' + internals.normalizationForms.join(', '));\n    const obj = this._test('normalize', form, function (value, state, options) {\n      if (options.convert || value === value.normalize(form)) {\n        return value;\n      }\n      return this.createError('string.normalize', {\n        value,\n        form\n      }, state, options);\n    });\n    obj._flags.normalize = form;\n    return obj;\n  }\n  lowercase() {\n    const obj = this._test('lowercase', undefined, function (value, state, options) {\n      if (options.convert || value === value.toLocaleLowerCase()) {\n        return value;\n      }\n      return this.createError('string.lowercase', {\n        value\n      }, state, options);\n    });\n    obj._flags.case = 'lower';\n    return obj;\n  }\n  uppercase() {\n    const obj = this._test('uppercase', undefined, function (value, state, options) {\n      if (options.convert || value === value.toLocaleUpperCase()) {\n        return value;\n      }\n      return this.createError('string.uppercase', {\n        value\n      }, state, options);\n    });\n    obj._flags.case = 'upper';\n    return obj;\n  }\n  trim() {\n    let enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    Hoek.assert(typeof enabled === 'boolean', 'option must be a boolean');\n    if (this._flags.trim && enabled || !this._flags.trim && !enabled) {\n      return this;\n    }\n    let obj;\n    if (enabled) {\n      obj = this._test('trim', undefined, function (value, state, options) {\n        if (options.convert || value === value.trim()) {\n          return value;\n        }\n        return this.createError('string.trim', {\n          value\n        }, state, options);\n      });\n    } else {\n      obj = this.clone();\n      obj._tests = obj._tests.filter(test => test.name !== 'trim');\n    }\n    obj._flags.trim = enabled;\n    return obj;\n  }\n  replace(pattern, replacement) {\n    if (typeof pattern === 'string') {\n      pattern = new RegExp(Hoek.escapeRegex(pattern), 'g');\n    }\n    Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');\n    Hoek.assert(typeof replacement === 'string', 'replacement must be a String');\n\n    // This can not be considere a test like trim, we can't \"reject\"\n    // anything from this rule, so just clone the current object\n    const obj = this.clone();\n    if (!obj._inner.replacements) {\n      obj._inner.replacements = [];\n    }\n    obj._inner.replacements.push({\n      pattern,\n      replacement\n    });\n    return obj;\n  }\n  truncate(enabled) {\n    const value = enabled === undefined ? true : !!enabled;\n    if (this._flags.truncate === value) {\n      return this;\n    }\n    const obj = this.clone();\n    obj._flags.truncate = value;\n    return obj;\n  }\n};\ninternals.compare = function (type, compare) {\n  return function (limit, encoding) {\n    const isRef = Ref.isRef(limit);\n    Hoek.assert(Number.isSafeInteger(limit) && limit >= 0 || isRef, 'limit must be a positive integer or reference');\n    Hoek.assert(!encoding || Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);\n    return this._test(type, limit, function (value, state, options) {\n      let compareTo;\n      if (isRef) {\n        compareTo = limit(state.reference || state.parent, options);\n        if (!Number.isSafeInteger(compareTo)) {\n          return this.createError('string.ref', {\n            ref: limit.key\n          }, state, options);\n        }\n      } else {\n        compareTo = limit;\n      }\n      if (compare(value, compareTo, encoding)) {\n        return value;\n      }\n      return this.createError('string.' + type, {\n        limit: compareTo,\n        value,\n        encoding\n      }, state, options);\n    });\n  };\n};\ninternals.String.prototype.min = internals.compare('min', (value, limit, encoding) => {\n  const length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n  return length >= limit;\n});\ninternals.String.prototype.max = internals.compare('max', (value, limit, encoding) => {\n  const length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n  return length <= limit;\n});\ninternals.String.prototype.length = internals.compare('length', (value, limit, encoding) => {\n  const length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n  return length === limit;\n});\n\n// Aliases\n\ninternals.String.prototype.uuid = internals.String.prototype.guid;\nmodule.exports = new internals.String();","map":{"version":3,"names":["Net","require","Hoek","Isemail","Any","Ref","JoiDate","Uri","Ip","internals","uriRegex","createUriRegex","ipRegex","createIpRegex","guidBrackets","guidVersions","uuidv1","uuidv2","uuidv3","uuidv4","uuidv5","cidrPresences","normalizationForms","String","constructor","_type","_invalids","add","_base","value","state","options","convert","_flags","normalize","case","toLocaleUpperCase","toLocaleLowerCase","trim","_inner","replacements","i","length","replacement","replace","pattern","truncate","_tests","test","name","slice","arg","byteAligned","errors","createError","insensitive","obj","clone","creditCard","_test","undefined","sum","mul","char","charAt","check","regex","patternOptions","assert","RegExp","patternObject","source","ignoreCase","invert","errorCode","join","patternMatch","alphanum","token","email","isEmailOptions","checkDNS","tldWhitelist","minDomainAtoms","Number","isSafeInteger","errorLevel","result","validate","e","ip","ipOptions","arguments","cidr","toLowerCase","contain","version","versions","Array","isArray","Object","keys","push","unique","uri","uriOptions","customScheme","allowRelative","relativeOnly","allowQuerySquareBrackets","unknownOptions","filter","key","includes","scheme","escapeRegex","isoDate","_isIsoDate","d","Date","isNaN","getTime","toISOString","guid","guidOptions","versionNumbers","Set","versionNumber","has","guidRegex","results","exec","hex","hexOptions","base64","base64Options","paddingRequired","dataUri","dataUriOptions","base64regex","matches","match","hostname","isIPv6","form","lowercase","uppercase","enabled","compare","type","limit","encoding","isRef","Buffer","isEncoding","compareTo","reference","parent","ref","prototype","min","byteLength","max","uuid","module","exports"],"sources":["/Users/mariovicky/Skripsi_OpenLayers/node_modules/joi/lib/types/string/index.js"],"sourcesContent":["'use strict';\n\n// Load modules\n\nconst Net = require('net');\nconst Hoek = require('hoek');\nlet Isemail;                            // Loaded on demand\nconst Any = require('../any');\nconst Ref = require('../../ref');\nconst JoiDate = require('../date');\nconst Uri = require('./uri');\nconst Ip = require('./ip');\n\n// Declare internals\n\nconst internals = {\n    uriRegex: Uri.createUriRegex(),\n    ipRegex: Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], 'optional'),\n    guidBrackets: {\n        '{': '}', '[': ']', '(': ')', '': ''\n    },\n    guidVersions: {\n        uuidv1: '1',\n        uuidv2: '2',\n        uuidv3: '3',\n        uuidv4: '4',\n        uuidv5: '5'\n    },\n    cidrPresences: ['required', 'optional', 'forbidden'],\n    normalizationForms: ['NFC', 'NFD', 'NFKC', 'NFKD']\n};\n\ninternals.String = class extends Any {\n\n    constructor() {\n\n        super();\n        this._type = 'string';\n        this._invalids.add('');\n    }\n\n    _base(value, state, options) {\n\n        if (typeof value === 'string' &&\n            options.convert) {\n\n            if (this._flags.normalize) {\n                value = value.normalize(this._flags.normalize);\n            }\n\n            if (this._flags.case) {\n                value = (this._flags.case === 'upper' ? value.toLocaleUpperCase() : value.toLocaleLowerCase());\n            }\n\n            if (this._flags.trim) {\n                value = value.trim();\n            }\n\n            if (this._inner.replacements) {\n\n                for (let i = 0; i < this._inner.replacements.length; ++i) {\n                    const replacement = this._inner.replacements[i];\n                    value = value.replace(replacement.pattern, replacement.replacement);\n                }\n            }\n\n            if (this._flags.truncate) {\n                for (let i = 0; i < this._tests.length; ++i) {\n                    const test = this._tests[i];\n                    if (test.name === 'max') {\n                        value = value.slice(0, test.arg);\n                        break;\n                    }\n                }\n            }\n\n            if (this._flags.byteAligned && value.length % 2 !== 0) {\n                value = `0${value}`;\n            }\n        }\n\n        return {\n            value,\n            errors: (typeof value === 'string') ? null : this.createError('string.base', { value }, state, options)\n        };\n    }\n\n    insensitive() {\n\n        if (this._flags.insensitive) {\n            return this;\n        }\n\n        const obj = this.clone();\n        obj._flags.insensitive = true;\n        return obj;\n    }\n\n    creditCard() {\n\n        return this._test('creditCard', undefined, function (value, state, options) {\n\n            let i = value.length;\n            let sum = 0;\n            let mul = 1;\n\n            while (i--) {\n                const char = value.charAt(i) * mul;\n                sum = sum + (char - (char > 9) * 9);\n                mul = mul ^ 3;\n            }\n\n            const check = (sum % 10 === 0) && (sum > 0);\n            return check ? value : this.createError('string.creditCard', { value }, state, options);\n        });\n    }\n\n    regex(pattern, patternOptions) {\n\n        Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');\n\n        const patternObject = {\n            pattern: new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined)         // Future version should break this and forbid unsupported regex flags\n        };\n\n        if (typeof patternOptions === 'string') {\n            patternObject.name = patternOptions;\n        }\n        else if (typeof patternOptions === 'object') {\n            patternObject.invert = !!patternOptions.invert;\n\n            if (patternOptions.name) {\n                patternObject.name = patternOptions.name;\n            }\n        }\n\n        const errorCode = ['string.regex', patternObject.invert ? '.invert' : '', patternObject.name ? '.name' : '.base'].join('');\n\n        return this._test('regex', patternObject, function (value, state, options) {\n\n            const patternMatch = patternObject.pattern.test(value);\n\n            if (patternMatch ^ patternObject.invert) {\n                return value;\n            }\n\n            return this.createError(errorCode, { name: patternObject.name, pattern: patternObject.pattern, value }, state, options);\n        });\n    }\n\n    alphanum() {\n\n        return this._test('alphanum', undefined, function (value, state, options) {\n\n            if (/^[a-zA-Z0-9]+$/.test(value)) {\n                return value;\n            }\n\n            return this.createError('string.alphanum', { value }, state, options);\n        });\n    }\n\n    token() {\n\n        return this._test('token', undefined, function (value, state, options) {\n\n            if (/^\\w+$/.test(value)) {\n                return value;\n            }\n\n            return this.createError('string.token', { value }, state, options);\n        });\n    }\n\n    email(isEmailOptions) {\n\n        if (isEmailOptions) {\n            Hoek.assert(typeof isEmailOptions === 'object', 'email options must be an object');\n            Hoek.assert(typeof isEmailOptions.checkDNS === 'undefined', 'checkDNS option is not supported');\n            Hoek.assert(typeof isEmailOptions.tldWhitelist === 'undefined' ||\n                typeof isEmailOptions.tldWhitelist === 'object', 'tldWhitelist must be an array or object');\n            Hoek.assert(\n                typeof isEmailOptions.minDomainAtoms === 'undefined' ||\n                Number.isSafeInteger(isEmailOptions.minDomainAtoms) &&\n                isEmailOptions.minDomainAtoms > 0,\n                'minDomainAtoms must be a positive integer'\n            );\n            Hoek.assert(\n                typeof isEmailOptions.errorLevel === 'undefined' ||\n                typeof isEmailOptions.errorLevel === 'boolean' ||\n                (\n                    Number.isSafeInteger(isEmailOptions.errorLevel) &&\n                    isEmailOptions.errorLevel >= 0\n                ),\n                'errorLevel must be a non-negative integer or boolean'\n            );\n        }\n\n        return this._test('email', isEmailOptions, function (value, state, options) {\n\n            Isemail = Isemail || require('isemail');\n\n            try {\n                const result = Isemail.validate(value, isEmailOptions);\n                if (result === true || result === 0) {\n                    return value;\n                }\n            }\n            catch (e) { }\n\n            return this.createError('string.email', { value }, state, options);\n        });\n    }\n\n    ip(ipOptions = {}) {\n\n        let regex = internals.ipRegex;\n        Hoek.assert(typeof ipOptions === 'object', 'options must be an object');\n\n        if (ipOptions.cidr) {\n            Hoek.assert(typeof ipOptions.cidr === 'string', 'cidr must be a string');\n            ipOptions.cidr = ipOptions.cidr.toLowerCase();\n\n            Hoek.assert(Hoek.contain(internals.cidrPresences, ipOptions.cidr), 'cidr must be one of ' + internals.cidrPresences.join(', '));\n\n            // If we only received a `cidr` setting, create a regex for it. But we don't need to create one if `cidr` is \"optional\" since that is the default\n            if (!ipOptions.version && ipOptions.cidr !== 'optional') {\n                regex = Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], ipOptions.cidr);\n            }\n        }\n        else {\n\n            // Set our default cidr strategy\n            ipOptions.cidr = 'optional';\n        }\n\n        let versions;\n        if (ipOptions.version) {\n            if (!Array.isArray(ipOptions.version)) {\n                ipOptions.version = [ipOptions.version];\n            }\n\n            Hoek.assert(ipOptions.version.length >= 1, 'version must have at least 1 version specified');\n\n            versions = [];\n            for (let i = 0; i < ipOptions.version.length; ++i) {\n                let version = ipOptions.version[i];\n                Hoek.assert(typeof version === 'string', 'version at position ' + i + ' must be a string');\n                version = version.toLowerCase();\n                Hoek.assert(Ip.versions[version], 'version at position ' + i + ' must be one of ' + Object.keys(Ip.versions).join(', '));\n                versions.push(version);\n            }\n\n            // Make sure we have a set of versions\n            versions = Hoek.unique(versions);\n\n            regex = Ip.createIpRegex(versions, ipOptions.cidr);\n        }\n\n        return this._test('ip', ipOptions, function (value, state, options) {\n\n            if (regex.test(value)) {\n                return value;\n            }\n\n            if (versions) {\n                return this.createError('string.ipVersion', { value, cidr: ipOptions.cidr, version: versions }, state, options);\n            }\n\n            return this.createError('string.ip', { value, cidr: ipOptions.cidr }, state, options);\n        });\n    }\n\n    uri(uriOptions) {\n\n        let customScheme = '';\n        let allowRelative = false;\n        let relativeOnly = false;\n        let allowQuerySquareBrackets = false;\n        let regex = internals.uriRegex;\n\n        if (uriOptions) {\n            Hoek.assert(typeof uriOptions === 'object', 'options must be an object');\n\n            const unknownOptions = Object.keys(uriOptions).filter((key) => !['scheme', 'allowRelative', 'relativeOnly', 'allowQuerySquareBrackets'].includes(key));\n            Hoek.assert(unknownOptions.length === 0, `options contain unknown keys: ${unknownOptions}`);\n\n            if (uriOptions.scheme) {\n                Hoek.assert(uriOptions.scheme instanceof RegExp || typeof uriOptions.scheme === 'string' || Array.isArray(uriOptions.scheme), 'scheme must be a RegExp, String, or Array');\n\n                if (!Array.isArray(uriOptions.scheme)) {\n                    uriOptions.scheme = [uriOptions.scheme];\n                }\n\n                Hoek.assert(uriOptions.scheme.length >= 1, 'scheme must have at least 1 scheme specified');\n\n                // Flatten the array into a string to be used to match the schemes.\n                for (let i = 0; i < uriOptions.scheme.length; ++i) {\n                    const scheme = uriOptions.scheme[i];\n                    Hoek.assert(scheme instanceof RegExp || typeof scheme === 'string', 'scheme at position ' + i + ' must be a RegExp or String');\n\n                    // Add OR separators if a value already exists\n                    customScheme = customScheme + (customScheme ? '|' : '');\n\n                    // If someone wants to match HTTP or HTTPS for example then we need to support both RegExp and String so we don't escape their pattern unknowingly.\n                    if (scheme instanceof RegExp) {\n                        customScheme = customScheme + scheme.source;\n                    }\n                    else {\n                        Hoek.assert(/[a-zA-Z][a-zA-Z0-9+-\\.]*/.test(scheme), 'scheme at position ' + i + ' must be a valid scheme');\n                        customScheme = customScheme + Hoek.escapeRegex(scheme);\n                    }\n                }\n            }\n\n            if (uriOptions.allowRelative) {\n                allowRelative = true;\n            }\n\n            if (uriOptions.relativeOnly) {\n                relativeOnly = true;\n            }\n\n            if (uriOptions.allowQuerySquareBrackets) {\n                allowQuerySquareBrackets = true;\n            }\n        }\n\n        if (customScheme || allowRelative || relativeOnly || allowQuerySquareBrackets) {\n            regex = Uri.createUriRegex(customScheme, allowRelative, relativeOnly, allowQuerySquareBrackets);\n        }\n\n        return this._test('uri', uriOptions, function (value, state, options) {\n\n            if (regex.test(value)) {\n                return value;\n            }\n\n            if (relativeOnly) {\n                return this.createError('string.uriRelativeOnly', { value }, state, options);\n            }\n\n            if (customScheme) {\n                return this.createError('string.uriCustomScheme', { scheme: customScheme, value }, state, options);\n            }\n\n            return this.createError('string.uri', { value }, state, options);\n        });\n    }\n\n    isoDate() {\n\n        return this._test('isoDate', undefined, function (value, state, options) {\n\n            if (JoiDate._isIsoDate(value)) {\n                if (!options.convert) {\n                    return value;\n                }\n\n                const d = new Date(value);\n                if (!isNaN(d.getTime())) {\n                    return d.toISOString();\n                }\n            }\n\n            return this.createError('string.isoDate', { value }, state, options);\n        });\n    }\n\n    guid(guidOptions) {\n\n        let versionNumbers = '';\n\n        if (guidOptions && guidOptions.version) {\n            if (!Array.isArray(guidOptions.version)) {\n                guidOptions.version = [guidOptions.version];\n            }\n\n            Hoek.assert(guidOptions.version.length >= 1, 'version must have at least 1 valid version specified');\n            const versions = new Set();\n\n            for (let i = 0; i < guidOptions.version.length; ++i) {\n                let version = guidOptions.version[i];\n                Hoek.assert(typeof version === 'string', 'version at position ' + i + ' must be a string');\n                version = version.toLowerCase();\n                const versionNumber = internals.guidVersions[version];\n                Hoek.assert(versionNumber, 'version at position ' + i + ' must be one of ' + Object.keys(internals.guidVersions).join(', '));\n                Hoek.assert(!(versions.has(versionNumber)), 'version at position ' + i + ' must not be a duplicate.');\n\n                versionNumbers += versionNumber;\n                versions.add(versionNumber);\n            }\n        }\n\n        const guidRegex = new RegExp(`^([\\\\[{\\\\(]?)[0-9A-F]{8}([:-]?)[0-9A-F]{4}\\\\2?[${versionNumbers || '0-9A-F'}][0-9A-F]{3}\\\\2?[${versionNumbers ? '89AB' : '0-9A-F'}][0-9A-F]{3}\\\\2?[0-9A-F]{12}([\\\\]}\\\\)]?)$`, 'i');\n\n        return this._test('guid', guidOptions, function (value, state, options) {\n\n            const results = guidRegex.exec(value);\n\n            if (!results) {\n                return this.createError('string.guid', { value }, state, options);\n            }\n\n            // Matching braces\n            if (internals.guidBrackets[results[1]] !== results[results.length - 1]) {\n                return this.createError('string.guid', { value }, state, options);\n            }\n\n            return value;\n        });\n    }\n\n    hex(hexOptions = {}) {\n\n        Hoek.assert(typeof hexOptions === 'object', 'hex options must be an object');\n        Hoek.assert(typeof hexOptions.byteAligned === 'undefined' || typeof hexOptions.byteAligned === 'boolean',\n            'byteAligned must be boolean');\n\n        const byteAligned = hexOptions.byteAligned === true;\n        const regex = /^[a-f0-9]+$/i;\n\n        const obj = this._test('hex', regex, function (value, state, options) {\n\n            if (regex.test(value)) {\n                if (byteAligned && value.length % 2 !== 0) {\n                    return this.createError('string.hexAlign', { value }, state, options);\n                }\n                return value;\n            }\n\n            return this.createError('string.hex', { value }, state, options);\n        });\n\n        if (byteAligned) {\n            obj._flags.byteAligned = true;\n        }\n\n        return obj;\n    }\n\n    base64(base64Options = {}) {\n\n        // Validation.\n        Hoek.assert(typeof base64Options === 'object', 'base64 options must be an object');\n        Hoek.assert(typeof base64Options.paddingRequired === 'undefined' || typeof base64Options.paddingRequired === 'boolean',\n            'paddingRequired must be boolean');\n\n        // Determine if padding is required.\n        const paddingRequired = base64Options.paddingRequired === false ?\n            base64Options.paddingRequired\n            : base64Options.paddingRequired || true;\n\n        // Set validation based on preference.\n        const regex = paddingRequired ?\n            // Padding is required.\n            /^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=)?$/\n            // Padding is optional.\n            : /^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}(==)?|[A-Za-z0-9+\\/]{3}=?)?$/;\n\n        return this._test('base64', regex, function (value, state, options) {\n\n            if (regex.test(value)) {\n                return value;\n            }\n\n            return this.createError('string.base64', { value }, state, options);\n        });\n    }\n\n    dataUri(dataUriOptions = {}) {\n\n        const regex = /^data:[\\w\\/\\+]+;((charset=[\\w-]+|base64),)?(.*)$/;\n\n        // Determine if padding is required.\n        const paddingRequired = dataUriOptions.paddingRequired === false ?\n            dataUriOptions.paddingRequired\n            : dataUriOptions.paddingRequired || true;\n\n        const base64regex =  paddingRequired ?\n            /^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=)?$/\n            : /^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}(==)?|[A-Za-z0-9+\\/]{3}=?)?$/;\n\n        return this._test('dataUri', regex, function (value, state, options) {\n\n            const matches = value.match(regex);\n\n            if (matches) {\n                if (!matches[2]) {\n                    return value;\n                }\n\n                if (matches[2] !== 'base64') {\n                    return value;\n                }\n\n                if (base64regex.test(matches[3])) {\n                    return value;\n                }\n            }\n\n            return this.createError('string.dataUri', { value }, state, options);\n        });\n    }\n\n    hostname() {\n\n        const regex = /^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$/;\n\n        return this._test('hostname', undefined, function (value, state, options) {\n\n            if ((value.length <= 255 && regex.test(value)) ||\n                Net.isIPv6(value)) {\n\n                return value;\n            }\n\n            return this.createError('string.hostname', { value }, state, options);\n        });\n    }\n\n    normalize(form = 'NFC') {\n\n        Hoek.assert(Hoek.contain(internals.normalizationForms, form), 'normalization form must be one of ' + internals.normalizationForms.join(', '));\n\n        const obj = this._test('normalize', form, function (value, state, options) {\n\n            if (options.convert ||\n                value === value.normalize(form)) {\n\n                return value;\n            }\n\n            return this.createError('string.normalize', { value, form }, state, options);\n        });\n\n        obj._flags.normalize = form;\n        return obj;\n    }\n\n    lowercase() {\n\n        const obj = this._test('lowercase', undefined, function (value, state, options) {\n\n            if (options.convert ||\n                value === value.toLocaleLowerCase()) {\n\n                return value;\n            }\n\n            return this.createError('string.lowercase', { value }, state, options);\n        });\n\n        obj._flags.case = 'lower';\n        return obj;\n    }\n\n    uppercase() {\n\n        const obj = this._test('uppercase', undefined, function (value, state, options) {\n\n            if (options.convert ||\n                value === value.toLocaleUpperCase()) {\n\n                return value;\n            }\n\n            return this.createError('string.uppercase', { value }, state, options);\n        });\n\n        obj._flags.case = 'upper';\n        return obj;\n    }\n\n    trim(enabled = true) {\n\n        Hoek.assert(typeof enabled === 'boolean', 'option must be a boolean');\n\n        if ((this._flags.trim && enabled) || (!this._flags.trim && !enabled)) {\n            return this;\n        }\n\n        let obj;\n        if (enabled) {\n            obj = this._test('trim', undefined, function (value, state, options) {\n\n                if (options.convert ||\n                    value === value.trim()) {\n\n                    return value;\n                }\n\n                return this.createError('string.trim', { value }, state, options);\n            });\n        }\n        else {\n            obj = this.clone();\n            obj._tests = obj._tests.filter((test) => test.name !== 'trim');\n        }\n\n        obj._flags.trim = enabled;\n        return obj;\n    }\n\n    replace(pattern, replacement) {\n\n        if (typeof pattern === 'string') {\n            pattern = new RegExp(Hoek.escapeRegex(pattern), 'g');\n        }\n\n        Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');\n        Hoek.assert(typeof replacement === 'string', 'replacement must be a String');\n\n        // This can not be considere a test like trim, we can't \"reject\"\n        // anything from this rule, so just clone the current object\n        const obj = this.clone();\n\n        if (!obj._inner.replacements) {\n            obj._inner.replacements = [];\n        }\n\n        obj._inner.replacements.push({\n            pattern,\n            replacement\n        });\n\n        return obj;\n    }\n\n    truncate(enabled) {\n\n        const value = enabled === undefined ? true : !!enabled;\n\n        if (this._flags.truncate === value) {\n            return this;\n        }\n\n        const obj = this.clone();\n        obj._flags.truncate = value;\n        return obj;\n    }\n\n};\n\ninternals.compare = function (type, compare) {\n\n    return function (limit, encoding) {\n\n        const isRef = Ref.isRef(limit);\n\n        Hoek.assert((Number.isSafeInteger(limit) && limit >= 0) || isRef, 'limit must be a positive integer or reference');\n        Hoek.assert(!encoding || Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);\n\n        return this._test(type, limit, function (value, state, options) {\n\n            let compareTo;\n            if (isRef) {\n                compareTo = limit(state.reference || state.parent, options);\n\n                if (!Number.isSafeInteger(compareTo)) {\n                    return this.createError('string.ref', { ref: limit.key }, state, options);\n                }\n            }\n            else {\n                compareTo = limit;\n            }\n\n            if (compare(value, compareTo, encoding)) {\n                return value;\n            }\n\n            return this.createError('string.' + type, { limit: compareTo, value, encoding }, state, options);\n        });\n    };\n};\n\n\ninternals.String.prototype.min = internals.compare('min', (value, limit, encoding) => {\n\n    const length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n    return length >= limit;\n});\n\n\ninternals.String.prototype.max = internals.compare('max', (value, limit, encoding) => {\n\n    const length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n    return length <= limit;\n});\n\n\ninternals.String.prototype.length = internals.compare('length', (value, limit, encoding) => {\n\n    const length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n    return length === limit;\n});\n\n// Aliases\n\ninternals.String.prototype.uuid = internals.String.prototype.guid;\n\nmodule.exports = new internals.String();\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}
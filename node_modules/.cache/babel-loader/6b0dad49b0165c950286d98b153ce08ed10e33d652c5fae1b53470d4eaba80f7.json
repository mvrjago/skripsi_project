{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/interaction/Snap\n */\nimport CollectionEventType from '../CollectionEventType.js';\nimport EventType from '../events/EventType.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport PointerInteraction from './Pointer.js';\nimport RBush from '../structs/RBush.js';\nimport VectorEventType from '../source/VectorEventType.js';\nimport { FALSE, TRUE } from '../functions.js';\nimport { boundingExtent, createEmpty } from '../extent.js';\nimport { closestOnCircle, closestOnSegment, distance as coordinateDistance, squaredDistance as squaredCoordinateDistance, squaredDistanceToSegment } from '../coordinate.js';\nimport { fromCircle } from '../geom/Polygon.js';\nimport { fromUserCoordinate, getUserProjection, toUserCoordinate } from '../proj.js';\nimport { getUid } from '../util.js';\nimport { getValues } from '../obj.js';\nimport { listen, unlistenByKey } from '../events.js';\n/**\n * @typedef {Object} Result\n * @property {boolean} snapped\n * @property {import(\"../coordinate.js\").Coordinate|null} vertex\n * @property {import(\"../pixel.js\").Pixel|null} vertexPixel\n */\n/**\n * @typedef {Object} SegmentData\n * @property {import(\"../Feature.js\").default} feature\n * @property {Array<import(\"../coordinate.js\").Coordinate>} segment\n */\n/**\n * @typedef {Object} Options\n * @property {import(\"../Collection.js\").default<import(\"../Feature.js\").default>} [features] Snap to these features. Either this option or source should be provided.\n * @property {boolean} [edge=true] Snap to edges.\n * @property {boolean} [vertex=true] Snap to vertices.\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or\n * vertex for snapping.\n * @property {import(\"../source/Vector.js\").default} [source] Snap to features from this source. Either this option or features should be provided\n */\n/**\n * @param  {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n * @return {import(\"../Feature.js\").default} Feature.\n */\nfunction getFeatureFromEvent(evt) {\n  if ( /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */evt.feature) {\n    return (/** @type {import(\"../source/Vector.js\").VectorSourceEvent} */evt.feature\n    );\n  } else if ( /** @type {import(\"../Collection.js\").CollectionEvent} */evt.element) {\n    return (/** @type {import(\"../Feature.js\").default} */\n      /** @type {import(\"../Collection.js\").CollectionEvent} */evt.element\n    );\n  }\n}\nvar tempSegment = [];\n/**\n * @classdesc\n * Handles snapping of vector features while modifying or drawing them.  The\n * features can come from a {@link module:ol/source/Vector} or {@link module:ol/Collection~Collection}\n * Any interaction object that allows the user to interact\n * with the features using the mouse can benefit from the snapping, as long\n * as it is added before.\n *\n * The snap interaction modifies map browser event `coordinate` and `pixel`\n * properties to force the snap to occur to any interaction that them.\n *\n * Example:\n *\n *     import Snap from 'ol/interaction/Snap';\n *\n *     const snap = new Snap({\n *       source: source\n *     });\n *\n *     map.addInteraction(snap);\n *\n * @api\n */\nvar Snap = /** @class */function (_super) {\n  __extends(Snap, _super);\n  /**\n   * @param {Options=} opt_options Options.\n   */\n  function Snap(opt_options) {\n    var _this = this;\n    var options = opt_options ? opt_options : {};\n    var pointerOptions = /** @type {import(\"./Pointer.js\").Options} */options;\n    if (!pointerOptions.handleDownEvent) {\n      pointerOptions.handleDownEvent = TRUE;\n    }\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n    _this = _super.call(this, pointerOptions) || this;\n    /**\n     * @type {import(\"../source/Vector.js\").default}\n     * @private\n     */\n    _this.source_ = options.source ? options.source : null;\n    /**\n     * @private\n     * @type {boolean}\n     */\n    _this.vertex_ = options.vertex !== undefined ? options.vertex : true;\n    /**\n     * @private\n     * @type {boolean}\n     */\n    _this.edge_ = options.edge !== undefined ? options.edge : true;\n    /**\n     * @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>}\n     * @private\n     */\n    _this.features_ = options.features ? options.features : null;\n    /**\n     * @type {Array<import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    _this.featuresListenerKeys_ = [];\n    /**\n     * @type {Object<string, import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    _this.featureChangeListenerKeys_ = {};\n    /**\n     * Extents are preserved so indexed segment can be quickly removed\n     * when its feature geometry changes\n     * @type {Object<string, import(\"../extent.js\").Extent>}\n     * @private\n     */\n    _this.indexedFeaturesExtents_ = {};\n    /**\n     * If a feature geometry changes while a pointer drag|move event occurs, the\n     * feature doesn't get updated right away.  It will be at the next 'pointerup'\n     * event fired.\n     * @type {!Object<string, import(\"../Feature.js\").default>}\n     * @private\n     */\n    _this.pendingFeatures_ = {};\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.pixelTolerance_ = options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\n    /**\n     * Segment RTree for each layer\n     * @type {import(\"../structs/RBush.js\").default<SegmentData>}\n     * @private\n     */\n    _this.rBush_ = new RBush();\n    /**\n     * @const\n     * @private\n     * @type {Object<string, function(import(\"../Feature.js\").default, import(\"../geom/Geometry.js\").default): void>}\n     */\n    _this.SEGMENT_WRITERS_ = {\n      'Point': _this.writePointGeometry_.bind(_this),\n      'LineString': _this.writeLineStringGeometry_.bind(_this),\n      'LinearRing': _this.writeLineStringGeometry_.bind(_this),\n      'Polygon': _this.writePolygonGeometry_.bind(_this),\n      'MultiPoint': _this.writeMultiPointGeometry_.bind(_this),\n      'MultiLineString': _this.writeMultiLineStringGeometry_.bind(_this),\n      'MultiPolygon': _this.writeMultiPolygonGeometry_.bind(_this),\n      'GeometryCollection': _this.writeGeometryCollectionGeometry_.bind(_this),\n      'Circle': _this.writeCircleGeometry_.bind(_this)\n    };\n    return _this;\n  }\n  /**\n   * Add a feature to the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {boolean=} opt_listen Whether to listen to the feature change or not\n   *     Defaults to `true`.\n   * @api\n   */\n  Snap.prototype.addFeature = function (feature, opt_listen) {\n    var register = opt_listen !== undefined ? opt_listen : true;\n    var feature_uid = getUid(feature);\n    var geometry = feature.getGeometry();\n    if (geometry) {\n      var segmentWriter = this.SEGMENT_WRITERS_[geometry.getType()];\n      if (segmentWriter) {\n        this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(createEmpty());\n        segmentWriter(feature, geometry);\n      }\n    }\n    if (register) {\n      this.featureChangeListenerKeys_[feature_uid] = listen(feature, EventType.CHANGE, this.handleFeatureChange_, this);\n    }\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @private\n   */\n  Snap.prototype.forEachFeatureAdd_ = function (feature) {\n    this.addFeature(feature);\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @private\n   */\n  Snap.prototype.forEachFeatureRemove_ = function (feature) {\n    this.removeFeature(feature);\n  };\n  /**\n   * @return {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} Features.\n   * @private\n   */\n  Snap.prototype.getFeatures_ = function () {\n    var features;\n    if (this.features_) {\n      features = this.features_;\n    } else if (this.source_) {\n      features = this.source_.getFeatures();\n    }\n    return features;\n  };\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   */\n  Snap.prototype.handleEvent = function (evt) {\n    var result = this.snapTo(evt.pixel, evt.coordinate, evt.map);\n    if (result.snapped) {\n      evt.coordinate = result.vertex.slice(0, 2);\n      evt.pixel = result.vertexPixel;\n    }\n    return _super.prototype.handleEvent.call(this, evt);\n  };\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n   * @private\n   */\n  Snap.prototype.handleFeatureAdd_ = function (evt) {\n    var feature = getFeatureFromEvent(evt);\n    this.addFeature(feature);\n  };\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n   * @private\n   */\n  Snap.prototype.handleFeatureRemove_ = function (evt) {\n    var feature = getFeatureFromEvent(evt);\n    this.removeFeature(feature);\n  };\n  /**\n   * @param {import(\"../events/Event.js\").default} evt Event.\n   * @private\n   */\n  Snap.prototype.handleFeatureChange_ = function (evt) {\n    var feature = /** @type {import(\"../Feature.js\").default} */evt.target;\n    if (this.handlingDownUpSequence) {\n      var uid = getUid(feature);\n      if (!(uid in this.pendingFeatures_)) {\n        this.pendingFeatures_[uid] = feature;\n      }\n    } else {\n      this.updateFeature_(feature);\n    }\n  };\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\n   * @return {boolean} If the event was consumed.\n   */\n  Snap.prototype.handleUpEvent = function (evt) {\n    var featuresToUpdate = getValues(this.pendingFeatures_);\n    if (featuresToUpdate.length) {\n      featuresToUpdate.forEach(this.updateFeature_.bind(this));\n      this.pendingFeatures_ = {};\n    }\n    return false;\n  };\n  /**\n   * Remove a feature from the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {boolean=} opt_unlisten Whether to unlisten to the feature change\n   *     or not. Defaults to `true`.\n   * @api\n   */\n  Snap.prototype.removeFeature = function (feature, opt_unlisten) {\n    var unregister = opt_unlisten !== undefined ? opt_unlisten : true;\n    var feature_uid = getUid(feature);\n    var extent = this.indexedFeaturesExtents_[feature_uid];\n    if (extent) {\n      var rBush = this.rBush_;\n      var nodesToRemove_1 = [];\n      rBush.forEachInExtent(extent, function (node) {\n        if (feature === node.feature) {\n          nodesToRemove_1.push(node);\n        }\n      });\n      for (var i = nodesToRemove_1.length - 1; i >= 0; --i) {\n        rBush.remove(nodesToRemove_1[i]);\n      }\n    }\n    if (unregister) {\n      unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);\n      delete this.featureChangeListenerKeys_[feature_uid];\n    }\n  };\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../PluggableMap.js\").default} map Map.\n   */\n  Snap.prototype.setMap = function (map) {\n    var currentMap = this.getMap();\n    var keys = this.featuresListenerKeys_;\n    var features = /** @type {Array<import(\"../Feature.js\").default>} */this.getFeatures_();\n    if (currentMap) {\n      keys.forEach(unlistenByKey);\n      keys.length = 0;\n      features.forEach(this.forEachFeatureRemove_.bind(this));\n    }\n    _super.prototype.setMap.call(this, map);\n    if (map) {\n      if (this.features_) {\n        keys.push(listen(this.features_, CollectionEventType.ADD, this.handleFeatureAdd_, this), listen(this.features_, CollectionEventType.REMOVE, this.handleFeatureRemove_, this));\n      } else if (this.source_) {\n        keys.push(listen(this.source_, VectorEventType.ADDFEATURE, this.handleFeatureAdd_, this), listen(this.source_, VectorEventType.REMOVEFEATURE, this.handleFeatureRemove_, this));\n      }\n      features.forEach(this.forEachFeatureAdd_.bind(this));\n    }\n  };\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel\n   * @param {import(\"../coordinate.js\").Coordinate} pixelCoordinate Coordinate\n   * @param {import(\"../PluggableMap.js\").default} map Map.\n   * @return {Result} Snap result\n   */\n  Snap.prototype.snapTo = function (pixel, pixelCoordinate, map) {\n    var lowerLeft = map.getCoordinateFromPixel([pixel[0] - this.pixelTolerance_, pixel[1] + this.pixelTolerance_]);\n    var upperRight = map.getCoordinateFromPixel([pixel[0] + this.pixelTolerance_, pixel[1] - this.pixelTolerance_]);\n    var box = boundingExtent([lowerLeft, upperRight]);\n    var segments = this.rBush_.getInExtent(box);\n    // If snapping on vertices only, don't consider circles\n    if (this.vertex_ && !this.edge_) {\n      segments = segments.filter(function (segment) {\n        return segment.feature.getGeometry().getType() !== GeometryType.CIRCLE;\n      });\n    }\n    var snapped = false;\n    var vertex = null;\n    var vertexPixel = null;\n    if (segments.length === 0) {\n      return {\n        snapped: snapped,\n        vertex: vertex,\n        vertexPixel: vertexPixel\n      };\n    }\n    var projection = map.getView().getProjection();\n    var projectedCoordinate = fromUserCoordinate(pixelCoordinate, projection);\n    var closestSegmentData;\n    var minSquaredDistance = Infinity;\n    for (var i = 0; i < segments.length; ++i) {\n      var segmentData = segments[i];\n      tempSegment[0] = fromUserCoordinate(segmentData.segment[0], projection);\n      tempSegment[1] = fromUserCoordinate(segmentData.segment[1], projection);\n      var delta = squaredDistanceToSegment(projectedCoordinate, tempSegment);\n      if (delta < minSquaredDistance) {\n        closestSegmentData = segmentData;\n        minSquaredDistance = delta;\n      }\n    }\n    var closestSegment = closestSegmentData.segment;\n    if (this.vertex_ && !this.edge_) {\n      var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\n      var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\n      var squaredDist1 = squaredCoordinateDistance(pixel, pixel1);\n      var squaredDist2 = squaredCoordinateDistance(pixel, pixel2);\n      var dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n      if (dist <= this.pixelTolerance_) {\n        snapped = true;\n        vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];\n        vertexPixel = map.getPixelFromCoordinate(vertex);\n      }\n    } else if (this.edge_) {\n      var isCircle = closestSegmentData.feature.getGeometry().getType() === GeometryType.CIRCLE;\n      if (isCircle) {\n        var circleGeometry = closestSegmentData.feature.getGeometry();\n        var userProjection = getUserProjection();\n        if (userProjection) {\n          circleGeometry = circleGeometry.clone().transform(userProjection, projection);\n        }\n        vertex = toUserCoordinate(closestOnCircle(projectedCoordinate, /** @type {import(\"../geom/Circle.js\").default} */circleGeometry), projection);\n      } else {\n        tempSegment[0] = fromUserCoordinate(closestSegment[0], projection);\n        tempSegment[1] = fromUserCoordinate(closestSegment[1], projection);\n        vertex = toUserCoordinate(closestOnSegment(projectedCoordinate, tempSegment), projection);\n      }\n      vertexPixel = map.getPixelFromCoordinate(vertex);\n      if (coordinateDistance(pixel, vertexPixel) <= this.pixelTolerance_) {\n        snapped = true;\n        if (this.vertex_ && !isCircle) {\n          var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\n          var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\n          var squaredDist1 = squaredCoordinateDistance(vertexPixel, pixel1);\n          var squaredDist2 = squaredCoordinateDistance(vertexPixel, pixel2);\n          var dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n          if (dist <= this.pixelTolerance_) {\n            vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];\n            vertexPixel = map.getPixelFromCoordinate(vertex);\n          }\n        }\n      }\n    }\n    if (snapped) {\n      vertexPixel = [Math.round(vertexPixel[0]), Math.round(vertexPixel[1])];\n    }\n    return {\n      snapped: snapped,\n      vertex: vertex,\n      vertexPixel: vertexPixel\n    };\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @private\n   */\n  Snap.prototype.updateFeature_ = function (feature) {\n    this.removeFeature(feature, false);\n    this.addFeature(feature, false);\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.writeCircleGeometry_ = function (feature, geometry) {\n    var projection = this.getMap().getView().getProjection();\n    var circleGeometry = geometry;\n    var userProjection = getUserProjection();\n    if (userProjection) {\n      circleGeometry = /** @type {import(\"../geom/Circle.js\").default} */circleGeometry.clone().transform(userProjection, projection);\n    }\n    var polygon = fromCircle(circleGeometry);\n    if (userProjection) {\n      polygon.transform(projection, userProjection);\n    }\n    var coordinates = polygon.getCoordinates()[0];\n    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      var segment = coordinates.slice(i, i + 2);\n      var segmentData = {\n        feature: feature,\n        segment: segment\n      };\n      this.rBush_.insert(boundingExtent(segment), segmentData);\n    }\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.writeGeometryCollectionGeometry_ = function (feature, geometry) {\n    var geometries = geometry.getGeometriesArray();\n    for (var i = 0; i < geometries.length; ++i) {\n      var segmentWriter = this.SEGMENT_WRITERS_[geometries[i].getType()];\n      if (segmentWriter) {\n        segmentWriter(feature, geometries[i]);\n      }\n    }\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/LineString.js\").default} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.writeLineStringGeometry_ = function (feature, geometry) {\n    var coordinates = geometry.getCoordinates();\n    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      var segment = coordinates.slice(i, i + 2);\n      var segmentData = {\n        feature: feature,\n        segment: segment\n      };\n      this.rBush_.insert(boundingExtent(segment), segmentData);\n    }\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/MultiLineString.js\").default} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.writeMultiLineStringGeometry_ = function (feature, geometry) {\n    var lines = geometry.getCoordinates();\n    for (var j = 0, jj = lines.length; j < jj; ++j) {\n      var coordinates = lines[j];\n      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        var segment = coordinates.slice(i, i + 2);\n        var segmentData = {\n          feature: feature,\n          segment: segment\n        };\n        this.rBush_.insert(boundingExtent(segment), segmentData);\n      }\n    }\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.writeMultiPointGeometry_ = function (feature, geometry) {\n    var points = geometry.getCoordinates();\n    for (var i = 0, ii = points.length; i < ii; ++i) {\n      var coordinates = points[i];\n      var segmentData = {\n        feature: feature,\n        segment: [coordinates, coordinates]\n      };\n      this.rBush_.insert(geometry.getExtent(), segmentData);\n    }\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.writeMultiPolygonGeometry_ = function (feature, geometry) {\n    var polygons = geometry.getCoordinates();\n    for (var k = 0, kk = polygons.length; k < kk; ++k) {\n      var rings = polygons[k];\n      for (var j = 0, jj = rings.length; j < jj; ++j) {\n        var coordinates = rings[j];\n        for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n          var segment = coordinates.slice(i, i + 2);\n          var segmentData = {\n            feature: feature,\n            segment: segment\n          };\n          this.rBush_.insert(boundingExtent(segment), segmentData);\n        }\n      }\n    }\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/Point.js\").default} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.writePointGeometry_ = function (feature, geometry) {\n    var coordinates = geometry.getCoordinates();\n    var segmentData = {\n      feature: feature,\n      segment: [coordinates, coordinates]\n    };\n    this.rBush_.insert(geometry.getExtent(), segmentData);\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/Polygon.js\").default} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.writePolygonGeometry_ = function (feature, geometry) {\n    var rings = geometry.getCoordinates();\n    for (var j = 0, jj = rings.length; j < jj; ++j) {\n      var coordinates = rings[j];\n      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        var segment = coordinates.slice(i, i + 2);\n        var segmentData = {\n          feature: feature,\n          segment: segment\n        };\n        this.rBush_.insert(boundingExtent(segment), segmentData);\n      }\n    }\n  };\n  return Snap;\n}(PointerInteraction);\nexport default Snap;","map":{"version":3,"names":["CollectionEventType","EventType","GeometryType","PointerInteraction","RBush","VectorEventType","FALSE","TRUE","boundingExtent","createEmpty","closestOnCircle","closestOnSegment","distance","coordinateDistance","squaredDistance","squaredCoordinateDistance","squaredDistanceToSegment","fromCircle","fromUserCoordinate","getUserProjection","toUserCoordinate","getUid","getValues","listen","unlistenByKey","getFeatureFromEvent","evt","feature","element","tempSegment","Snap","_super","__extends","opt_options","_this","options","pointerOptions","handleDownEvent","stopDown","call","source_","source","vertex_","vertex","undefined","edge_","edge","features_","features","featuresListenerKeys_","featureChangeListenerKeys_","indexedFeaturesExtents_","pendingFeatures_","pixelTolerance_","pixelTolerance","rBush_","SEGMENT_WRITERS_","writePointGeometry_","bind","writeLineStringGeometry_","writePolygonGeometry_","writeMultiPointGeometry_","writeMultiLineStringGeometry_","writeMultiPolygonGeometry_","writeGeometryCollectionGeometry_","writeCircleGeometry_","prototype","addFeature","opt_listen","register","feature_uid","geometry","getGeometry","segmentWriter","getType","getExtent","CHANGE","handleFeatureChange_","forEachFeatureAdd_","forEachFeatureRemove_","removeFeature","getFeatures_","getFeatures","handleEvent","result","snapTo","pixel","coordinate","map","snapped","slice","vertexPixel","handleFeatureAdd_","handleFeatureRemove_","target","handlingDownUpSequence","uid","updateFeature_","handleUpEvent","featuresToUpdate","length","forEach","opt_unlisten","unregister","extent","rBush","nodesToRemove_1","forEachInExtent","node","push","i","remove","setMap","currentMap","getMap","keys","ADD","REMOVE","ADDFEATURE","REMOVEFEATURE","pixelCoordinate","lowerLeft","getCoordinateFromPixel","upperRight","box","segments","getInExtent","filter","segment","CIRCLE","projection","getView","getProjection","projectedCoordinate","closestSegmentData","minSquaredDistance","Infinity","segmentData","delta","closestSegment","pixel1","getPixelFromCoordinate","pixel2","squaredDist1","squaredDist2","dist","Math","sqrt","min","isCircle","circleGeometry","userProjection","clone","transform","round","polygon","coordinates","getCoordinates","ii","insert","geometries","getGeometriesArray","lines","j","jj","points","polygons","k","kk","rings"],"sources":["/Users/mariovicky/Skripsi_OpenLayers/node_modules/ol/src/interaction/Snap.js"],"sourcesContent":["/**\n * @module ol/interaction/Snap\n */\nimport CollectionEventType from '../CollectionEventType.js';\nimport EventType from '../events/EventType.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport PointerInteraction from './Pointer.js';\nimport RBush from '../structs/RBush.js';\nimport VectorEventType from '../source/VectorEventType.js';\nimport {FALSE, TRUE} from '../functions.js';\nimport {boundingExtent, createEmpty} from '../extent.js';\nimport {\n  closestOnCircle,\n  closestOnSegment,\n  distance as coordinateDistance,\n  squaredDistance as squaredCoordinateDistance,\n  squaredDistanceToSegment,\n} from '../coordinate.js';\nimport {fromCircle} from '../geom/Polygon.js';\nimport {\n  fromUserCoordinate,\n  getUserProjection,\n  toUserCoordinate,\n} from '../proj.js';\nimport {getUid} from '../util.js';\nimport {getValues} from '../obj.js';\nimport {listen, unlistenByKey} from '../events.js';\n\n/**\n * @typedef {Object} Result\n * @property {boolean} snapped\n * @property {import(\"../coordinate.js\").Coordinate|null} vertex\n * @property {import(\"../pixel.js\").Pixel|null} vertexPixel\n */\n\n/**\n * @typedef {Object} SegmentData\n * @property {import(\"../Feature.js\").default} feature\n * @property {Array<import(\"../coordinate.js\").Coordinate>} segment\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../Collection.js\").default<import(\"../Feature.js\").default>} [features] Snap to these features. Either this option or source should be provided.\n * @property {boolean} [edge=true] Snap to edges.\n * @property {boolean} [vertex=true] Snap to vertices.\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or\n * vertex for snapping.\n * @property {import(\"../source/Vector.js\").default} [source] Snap to features from this source. Either this option or features should be provided\n */\n\n/**\n * @param  {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n * @return {import(\"../Feature.js\").default} Feature.\n */\nfunction getFeatureFromEvent(evt) {\n  if (\n    /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */ (evt).feature\n  ) {\n    return /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */ (evt)\n      .feature;\n  } else if (\n    /** @type {import(\"../Collection.js\").CollectionEvent} */ (evt).element\n  ) {\n    return /** @type {import(\"../Feature.js\").default} */ (\n      /** @type {import(\"../Collection.js\").CollectionEvent} */ (evt).element\n    );\n  }\n}\n\nconst tempSegment = [];\n\n/**\n * @classdesc\n * Handles snapping of vector features while modifying or drawing them.  The\n * features can come from a {@link module:ol/source/Vector} or {@link module:ol/Collection~Collection}\n * Any interaction object that allows the user to interact\n * with the features using the mouse can benefit from the snapping, as long\n * as it is added before.\n *\n * The snap interaction modifies map browser event `coordinate` and `pixel`\n * properties to force the snap to occur to any interaction that them.\n *\n * Example:\n *\n *     import Snap from 'ol/interaction/Snap';\n *\n *     const snap = new Snap({\n *       source: source\n *     });\n *\n *     map.addInteraction(snap);\n *\n * @api\n */\nclass Snap extends PointerInteraction {\n  /**\n   * @param {Options=} opt_options Options.\n   */\n  constructor(opt_options) {\n    const options = opt_options ? opt_options : {};\n\n    const pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (options);\n\n    if (!pointerOptions.handleDownEvent) {\n      pointerOptions.handleDownEvent = TRUE;\n    }\n\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    super(pointerOptions);\n\n    /**\n     * @type {import(\"../source/Vector.js\").default}\n     * @private\n     */\n    this.source_ = options.source ? options.source : null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.vertex_ = options.vertex !== undefined ? options.vertex : true;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.edge_ = options.edge !== undefined ? options.edge : true;\n\n    /**\n     * @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>}\n     * @private\n     */\n    this.features_ = options.features ? options.features : null;\n\n    /**\n     * @type {Array<import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    this.featuresListenerKeys_ = [];\n\n    /**\n     * @type {Object<string, import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    this.featureChangeListenerKeys_ = {};\n\n    /**\n     * Extents are preserved so indexed segment can be quickly removed\n     * when its feature geometry changes\n     * @type {Object<string, import(\"../extent.js\").Extent>}\n     * @private\n     */\n    this.indexedFeaturesExtents_ = {};\n\n    /**\n     * If a feature geometry changes while a pointer drag|move event occurs, the\n     * feature doesn't get updated right away.  It will be at the next 'pointerup'\n     * event fired.\n     * @type {!Object<string, import(\"../Feature.js\").default>}\n     * @private\n     */\n    this.pendingFeatures_ = {};\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.pixelTolerance_ =\n      options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\n\n    /**\n     * Segment RTree for each layer\n     * @type {import(\"../structs/RBush.js\").default<SegmentData>}\n     * @private\n     */\n    this.rBush_ = new RBush();\n\n    /**\n     * @const\n     * @private\n     * @type {Object<string, function(import(\"../Feature.js\").default, import(\"../geom/Geometry.js\").default): void>}\n     */\n    this.SEGMENT_WRITERS_ = {\n      'Point': this.writePointGeometry_.bind(this),\n      'LineString': this.writeLineStringGeometry_.bind(this),\n      'LinearRing': this.writeLineStringGeometry_.bind(this),\n      'Polygon': this.writePolygonGeometry_.bind(this),\n      'MultiPoint': this.writeMultiPointGeometry_.bind(this),\n      'MultiLineString': this.writeMultiLineStringGeometry_.bind(this),\n      'MultiPolygon': this.writeMultiPolygonGeometry_.bind(this),\n      'GeometryCollection': this.writeGeometryCollectionGeometry_.bind(this),\n      'Circle': this.writeCircleGeometry_.bind(this),\n    };\n  }\n\n  /**\n   * Add a feature to the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {boolean=} opt_listen Whether to listen to the feature change or not\n   *     Defaults to `true`.\n   * @api\n   */\n  addFeature(feature, opt_listen) {\n    const register = opt_listen !== undefined ? opt_listen : true;\n    const feature_uid = getUid(feature);\n    const geometry = feature.getGeometry();\n    if (geometry) {\n      const segmentWriter = this.SEGMENT_WRITERS_[geometry.getType()];\n      if (segmentWriter) {\n        this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(\n          createEmpty()\n        );\n        segmentWriter(feature, geometry);\n      }\n    }\n\n    if (register) {\n      this.featureChangeListenerKeys_[feature_uid] = listen(\n        feature,\n        EventType.CHANGE,\n        this.handleFeatureChange_,\n        this\n      );\n    }\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @private\n   */\n  forEachFeatureAdd_(feature) {\n    this.addFeature(feature);\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @private\n   */\n  forEachFeatureRemove_(feature) {\n    this.removeFeature(feature);\n  }\n\n  /**\n   * @return {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} Features.\n   * @private\n   */\n  getFeatures_() {\n    let features;\n    if (this.features_) {\n      features = this.features_;\n    } else if (this.source_) {\n      features = this.source_.getFeatures();\n    }\n    return features;\n  }\n\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   */\n  handleEvent(evt) {\n    const result = this.snapTo(evt.pixel, evt.coordinate, evt.map);\n    if (result.snapped) {\n      evt.coordinate = result.vertex.slice(0, 2);\n      evt.pixel = result.vertexPixel;\n    }\n    return super.handleEvent(evt);\n  }\n\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n   * @private\n   */\n  handleFeatureAdd_(evt) {\n    const feature = getFeatureFromEvent(evt);\n    this.addFeature(feature);\n  }\n\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n   * @private\n   */\n  handleFeatureRemove_(evt) {\n    const feature = getFeatureFromEvent(evt);\n    this.removeFeature(feature);\n  }\n\n  /**\n   * @param {import(\"../events/Event.js\").default} evt Event.\n   * @private\n   */\n  handleFeatureChange_(evt) {\n    const feature = /** @type {import(\"../Feature.js\").default} */ (evt.target);\n    if (this.handlingDownUpSequence) {\n      const uid = getUid(feature);\n      if (!(uid in this.pendingFeatures_)) {\n        this.pendingFeatures_[uid] = feature;\n      }\n    } else {\n      this.updateFeature_(feature);\n    }\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(evt) {\n    const featuresToUpdate = getValues(this.pendingFeatures_);\n    if (featuresToUpdate.length) {\n      featuresToUpdate.forEach(this.updateFeature_.bind(this));\n      this.pendingFeatures_ = {};\n    }\n    return false;\n  }\n\n  /**\n   * Remove a feature from the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {boolean=} opt_unlisten Whether to unlisten to the feature change\n   *     or not. Defaults to `true`.\n   * @api\n   */\n  removeFeature(feature, opt_unlisten) {\n    const unregister = opt_unlisten !== undefined ? opt_unlisten : true;\n    const feature_uid = getUid(feature);\n    const extent = this.indexedFeaturesExtents_[feature_uid];\n    if (extent) {\n      const rBush = this.rBush_;\n      const nodesToRemove = [];\n      rBush.forEachInExtent(extent, function (node) {\n        if (feature === node.feature) {\n          nodesToRemove.push(node);\n        }\n      });\n      for (let i = nodesToRemove.length - 1; i >= 0; --i) {\n        rBush.remove(nodesToRemove[i]);\n      }\n    }\n\n    if (unregister) {\n      unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);\n      delete this.featureChangeListenerKeys_[feature_uid];\n    }\n  }\n\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../PluggableMap.js\").default} map Map.\n   */\n  setMap(map) {\n    const currentMap = this.getMap();\n    const keys = this.featuresListenerKeys_;\n    const features = /** @type {Array<import(\"../Feature.js\").default>} */ (this.getFeatures_());\n\n    if (currentMap) {\n      keys.forEach(unlistenByKey);\n      keys.length = 0;\n      features.forEach(this.forEachFeatureRemove_.bind(this));\n    }\n    super.setMap(map);\n\n    if (map) {\n      if (this.features_) {\n        keys.push(\n          listen(\n            this.features_,\n            CollectionEventType.ADD,\n            this.handleFeatureAdd_,\n            this\n          ),\n          listen(\n            this.features_,\n            CollectionEventType.REMOVE,\n            this.handleFeatureRemove_,\n            this\n          )\n        );\n      } else if (this.source_) {\n        keys.push(\n          listen(\n            this.source_,\n            VectorEventType.ADDFEATURE,\n            this.handleFeatureAdd_,\n            this\n          ),\n          listen(\n            this.source_,\n            VectorEventType.REMOVEFEATURE,\n            this.handleFeatureRemove_,\n            this\n          )\n        );\n      }\n      features.forEach(this.forEachFeatureAdd_.bind(this));\n    }\n  }\n\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel\n   * @param {import(\"../coordinate.js\").Coordinate} pixelCoordinate Coordinate\n   * @param {import(\"../PluggableMap.js\").default} map Map.\n   * @return {Result} Snap result\n   */\n  snapTo(pixel, pixelCoordinate, map) {\n    const lowerLeft = map.getCoordinateFromPixel([\n      pixel[0] - this.pixelTolerance_,\n      pixel[1] + this.pixelTolerance_,\n    ]);\n    const upperRight = map.getCoordinateFromPixel([\n      pixel[0] + this.pixelTolerance_,\n      pixel[1] - this.pixelTolerance_,\n    ]);\n    const box = boundingExtent([lowerLeft, upperRight]);\n\n    let segments = this.rBush_.getInExtent(box);\n\n    // If snapping on vertices only, don't consider circles\n    if (this.vertex_ && !this.edge_) {\n      segments = segments.filter(function (segment) {\n        return segment.feature.getGeometry().getType() !== GeometryType.CIRCLE;\n      });\n    }\n\n    let snapped = false;\n    let vertex = null;\n    let vertexPixel = null;\n\n    if (segments.length === 0) {\n      return {\n        snapped: snapped,\n        vertex: vertex,\n        vertexPixel: vertexPixel,\n      };\n    }\n\n    const projection = map.getView().getProjection();\n    const projectedCoordinate = fromUserCoordinate(pixelCoordinate, projection);\n\n    let closestSegmentData;\n    let minSquaredDistance = Infinity;\n    for (let i = 0; i < segments.length; ++i) {\n      const segmentData = segments[i];\n      tempSegment[0] = fromUserCoordinate(segmentData.segment[0], projection);\n      tempSegment[1] = fromUserCoordinate(segmentData.segment[1], projection);\n      const delta = squaredDistanceToSegment(projectedCoordinate, tempSegment);\n      if (delta < minSquaredDistance) {\n        closestSegmentData = segmentData;\n        minSquaredDistance = delta;\n      }\n    }\n    const closestSegment = closestSegmentData.segment;\n\n    if (this.vertex_ && !this.edge_) {\n      const pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\n      const pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\n      const squaredDist1 = squaredCoordinateDistance(pixel, pixel1);\n      const squaredDist2 = squaredCoordinateDistance(pixel, pixel2);\n      const dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n      if (dist <= this.pixelTolerance_) {\n        snapped = true;\n        vertex =\n          squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];\n        vertexPixel = map.getPixelFromCoordinate(vertex);\n      }\n    } else if (this.edge_) {\n      const isCircle =\n        closestSegmentData.feature.getGeometry().getType() ===\n        GeometryType.CIRCLE;\n      if (isCircle) {\n        let circleGeometry = closestSegmentData.feature.getGeometry();\n        const userProjection = getUserProjection();\n        if (userProjection) {\n          circleGeometry = circleGeometry\n            .clone()\n            .transform(userProjection, projection);\n        }\n        vertex = toUserCoordinate(\n          closestOnCircle(\n            projectedCoordinate,\n            /** @type {import(\"../geom/Circle.js\").default} */ (circleGeometry)\n          ),\n          projection\n        );\n      } else {\n        tempSegment[0] = fromUserCoordinate(closestSegment[0], projection);\n        tempSegment[1] = fromUserCoordinate(closestSegment[1], projection);\n        vertex = toUserCoordinate(\n          closestOnSegment(projectedCoordinate, tempSegment),\n          projection\n        );\n      }\n      vertexPixel = map.getPixelFromCoordinate(vertex);\n\n      if (coordinateDistance(pixel, vertexPixel) <= this.pixelTolerance_) {\n        snapped = true;\n        if (this.vertex_ && !isCircle) {\n          const pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\n          const pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\n          const squaredDist1 = squaredCoordinateDistance(vertexPixel, pixel1);\n          const squaredDist2 = squaredCoordinateDistance(vertexPixel, pixel2);\n          const dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n          if (dist <= this.pixelTolerance_) {\n            vertex =\n              squaredDist1 > squaredDist2\n                ? closestSegment[1]\n                : closestSegment[0];\n            vertexPixel = map.getPixelFromCoordinate(vertex);\n          }\n        }\n      }\n    }\n\n    if (snapped) {\n      vertexPixel = [Math.round(vertexPixel[0]), Math.round(vertexPixel[1])];\n    }\n\n    return {\n      snapped: snapped,\n      vertex: vertex,\n      vertexPixel: vertexPixel,\n    };\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @private\n   */\n  updateFeature_(feature) {\n    this.removeFeature(feature, false);\n    this.addFeature(feature, false);\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n   * @private\n   */\n  writeCircleGeometry_(feature, geometry) {\n    const projection = this.getMap().getView().getProjection();\n    let circleGeometry = geometry;\n    const userProjection = getUserProjection();\n    if (userProjection) {\n      circleGeometry = /** @type {import(\"../geom/Circle.js\").default} */ (circleGeometry\n        .clone()\n        .transform(userProjection, projection));\n    }\n    const polygon = fromCircle(circleGeometry);\n    if (userProjection) {\n      polygon.transform(projection, userProjection);\n    }\n    const coordinates = polygon.getCoordinates()[0];\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      const segment = coordinates.slice(i, i + 2);\n      const segmentData = {\n        feature: feature,\n        segment: segment,\n      };\n      this.rBush_.insert(boundingExtent(segment), segmentData);\n    }\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n   * @private\n   */\n  writeGeometryCollectionGeometry_(feature, geometry) {\n    const geometries = geometry.getGeometriesArray();\n    for (let i = 0; i < geometries.length; ++i) {\n      const segmentWriter = this.SEGMENT_WRITERS_[geometries[i].getType()];\n      if (segmentWriter) {\n        segmentWriter(feature, geometries[i]);\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/LineString.js\").default} geometry Geometry.\n   * @private\n   */\n  writeLineStringGeometry_(feature, geometry) {\n    const coordinates = geometry.getCoordinates();\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      const segment = coordinates.slice(i, i + 2);\n      const segmentData = {\n        feature: feature,\n        segment: segment,\n      };\n      this.rBush_.insert(boundingExtent(segment), segmentData);\n    }\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/MultiLineString.js\").default} geometry Geometry.\n   * @private\n   */\n  writeMultiLineStringGeometry_(feature, geometry) {\n    const lines = geometry.getCoordinates();\n    for (let j = 0, jj = lines.length; j < jj; ++j) {\n      const coordinates = lines[j];\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        const segment = coordinates.slice(i, i + 2);\n        const segmentData = {\n          feature: feature,\n          segment: segment,\n        };\n        this.rBush_.insert(boundingExtent(segment), segmentData);\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry Geometry.\n   * @private\n   */\n  writeMultiPointGeometry_(feature, geometry) {\n    const points = geometry.getCoordinates();\n    for (let i = 0, ii = points.length; i < ii; ++i) {\n      const coordinates = points[i];\n      const segmentData = {\n        feature: feature,\n        segment: [coordinates, coordinates],\n      };\n      this.rBush_.insert(geometry.getExtent(), segmentData);\n    }\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n   * @private\n   */\n  writeMultiPolygonGeometry_(feature, geometry) {\n    const polygons = geometry.getCoordinates();\n    for (let k = 0, kk = polygons.length; k < kk; ++k) {\n      const rings = polygons[k];\n      for (let j = 0, jj = rings.length; j < jj; ++j) {\n        const coordinates = rings[j];\n        for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n          const segment = coordinates.slice(i, i + 2);\n          const segmentData = {\n            feature: feature,\n            segment: segment,\n          };\n          this.rBush_.insert(boundingExtent(segment), segmentData);\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/Point.js\").default} geometry Geometry.\n   * @private\n   */\n  writePointGeometry_(feature, geometry) {\n    const coordinates = geometry.getCoordinates();\n    const segmentData = {\n      feature: feature,\n      segment: [coordinates, coordinates],\n    };\n    this.rBush_.insert(geometry.getExtent(), segmentData);\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/Polygon.js\").default} geometry Geometry.\n   * @private\n   */\n  writePolygonGeometry_(feature, geometry) {\n    const rings = geometry.getCoordinates();\n    for (let j = 0, jj = rings.length; j < jj; ++j) {\n      const coordinates = rings[j];\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        const segment = coordinates.slice(i, i + 2);\n        const segmentData = {\n          feature: feature,\n          segment: segment,\n        };\n        this.rBush_.insert(boundingExtent(segment), segmentData);\n      }\n    }\n  }\n}\n\nexport default Snap;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
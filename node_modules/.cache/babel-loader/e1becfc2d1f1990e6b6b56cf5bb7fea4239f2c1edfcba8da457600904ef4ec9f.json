{"ast":null,"code":"/**\n * @module ol/source/TileJSON\n */\n// FIXME check order of async callbacks\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * See https://mapbox.com/developers/api/.\n */\nimport SourceState from './State.js';\nimport TileImage from './TileImage.js';\nimport { applyTransform, intersects } from '../extent.js';\nimport { assert } from '../asserts.js';\nimport { createFromTemplates } from '../tileurlfunction.js';\nimport { createXYZ, extentFromProjection } from '../tilegrid.js';\nimport { get as getProjection, getTransformFromProjections } from '../proj.js';\nimport { jsonp as requestJSONP } from '../net.js';\n/**\n * @typedef {Object} Config\n * @property {string} [name] The name.\n * @property {string} [description] The description.\n * @property {string} [version] The version.\n * @property {string} [attribution] The attribution.\n * @property {string} [template] The template.\n * @property {string} [legend] The legend.\n * @property {string} [scheme] The scheme.\n * @property {Array<string>} tiles The tile URL templates.\n * @property {Array<string>} [grids] Optional grids.\n * @property {number} [minzoom] Minimum zoom level.\n * @property {number} [maxzoom] Maximum zoom level.\n * @property {Array<number>} [bounds] Optional bounds.\n * @property {Array<number>} [center] Optional center.\n */\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [imageSmoothing=true] Enable image smoothing.\n * @property {boolean} [jsonp=false] Use JSONP with callback to load the TileJSON.\n * Useful when the server does not support CORS..\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {Config} [tileJSON] TileJSON configuration for this source.\n * If not provided, `url` must be configured.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\n * ```js\n * function(imageTile, src) {\n *   imageTile.getImage().src = src;\n * };\n * ```\n * @property {number|import(\"../size.js\").Size} [tileSize=[256, 256]] The tile size used by the tile service.\n * Note: `tileSize` and other non-standard TileJSON properties are currently ignored.\n * @property {string} [url] URL to the TileJSON file. If not provided, `tileJSON` must be configured.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * @property {number} [transition] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n */\n/**\n * @classdesc\n * Layer source for tile data in TileJSON format.\n * @api\n */\nvar TileJSON = /** @class */function (_super) {\n  __extends(TileJSON, _super);\n  /**\n   * @param {Options} options TileJSON options.\n   */\n  function TileJSON(options) {\n    var _this = _super.call(this, {\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      crossOrigin: options.crossOrigin,\n      imageSmoothing: options.imageSmoothing,\n      projection: getProjection('EPSG:3857'),\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      state: SourceState.LOADING,\n      tileLoadFunction: options.tileLoadFunction,\n      wrapX: options.wrapX !== undefined ? options.wrapX : true,\n      transition: options.transition\n    }) || this;\n    /**\n     * @type {Config}\n     * @private\n     */\n    _this.tileJSON_ = null;\n    /**\n     * @type {number|import(\"../size.js\").Size}\n     * @private\n     */\n    _this.tileSize_ = options.tileSize;\n    if (options.url) {\n      if (options.jsonp) {\n        requestJSONP(options.url, _this.handleTileJSONResponse.bind(_this), _this.handleTileJSONError.bind(_this));\n      } else {\n        var client = new XMLHttpRequest();\n        client.addEventListener('load', _this.onXHRLoad_.bind(_this));\n        client.addEventListener('error', _this.onXHRError_.bind(_this));\n        client.open('GET', options.url);\n        client.send();\n      }\n    } else if (options.tileJSON) {\n      _this.handleTileJSONResponse(options.tileJSON);\n    } else {\n      assert(false, 51); // Either `url` or `tileJSON` options must be provided\n    }\n\n    return _this;\n  }\n  /**\n   * @private\n   * @param {Event} event The load event.\n   */\n  TileJSON.prototype.onXHRLoad_ = function (event) {\n    var client = /** @type {XMLHttpRequest} */event.target;\n    // status will be 0 for file:// urls\n    if (!client.status || client.status >= 200 && client.status < 300) {\n      var response = void 0;\n      try {\n        response = /** @type {TileJSON} */JSON.parse(client.responseText);\n      } catch (err) {\n        this.handleTileJSONError();\n        return;\n      }\n      this.handleTileJSONResponse(response);\n    } else {\n      this.handleTileJSONError();\n    }\n  };\n  /**\n   * @private\n   * @param {Event} event The error event.\n   */\n  TileJSON.prototype.onXHRError_ = function (event) {\n    this.handleTileJSONError();\n  };\n  /**\n   * @return {Config} The tilejson object.\n   * @api\n   */\n  TileJSON.prototype.getTileJSON = function () {\n    return this.tileJSON_;\n  };\n  /**\n   * @protected\n   * @param {Config} tileJSON Tile JSON.\n   */\n  TileJSON.prototype.handleTileJSONResponse = function (tileJSON) {\n    var epsg4326Projection = getProjection('EPSG:4326');\n    var sourceProjection = this.getProjection();\n    var extent;\n    if (tileJSON['bounds'] !== undefined) {\n      var transform = getTransformFromProjections(epsg4326Projection, sourceProjection);\n      extent = applyTransform(tileJSON['bounds'], transform);\n    }\n    var minZoom = tileJSON['minzoom'] || 0;\n    var maxZoom = tileJSON['maxzoom'] || 22;\n    var tileGrid = createXYZ({\n      extent: extentFromProjection(sourceProjection),\n      maxZoom: maxZoom,\n      minZoom: minZoom,\n      tileSize: this.tileSize_\n    });\n    this.tileGrid = tileGrid;\n    this.tileUrlFunction = createFromTemplates(tileJSON['tiles'], tileGrid);\n    if (tileJSON['attribution'] !== undefined && !this.getAttributions()) {\n      var attributionExtent_1 = extent !== undefined ? extent : epsg4326Projection.getExtent();\n      this.setAttributions(function (frameState) {\n        if (intersects(attributionExtent_1, frameState.extent)) {\n          return [tileJSON['attribution']];\n        }\n        return null;\n      });\n    }\n    this.tileJSON_ = tileJSON;\n    this.setState(SourceState.READY);\n  };\n  /**\n   * @protected\n   */\n  TileJSON.prototype.handleTileJSONError = function () {\n    this.setState(SourceState.ERROR);\n  };\n  return TileJSON;\n}(TileImage);\nexport default TileJSON;","map":{"version":3,"names":["SourceState","TileImage","applyTransform","intersects","assert","createFromTemplates","createXYZ","extentFromProjection","get","getProjection","getTransformFromProjections","jsonp","requestJSONP","TileJSON","_super","__extends","options","_this","call","attributions","cacheSize","crossOrigin","imageSmoothing","projection","reprojectionErrorThreshold","state","LOADING","tileLoadFunction","wrapX","undefined","transition","tileJSON_","tileSize_","tileSize","url","handleTileJSONResponse","bind","handleTileJSONError","client","XMLHttpRequest","addEventListener","onXHRLoad_","onXHRError_","open","send","tileJSON","prototype","event","target","status","response","JSON","parse","responseText","err","getTileJSON","epsg4326Projection","sourceProjection","extent","transform","minZoom","maxZoom","tileGrid","tileUrlFunction","getAttributions","attributionExtent_1","getExtent","setAttributions","frameState","setState","READY","ERROR"],"sources":["/Users/mariovicky/Skripsi_OpenLayers/node_modules/ol/src/source/TileJSON.js"],"sourcesContent":["/**\n * @module ol/source/TileJSON\n */\n// FIXME check order of async callbacks\n\n/**\n * See https://mapbox.com/developers/api/.\n */\n\nimport SourceState from './State.js';\nimport TileImage from './TileImage.js';\nimport {applyTransform, intersects} from '../extent.js';\nimport {assert} from '../asserts.js';\nimport {createFromTemplates} from '../tileurlfunction.js';\nimport {createXYZ, extentFromProjection} from '../tilegrid.js';\nimport {get as getProjection, getTransformFromProjections} from '../proj.js';\nimport {jsonp as requestJSONP} from '../net.js';\n\n/**\n * @typedef {Object} Config\n * @property {string} [name] The name.\n * @property {string} [description] The description.\n * @property {string} [version] The version.\n * @property {string} [attribution] The attribution.\n * @property {string} [template] The template.\n * @property {string} [legend] The legend.\n * @property {string} [scheme] The scheme.\n * @property {Array<string>} tiles The tile URL templates.\n * @property {Array<string>} [grids] Optional grids.\n * @property {number} [minzoom] Minimum zoom level.\n * @property {number} [maxzoom] Maximum zoom level.\n * @property {Array<number>} [bounds] Optional bounds.\n * @property {Array<number>} [center] Optional center.\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [imageSmoothing=true] Enable image smoothing.\n * @property {boolean} [jsonp=false] Use JSONP with callback to load the TileJSON.\n * Useful when the server does not support CORS..\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {Config} [tileJSON] TileJSON configuration for this source.\n * If not provided, `url` must be configured.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\n * ```js\n * function(imageTile, src) {\n *   imageTile.getImage().src = src;\n * };\n * ```\n * @property {number|import(\"../size.js\").Size} [tileSize=[256, 256]] The tile size used by the tile service.\n * Note: `tileSize` and other non-standard TileJSON properties are currently ignored.\n * @property {string} [url] URL to the TileJSON file. If not provided, `tileJSON` must be configured.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * @property {number} [transition] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n */\n\n/**\n * @classdesc\n * Layer source for tile data in TileJSON format.\n * @api\n */\nclass TileJSON extends TileImage {\n  /**\n   * @param {Options} options TileJSON options.\n   */\n  constructor(options) {\n    super({\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      crossOrigin: options.crossOrigin,\n      imageSmoothing: options.imageSmoothing,\n      projection: getProjection('EPSG:3857'),\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      state: SourceState.LOADING,\n      tileLoadFunction: options.tileLoadFunction,\n      wrapX: options.wrapX !== undefined ? options.wrapX : true,\n      transition: options.transition,\n    });\n\n    /**\n     * @type {Config}\n     * @private\n     */\n    this.tileJSON_ = null;\n\n    /**\n     * @type {number|import(\"../size.js\").Size}\n     * @private\n     */\n    this.tileSize_ = options.tileSize;\n\n    if (options.url) {\n      if (options.jsonp) {\n        requestJSONP(\n          options.url,\n          this.handleTileJSONResponse.bind(this),\n          this.handleTileJSONError.bind(this)\n        );\n      } else {\n        const client = new XMLHttpRequest();\n        client.addEventListener('load', this.onXHRLoad_.bind(this));\n        client.addEventListener('error', this.onXHRError_.bind(this));\n        client.open('GET', options.url);\n        client.send();\n      }\n    } else if (options.tileJSON) {\n      this.handleTileJSONResponse(options.tileJSON);\n    } else {\n      assert(false, 51); // Either `url` or `tileJSON` options must be provided\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} event The load event.\n   */\n  onXHRLoad_(event) {\n    const client = /** @type {XMLHttpRequest} */ (event.target);\n    // status will be 0 for file:// urls\n    if (!client.status || (client.status >= 200 && client.status < 300)) {\n      let response;\n      try {\n        response = /** @type {TileJSON} */ (JSON.parse(client.responseText));\n      } catch (err) {\n        this.handleTileJSONError();\n        return;\n      }\n      this.handleTileJSONResponse(response);\n    } else {\n      this.handleTileJSONError();\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} event The error event.\n   */\n  onXHRError_(event) {\n    this.handleTileJSONError();\n  }\n\n  /**\n   * @return {Config} The tilejson object.\n   * @api\n   */\n  getTileJSON() {\n    return this.tileJSON_;\n  }\n\n  /**\n   * @protected\n   * @param {Config} tileJSON Tile JSON.\n   */\n  handleTileJSONResponse(tileJSON) {\n    const epsg4326Projection = getProjection('EPSG:4326');\n\n    const sourceProjection = this.getProjection();\n    let extent;\n    if (tileJSON['bounds'] !== undefined) {\n      const transform = getTransformFromProjections(\n        epsg4326Projection,\n        sourceProjection\n      );\n      extent = applyTransform(tileJSON['bounds'], transform);\n    }\n\n    const minZoom = tileJSON['minzoom'] || 0;\n    const maxZoom = tileJSON['maxzoom'] || 22;\n    const tileGrid = createXYZ({\n      extent: extentFromProjection(sourceProjection),\n      maxZoom: maxZoom,\n      minZoom: minZoom,\n      tileSize: this.tileSize_,\n    });\n    this.tileGrid = tileGrid;\n\n    this.tileUrlFunction = createFromTemplates(tileJSON['tiles'], tileGrid);\n\n    if (tileJSON['attribution'] !== undefined && !this.getAttributions()) {\n      const attributionExtent =\n        extent !== undefined ? extent : epsg4326Projection.getExtent();\n\n      this.setAttributions(function (frameState) {\n        if (intersects(attributionExtent, frameState.extent)) {\n          return [tileJSON['attribution']];\n        }\n        return null;\n      });\n    }\n    this.tileJSON_ = tileJSON;\n    this.setState(SourceState.READY);\n  }\n\n  /**\n   * @protected\n   */\n  handleTileJSONError() {\n    this.setState(SourceState.ERROR);\n  }\n}\n\nexport default TileJSON;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
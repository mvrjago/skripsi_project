{"ast":null,"code":"'use strict';\n\nconst Ref = require('./ref');\nconst internals = {};\ninternals.extendedCheckForValue = function (value, insensitive) {\n  const valueType = typeof value;\n  if (valueType === 'object') {\n    if (value instanceof Date) {\n      return item => {\n        return item instanceof Date && value.getTime() === item.getTime();\n      };\n    }\n    if (Buffer.isBuffer(value)) {\n      return item => {\n        return Buffer.isBuffer(item) && value.length === item.length && value.toString('binary') === item.toString('binary');\n      };\n    }\n  } else if (insensitive && valueType === 'string') {\n    const lowercaseValue = value.toLowerCase();\n    return item => {\n      return typeof item === 'string' && lowercaseValue === item.toLowerCase();\n    };\n  }\n  return null;\n};\nmodule.exports = class InternalSet {\n  constructor(from) {\n    this._set = new Set(from);\n    this._hasRef = false;\n  }\n  add(value, refs) {\n    const isRef = Ref.isRef(value);\n    if (!isRef && this.has(value, null, null, false)) {\n      return this;\n    }\n    if (refs !== undefined) {\n      // If it's a merge, we don't have any refs\n      Ref.push(refs, value);\n    }\n    this._set.add(value);\n    this._hasRef |= isRef;\n    return this;\n  }\n  merge(add, remove) {\n    for (const item of add._set) {\n      this.add(item);\n    }\n    for (const item of remove._set) {\n      this.remove(item);\n    }\n    return this;\n  }\n  remove(value) {\n    this._set.delete(value);\n    return this;\n  }\n  has(value, state, options, insensitive) {\n    if (!this._set.size) {\n      return false;\n    }\n    const hasValue = this._set.has(value);\n    if (hasValue) {\n      return hasValue;\n    }\n    const extendedCheck = internals.extendedCheckForValue(value, insensitive);\n    if (!extendedCheck) {\n      if (state && this._hasRef) {\n        for (let item of this._set) {\n          if (Ref.isRef(item)) {\n            item = item(state.reference || state.parent, options);\n            if (value === item || Array.isArray(item) && item.includes(value)) {\n              return true;\n            }\n          }\n        }\n      }\n      return false;\n    }\n    return this._has(value, state, options, extendedCheck);\n  }\n  _has(value, state, options, check) {\n    const checkRef = !!(state && this._hasRef);\n    const isReallyEqual = function (item) {\n      if (value === item) {\n        return true;\n      }\n      return check(item);\n    };\n    for (let item of this._set) {\n      if (checkRef && Ref.isRef(item)) {\n        // Only resolve references if there is a state, otherwise it's a merge\n        item = item(state.reference || state.parent, options);\n        if (Array.isArray(item)) {\n          if (item.find(isReallyEqual)) {\n            return true;\n          }\n          continue;\n        }\n      }\n      if (isReallyEqual(item)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  values(options) {\n    if (options && options.stripUndefined) {\n      const values = [];\n      for (const item of this._set) {\n        if (item !== undefined) {\n          values.push(item);\n        }\n      }\n      return values;\n    }\n    return Array.from(this._set);\n  }\n  slice() {\n    const set = new InternalSet(this._set);\n    set._hasRef = this._hasRef;\n    return set;\n  }\n  concat(source) {\n    const set = new InternalSet([...this._set, ...source._set]);\n    set._hasRef = !!(this._hasRef | source._hasRef);\n    return set;\n  }\n};","map":{"version":3,"names":["Ref","require","internals","extendedCheckForValue","value","insensitive","valueType","Date","item","getTime","Buffer","isBuffer","length","toString","lowercaseValue","toLowerCase","module","exports","InternalSet","constructor","from","_set","Set","_hasRef","add","refs","isRef","has","undefined","push","merge","remove","delete","state","options","size","hasValue","extendedCheck","reference","parent","Array","isArray","includes","_has","check","checkRef","isReallyEqual","find","values","stripUndefined","slice","set","concat","source"],"sources":["/Users/mariovicky/Skripsi_OpenLayers/node_modules/joi/lib/set.js"],"sourcesContent":["'use strict';\n\nconst Ref = require('./ref');\n\n\nconst internals = {};\n\n\ninternals.extendedCheckForValue = function (value, insensitive) {\n\n    const valueType = typeof value;\n\n    if (valueType === 'object') {\n        if (value instanceof Date) {\n            return (item) => {\n\n                return item instanceof Date && value.getTime() === item.getTime();\n            };\n        }\n        if (Buffer.isBuffer(value)) {\n            return (item) => {\n\n                return Buffer.isBuffer(item) && value.length === item.length && value.toString('binary') === item.toString('binary');\n            };\n        }\n    }\n    else if (insensitive && valueType === 'string') {\n        const lowercaseValue = value.toLowerCase();\n        return (item) => {\n\n            return typeof item === 'string' && lowercaseValue === item.toLowerCase();\n        };\n    }\n\n    return null;\n};\n\n\nmodule.exports = class InternalSet {\n\n    constructor(from) {\n\n        this._set = new Set(from);\n        this._hasRef = false;\n    }\n\n    add(value, refs) {\n\n        const isRef = Ref.isRef(value);\n        if (!isRef && this.has(value, null, null, false)) {\n\n            return this;\n        }\n\n        if (refs !== undefined) { // If it's a merge, we don't have any refs\n            Ref.push(refs, value);\n        }\n\n        this._set.add(value);\n\n        this._hasRef |= isRef;\n\n        return this;\n    }\n\n    merge(add, remove) {\n\n        for (const item of add._set) {\n            this.add(item);\n        }\n\n        for (const item of remove._set) {\n            this.remove(item);\n        }\n\n        return this;\n    }\n\n    remove(value) {\n\n        this._set.delete(value);\n        return this;\n    }\n\n    has(value, state, options, insensitive) {\n\n        if (!this._set.size) {\n            return false;\n        }\n\n        const hasValue = this._set.has(value);\n        if (hasValue) {\n            return hasValue;\n        }\n\n        const extendedCheck = internals.extendedCheckForValue(value, insensitive);\n        if (!extendedCheck) {\n            if (state && this._hasRef) {\n                for (let item of this._set) {\n                    if (Ref.isRef(item)) {\n                        item = item(state.reference || state.parent, options);\n                        if (value === item || (Array.isArray(item) && item.includes(value))) {\n                            return true;\n                        }\n                    }\n                }\n            }\n\n            return false;\n        }\n\n        return this._has(value, state, options, extendedCheck);\n    }\n\n    _has(value, state, options, check) {\n\n        const checkRef = !!(state && this._hasRef);\n\n        const isReallyEqual = function (item) {\n\n            if (value === item) {\n                return true;\n            }\n\n            return check(item);\n        };\n\n        for (let item of this._set) {\n            if (checkRef && Ref.isRef(item)) { // Only resolve references if there is a state, otherwise it's a merge\n                item = item(state.reference || state.parent, options);\n\n                if (Array.isArray(item)) {\n                    if (item.find(isReallyEqual)) {\n                        return true;\n                    }\n                    continue;\n                }\n            }\n\n            if (isReallyEqual(item)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    values(options) {\n\n        if (options && options.stripUndefined) {\n            const values = [];\n\n            for (const item of this._set) {\n                if (item !== undefined) {\n                    values.push(item);\n                }\n            }\n\n            return values;\n        }\n\n        return Array.from(this._set);\n    }\n\n    slice() {\n\n        const set = new InternalSet(this._set);\n        set._hasRef = this._hasRef;\n        return set;\n    }\n\n    concat(source) {\n\n        const set = new InternalSet([...this._set, ...source._set]);\n        set._hasRef = !!(this._hasRef | source._hasRef);\n        return set;\n    }\n};\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,GAAG,GAAGC,OAAO,CAAC,OAAO,CAAC;AAG5B,MAAMC,SAAS,GAAG,CAAC,CAAC;AAGpBA,SAAS,CAACC,qBAAqB,GAAG,UAAUC,KAAK,EAAEC,WAAW,EAAE;EAE5D,MAAMC,SAAS,GAAG,OAAOF,KAAK;EAE9B,IAAIE,SAAS,KAAK,QAAQ,EAAE;IACxB,IAAIF,KAAK,YAAYG,IAAI,EAAE;MACvB,OAAQC,IAAI,IAAK;QAEb,OAAOA,IAAI,YAAYD,IAAI,IAAIH,KAAK,CAACK,OAAO,CAAC,CAAC,KAAKD,IAAI,CAACC,OAAO,CAAC,CAAC;MACrE,CAAC;IACL;IACA,IAAIC,MAAM,CAACC,QAAQ,CAACP,KAAK,CAAC,EAAE;MACxB,OAAQI,IAAI,IAAK;QAEb,OAAOE,MAAM,CAACC,QAAQ,CAACH,IAAI,CAAC,IAAIJ,KAAK,CAACQ,MAAM,KAAKJ,IAAI,CAACI,MAAM,IAAIR,KAAK,CAACS,QAAQ,CAAC,QAAQ,CAAC,KAAKL,IAAI,CAACK,QAAQ,CAAC,QAAQ,CAAC;MACxH,CAAC;IACL;EACJ,CAAC,MACI,IAAIR,WAAW,IAAIC,SAAS,KAAK,QAAQ,EAAE;IAC5C,MAAMQ,cAAc,GAAGV,KAAK,CAACW,WAAW,CAAC,CAAC;IAC1C,OAAQP,IAAI,IAAK;MAEb,OAAO,OAAOA,IAAI,KAAK,QAAQ,IAAIM,cAAc,KAAKN,IAAI,CAACO,WAAW,CAAC,CAAC;IAC5E,CAAC;EACL;EAEA,OAAO,IAAI;AACf,CAAC;AAGDC,MAAM,CAACC,OAAO,GAAG,MAAMC,WAAW,CAAC;EAE/BC,WAAWA,CAACC,IAAI,EAAE;IAEd,IAAI,CAACC,IAAI,GAAG,IAAIC,GAAG,CAACF,IAAI,CAAC;IACzB,IAAI,CAACG,OAAO,GAAG,KAAK;EACxB;EAEAC,GAAGA,CAACpB,KAAK,EAAEqB,IAAI,EAAE;IAEb,MAAMC,KAAK,GAAG1B,GAAG,CAAC0B,KAAK,CAACtB,KAAK,CAAC;IAC9B,IAAI,CAACsB,KAAK,IAAI,IAAI,CAACC,GAAG,CAACvB,KAAK,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,CAAC,EAAE;MAE9C,OAAO,IAAI;IACf;IAEA,IAAIqB,IAAI,KAAKG,SAAS,EAAE;MAAE;MACtB5B,GAAG,CAAC6B,IAAI,CAACJ,IAAI,EAAErB,KAAK,CAAC;IACzB;IAEA,IAAI,CAACiB,IAAI,CAACG,GAAG,CAACpB,KAAK,CAAC;IAEpB,IAAI,CAACmB,OAAO,IAAIG,KAAK;IAErB,OAAO,IAAI;EACf;EAEAI,KAAKA,CAACN,GAAG,EAAEO,MAAM,EAAE;IAEf,KAAK,MAAMvB,IAAI,IAAIgB,GAAG,CAACH,IAAI,EAAE;MACzB,IAAI,CAACG,GAAG,CAAChB,IAAI,CAAC;IAClB;IAEA,KAAK,MAAMA,IAAI,IAAIuB,MAAM,CAACV,IAAI,EAAE;MAC5B,IAAI,CAACU,MAAM,CAACvB,IAAI,CAAC;IACrB;IAEA,OAAO,IAAI;EACf;EAEAuB,MAAMA,CAAC3B,KAAK,EAAE;IAEV,IAAI,CAACiB,IAAI,CAACW,MAAM,CAAC5B,KAAK,CAAC;IACvB,OAAO,IAAI;EACf;EAEAuB,GAAGA,CAACvB,KAAK,EAAE6B,KAAK,EAAEC,OAAO,EAAE7B,WAAW,EAAE;IAEpC,IAAI,CAAC,IAAI,CAACgB,IAAI,CAACc,IAAI,EAAE;MACjB,OAAO,KAAK;IAChB;IAEA,MAAMC,QAAQ,GAAG,IAAI,CAACf,IAAI,CAACM,GAAG,CAACvB,KAAK,CAAC;IACrC,IAAIgC,QAAQ,EAAE;MACV,OAAOA,QAAQ;IACnB;IAEA,MAAMC,aAAa,GAAGnC,SAAS,CAACC,qBAAqB,CAACC,KAAK,EAAEC,WAAW,CAAC;IACzE,IAAI,CAACgC,aAAa,EAAE;MAChB,IAAIJ,KAAK,IAAI,IAAI,CAACV,OAAO,EAAE;QACvB,KAAK,IAAIf,IAAI,IAAI,IAAI,CAACa,IAAI,EAAE;UACxB,IAAIrB,GAAG,CAAC0B,KAAK,CAAClB,IAAI,CAAC,EAAE;YACjBA,IAAI,GAAGA,IAAI,CAACyB,KAAK,CAACK,SAAS,IAAIL,KAAK,CAACM,MAAM,EAAEL,OAAO,CAAC;YACrD,IAAI9B,KAAK,KAAKI,IAAI,IAAKgC,KAAK,CAACC,OAAO,CAACjC,IAAI,CAAC,IAAIA,IAAI,CAACkC,QAAQ,CAACtC,KAAK,CAAE,EAAE;cACjE,OAAO,IAAI;YACf;UACJ;QACJ;MACJ;MAEA,OAAO,KAAK;IAChB;IAEA,OAAO,IAAI,CAACuC,IAAI,CAACvC,KAAK,EAAE6B,KAAK,EAAEC,OAAO,EAAEG,aAAa,CAAC;EAC1D;EAEAM,IAAIA,CAACvC,KAAK,EAAE6B,KAAK,EAAEC,OAAO,EAAEU,KAAK,EAAE;IAE/B,MAAMC,QAAQ,GAAG,CAAC,EAAEZ,KAAK,IAAI,IAAI,CAACV,OAAO,CAAC;IAE1C,MAAMuB,aAAa,GAAG,SAAAA,CAAUtC,IAAI,EAAE;MAElC,IAAIJ,KAAK,KAAKI,IAAI,EAAE;QAChB,OAAO,IAAI;MACf;MAEA,OAAOoC,KAAK,CAACpC,IAAI,CAAC;IACtB,CAAC;IAED,KAAK,IAAIA,IAAI,IAAI,IAAI,CAACa,IAAI,EAAE;MACxB,IAAIwB,QAAQ,IAAI7C,GAAG,CAAC0B,KAAK,CAAClB,IAAI,CAAC,EAAE;QAAE;QAC/BA,IAAI,GAAGA,IAAI,CAACyB,KAAK,CAACK,SAAS,IAAIL,KAAK,CAACM,MAAM,EAAEL,OAAO,CAAC;QAErD,IAAIM,KAAK,CAACC,OAAO,CAACjC,IAAI,CAAC,EAAE;UACrB,IAAIA,IAAI,CAACuC,IAAI,CAACD,aAAa,CAAC,EAAE;YAC1B,OAAO,IAAI;UACf;UACA;QACJ;MACJ;MAEA,IAAIA,aAAa,CAACtC,IAAI,CAAC,EAAE;QACrB,OAAO,IAAI;MACf;IACJ;IAEA,OAAO,KAAK;EAChB;EAEAwC,MAAMA,CAACd,OAAO,EAAE;IAEZ,IAAIA,OAAO,IAAIA,OAAO,CAACe,cAAc,EAAE;MACnC,MAAMD,MAAM,GAAG,EAAE;MAEjB,KAAK,MAAMxC,IAAI,IAAI,IAAI,CAACa,IAAI,EAAE;QAC1B,IAAIb,IAAI,KAAKoB,SAAS,EAAE;UACpBoB,MAAM,CAACnB,IAAI,CAACrB,IAAI,CAAC;QACrB;MACJ;MAEA,OAAOwC,MAAM;IACjB;IAEA,OAAOR,KAAK,CAACpB,IAAI,CAAC,IAAI,CAACC,IAAI,CAAC;EAChC;EAEA6B,KAAKA,CAAA,EAAG;IAEJ,MAAMC,GAAG,GAAG,IAAIjC,WAAW,CAAC,IAAI,CAACG,IAAI,CAAC;IACtC8B,GAAG,CAAC5B,OAAO,GAAG,IAAI,CAACA,OAAO;IAC1B,OAAO4B,GAAG;EACd;EAEAC,MAAMA,CAACC,MAAM,EAAE;IAEX,MAAMF,GAAG,GAAG,IAAIjC,WAAW,CAAC,CAAC,GAAG,IAAI,CAACG,IAAI,EAAE,GAAGgC,MAAM,CAAChC,IAAI,CAAC,CAAC;IAC3D8B,GAAG,CAAC5B,OAAO,GAAG,CAAC,EAAE,IAAI,CAACA,OAAO,GAAG8B,MAAM,CAAC9B,OAAO,CAAC;IAC/C,OAAO4B,GAAG;EACd;AACJ,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}
{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/render/canvas/Builder\n */\nimport CanvasInstruction from './Instruction.js';\nimport GeometryType from '../../geom/GeometryType.js';\nimport Relationship from '../../extent/Relationship.js';\nimport VectorContext from '../VectorContext.js';\nimport { asColorLike } from '../../colorlike.js';\nimport { buffer, clone, coordinateRelationship } from '../../extent.js';\nimport { defaultFillStyle, defaultLineCap, defaultLineDash, defaultLineDashOffset, defaultLineJoin, defaultLineWidth, defaultMiterLimit, defaultStrokeStyle } from '../canvas.js';\nimport { equals, reverseSubArray } from '../../array.js';\nimport { inflateCoordinates, inflateCoordinatesArray, inflateMultiCoordinatesArray } from '../../geom/flat/inflate.js';\n/**\n * @typedef {Object} SerializableInstructions\n * @property {Array<*>} instructions The rendering instructions.\n * @property {Array<*>} hitDetectionInstructions The rendering hit detection instructions.\n * @property {Array<number>} coordinates The array of all coordinates.\n * @property {!Object<string, import(\"../canvas.js\").TextState>} [textStates] The text states (decluttering).\n * @property {!Object<string, import(\"../canvas.js\").FillState>} [fillStates] The fill states (decluttering).\n * @property {!Object<string, import(\"../canvas.js\").StrokeState>} [strokeStates] The stroke states (decluttering).\n */\nvar CanvasBuilder = /** @class */function (_super) {\n  __extends(CanvasBuilder, _super);\n  /**\n   * @param {number} tolerance Tolerance.\n   * @param {import(\"../../extent.js\").Extent} maxExtent Maximum extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   */\n  function CanvasBuilder(tolerance, maxExtent, resolution, pixelRatio) {\n    var _this = _super.call(this) || this;\n    /**\n     * @protected\n     * @type {number}\n     */\n    _this.tolerance = tolerance;\n    /**\n     * @protected\n     * @const\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    _this.maxExtent = maxExtent;\n    /**\n     * @protected\n     * @type {number}\n     */\n    _this.pixelRatio = pixelRatio;\n    /**\n     * @protected\n     * @type {number}\n     */\n    _this.maxLineWidth = 0;\n    /**\n     * @protected\n     * @const\n     * @type {number}\n     */\n    _this.resolution = resolution;\n    /**\n     * @private\n     * @type {Array<*>}\n     */\n    _this.beginGeometryInstruction1_ = null;\n    /**\n     * @private\n     * @type {Array<*>}\n     */\n    _this.beginGeometryInstruction2_ = null;\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    _this.bufferedMaxExtent_ = null;\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n    _this.instructions = [];\n    /**\n     * @protected\n     * @type {Array<number>}\n     */\n    _this.coordinates = [];\n    /**\n     * @private\n     * @type {import(\"../../coordinate.js\").Coordinate}\n     */\n    _this.tmpCoordinate_ = [];\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n    _this.hitDetectionInstructions = [];\n    /**\n     * @protected\n     * @type {import(\"../canvas.js\").FillStrokeState}\n     */\n    _this.state = /** @type {import(\"../canvas.js\").FillStrokeState} */{};\n    return _this;\n  }\n  /**\n   * @protected\n   * @param {Array<number>} dashArray Dash array.\n   * @return {Array<number>} Dash array with pixel ratio applied\n   */\n  CanvasBuilder.prototype.applyPixelRatio = function (dashArray) {\n    var pixelRatio = this.pixelRatio;\n    return pixelRatio == 1 ? dashArray : dashArray.map(function (dash) {\n      return dash * pixelRatio;\n    });\n  };\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @param {boolean} closed Last input coordinate equals first.\n   * @param {boolean} skipFirst Skip first coordinate.\n   * @protected\n   * @return {number} My end.\n   */\n  CanvasBuilder.prototype.appendFlatCoordinates = function (flatCoordinates, offset, end, stride, closed, skipFirst) {\n    var myEnd = this.coordinates.length;\n    var extent = this.getBufferedMaxExtent();\n    if (skipFirst) {\n      offset += stride;\n    }\n    var lastXCoord = flatCoordinates[offset];\n    var lastYCoord = flatCoordinates[offset + 1];\n    var nextCoord = this.tmpCoordinate_;\n    var skipped = true;\n    var i, lastRel, nextRel;\n    for (i = offset + stride; i < end; i += stride) {\n      nextCoord[0] = flatCoordinates[i];\n      nextCoord[1] = flatCoordinates[i + 1];\n      nextRel = coordinateRelationship(extent, nextCoord);\n      if (nextRel !== lastRel) {\n        if (skipped) {\n          this.coordinates[myEnd++] = lastXCoord;\n          this.coordinates[myEnd++] = lastYCoord;\n        }\n        this.coordinates[myEnd++] = nextCoord[0];\n        this.coordinates[myEnd++] = nextCoord[1];\n        skipped = false;\n      } else if (nextRel === Relationship.INTERSECTING) {\n        this.coordinates[myEnd++] = nextCoord[0];\n        this.coordinates[myEnd++] = nextCoord[1];\n        skipped = false;\n      } else {\n        skipped = true;\n      }\n      lastXCoord = nextCoord[0];\n      lastYCoord = nextCoord[1];\n      lastRel = nextRel;\n    }\n    // Last coordinate equals first or only one point to append:\n    if (closed && skipped || i === offset + stride) {\n      this.coordinates[myEnd++] = lastXCoord;\n      this.coordinates[myEnd++] = lastYCoord;\n    }\n    return myEnd;\n  };\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @param {Array<number>} builderEnds Builder ends.\n   * @return {number} Offset.\n   */\n  CanvasBuilder.prototype.drawCustomCoordinates_ = function (flatCoordinates, offset, ends, stride, builderEnds) {\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n      var end = ends[i];\n      var builderEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);\n      builderEnds.push(builderEnd);\n      offset = end;\n    }\n    return offset;\n  };\n  /**\n   * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {Function} renderer Renderer.\n   */\n  CanvasBuilder.prototype.drawCustom = function (geometry, feature, renderer) {\n    this.beginGeometry(geometry, feature);\n    var type = geometry.getType();\n    var stride = geometry.getStride();\n    var builderBegin = this.coordinates.length;\n    var flatCoordinates, builderEnd, builderEnds, builderEndss;\n    var offset;\n    if (type == GeometryType.MULTI_POLYGON) {\n      flatCoordinates = /** @type {import(\"../../geom/MultiPolygon.js\").default} */geometry.getOrientedFlatCoordinates();\n      builderEndss = [];\n      var endss = /** @type {import(\"../../geom/MultiPolygon.js\").default} */geometry.getEndss();\n      offset = 0;\n      for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var myEnds = [];\n        offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);\n        builderEndss.push(myEnds);\n      }\n      this.instructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEndss, geometry, renderer, inflateMultiCoordinatesArray]);\n    } else if (type == GeometryType.POLYGON || type == GeometryType.MULTI_LINE_STRING) {\n      builderEnds = [];\n      flatCoordinates = type == GeometryType.POLYGON ? /** @type {import(\"../../geom/Polygon.js\").default} */geometry.getOrientedFlatCoordinates() : geometry.getFlatCoordinates();\n      offset = this.drawCustomCoordinates_(flatCoordinates, 0, /** @type {import(\"../../geom/Polygon.js\").default|import(\"../../geom/MultiLineString.js\").default} */geometry.getEnds(), stride, builderEnds);\n      this.instructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnds, geometry, renderer, inflateCoordinatesArray]);\n    } else if (type == GeometryType.LINE_STRING || type == GeometryType.MULTI_POINT) {\n      flatCoordinates = geometry.getFlatCoordinates();\n      builderEnd = this.appendFlatCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n      this.instructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, renderer, inflateCoordinates]);\n    } else if (type == GeometryType.POINT) {\n      flatCoordinates = geometry.getFlatCoordinates();\n      this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);\n      builderEnd = this.coordinates.length;\n      this.instructions.push([CanvasInstruction.CUSTOM, builderBegin, builderEnd, geometry, renderer]);\n    }\n    this.endGeometry(feature);\n  };\n  /**\n   * @protected\n   * @param {import(\"../../geom/Geometry\").default|import(\"../Feature.js\").default} geometry The geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   */\n  CanvasBuilder.prototype.beginGeometry = function (geometry, feature) {\n    var extent = geometry.getExtent();\n    this.beginGeometryInstruction1_ = [CanvasInstruction.BEGIN_GEOMETRY, feature, 0, extent];\n    this.instructions.push(this.beginGeometryInstruction1_);\n    this.beginGeometryInstruction2_ = [CanvasInstruction.BEGIN_GEOMETRY, feature, 0, extent];\n    this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);\n  };\n  /**\n   * @return {SerializableInstructions} the serializable instructions.\n   */\n  CanvasBuilder.prototype.finish = function () {\n    return {\n      instructions: this.instructions,\n      hitDetectionInstructions: this.hitDetectionInstructions,\n      coordinates: this.coordinates\n    };\n  };\n  /**\n   * Reverse the hit detection instructions.\n   */\n  CanvasBuilder.prototype.reverseHitDetectionInstructions = function () {\n    var hitDetectionInstructions = this.hitDetectionInstructions;\n    // step 1 - reverse array\n    hitDetectionInstructions.reverse();\n    // step 2 - reverse instructions within geometry blocks\n    var i;\n    var n = hitDetectionInstructions.length;\n    var instruction;\n    var type;\n    var begin = -1;\n    for (i = 0; i < n; ++i) {\n      instruction = hitDetectionInstructions[i];\n      type = /** @type {import(\"./Instruction.js\").default} */instruction[0];\n      if (type == CanvasInstruction.END_GEOMETRY) {\n        begin = i;\n      } else if (type == CanvasInstruction.BEGIN_GEOMETRY) {\n        instruction[2] = i;\n        reverseSubArray(this.hitDetectionInstructions, begin, i);\n        begin = -1;\n      }\n    }\n  };\n  /**\n   * @param {import(\"../../style/Fill.js\").default} fillStyle Fill style.\n   * @param {import(\"../../style/Stroke.js\").default} strokeStyle Stroke style.\n   */\n  CanvasBuilder.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {\n    var state = this.state;\n    if (fillStyle) {\n      var fillStyleColor = fillStyle.getColor();\n      state.fillStyle = asColorLike(fillStyleColor ? fillStyleColor : defaultFillStyle);\n    } else {\n      state.fillStyle = undefined;\n    }\n    if (strokeStyle) {\n      var strokeStyleColor = strokeStyle.getColor();\n      state.strokeStyle = asColorLike(strokeStyleColor ? strokeStyleColor : defaultStrokeStyle);\n      var strokeStyleLineCap = strokeStyle.getLineCap();\n      state.lineCap = strokeStyleLineCap !== undefined ? strokeStyleLineCap : defaultLineCap;\n      var strokeStyleLineDash = strokeStyle.getLineDash();\n      state.lineDash = strokeStyleLineDash ? strokeStyleLineDash.slice() : defaultLineDash;\n      var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();\n      state.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : defaultLineDashOffset;\n      var strokeStyleLineJoin = strokeStyle.getLineJoin();\n      state.lineJoin = strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : defaultLineJoin;\n      var strokeStyleWidth = strokeStyle.getWidth();\n      state.lineWidth = strokeStyleWidth !== undefined ? strokeStyleWidth : defaultLineWidth;\n      var strokeStyleMiterLimit = strokeStyle.getMiterLimit();\n      state.miterLimit = strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : defaultMiterLimit;\n      if (state.lineWidth > this.maxLineWidth) {\n        this.maxLineWidth = state.lineWidth;\n        // invalidate the buffered max extent cache\n        this.bufferedMaxExtent_ = null;\n      }\n    } else {\n      state.strokeStyle = undefined;\n      state.lineCap = undefined;\n      state.lineDash = null;\n      state.lineDashOffset = undefined;\n      state.lineJoin = undefined;\n      state.lineWidth = undefined;\n      state.miterLimit = undefined;\n    }\n  };\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @return {Array<*>} Fill instruction.\n   */\n  CanvasBuilder.prototype.createFill = function (state) {\n    var fillStyle = state.fillStyle;\n    /** @type {Array<*>} */\n    var fillInstruction = [CanvasInstruction.SET_FILL_STYLE, fillStyle];\n    if (typeof fillStyle !== 'string') {\n      // Fill is a pattern or gradient - align it!\n      fillInstruction.push(true);\n    }\n    return fillInstruction;\n  };\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   */\n  CanvasBuilder.prototype.applyStroke = function (state) {\n    this.instructions.push(this.createStroke(state));\n  };\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @return {Array<*>} Stroke instruction.\n   */\n  CanvasBuilder.prototype.createStroke = function (state) {\n    return [CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth * this.pixelRatio, state.lineCap, state.lineJoin, state.miterLimit, this.applyPixelRatio(state.lineDash), state.lineDashOffset * this.pixelRatio];\n  };\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @param {function(this:CanvasBuilder, import(\"../canvas.js\").FillStrokeState):Array<*>} createFill Create fill.\n   */\n  CanvasBuilder.prototype.updateFillStyle = function (state, createFill) {\n    var fillStyle = state.fillStyle;\n    if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {\n      if (fillStyle !== undefined) {\n        this.instructions.push(createFill.call(this, state));\n      }\n      state.currentFillStyle = fillStyle;\n    }\n  };\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @param {function(this:CanvasBuilder, import(\"../canvas.js\").FillStrokeState): void} applyStroke Apply stroke.\n   */\n  CanvasBuilder.prototype.updateStrokeStyle = function (state, applyStroke) {\n    var strokeStyle = state.strokeStyle;\n    var lineCap = state.lineCap;\n    var lineDash = state.lineDash;\n    var lineDashOffset = state.lineDashOffset;\n    var lineJoin = state.lineJoin;\n    var lineWidth = state.lineWidth;\n    var miterLimit = state.miterLimit;\n    if (state.currentStrokeStyle != strokeStyle || state.currentLineCap != lineCap || lineDash != state.currentLineDash && !equals(state.currentLineDash, lineDash) || state.currentLineDashOffset != lineDashOffset || state.currentLineJoin != lineJoin || state.currentLineWidth != lineWidth || state.currentMiterLimit != miterLimit) {\n      if (strokeStyle !== undefined) {\n        applyStroke.call(this, state);\n      }\n      state.currentStrokeStyle = strokeStyle;\n      state.currentLineCap = lineCap;\n      state.currentLineDash = lineDash;\n      state.currentLineDashOffset = lineDashOffset;\n      state.currentLineJoin = lineJoin;\n      state.currentLineWidth = lineWidth;\n      state.currentMiterLimit = miterLimit;\n    }\n  };\n  /**\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   */\n  CanvasBuilder.prototype.endGeometry = function (feature) {\n    this.beginGeometryInstruction1_[2] = this.instructions.length;\n    this.beginGeometryInstruction1_ = null;\n    this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;\n    this.beginGeometryInstruction2_ = null;\n    var endGeometryInstruction = [CanvasInstruction.END_GEOMETRY, feature];\n    this.instructions.push(endGeometryInstruction);\n    this.hitDetectionInstructions.push(endGeometryInstruction);\n  };\n  /**\n   * Get the buffered rendering extent.  Rendering will be clipped to the extent\n   * provided to the constructor.  To account for symbolizers that may intersect\n   * this extent, we calculate a buffered extent (e.g. based on stroke width).\n   * @return {import(\"../../extent.js\").Extent} The buffered rendering extent.\n   * @protected\n   */\n  CanvasBuilder.prototype.getBufferedMaxExtent = function () {\n    if (!this.bufferedMaxExtent_) {\n      this.bufferedMaxExtent_ = clone(this.maxExtent);\n      if (this.maxLineWidth > 0) {\n        var width = this.resolution * (this.maxLineWidth + 1) / 2;\n        buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);\n      }\n    }\n    return this.bufferedMaxExtent_;\n  };\n  return CanvasBuilder;\n}(VectorContext);\nexport default CanvasBuilder;","map":{"version":3,"names":["CanvasInstruction","GeometryType","Relationship","VectorContext","asColorLike","buffer","clone","coordinateRelationship","defaultFillStyle","defaultLineCap","defaultLineDash","defaultLineDashOffset","defaultLineJoin","defaultLineWidth","defaultMiterLimit","defaultStrokeStyle","equals","reverseSubArray","inflateCoordinates","inflateCoordinatesArray","inflateMultiCoordinatesArray","CanvasBuilder","_super","__extends","tolerance","maxExtent","resolution","pixelRatio","_this","call","maxLineWidth","beginGeometryInstruction1_","beginGeometryInstruction2_","bufferedMaxExtent_","instructions","coordinates","tmpCoordinate_","hitDetectionInstructions","state","prototype","applyPixelRatio","dashArray","map","dash","appendFlatCoordinates","flatCoordinates","offset","end","stride","closed","skipFirst","myEnd","length","extent","getBufferedMaxExtent","lastXCoord","lastYCoord","nextCoord","skipped","i","lastRel","nextRel","INTERSECTING","drawCustomCoordinates_","ends","builderEnds","ii","builderEnd","push","drawCustom","geometry","feature","renderer","beginGeometry","type","getType","getStride","builderBegin","builderEndss","MULTI_POLYGON","getOrientedFlatCoordinates","endss","getEndss","myEnds","CUSTOM","POLYGON","MULTI_LINE_STRING","getFlatCoordinates","getEnds","LINE_STRING","MULTI_POINT","POINT","endGeometry","getExtent","BEGIN_GEOMETRY","finish","reverseHitDetectionInstructions","reverse","n","instruction","begin","END_GEOMETRY","setFillStrokeStyle","fillStyle","strokeStyle","fillStyleColor","getColor","undefined","strokeStyleColor","strokeStyleLineCap","getLineCap","lineCap","strokeStyleLineDash","getLineDash","lineDash","slice","strokeStyleLineDashOffset","getLineDashOffset","lineDashOffset","strokeStyleLineJoin","getLineJoin","lineJoin","strokeStyleWidth","getWidth","lineWidth","strokeStyleMiterLimit","getMiterLimit","miterLimit","createFill","fillInstruction","SET_FILL_STYLE","applyStroke","createStroke","SET_STROKE_STYLE","updateFillStyle","currentFillStyle","updateStrokeStyle","currentStrokeStyle","currentLineCap","currentLineDash","currentLineDashOffset","currentLineJoin","currentLineWidth","currentMiterLimit","endGeometryInstruction","width"],"sources":["/Users/mariovicky/Skripsi_OpenLayers/node_modules/ol/src/render/canvas/Builder.js"],"sourcesContent":["/**\n * @module ol/render/canvas/Builder\n */\nimport CanvasInstruction from './Instruction.js';\nimport GeometryType from '../../geom/GeometryType.js';\nimport Relationship from '../../extent/Relationship.js';\nimport VectorContext from '../VectorContext.js';\nimport {asColorLike} from '../../colorlike.js';\nimport {buffer, clone, coordinateRelationship} from '../../extent.js';\nimport {\n  defaultFillStyle,\n  defaultLineCap,\n  defaultLineDash,\n  defaultLineDashOffset,\n  defaultLineJoin,\n  defaultLineWidth,\n  defaultMiterLimit,\n  defaultStrokeStyle,\n} from '../canvas.js';\nimport {equals, reverseSubArray} from '../../array.js';\nimport {\n  inflateCoordinates,\n  inflateCoordinatesArray,\n  inflateMultiCoordinatesArray,\n} from '../../geom/flat/inflate.js';\n\n/**\n * @typedef {Object} SerializableInstructions\n * @property {Array<*>} instructions The rendering instructions.\n * @property {Array<*>} hitDetectionInstructions The rendering hit detection instructions.\n * @property {Array<number>} coordinates The array of all coordinates.\n * @property {!Object<string, import(\"../canvas.js\").TextState>} [textStates] The text states (decluttering).\n * @property {!Object<string, import(\"../canvas.js\").FillState>} [fillStates] The fill states (decluttering).\n * @property {!Object<string, import(\"../canvas.js\").StrokeState>} [strokeStates] The stroke states (decluttering).\n */\n\nclass CanvasBuilder extends VectorContext {\n  /**\n   * @param {number} tolerance Tolerance.\n   * @param {import(\"../../extent.js\").Extent} maxExtent Maximum extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   */\n  constructor(tolerance, maxExtent, resolution, pixelRatio) {\n    super();\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.tolerance = tolerance;\n\n    /**\n     * @protected\n     * @const\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.maxExtent = maxExtent;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.pixelRatio = pixelRatio;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.maxLineWidth = 0;\n\n    /**\n     * @protected\n     * @const\n     * @type {number}\n     */\n    this.resolution = resolution;\n\n    /**\n     * @private\n     * @type {Array<*>}\n     */\n    this.beginGeometryInstruction1_ = null;\n\n    /**\n     * @private\n     * @type {Array<*>}\n     */\n    this.beginGeometryInstruction2_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.bufferedMaxExtent_ = null;\n\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n    this.instructions = [];\n\n    /**\n     * @protected\n     * @type {Array<number>}\n     */\n    this.coordinates = [];\n\n    /**\n     * @private\n     * @type {import(\"../../coordinate.js\").Coordinate}\n     */\n    this.tmpCoordinate_ = [];\n\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n    this.hitDetectionInstructions = [];\n\n    /**\n     * @protected\n     * @type {import(\"../canvas.js\").FillStrokeState}\n     */\n    this.state = /** @type {import(\"../canvas.js\").FillStrokeState} */ ({});\n  }\n\n  /**\n   * @protected\n   * @param {Array<number>} dashArray Dash array.\n   * @return {Array<number>} Dash array with pixel ratio applied\n   */\n  applyPixelRatio(dashArray) {\n    const pixelRatio = this.pixelRatio;\n    return pixelRatio == 1\n      ? dashArray\n      : dashArray.map(function (dash) {\n          return dash * pixelRatio;\n        });\n  }\n\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @param {boolean} closed Last input coordinate equals first.\n   * @param {boolean} skipFirst Skip first coordinate.\n   * @protected\n   * @return {number} My end.\n   */\n  appendFlatCoordinates(\n    flatCoordinates,\n    offset,\n    end,\n    stride,\n    closed,\n    skipFirst\n  ) {\n    let myEnd = this.coordinates.length;\n    const extent = this.getBufferedMaxExtent();\n    if (skipFirst) {\n      offset += stride;\n    }\n    let lastXCoord = flatCoordinates[offset];\n    let lastYCoord = flatCoordinates[offset + 1];\n    const nextCoord = this.tmpCoordinate_;\n    let skipped = true;\n\n    let i, lastRel, nextRel;\n    for (i = offset + stride; i < end; i += stride) {\n      nextCoord[0] = flatCoordinates[i];\n      nextCoord[1] = flatCoordinates[i + 1];\n      nextRel = coordinateRelationship(extent, nextCoord);\n      if (nextRel !== lastRel) {\n        if (skipped) {\n          this.coordinates[myEnd++] = lastXCoord;\n          this.coordinates[myEnd++] = lastYCoord;\n        }\n        this.coordinates[myEnd++] = nextCoord[0];\n        this.coordinates[myEnd++] = nextCoord[1];\n        skipped = false;\n      } else if (nextRel === Relationship.INTERSECTING) {\n        this.coordinates[myEnd++] = nextCoord[0];\n        this.coordinates[myEnd++] = nextCoord[1];\n        skipped = false;\n      } else {\n        skipped = true;\n      }\n      lastXCoord = nextCoord[0];\n      lastYCoord = nextCoord[1];\n      lastRel = nextRel;\n    }\n\n    // Last coordinate equals first or only one point to append:\n    if ((closed && skipped) || i === offset + stride) {\n      this.coordinates[myEnd++] = lastXCoord;\n      this.coordinates[myEnd++] = lastYCoord;\n    }\n    return myEnd;\n  }\n\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @param {Array<number>} builderEnds Builder ends.\n   * @return {number} Offset.\n   */\n  drawCustomCoordinates_(flatCoordinates, offset, ends, stride, builderEnds) {\n    for (let i = 0, ii = ends.length; i < ii; ++i) {\n      const end = ends[i];\n      const builderEnd = this.appendFlatCoordinates(\n        flatCoordinates,\n        offset,\n        end,\n        stride,\n        false,\n        false\n      );\n      builderEnds.push(builderEnd);\n      offset = end;\n    }\n    return offset;\n  }\n\n  /**\n   * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {Function} renderer Renderer.\n   */\n  drawCustom(geometry, feature, renderer) {\n    this.beginGeometry(geometry, feature);\n    const type = geometry.getType();\n    const stride = geometry.getStride();\n    const builderBegin = this.coordinates.length;\n    let flatCoordinates, builderEnd, builderEnds, builderEndss;\n    let offset;\n    if (type == GeometryType.MULTI_POLYGON) {\n      flatCoordinates = /** @type {import(\"../../geom/MultiPolygon.js\").default} */ (geometry).getOrientedFlatCoordinates();\n      builderEndss = [];\n      const endss = /** @type {import(\"../../geom/MultiPolygon.js\").default} */ (geometry).getEndss();\n      offset = 0;\n      for (let i = 0, ii = endss.length; i < ii; ++i) {\n        const myEnds = [];\n        offset = this.drawCustomCoordinates_(\n          flatCoordinates,\n          offset,\n          endss[i],\n          stride,\n          myEnds\n        );\n        builderEndss.push(myEnds);\n      }\n      this.instructions.push([\n        CanvasInstruction.CUSTOM,\n        builderBegin,\n        builderEndss,\n        geometry,\n        renderer,\n        inflateMultiCoordinatesArray,\n      ]);\n    } else if (\n      type == GeometryType.POLYGON ||\n      type == GeometryType.MULTI_LINE_STRING\n    ) {\n      builderEnds = [];\n      flatCoordinates =\n        type == GeometryType.POLYGON\n          ? /** @type {import(\"../../geom/Polygon.js\").default} */ (geometry).getOrientedFlatCoordinates()\n          : geometry.getFlatCoordinates();\n      offset = this.drawCustomCoordinates_(\n        flatCoordinates,\n        0,\n        /** @type {import(\"../../geom/Polygon.js\").default|import(\"../../geom/MultiLineString.js\").default} */ (geometry).getEnds(),\n        stride,\n        builderEnds\n      );\n      this.instructions.push([\n        CanvasInstruction.CUSTOM,\n        builderBegin,\n        builderEnds,\n        geometry,\n        renderer,\n        inflateCoordinatesArray,\n      ]);\n    } else if (\n      type == GeometryType.LINE_STRING ||\n      type == GeometryType.MULTI_POINT\n    ) {\n      flatCoordinates = geometry.getFlatCoordinates();\n      builderEnd = this.appendFlatCoordinates(\n        flatCoordinates,\n        0,\n        flatCoordinates.length,\n        stride,\n        false,\n        false\n      );\n      this.instructions.push([\n        CanvasInstruction.CUSTOM,\n        builderBegin,\n        builderEnd,\n        geometry,\n        renderer,\n        inflateCoordinates,\n      ]);\n    } else if (type == GeometryType.POINT) {\n      flatCoordinates = geometry.getFlatCoordinates();\n      this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);\n      builderEnd = this.coordinates.length;\n      this.instructions.push([\n        CanvasInstruction.CUSTOM,\n        builderBegin,\n        builderEnd,\n        geometry,\n        renderer,\n      ]);\n    }\n    this.endGeometry(feature);\n  }\n\n  /**\n   * @protected\n   * @param {import(\"../../geom/Geometry\").default|import(\"../Feature.js\").default} geometry The geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   */\n  beginGeometry(geometry, feature) {\n    const extent = geometry.getExtent();\n    this.beginGeometryInstruction1_ = [\n      CanvasInstruction.BEGIN_GEOMETRY,\n      feature,\n      0,\n      extent,\n    ];\n    this.instructions.push(this.beginGeometryInstruction1_);\n    this.beginGeometryInstruction2_ = [\n      CanvasInstruction.BEGIN_GEOMETRY,\n      feature,\n      0,\n      extent,\n    ];\n    this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);\n  }\n\n  /**\n   * @return {SerializableInstructions} the serializable instructions.\n   */\n  finish() {\n    return {\n      instructions: this.instructions,\n      hitDetectionInstructions: this.hitDetectionInstructions,\n      coordinates: this.coordinates,\n    };\n  }\n\n  /**\n   * Reverse the hit detection instructions.\n   */\n  reverseHitDetectionInstructions() {\n    const hitDetectionInstructions = this.hitDetectionInstructions;\n    // step 1 - reverse array\n    hitDetectionInstructions.reverse();\n    // step 2 - reverse instructions within geometry blocks\n    let i;\n    const n = hitDetectionInstructions.length;\n    let instruction;\n    let type;\n    let begin = -1;\n    for (i = 0; i < n; ++i) {\n      instruction = hitDetectionInstructions[i];\n      type = /** @type {import(\"./Instruction.js\").default} */ (instruction[0]);\n      if (type == CanvasInstruction.END_GEOMETRY) {\n        begin = i;\n      } else if (type == CanvasInstruction.BEGIN_GEOMETRY) {\n        instruction[2] = i;\n        reverseSubArray(this.hitDetectionInstructions, begin, i);\n        begin = -1;\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../../style/Fill.js\").default} fillStyle Fill style.\n   * @param {import(\"../../style/Stroke.js\").default} strokeStyle Stroke style.\n   */\n  setFillStrokeStyle(fillStyle, strokeStyle) {\n    const state = this.state;\n    if (fillStyle) {\n      const fillStyleColor = fillStyle.getColor();\n      state.fillStyle = asColorLike(\n        fillStyleColor ? fillStyleColor : defaultFillStyle\n      );\n    } else {\n      state.fillStyle = undefined;\n    }\n    if (strokeStyle) {\n      const strokeStyleColor = strokeStyle.getColor();\n      state.strokeStyle = asColorLike(\n        strokeStyleColor ? strokeStyleColor : defaultStrokeStyle\n      );\n      const strokeStyleLineCap = strokeStyle.getLineCap();\n      state.lineCap =\n        strokeStyleLineCap !== undefined ? strokeStyleLineCap : defaultLineCap;\n      const strokeStyleLineDash = strokeStyle.getLineDash();\n      state.lineDash = strokeStyleLineDash\n        ? strokeStyleLineDash.slice()\n        : defaultLineDash;\n      const strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();\n      state.lineDashOffset = strokeStyleLineDashOffset\n        ? strokeStyleLineDashOffset\n        : defaultLineDashOffset;\n      const strokeStyleLineJoin = strokeStyle.getLineJoin();\n      state.lineJoin =\n        strokeStyleLineJoin !== undefined\n          ? strokeStyleLineJoin\n          : defaultLineJoin;\n      const strokeStyleWidth = strokeStyle.getWidth();\n      state.lineWidth =\n        strokeStyleWidth !== undefined ? strokeStyleWidth : defaultLineWidth;\n      const strokeStyleMiterLimit = strokeStyle.getMiterLimit();\n      state.miterLimit =\n        strokeStyleMiterLimit !== undefined\n          ? strokeStyleMiterLimit\n          : defaultMiterLimit;\n\n      if (state.lineWidth > this.maxLineWidth) {\n        this.maxLineWidth = state.lineWidth;\n        // invalidate the buffered max extent cache\n        this.bufferedMaxExtent_ = null;\n      }\n    } else {\n      state.strokeStyle = undefined;\n      state.lineCap = undefined;\n      state.lineDash = null;\n      state.lineDashOffset = undefined;\n      state.lineJoin = undefined;\n      state.lineWidth = undefined;\n      state.miterLimit = undefined;\n    }\n  }\n\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @return {Array<*>} Fill instruction.\n   */\n  createFill(state) {\n    const fillStyle = state.fillStyle;\n    /** @type {Array<*>} */\n    const fillInstruction = [CanvasInstruction.SET_FILL_STYLE, fillStyle];\n    if (typeof fillStyle !== 'string') {\n      // Fill is a pattern or gradient - align it!\n      fillInstruction.push(true);\n    }\n    return fillInstruction;\n  }\n\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   */\n  applyStroke(state) {\n    this.instructions.push(this.createStroke(state));\n  }\n\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @return {Array<*>} Stroke instruction.\n   */\n  createStroke(state) {\n    return [\n      CanvasInstruction.SET_STROKE_STYLE,\n      state.strokeStyle,\n      state.lineWidth * this.pixelRatio,\n      state.lineCap,\n      state.lineJoin,\n      state.miterLimit,\n      this.applyPixelRatio(state.lineDash),\n      state.lineDashOffset * this.pixelRatio,\n    ];\n  }\n\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @param {function(this:CanvasBuilder, import(\"../canvas.js\").FillStrokeState):Array<*>} createFill Create fill.\n   */\n  updateFillStyle(state, createFill) {\n    const fillStyle = state.fillStyle;\n    if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {\n      if (fillStyle !== undefined) {\n        this.instructions.push(createFill.call(this, state));\n      }\n      state.currentFillStyle = fillStyle;\n    }\n  }\n\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @param {function(this:CanvasBuilder, import(\"../canvas.js\").FillStrokeState): void} applyStroke Apply stroke.\n   */\n  updateStrokeStyle(state, applyStroke) {\n    const strokeStyle = state.strokeStyle;\n    const lineCap = state.lineCap;\n    const lineDash = state.lineDash;\n    const lineDashOffset = state.lineDashOffset;\n    const lineJoin = state.lineJoin;\n    const lineWidth = state.lineWidth;\n    const miterLimit = state.miterLimit;\n    if (\n      state.currentStrokeStyle != strokeStyle ||\n      state.currentLineCap != lineCap ||\n      (lineDash != state.currentLineDash &&\n        !equals(state.currentLineDash, lineDash)) ||\n      state.currentLineDashOffset != lineDashOffset ||\n      state.currentLineJoin != lineJoin ||\n      state.currentLineWidth != lineWidth ||\n      state.currentMiterLimit != miterLimit\n    ) {\n      if (strokeStyle !== undefined) {\n        applyStroke.call(this, state);\n      }\n      state.currentStrokeStyle = strokeStyle;\n      state.currentLineCap = lineCap;\n      state.currentLineDash = lineDash;\n      state.currentLineDashOffset = lineDashOffset;\n      state.currentLineJoin = lineJoin;\n      state.currentLineWidth = lineWidth;\n      state.currentMiterLimit = miterLimit;\n    }\n  }\n\n  /**\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   */\n  endGeometry(feature) {\n    this.beginGeometryInstruction1_[2] = this.instructions.length;\n    this.beginGeometryInstruction1_ = null;\n    this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;\n    this.beginGeometryInstruction2_ = null;\n    const endGeometryInstruction = [CanvasInstruction.END_GEOMETRY, feature];\n    this.instructions.push(endGeometryInstruction);\n    this.hitDetectionInstructions.push(endGeometryInstruction);\n  }\n\n  /**\n   * Get the buffered rendering extent.  Rendering will be clipped to the extent\n   * provided to the constructor.  To account for symbolizers that may intersect\n   * this extent, we calculate a buffered extent (e.g. based on stroke width).\n   * @return {import(\"../../extent.js\").Extent} The buffered rendering extent.\n   * @protected\n   */\n  getBufferedMaxExtent() {\n    if (!this.bufferedMaxExtent_) {\n      this.bufferedMaxExtent_ = clone(this.maxExtent);\n      if (this.maxLineWidth > 0) {\n        const width = (this.resolution * (this.maxLineWidth + 1)) / 2;\n        buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);\n      }\n    }\n    return this.bufferedMaxExtent_;\n  }\n}\n\nexport default CanvasBuilder;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
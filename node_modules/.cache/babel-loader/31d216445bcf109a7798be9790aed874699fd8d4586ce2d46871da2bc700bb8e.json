{"ast":null,"code":"/**\n * Operators and utilities used for style expressions\n * @module ol/style/expressions\n */\nimport { asArray, isStringColor } from '../color.js';\n/**\n * Base type used for literal style parameters; can be a number literal or the output of an operator,\n * which in turns takes {@link ExpressionValue} arguments.\n *\n * The following operators can be used:\n *\n * * Reading operators:\n *   * `['get', 'attributeName']` fetches a feature attribute (it will be prefixed by `a_` in the shader)\n *     Note: those will be taken from the attributes provided to the renderer\n *   * `['var', 'varName']` fetches a value from the style variables, or 0 if undefined\n *   * `['time']` returns the time in seconds since the creation of the layer\n *   * `['zoom']` returns the current zoom level\n *   * `['resolution']` returns the current resolution\n *\n * * Math operators:\n *   * `['*', value1, value2]` multiplies `value1` by `value2`\n *   * `['/', value1, value2]` divides `value1` by `value2`\n *   * `['+', value1, value2]` adds `value1` and `value2`\n *   * `['-', value1, value2]` subtracts `value2` from `value1`\n *   * `['clamp', value, low, high]` clamps `value` between `low` and `high`\n *   * `['%', value1, value2]` returns the result of `value1 % value2` (modulo)\n *   * `['^', value1, value2]` returns the value of `value1` raised to the `value2` power\n *\n * * Transform operators:\n *   * `['case', condition1, output1, ...conditionN, outputN, fallback]` selects the first output whose corresponding\n *     condition evaluates to `true`. If no match is found, returns the `fallback` value.\n *     All conditions should be `boolean`, output and fallback can be any kind.\n *   * `['match', input, match1, output1, ...matchN, outputN, fallback]` compares the `input` value against all\n *     provided `matchX` values, returning the output associated with the first valid match. If no match is found,\n *     returns the `fallback` value.\n *     `input` and `matchX` values must all be of the same type, and can be `number` or `string`. `outputX` and\n *     `fallback` values must be of the same type, and can be of any kind.\n *   * `['interpolate', interpolation, input, stop1, output1, ...stopN, outputN]` returns a value by interpolating between\n *     pairs of inputs and outputs; `interpolation` can either be `['linear']` or `['exponential', base]` where `base` is\n *     the rate of increase from stop A to stop B (i.e. power to which the interpolation ratio is raised); a value\n *     of 1 is equivalent to `['linear']`.\n *     `input` and `stopX` values must all be of type `number`. `outputX` values can be `number` or `color` values.\n *     Note: `input` will be clamped between `stop1` and `stopN`, meaning that all output values will be comprised\n *     between `output1` and `outputN`.\n *\n * * Logical operators:\n *   * `['<', value1, value2]` returns `true` if `value1` is strictly lower than `value2`, or `false` otherwise.\n *   * `['<=', value1, value2]` returns `true` if `value1` is lower than or equals `value2`, or `false` otherwise.\n *   * `['>', value1, value2]` returns `true` if `value1` is strictly greater than `value2`, or `false` otherwise.\n *   * `['>=', value1, value2]` returns `true` if `value1` is greater than or equals `value2`, or `false` otherwise.\n *   * `['==', value1, value2]` returns `true` if `value1` equals `value2`, or `false` otherwise.\n *   * `['!=', value1, value2]` returns `true` if `value1` does not equal `value2`, or `false` otherwise.\n *   * `['!', value1]` returns `false` if `value1` is `true` or greater than `0`, or `true` otherwise.\n *   * `['all', value1, value2, ...]` returns `true` if all the inputs are `true`, `false` otherwise.\n *   * `['any', value1, value2, ...]` returns `true` if any of the inputs are `true`, `false` otherwise.\n *   * `['between', value1, value2, value3]` returns `true` if `value1` is contained between `value2` and `value3`\n *     (inclusively), or `false` otherwise.\n *\n * * Conversion operators:\n *   * `['array', value1, ...valueN]` creates a numerical array from `number` values; please note that the amount of\n *     values can currently only be 2, 3 or 4.\n *   * `['color', red, green, blue, alpha]` creates a `color` value from `number` values; the `alpha` parameter is\n *     optional; if not specified, it will be set to 1.\n *     Note: `red`, `green` and `blue` components must be values between 0 and 255; `alpha` between 0 and 1.\n *\n * Values can either be literals or another operator, as they will be evaluated recursively.\n * Literal values can be of the following types:\n * * `boolean`\n * * `number`\n * * `string`\n * * {@link module:ol/color~Color}\n *\n * @typedef {Array<*>|import(\"../color.js\").Color|string|number|boolean} ExpressionValue\n */\n/**\n * Possible inferred types from a given value or expression.\n * Note: these are binary flags.\n * @enum {number}\n */\nexport var ValueTypes = {\n  NUMBER: 1,\n  STRING: 2,\n  COLOR: 4,\n  BOOLEAN: 8,\n  NUMBER_ARRAY: 16,\n  ANY: 31,\n  NONE: 0\n};\n/**\n * An operator declaration must contain two methods: `getReturnType` which returns a type based on\n * the operator arguments, and `toGlsl` which returns a GLSL-compatible string.\n * Note: both methods can process arguments recursively.\n * @typedef {Object} Operator\n * @property {function(Array<ExpressionValue>): ValueTypes|number} getReturnType Returns one or several types\n * @property {function(ParsingContext, Array<ExpressionValue>, ValueTypes=): string} toGlsl Returns a GLSL-compatible string\n * Note: takes in an optional type hint as 3rd parameter\n */\n/**\n * Operator declarations\n * @type {Object<string, Operator>}\n */\nexport var Operators = {};\n/**\n * Returns the possible types for a given value (each type being a binary flag)\n * To test a value use e.g. `getValueType(v) & ValueTypes.BOOLEAN`\n * @param {ExpressionValue} value Value\n * @returns {ValueTypes|number} Type or types inferred from the value\n */\nexport function getValueType(value) {\n  if (typeof value === 'number') {\n    return ValueTypes.NUMBER;\n  }\n  if (typeof value === 'boolean') {\n    return ValueTypes.BOOLEAN;\n  }\n  if (typeof value === 'string') {\n    if (isStringColor(value)) {\n      return ValueTypes.COLOR | ValueTypes.STRING;\n    }\n    return ValueTypes.STRING;\n  }\n  if (!Array.isArray(value)) {\n    throw new Error(\"Unhandled value type: \" + JSON.stringify(value));\n  }\n  var valueArr = /** @type {Array<*>} */value;\n  var onlyNumbers = valueArr.every(function (v) {\n    return typeof v === 'number';\n  });\n  if (onlyNumbers) {\n    if (valueArr.length === 3 || valueArr.length === 4) {\n      return ValueTypes.COLOR | ValueTypes.NUMBER_ARRAY;\n    }\n    return ValueTypes.NUMBER_ARRAY;\n  }\n  if (typeof valueArr[0] !== 'string') {\n    throw new Error(\"Expected an expression operator but received: \" + JSON.stringify(valueArr));\n  }\n  var operator = Operators[valueArr[0]];\n  if (operator === undefined) {\n    throw new Error(\"Unrecognized expression operator: \" + JSON.stringify(valueArr));\n  }\n  return operator.getReturnType(valueArr.slice(1));\n}\n/**\n * Checks if only one value type is enabled in the input number.\n * @param {ValueTypes|number} valueType Number containing value type binary flags\n * @return {boolean} True if only one type flag is enabled, false if zero or multiple\n */\nexport function isTypeUnique(valueType) {\n  return Math.log2(valueType) % 1 === 0;\n}\n/**\n * Context available during the parsing of an expression.\n * @typedef {Object} ParsingContext\n * @property {boolean} [inFragmentShader] If false, means the expression output should be made for a vertex shader\n * @property {Array<string>} variables List of variables used in the expression; contains **unprefixed names**\n * @property {Array<string>} attributes List of attributes used in the expression; contains **unprefixed names**\n * @property {Object<string, number>} stringLiteralsMap This object maps all encountered string values to a number\n */\n/**\n * Will return the number as a float with a dot separator, which is required by GLSL.\n * @param {number} v Numerical value.\n * @returns {string} The value as string.\n */\nexport function numberToGlsl(v) {\n  var s = v.toString();\n  return s.indexOf('.') === -1 ? s + '.0' : s;\n}\n/**\n * Will return the number array as a float with a dot separator, concatenated with ', '.\n * @param {Array<number>} array Numerical values array.\n * @returns {string} The array as a vector, e. g.: `vec3(1.0, 2.0, 3.0)`.\n */\nexport function arrayToGlsl(array) {\n  if (array.length < 2 || array.length > 4) {\n    throw new Error('`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.');\n  }\n  return \"vec\" + array.length + \"(\" + array.map(numberToGlsl).join(', ') + \")\";\n}\n/**\n * Will normalize and converts to string a `vec4` color array compatible with GLSL.\n * @param {string|import(\"../color.js\").Color} color Color either in string format or [r, g, b, a] array format,\n * with RGB components in the 0..255 range and the alpha component in the 0..1 range.\n * Note that the final array will always have 4 components.\n * @returns {string} The color expressed in the `vec4(1.0, 1.0, 1.0, 1.0)` form.\n */\nexport function colorToGlsl(color) {\n  var array = asArray(color).slice();\n  if (array.length < 4) {\n    array.push(1);\n  }\n  return arrayToGlsl(array.map(function (c, i) {\n    return i < 3 ? c / 255 : c;\n  }));\n}\n/**\n * Returns a stable equivalent number for the string literal.\n * @param {ParsingContext} context Parsing context\n * @param {string} string String literal value\n * @returns {number} Number equivalent\n */\nexport function getStringNumberEquivalent(context, string) {\n  if (context.stringLiteralsMap[string] === undefined) {\n    context.stringLiteralsMap[string] = Object.keys(context.stringLiteralsMap).length;\n  }\n  return context.stringLiteralsMap[string];\n}\n/**\n * Returns a stable equivalent number for the string literal, for use in shaders. This number is then\n * converted to be a GLSL-compatible string.\n * @param {ParsingContext} context Parsing context\n * @param {string} string String literal value\n * @returns {string} GLSL-compatible string containing a number\n */\nexport function stringToGlsl(context, string) {\n  return numberToGlsl(getStringNumberEquivalent(context, string));\n}\n/**\n * Recursively parses a style expression and outputs a GLSL-compatible string. Takes in a parsing context that\n * will be read and modified during the parsing operation.\n * @param {ParsingContext} context Parsing context\n * @param {ExpressionValue} value Value\n * @param {ValueTypes|number} [typeHint] Hint for the expected final type (can be several types combined)\n * @returns {string} GLSL-compatible output\n */\nexport function expressionToGlsl(context, value, typeHint) {\n  // operator\n  if (Array.isArray(value) && typeof value[0] === 'string') {\n    var operator = Operators[value[0]];\n    if (operator === undefined) {\n      throw new Error(\"Unrecognized expression operator: \" + JSON.stringify(value));\n    }\n    return operator.toGlsl(context, value.slice(1), typeHint);\n  } else if ((getValueType(value) & ValueTypes.NUMBER) > 0) {\n    return numberToGlsl( /** @type {number} */value);\n  } else if ((getValueType(value) & ValueTypes.BOOLEAN) > 0) {\n    return value.toString();\n  } else if ((getValueType(value) & ValueTypes.STRING) > 0 && (typeHint === undefined || typeHint == ValueTypes.STRING)) {\n    return stringToGlsl(context, value.toString());\n  } else if ((getValueType(value) & ValueTypes.COLOR) > 0 && (typeHint === undefined || typeHint == ValueTypes.COLOR)) {\n    return colorToGlsl( /** @type {number[]|string} */value);\n  } else if ((getValueType(value) & ValueTypes.NUMBER_ARRAY) > 0) {\n    return arrayToGlsl( /** @type {number[]} */value);\n  }\n}\nfunction assertNumber(value) {\n  if (!(getValueType(value) & ValueTypes.NUMBER)) {\n    throw new Error(\"A numeric value was expected, got \" + JSON.stringify(value) + \" instead\");\n  }\n}\nfunction assertNumbers(values) {\n  for (var i = 0; i < values.length; i++) {\n    assertNumber(values[i]);\n  }\n}\nfunction assertString(value) {\n  if (!(getValueType(value) & ValueTypes.STRING)) {\n    throw new Error(\"A string value was expected, got \" + JSON.stringify(value) + \" instead\");\n  }\n}\nfunction assertBoolean(value) {\n  if (!(getValueType(value) & ValueTypes.BOOLEAN)) {\n    throw new Error(\"A boolean value was expected, got \" + JSON.stringify(value) + \" instead\");\n  }\n}\nfunction assertArgsCount(args, count) {\n  if (args.length !== count) {\n    throw new Error(\"Exactly \" + count + \" arguments were expected, got \" + args.length + \" instead\");\n  }\n}\nfunction assertArgsMinCount(args, count) {\n  if (args.length < count) {\n    throw new Error(\"At least \" + count + \" arguments were expected, got \" + args.length + \" instead\");\n  }\n}\nfunction assertArgsMaxCount(args, count) {\n  if (args.length > count) {\n    throw new Error(\"At most \" + count + \" arguments were expected, got \" + args.length + \" instead\");\n  }\n}\nfunction assertArgsEven(args) {\n  if (args.length % 2 !== 0) {\n    throw new Error(\"An even amount of arguments was expected, got \" + args + \" instead\");\n  }\n}\nfunction assertArgsOdd(args) {\n  if (args.length % 2 === 0) {\n    throw new Error(\"An even amount of arguments was expected, got \" + args + \" instead\");\n  }\n}\nfunction assertUniqueInferredType(args, types) {\n  if (!isTypeUnique(types)) {\n    throw new Error(\"Could not infer only one type from the following expression: \" + JSON.stringify(args));\n  }\n}\nOperators['get'] = {\n  getReturnType: function getReturnType(args) {\n    return ValueTypes.ANY;\n  },\n  toGlsl: function toGlsl(context, args) {\n    assertArgsCount(args, 1);\n    assertString(args[0]);\n    var value = args[0].toString();\n    if (context.attributes.indexOf(value) === -1) {\n      context.attributes.push(value);\n    }\n    var prefix = context.inFragmentShader ? 'v_' : 'a_';\n    return prefix + value;\n  }\n};\nOperators['var'] = {\n  getReturnType: function getReturnType(args) {\n    return ValueTypes.ANY;\n  },\n  toGlsl: function toGlsl(context, args) {\n    assertArgsCount(args, 1);\n    assertString(args[0]);\n    var value = args[0].toString();\n    if (context.variables.indexOf(value) === -1) {\n      context.variables.push(value);\n    }\n    return \"u_\" + value;\n  }\n};\nOperators['time'] = {\n  getReturnType: function getReturnType(args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function toGlsl(context, args) {\n    assertArgsCount(args, 0);\n    return 'u_time';\n  }\n};\nOperators['zoom'] = {\n  getReturnType: function getReturnType(args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function toGlsl(context, args) {\n    assertArgsCount(args, 0);\n    return 'u_zoom';\n  }\n};\nOperators['resolution'] = {\n  getReturnType: function getReturnType(args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function toGlsl(context, args) {\n    assertArgsCount(args, 0);\n    return 'u_resolution';\n  }\n};\nOperators['*'] = {\n  getReturnType: function getReturnType(args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function toGlsl(context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"(\" + expressionToGlsl(context, args[0]) + \" * \" + expressionToGlsl(context, args[1]) + \")\";\n  }\n};\nOperators['/'] = {\n  getReturnType: function getReturnType(args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function toGlsl(context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"(\" + expressionToGlsl(context, args[0]) + \" / \" + expressionToGlsl(context, args[1]) + \")\";\n  }\n};\nOperators['+'] = {\n  getReturnType: function getReturnType(args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function toGlsl(context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"(\" + expressionToGlsl(context, args[0]) + \" + \" + expressionToGlsl(context, args[1]) + \")\";\n  }\n};\nOperators['-'] = {\n  getReturnType: function getReturnType(args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function toGlsl(context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"(\" + expressionToGlsl(context, args[0]) + \" - \" + expressionToGlsl(context, args[1]) + \")\";\n  }\n};\nOperators['clamp'] = {\n  getReturnType: function getReturnType(args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function toGlsl(context, args) {\n    assertArgsCount(args, 3);\n    assertNumbers(args);\n    var min = expressionToGlsl(context, args[1]);\n    var max = expressionToGlsl(context, args[2]);\n    return \"clamp(\" + expressionToGlsl(context, args[0]) + \", \" + min + \", \" + max + \")\";\n  }\n};\nOperators['%'] = {\n  getReturnType: function getReturnType(args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function toGlsl(context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"mod(\" + expressionToGlsl(context, args[0]) + \", \" + expressionToGlsl(context, args[1]) + \")\";\n  }\n};\nOperators['^'] = {\n  getReturnType: function getReturnType(args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function toGlsl(context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"pow(\" + expressionToGlsl(context, args[0]) + \", \" + expressionToGlsl(context, args[1]) + \")\";\n  }\n};\nOperators['>'] = {\n  getReturnType: function getReturnType(args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function toGlsl(context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"(\" + expressionToGlsl(context, args[0]) + \" > \" + expressionToGlsl(context, args[1]) + \")\";\n  }\n};\nOperators['>='] = {\n  getReturnType: function getReturnType(args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function toGlsl(context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"(\" + expressionToGlsl(context, args[0]) + \" >= \" + expressionToGlsl(context, args[1]) + \")\";\n  }\n};\nOperators['<'] = {\n  getReturnType: function getReturnType(args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function toGlsl(context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"(\" + expressionToGlsl(context, args[0]) + \" < \" + expressionToGlsl(context, args[1]) + \")\";\n  }\n};\nOperators['<='] = {\n  getReturnType: function getReturnType(args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function toGlsl(context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"(\" + expressionToGlsl(context, args[0]) + \" <= \" + expressionToGlsl(context, args[1]) + \")\";\n  }\n};\nfunction getEqualOperator(operator) {\n  return {\n    getReturnType: function getReturnType(args) {\n      return ValueTypes.BOOLEAN;\n    },\n    toGlsl: function toGlsl(context, args) {\n      assertArgsCount(args, 2);\n      // find common type\n      var type = ValueTypes.ANY;\n      for (var i = 0; i < args.length; i++) {\n        type = type & getValueType(args[i]);\n      }\n      if (type === 0) {\n        throw new Error(\"All arguments should be of compatible type, got \" + JSON.stringify(args) + \" instead\");\n      }\n      return \"(\" + expressionToGlsl(context, args[0], type) + \" \" + operator + \" \" + expressionToGlsl(context, args[1], type) + \")\";\n    }\n  };\n}\nOperators['=='] = getEqualOperator('==');\nOperators['!='] = getEqualOperator('!=');\nOperators['!'] = {\n  getReturnType: function getReturnType(args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function toGlsl(context, args) {\n    assertArgsCount(args, 1);\n    assertBoolean(args[0]);\n    return \"(!\" + expressionToGlsl(context, args[0]) + \")\";\n  }\n};\nfunction getDecisionOperator(operator) {\n  return {\n    getReturnType: function getReturnType(args) {\n      return ValueTypes.BOOLEAN;\n    },\n    toGlsl: function toGlsl(context, args) {\n      assertArgsMinCount(args, 2);\n      for (var i = 0; i < args.length; i++) {\n        assertBoolean(args[i]);\n      }\n      var result = '';\n      result = args.map(function (arg) {\n        return expressionToGlsl(context, arg);\n      }).join(\" \" + operator + \" \");\n      result = \"(\" + result + \")\";\n      return result;\n    }\n  };\n}\nOperators['all'] = getDecisionOperator('&&');\nOperators['any'] = getDecisionOperator('||');\nOperators['between'] = {\n  getReturnType: function getReturnType(args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function toGlsl(context, args) {\n    assertArgsCount(args, 3);\n    assertNumbers(args);\n    var min = expressionToGlsl(context, args[1]);\n    var max = expressionToGlsl(context, args[2]);\n    var value = expressionToGlsl(context, args[0]);\n    return \"(\" + value + \" >= \" + min + \" && \" + value + \" <= \" + max + \")\";\n  }\n};\nOperators['array'] = {\n  getReturnType: function getReturnType(args) {\n    return ValueTypes.NUMBER_ARRAY;\n  },\n  toGlsl: function toGlsl(context, args) {\n    assertArgsMinCount(args, 2);\n    assertArgsMaxCount(args, 4);\n    assertNumbers(args);\n    var parsedArgs = args.map(function (val) {\n      return expressionToGlsl(context, val, ValueTypes.NUMBER);\n    });\n    return \"vec\" + args.length + \"(\" + parsedArgs.join(', ') + \")\";\n  }\n};\nOperators['color'] = {\n  getReturnType: function getReturnType(args) {\n    return ValueTypes.COLOR;\n  },\n  toGlsl: function toGlsl(context, args) {\n    assertArgsMinCount(args, 3);\n    assertArgsMaxCount(args, 4);\n    assertNumbers(args);\n    var array = /** @type {number[]} */args;\n    if (args.length === 3) {\n      array.push(1);\n    }\n    var parsedArgs = args.map(function (val, i) {\n      return expressionToGlsl(context, val, ValueTypes.NUMBER) + (i < 3 ? ' / 255.0' : '');\n    });\n    return \"vec\" + args.length + \"(\" + parsedArgs.join(', ') + \")\";\n  }\n};\nOperators['interpolate'] = {\n  getReturnType: function getReturnType(args) {\n    var type = ValueTypes.COLOR | ValueTypes.NUMBER;\n    for (var i = 3; i < args.length; i += 2) {\n      type = type & getValueType(args[i]);\n    }\n    return type;\n  },\n  toGlsl: function toGlsl(context, args, opt_typeHint) {\n    assertArgsEven(args);\n    assertArgsMinCount(args, 6);\n    // validate interpolation type\n    var type = args[0];\n    var interpolation;\n    switch (type[0]) {\n      case 'linear':\n        interpolation = 1;\n        break;\n      case 'exponential':\n        interpolation = type[1];\n        break;\n      default:\n        interpolation = null;\n    }\n    if (!interpolation) {\n      throw new Error(\"Invalid interpolation type for \\\"interpolate\\\" operator, received: \" + JSON.stringify(type));\n    }\n    // compute input/output types\n    var typeHint = opt_typeHint !== undefined ? opt_typeHint : ValueTypes.ANY;\n    var outputType = Operators['interpolate'].getReturnType(args) & typeHint;\n    assertUniqueInferredType(args, outputType);\n    var input = expressionToGlsl(context, args[1]);\n    var result = null;\n    for (var i = 2; i < args.length - 2; i += 2) {\n      var stop1 = expressionToGlsl(context, args[i]);\n      var output1 = expressionToGlsl(context, args[i + 1], outputType);\n      var stop2 = expressionToGlsl(context, args[i + 2]);\n      var output2 = expressionToGlsl(context, args[i + 3], outputType);\n      result = \"mix(\" + (result || output1) + \", \" + output2 + \", pow(clamp((\" + input + \" - \" + stop1 + \") / (\" + stop2 + \" - \" + stop1 + \"), 0.0, 1.0), \" + numberToGlsl(interpolation) + \"))\";\n    }\n    return result;\n  }\n};\nOperators['match'] = {\n  getReturnType: function getReturnType(args) {\n    var type = ValueTypes.ANY;\n    for (var i = 2; i < args.length; i += 2) {\n      type = type & getValueType(args[i]);\n    }\n    type = type & getValueType(args[args.length - 1]);\n    return type;\n  },\n  toGlsl: function toGlsl(context, args, opt_typeHint) {\n    assertArgsEven(args);\n    assertArgsMinCount(args, 4);\n    var typeHint = opt_typeHint !== undefined ? opt_typeHint : ValueTypes.ANY;\n    var outputType = Operators['match'].getReturnType(args) & typeHint;\n    assertUniqueInferredType(args, outputType);\n    var input = expressionToGlsl(context, args[0]);\n    var fallback = expressionToGlsl(context, args[args.length - 1], outputType);\n    var result = null;\n    for (var i = args.length - 3; i >= 1; i -= 2) {\n      var match = expressionToGlsl(context, args[i]);\n      var output = expressionToGlsl(context, args[i + 1], outputType);\n      result = \"(\" + input + \" == \" + match + \" ? \" + output + \" : \" + (result || fallback) + \")\";\n    }\n    return result;\n  }\n};\nOperators['case'] = {\n  getReturnType: function getReturnType(args) {\n    var type = ValueTypes.ANY;\n    for (var i = 1; i < args.length; i += 2) {\n      type = type & getValueType(args[i]);\n    }\n    type = type & getValueType(args[args.length - 1]);\n    return type;\n  },\n  toGlsl: function toGlsl(context, args, opt_typeHint) {\n    assertArgsOdd(args);\n    assertArgsMinCount(args, 3);\n    var typeHint = opt_typeHint !== undefined ? opt_typeHint : ValueTypes.ANY;\n    var outputType = Operators['case'].getReturnType(args) & typeHint;\n    assertUniqueInferredType(args, outputType);\n    for (var i = 0; i < args.length - 1; i += 2) {\n      assertBoolean(args[i]);\n    }\n    var fallback = expressionToGlsl(context, args[args.length - 1], outputType);\n    var result = null;\n    for (var i = args.length - 3; i >= 0; i -= 2) {\n      var condition = expressionToGlsl(context, args[i]);\n      var output = expressionToGlsl(context, args[i + 1], outputType);\n      result = \"(\" + condition + \" ? \" + output + \" : \" + (result || fallback) + \")\";\n    }\n    return result;\n  }\n};","map":{"version":3,"names":["asArray","isStringColor","ValueTypes","NUMBER","STRING","COLOR","BOOLEAN","NUMBER_ARRAY","ANY","NONE","Operators","getValueType","value","Array","isArray","Error","JSON","stringify","valueArr","onlyNumbers","every","v","length","operator","undefined","getReturnType","slice","isTypeUnique","valueType","Math","log2","numberToGlsl","s","toString","indexOf","arrayToGlsl","array","map","join","colorToGlsl","color","push","c","i","getStringNumberEquivalent","context","string","stringLiteralsMap","Object","keys","stringToGlsl","expressionToGlsl","typeHint","toGlsl","assertNumber","assertNumbers","values","assertString","assertBoolean","assertArgsCount","args","count","assertArgsMinCount","assertArgsMaxCount","assertArgsEven","assertArgsOdd","assertUniqueInferredType","types","attributes","prefix","inFragmentShader","variables","min","max","getEqualOperator","type","getDecisionOperator","result","arg","parsedArgs","val","opt_typeHint","interpolation","outputType","input","stop1","output1","stop2","output2","fallback","match","output","condition"],"sources":["/Users/mariovicky/Skripsi_OpenLayers/node_modules/ol/src/style/expressions.js"],"sourcesContent":["/**\n * Operators and utilities used for style expressions\n * @module ol/style/expressions\n */\n\nimport {asArray, isStringColor} from '../color.js';\n\n/**\n * Base type used for literal style parameters; can be a number literal or the output of an operator,\n * which in turns takes {@link ExpressionValue} arguments.\n *\n * The following operators can be used:\n *\n * * Reading operators:\n *   * `['get', 'attributeName']` fetches a feature attribute (it will be prefixed by `a_` in the shader)\n *     Note: those will be taken from the attributes provided to the renderer\n *   * `['var', 'varName']` fetches a value from the style variables, or 0 if undefined\n *   * `['time']` returns the time in seconds since the creation of the layer\n *   * `['zoom']` returns the current zoom level\n *   * `['resolution']` returns the current resolution\n *\n * * Math operators:\n *   * `['*', value1, value2]` multiplies `value1` by `value2`\n *   * `['/', value1, value2]` divides `value1` by `value2`\n *   * `['+', value1, value2]` adds `value1` and `value2`\n *   * `['-', value1, value2]` subtracts `value2` from `value1`\n *   * `['clamp', value, low, high]` clamps `value` between `low` and `high`\n *   * `['%', value1, value2]` returns the result of `value1 % value2` (modulo)\n *   * `['^', value1, value2]` returns the value of `value1` raised to the `value2` power\n *\n * * Transform operators:\n *   * `['case', condition1, output1, ...conditionN, outputN, fallback]` selects the first output whose corresponding\n *     condition evaluates to `true`. If no match is found, returns the `fallback` value.\n *     All conditions should be `boolean`, output and fallback can be any kind.\n *   * `['match', input, match1, output1, ...matchN, outputN, fallback]` compares the `input` value against all\n *     provided `matchX` values, returning the output associated with the first valid match. If no match is found,\n *     returns the `fallback` value.\n *     `input` and `matchX` values must all be of the same type, and can be `number` or `string`. `outputX` and\n *     `fallback` values must be of the same type, and can be of any kind.\n *   * `['interpolate', interpolation, input, stop1, output1, ...stopN, outputN]` returns a value by interpolating between\n *     pairs of inputs and outputs; `interpolation` can either be `['linear']` or `['exponential', base]` where `base` is\n *     the rate of increase from stop A to stop B (i.e. power to which the interpolation ratio is raised); a value\n *     of 1 is equivalent to `['linear']`.\n *     `input` and `stopX` values must all be of type `number`. `outputX` values can be `number` or `color` values.\n *     Note: `input` will be clamped between `stop1` and `stopN`, meaning that all output values will be comprised\n *     between `output1` and `outputN`.\n *\n * * Logical operators:\n *   * `['<', value1, value2]` returns `true` if `value1` is strictly lower than `value2`, or `false` otherwise.\n *   * `['<=', value1, value2]` returns `true` if `value1` is lower than or equals `value2`, or `false` otherwise.\n *   * `['>', value1, value2]` returns `true` if `value1` is strictly greater than `value2`, or `false` otherwise.\n *   * `['>=', value1, value2]` returns `true` if `value1` is greater than or equals `value2`, or `false` otherwise.\n *   * `['==', value1, value2]` returns `true` if `value1` equals `value2`, or `false` otherwise.\n *   * `['!=', value1, value2]` returns `true` if `value1` does not equal `value2`, or `false` otherwise.\n *   * `['!', value1]` returns `false` if `value1` is `true` or greater than `0`, or `true` otherwise.\n *   * `['all', value1, value2, ...]` returns `true` if all the inputs are `true`, `false` otherwise.\n *   * `['any', value1, value2, ...]` returns `true` if any of the inputs are `true`, `false` otherwise.\n *   * `['between', value1, value2, value3]` returns `true` if `value1` is contained between `value2` and `value3`\n *     (inclusively), or `false` otherwise.\n *\n * * Conversion operators:\n *   * `['array', value1, ...valueN]` creates a numerical array from `number` values; please note that the amount of\n *     values can currently only be 2, 3 or 4.\n *   * `['color', red, green, blue, alpha]` creates a `color` value from `number` values; the `alpha` parameter is\n *     optional; if not specified, it will be set to 1.\n *     Note: `red`, `green` and `blue` components must be values between 0 and 255; `alpha` between 0 and 1.\n *\n * Values can either be literals or another operator, as they will be evaluated recursively.\n * Literal values can be of the following types:\n * * `boolean`\n * * `number`\n * * `string`\n * * {@link module:ol/color~Color}\n *\n * @typedef {Array<*>|import(\"../color.js\").Color|string|number|boolean} ExpressionValue\n */\n\n/**\n * Possible inferred types from a given value or expression.\n * Note: these are binary flags.\n * @enum {number}\n */\nexport const ValueTypes = {\n  NUMBER: 0b00001,\n  STRING: 0b00010,\n  COLOR: 0b00100,\n  BOOLEAN: 0b01000,\n  NUMBER_ARRAY: 0b10000,\n  ANY: 0b11111,\n  NONE: 0,\n};\n\n/**\n * An operator declaration must contain two methods: `getReturnType` which returns a type based on\n * the operator arguments, and `toGlsl` which returns a GLSL-compatible string.\n * Note: both methods can process arguments recursively.\n * @typedef {Object} Operator\n * @property {function(Array<ExpressionValue>): ValueTypes|number} getReturnType Returns one or several types\n * @property {function(ParsingContext, Array<ExpressionValue>, ValueTypes=): string} toGlsl Returns a GLSL-compatible string\n * Note: takes in an optional type hint as 3rd parameter\n */\n\n/**\n * Operator declarations\n * @type {Object<string, Operator>}\n */\nexport const Operators = {};\n\n/**\n * Returns the possible types for a given value (each type being a binary flag)\n * To test a value use e.g. `getValueType(v) & ValueTypes.BOOLEAN`\n * @param {ExpressionValue} value Value\n * @returns {ValueTypes|number} Type or types inferred from the value\n */\nexport function getValueType(value) {\n  if (typeof value === 'number') {\n    return ValueTypes.NUMBER;\n  }\n  if (typeof value === 'boolean') {\n    return ValueTypes.BOOLEAN;\n  }\n  if (typeof value === 'string') {\n    if (isStringColor(value)) {\n      return ValueTypes.COLOR | ValueTypes.STRING;\n    }\n    return ValueTypes.STRING;\n  }\n  if (!Array.isArray(value)) {\n    throw new Error(`Unhandled value type: ${JSON.stringify(value)}`);\n  }\n  const valueArr = /** @type {Array<*>} */ (value);\n  const onlyNumbers = valueArr.every(function (v) {\n    return typeof v === 'number';\n  });\n  if (onlyNumbers) {\n    if (valueArr.length === 3 || valueArr.length === 4) {\n      return ValueTypes.COLOR | ValueTypes.NUMBER_ARRAY;\n    }\n    return ValueTypes.NUMBER_ARRAY;\n  }\n  if (typeof valueArr[0] !== 'string') {\n    throw new Error(\n      `Expected an expression operator but received: ${JSON.stringify(\n        valueArr\n      )}`\n    );\n  }\n  const operator = Operators[valueArr[0]];\n  if (operator === undefined) {\n    throw new Error(\n      `Unrecognized expression operator: ${JSON.stringify(valueArr)}`\n    );\n  }\n  return operator.getReturnType(valueArr.slice(1));\n}\n\n/**\n * Checks if only one value type is enabled in the input number.\n * @param {ValueTypes|number} valueType Number containing value type binary flags\n * @return {boolean} True if only one type flag is enabled, false if zero or multiple\n */\nexport function isTypeUnique(valueType) {\n  return Math.log2(valueType) % 1 === 0;\n}\n\n/**\n * Context available during the parsing of an expression.\n * @typedef {Object} ParsingContext\n * @property {boolean} [inFragmentShader] If false, means the expression output should be made for a vertex shader\n * @property {Array<string>} variables List of variables used in the expression; contains **unprefixed names**\n * @property {Array<string>} attributes List of attributes used in the expression; contains **unprefixed names**\n * @property {Object<string, number>} stringLiteralsMap This object maps all encountered string values to a number\n */\n\n/**\n * Will return the number as a float with a dot separator, which is required by GLSL.\n * @param {number} v Numerical value.\n * @returns {string} The value as string.\n */\nexport function numberToGlsl(v) {\n  const s = v.toString();\n  return s.indexOf('.') === -1 ? s + '.0' : s;\n}\n\n/**\n * Will return the number array as a float with a dot separator, concatenated with ', '.\n * @param {Array<number>} array Numerical values array.\n * @returns {string} The array as a vector, e. g.: `vec3(1.0, 2.0, 3.0)`.\n */\nexport function arrayToGlsl(array) {\n  if (array.length < 2 || array.length > 4) {\n    throw new Error(\n      '`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.'\n    );\n  }\n  return `vec${array.length}(${array.map(numberToGlsl).join(', ')})`;\n}\n\n/**\n * Will normalize and converts to string a `vec4` color array compatible with GLSL.\n * @param {string|import(\"../color.js\").Color} color Color either in string format or [r, g, b, a] array format,\n * with RGB components in the 0..255 range and the alpha component in the 0..1 range.\n * Note that the final array will always have 4 components.\n * @returns {string} The color expressed in the `vec4(1.0, 1.0, 1.0, 1.0)` form.\n */\nexport function colorToGlsl(color) {\n  const array = asArray(color).slice();\n  if (array.length < 4) {\n    array.push(1);\n  }\n  return arrayToGlsl(\n    array.map(function (c, i) {\n      return i < 3 ? c / 255 : c;\n    })\n  );\n}\n\n/**\n * Returns a stable equivalent number for the string literal.\n * @param {ParsingContext} context Parsing context\n * @param {string} string String literal value\n * @returns {number} Number equivalent\n */\nexport function getStringNumberEquivalent(context, string) {\n  if (context.stringLiteralsMap[string] === undefined) {\n    context.stringLiteralsMap[string] = Object.keys(\n      context.stringLiteralsMap\n    ).length;\n  }\n  return context.stringLiteralsMap[string];\n}\n\n/**\n * Returns a stable equivalent number for the string literal, for use in shaders. This number is then\n * converted to be a GLSL-compatible string.\n * @param {ParsingContext} context Parsing context\n * @param {string} string String literal value\n * @returns {string} GLSL-compatible string containing a number\n */\nexport function stringToGlsl(context, string) {\n  return numberToGlsl(getStringNumberEquivalent(context, string));\n}\n\n/**\n * Recursively parses a style expression and outputs a GLSL-compatible string. Takes in a parsing context that\n * will be read and modified during the parsing operation.\n * @param {ParsingContext} context Parsing context\n * @param {ExpressionValue} value Value\n * @param {ValueTypes|number} [typeHint] Hint for the expected final type (can be several types combined)\n * @returns {string} GLSL-compatible output\n */\nexport function expressionToGlsl(context, value, typeHint) {\n  // operator\n  if (Array.isArray(value) && typeof value[0] === 'string') {\n    const operator = Operators[value[0]];\n    if (operator === undefined) {\n      throw new Error(\n        `Unrecognized expression operator: ${JSON.stringify(value)}`\n      );\n    }\n    return operator.toGlsl(context, value.slice(1), typeHint);\n  } else if ((getValueType(value) & ValueTypes.NUMBER) > 0) {\n    return numberToGlsl(/** @type {number} */ (value));\n  } else if ((getValueType(value) & ValueTypes.BOOLEAN) > 0) {\n    return value.toString();\n  } else if (\n    (getValueType(value) & ValueTypes.STRING) > 0 &&\n    (typeHint === undefined || typeHint == ValueTypes.STRING)\n  ) {\n    return stringToGlsl(context, value.toString());\n  } else if (\n    (getValueType(value) & ValueTypes.COLOR) > 0 &&\n    (typeHint === undefined || typeHint == ValueTypes.COLOR)\n  ) {\n    return colorToGlsl(/** @type {number[]|string} */ (value));\n  } else if ((getValueType(value) & ValueTypes.NUMBER_ARRAY) > 0) {\n    return arrayToGlsl(/** @type {number[]} */ (value));\n  }\n}\n\nfunction assertNumber(value) {\n  if (!(getValueType(value) & ValueTypes.NUMBER)) {\n    throw new Error(\n      `A numeric value was expected, got ${JSON.stringify(value)} instead`\n    );\n  }\n}\nfunction assertNumbers(values) {\n  for (let i = 0; i < values.length; i++) {\n    assertNumber(values[i]);\n  }\n}\nfunction assertString(value) {\n  if (!(getValueType(value) & ValueTypes.STRING)) {\n    throw new Error(\n      `A string value was expected, got ${JSON.stringify(value)} instead`\n    );\n  }\n}\nfunction assertBoolean(value) {\n  if (!(getValueType(value) & ValueTypes.BOOLEAN)) {\n    throw new Error(\n      `A boolean value was expected, got ${JSON.stringify(value)} instead`\n    );\n  }\n}\nfunction assertArgsCount(args, count) {\n  if (args.length !== count) {\n    throw new Error(\n      `Exactly ${count} arguments were expected, got ${args.length} instead`\n    );\n  }\n}\nfunction assertArgsMinCount(args, count) {\n  if (args.length < count) {\n    throw new Error(\n      `At least ${count} arguments were expected, got ${args.length} instead`\n    );\n  }\n}\nfunction assertArgsMaxCount(args, count) {\n  if (args.length > count) {\n    throw new Error(\n      `At most ${count} arguments were expected, got ${args.length} instead`\n    );\n  }\n}\nfunction assertArgsEven(args) {\n  if (args.length % 2 !== 0) {\n    throw new Error(\n      `An even amount of arguments was expected, got ${args} instead`\n    );\n  }\n}\nfunction assertArgsOdd(args) {\n  if (args.length % 2 === 0) {\n    throw new Error(\n      `An even amount of arguments was expected, got ${args} instead`\n    );\n  }\n}\nfunction assertUniqueInferredType(args, types) {\n  if (!isTypeUnique(types)) {\n    throw new Error(\n      `Could not infer only one type from the following expression: ${JSON.stringify(\n        args\n      )}`\n    );\n  }\n}\n\nOperators['get'] = {\n  getReturnType: function (args) {\n    return ValueTypes.ANY;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertString(args[0]);\n    const value = args[0].toString();\n    if (context.attributes.indexOf(value) === -1) {\n      context.attributes.push(value);\n    }\n    const prefix = context.inFragmentShader ? 'v_' : 'a_';\n    return prefix + value;\n  },\n};\nOperators['var'] = {\n  getReturnType: function (args) {\n    return ValueTypes.ANY;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertString(args[0]);\n    const value = args[0].toString();\n    if (context.variables.indexOf(value) === -1) {\n      context.variables.push(value);\n    }\n    return `u_${value}`;\n  },\n};\nOperators['time'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 0);\n    return 'u_time';\n  },\n};\nOperators['zoom'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 0);\n    return 'u_zoom';\n  },\n};\nOperators['resolution'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 0);\n    return 'u_resolution';\n  },\n};\n\nOperators['*'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} * ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\nOperators['/'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} / ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\nOperators['+'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} + ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\nOperators['-'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} - ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\nOperators['clamp'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 3);\n    assertNumbers(args);\n    const min = expressionToGlsl(context, args[1]);\n    const max = expressionToGlsl(context, args[2]);\n    return `clamp(${expressionToGlsl(context, args[0])}, ${min}, ${max})`;\n  },\n};\nOperators['%'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `mod(${expressionToGlsl(context, args[0])}, ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\nOperators['^'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `pow(${expressionToGlsl(context, args[0])}, ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\nOperators['>'] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} > ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\nOperators['>='] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} >= ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\nOperators['<'] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} < ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\nOperators['<='] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} <= ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nfunction getEqualOperator(operator) {\n  return {\n    getReturnType: function (args) {\n      return ValueTypes.BOOLEAN;\n    },\n    toGlsl: function (context, args) {\n      assertArgsCount(args, 2);\n\n      // find common type\n      let type = ValueTypes.ANY;\n      for (let i = 0; i < args.length; i++) {\n        type = type & getValueType(args[i]);\n      }\n      if (type === 0) {\n        throw new Error(\n          `All arguments should be of compatible type, got ${JSON.stringify(\n            args\n          )} instead`\n        );\n      }\n\n      return `(${expressionToGlsl(\n        context,\n        args[0],\n        type\n      )} ${operator} ${expressionToGlsl(context, args[1], type)})`;\n    },\n  };\n}\nOperators['=='] = getEqualOperator('==');\nOperators['!='] = getEqualOperator('!=');\n\nOperators['!'] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertBoolean(args[0]);\n    return `(!${expressionToGlsl(context, args[0])})`;\n  },\n};\n\nfunction getDecisionOperator(operator) {\n  return {\n    getReturnType: function (args) {\n      return ValueTypes.BOOLEAN;\n    },\n    toGlsl: function (context, args) {\n      assertArgsMinCount(args, 2);\n      for (let i = 0; i < args.length; i++) {\n        assertBoolean(args[i]);\n      }\n      let result = '';\n      result = args\n        .map((arg) => expressionToGlsl(context, arg))\n        .join(` ${operator} `);\n      result = `(${result})`;\n      return result;\n    },\n  };\n}\n\nOperators['all'] = getDecisionOperator('&&');\nOperators['any'] = getDecisionOperator('||');\nOperators['between'] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 3);\n    assertNumbers(args);\n    const min = expressionToGlsl(context, args[1]);\n    const max = expressionToGlsl(context, args[2]);\n    const value = expressionToGlsl(context, args[0]);\n    return `(${value} >= ${min} && ${value} <= ${max})`;\n  },\n};\n\nOperators['array'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER_ARRAY;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 2);\n    assertArgsMaxCount(args, 4);\n    assertNumbers(args);\n    const parsedArgs = args.map(function (val) {\n      return expressionToGlsl(context, val, ValueTypes.NUMBER);\n    });\n    return `vec${args.length}(${parsedArgs.join(', ')})`;\n  },\n};\nOperators['color'] = {\n  getReturnType: function (args) {\n    return ValueTypes.COLOR;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 3);\n    assertArgsMaxCount(args, 4);\n    assertNumbers(args);\n    const array = /** @type {number[]} */ (args);\n    if (args.length === 3) {\n      array.push(1);\n    }\n    const parsedArgs = args.map(function (val, i) {\n      return (\n        expressionToGlsl(context, val, ValueTypes.NUMBER) +\n        (i < 3 ? ' / 255.0' : '')\n      );\n    });\n    return `vec${args.length}(${parsedArgs.join(', ')})`;\n  },\n};\n\nOperators['interpolate'] = {\n  getReturnType: function (args) {\n    let type = ValueTypes.COLOR | ValueTypes.NUMBER;\n    for (let i = 3; i < args.length; i += 2) {\n      type = type & getValueType(args[i]);\n    }\n    return type;\n  },\n  toGlsl: function (context, args, opt_typeHint) {\n    assertArgsEven(args);\n    assertArgsMinCount(args, 6);\n\n    // validate interpolation type\n    const type = args[0];\n    let interpolation;\n    switch (type[0]) {\n      case 'linear':\n        interpolation = 1;\n        break;\n      case 'exponential':\n        interpolation = type[1];\n        break;\n      default:\n        interpolation = null;\n    }\n    if (!interpolation) {\n      throw new Error(\n        `Invalid interpolation type for \"interpolate\" operator, received: ${JSON.stringify(\n          type\n        )}`\n      );\n    }\n\n    // compute input/output types\n    const typeHint = opt_typeHint !== undefined ? opt_typeHint : ValueTypes.ANY;\n    const outputType = Operators['interpolate'].getReturnType(args) & typeHint;\n    assertUniqueInferredType(args, outputType);\n\n    const input = expressionToGlsl(context, args[1]);\n    let result = null;\n    for (let i = 2; i < args.length - 2; i += 2) {\n      const stop1 = expressionToGlsl(context, args[i]);\n      const output1 = expressionToGlsl(context, args[i + 1], outputType);\n      const stop2 = expressionToGlsl(context, args[i + 2]);\n      const output2 = expressionToGlsl(context, args[i + 3], outputType);\n      result = `mix(${\n        result || output1\n      }, ${output2}, pow(clamp((${input} - ${stop1}) / (${stop2} - ${stop1}), 0.0, 1.0), ${numberToGlsl(\n        interpolation\n      )}))`;\n    }\n    return result;\n  },\n};\nOperators['match'] = {\n  getReturnType: function (args) {\n    let type = ValueTypes.ANY;\n    for (let i = 2; i < args.length; i += 2) {\n      type = type & getValueType(args[i]);\n    }\n    type = type & getValueType(args[args.length - 1]);\n    return type;\n  },\n  toGlsl: function (context, args, opt_typeHint) {\n    assertArgsEven(args);\n    assertArgsMinCount(args, 4);\n\n    const typeHint = opt_typeHint !== undefined ? opt_typeHint : ValueTypes.ANY;\n    const outputType = Operators['match'].getReturnType(args) & typeHint;\n    assertUniqueInferredType(args, outputType);\n\n    const input = expressionToGlsl(context, args[0]);\n    const fallback = expressionToGlsl(\n      context,\n      args[args.length - 1],\n      outputType\n    );\n    let result = null;\n    for (let i = args.length - 3; i >= 1; i -= 2) {\n      const match = expressionToGlsl(context, args[i]);\n      const output = expressionToGlsl(context, args[i + 1], outputType);\n      result = `(${input} == ${match} ? ${output} : ${result || fallback})`;\n    }\n    return result;\n  },\n};\nOperators['case'] = {\n  getReturnType: function (args) {\n    let type = ValueTypes.ANY;\n    for (let i = 1; i < args.length; i += 2) {\n      type = type & getValueType(args[i]);\n    }\n    type = type & getValueType(args[args.length - 1]);\n    return type;\n  },\n  toGlsl: function (context, args, opt_typeHint) {\n    assertArgsOdd(args);\n    assertArgsMinCount(args, 3);\n\n    const typeHint = opt_typeHint !== undefined ? opt_typeHint : ValueTypes.ANY;\n    const outputType = Operators['case'].getReturnType(args) & typeHint;\n    assertUniqueInferredType(args, outputType);\n    for (let i = 0; i < args.length - 1; i += 2) {\n      assertBoolean(args[i]);\n    }\n\n    const fallback = expressionToGlsl(\n      context,\n      args[args.length - 1],\n      outputType\n    );\n    let result = null;\n    for (let i = args.length - 3; i >= 0; i -= 2) {\n      const condition = expressionToGlsl(context, args[i]);\n      const output = expressionToGlsl(context, args[i + 1], outputType);\n      result = `(${condition} ? ${output} : ${result || fallback})`;\n    }\n    return result;\n  },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
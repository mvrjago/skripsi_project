{"ast":null,"code":"/*\nol-mapbox-style - Use Mapbox Style objects with OpenLayers\nCopyright 2016-present ol-mapbox-style contributors\nLicense: https://raw.githubusercontent.com/openlayers/ol-mapbox-style/master/LICENSE\n*/\nimport mb2css from 'mapbox-to-css-font';\nimport applyStyleFunction, { getValue } from './stylefunction';\nimport googleFonts from 'webfont-matcher/lib/fonts/google';\nimport { fromLonLat } from 'ol/proj';\nimport { createXYZ } from 'ol/tilegrid';\nimport TileGrid from 'ol/tilegrid/TileGrid';\nimport Map from 'ol/Map';\nimport View from 'ol/View';\nimport GeoJSON from 'ol/format/GeoJSON';\nimport MVT from 'ol/format/MVT';\nimport { unByKey } from 'ol/Observable';\nimport TileLayer from 'ol/layer/Tile';\nimport VectorLayer from 'ol/layer/Vector';\nimport VectorTileLayer from 'ol/layer/VectorTile';\nimport TileJSON from 'ol/source/TileJSON';\nimport VectorSource from 'ol/source/Vector';\nimport VectorTileSource from 'ol/source/VectorTile';\nimport { Color } from '@mapbox/mapbox-gl-style-spec';\nimport { assign, defaultResolutions } from './util';\n/**\n * @typedef {import(\"ol/Map\").default} PluggableMap\n * @typedef {import(\"ol/layer/Layer\").default} Layer\n * @typedef {import(\"ol/source/Source\").default} Source\n * @private\n */\nvar tilejsonCache = {};\nvar fontFamilyRegEx = /font-family: ?([^;]*);/;\nvar stripQuotesRegEx = /(\"|')/g;\nvar loadedFontFamilies;\nfunction hasFontFamily(family) {\n  if (!loadedFontFamilies) {\n    loadedFontFamilies = {};\n    var styleSheets = document.styleSheets;\n    for (var i = 0, ii = styleSheets.length; i < ii; ++i) {\n      var styleSheet = /** @type {CSSStyleSheet} */styleSheets[i];\n      try {\n        var cssRules = styleSheet.rules || styleSheet.cssRules;\n        if (cssRules) {\n          for (var j = 0, jj = cssRules.length; j < jj; ++j) {\n            var cssRule = cssRules[j];\n            if (cssRule.type == 5) {\n              var match = cssRule.cssText.match(fontFamilyRegEx);\n              loadedFontFamilies[match[1].replace(stripQuotesRegEx, '')] = true;\n            }\n          }\n        }\n      } catch (e) {\n        // empty catch block\n      }\n    }\n  }\n  return family in loadedFontFamilies;\n}\nvar processedFontFamilies = {};\nvar googleFamilies = googleFonts.getNames();\n/**\n * @private\n * @param {Array} fonts Fonts.\n * @return {Array} Processed fonts.\n */\nfunction getFonts(fonts) {\n  var fontsKey = fonts.toString();\n  if (fontsKey in processedFontFamilies) {\n    return fonts;\n  }\n  var googleFontDescriptions = fonts.map(function (font) {\n    var parts = mb2css(font, 1).split(' ');\n    return [parts.slice(3).join(' ').replace(/\"/g, ''), parts[1] + parts[0]];\n  });\n  for (var i = 0, ii = googleFontDescriptions.length; i < ii; ++i) {\n    var googleFontDescription = googleFontDescriptions[i];\n    var family = googleFontDescription[0];\n    if (!hasFontFamily(family) && googleFamilies.indexOf(family) !== -1) {\n      var fontUrl = 'https://fonts.googleapis.com/css?family=' + family.replace(/ /g, '+') + ':' + googleFontDescription[1];\n      if (!document.querySelector('link[href=\"' + fontUrl + '\"]')) {\n        var markup = document.createElement('link');\n        markup.href = fontUrl;\n        markup.rel = 'stylesheet';\n        document.head.appendChild(markup);\n      }\n    }\n  }\n  processedFontFamilies[fontsKey] = true;\n  return fonts;\n}\nvar spriteRegEx = /^(.*)(\\?.*)$/;\nfunction withPath(url, path) {\n  if (path && url.indexOf('.') === 0) {\n    url = path + url;\n  }\n  return url;\n}\nfunction toSpriteUrl(url, path, extension) {\n  url = withPath(url, path);\n  var parts = url.match(spriteRegEx);\n  return parts ? parts[1] + extension + (parts.length > 2 ? parts[2] : '') : url + extension;\n}\n/**\n * ```js\n * import {applyStyle} from 'ol-mapbox-style';\n * ```\n *\n * Applies a style function to an `ol.layer.VectorTile` or `ol.layer.Vector`\n * with an `ol.source.VectorTile` or an `ol.source.Vector`. The style function\n * will render all layers from the `glStyle` object that use the specified\n * `source`, or a subset of layers from the same source. The source needs to be\n * a `\"type\": \"vector\"` or `\"type\": \"geojson\"` source.\n *\n * Two additional properties will be set on the provided layer:\n *\n *  * `mapbox-source`: The `id` of the Mapbox Style document's source that the\n *    OpenLayers layer was created from. Usually `apply()` creates one\n *    OpenLayers layer per Mapbox Style source, unless the layer stack has\n *    layers from different sources in between.\n *  * `mapbox-layers`: The `id`s of the Mapbox Style document's layers that are\n *    included in the OpenLayers layer.\n *\n * @param {VectorTileLayer|VectorLayer} layer OpenLayers layer.\n * @param {string|Object} glStyle Mapbox Style object.\n * @param {string|Array<string>} source `source` key or an array of layer `id`s from the\n * Mapbox Style object. When a `source` key is provided, all layers for the\n * specified source will be included in the style function. When layer `id`s\n * are provided, they must be from layers that use the same source.\n * @param {string} [path=undefined] Path of the style file. Only required when\n * a relative path is used with the `\"sprite\"` property of the style.\n * @param {Array<number>} [resolutions=undefined] Resolutions for mapping resolution to zoom level.\n * @return {Promise} Promise which will be resolved when the style can be used\n * for rendering.\n */\nexport function applyStyle(layer, glStyle, source, path, resolutions) {\n  return new Promise(function (resolve, reject) {\n    // TODO: figure out where best place to check source type is\n    // Note that the source arg is an array of gl layer ids and each must be\n    // dereferenced to get source type to validate\n    if (typeof glStyle != 'object') {\n      glStyle = JSON.parse(glStyle);\n    }\n    if (glStyle.version != 8) {\n      return reject(new Error('glStyle version 8 required.'));\n    }\n    if (!(layer instanceof VectorLayer || layer instanceof VectorTileLayer)) {\n      return reject(new Error('Can only apply to VectorLayer or VectorTileLayer'));\n    }\n    var spriteScale, spriteData, spriteImageUrl, style;\n    function onChange() {\n      if (!style && (!glStyle.sprite || spriteData)) {\n        style = applyStyleFunction(layer, glStyle, source, resolutions, spriteData, spriteImageUrl, getFonts);\n        if (!layer.getStyle()) {\n          reject(new Error(\"Nothing to show for source [\" + source + \"]\"));\n        } else {\n          resolve();\n        }\n      } else if (style) {\n        layer.setStyle(style);\n        resolve();\n      } else {\n        reject(new Error('Something went wrong trying to apply style.'));\n      }\n    }\n    if (glStyle.sprite) {\n      spriteScale = window.devicePixelRatio >= 1.5 ? 0.5 : 1;\n      var sizeFactor_1 = spriteScale == 0.5 ? '@2x' : '';\n      var spriteUrl_1 = toSpriteUrl(glStyle.sprite, path, sizeFactor_1 + '.json');\n      fetch(spriteUrl_1, {\n        credentials: 'same-origin'\n      }).then(function (response) {\n        if (!response.ok && sizeFactor_1 !== '') {\n          spriteUrl_1 = toSpriteUrl(glStyle.sprite, path, '.json');\n          return fetch(spriteUrl_1, {\n            credentials: 'same-origin'\n          });\n        } else {\n          return response;\n        }\n      }).then(function (response) {\n        if (response.ok) {\n          return response.json();\n        } else {\n          reject(new Error(\"Problem fetching sprite from \" + spriteUrl_1 + \": \" + response.statusText));\n        }\n      }).then(function (spritesJson) {\n        if (spritesJson === undefined || Object.keys(spritesJson).length === 0) {\n          return reject(new Error('No sprites found.'));\n        }\n        spriteData = spritesJson;\n        spriteImageUrl = toSpriteUrl(glStyle.sprite, path, sizeFactor_1 + '.png');\n        onChange();\n      }).catch(function (err) {\n        reject(new Error(\"Sprites cannot be loaded: \" + spriteUrl_1 + \": \" + err.message));\n      });\n    } else {\n      onChange();\n    }\n  });\n}\nvar emptyObj = {};\nfunction setBackground(map, layer) {\n  var background = {\n    type: layer.type\n  };\n  function updateStyle() {\n    var element = map.getTargetElement();\n    if (!element) {\n      return;\n    }\n    var layout = layer.layout || {};\n    var paint = layer.paint || {};\n    background['paint'] = paint;\n    background.id = 'olms-bg-' + paint['background-opacity'] + paint['background-color'];\n    var zoom = map.getView().getZoom();\n    if (paint['background-color'] !== undefined) {\n      var bg = getValue(background, 'paint', 'background-color', zoom, emptyObj);\n      element.style.background = Color.parse(bg).toString();\n    }\n    if (paint['background-opacity'] !== undefined) {\n      element.style.opacity = getValue(background, 'paint', 'background-opacity', zoom, emptyObj);\n    }\n    if (layout.visibility == 'none') {\n      element.style.backgroundColor = '';\n      element.style.opacity = '';\n    }\n  }\n  if (map.getTargetElement()) {\n    updateStyle();\n  }\n  map.on(['change:resolution', 'change:target'], updateStyle);\n}\n/**\n * ```js\n * import {applyBackground} from 'ol-mapbox-style';\n * ```\n * Applies properties of the Mapbox Style's first `background` layer to the map.\n * @param {PluggableMap} map OpenLayers Map.\n * @param {Object} glStyle Mapbox Style object.\n */\nexport function applyBackground(map, glStyle) {\n  glStyle.layers.some(function (l) {\n    if (l.type == 'background') {\n      setBackground(map, l);\n      return true;\n    }\n  });\n}\nfunction getSourceIdByRef(layers, ref) {\n  var sourceId;\n  layers.some(function (layer) {\n    if (layer.id == ref) {\n      sourceId = layer.source;\n      return true;\n    }\n  });\n  return sourceId;\n}\nfunction extentFromTileJSON(tileJSON) {\n  var bounds = tileJSON.bounds;\n  if (bounds) {\n    var ll = fromLonLat([bounds[0], bounds[1]]);\n    var tr = fromLonLat([bounds[2], bounds[3]]);\n    return [ll[0], ll[1], tr[0], tr[1]];\n  }\n}\nfunction setupVectorLayer(glSource, accessToken, url) {\n  glSource = assign({}, glSource);\n  var layer = new VectorTileLayer({\n    declutter: true,\n    visible: false\n  });\n  var cacheKey = JSON.stringify(glSource);\n  var tilejson = tilejsonCache[cacheKey];\n  if (!tilejson) {\n    tilejson = tilejsonCache[cacheKey] = new TileJSON({\n      url: glSource.tiles ? undefined : url,\n      tileJSON: glSource.tiles ? glSource : undefined\n    });\n  }\n  var key = tilejson.on('change', function () {\n    var state = tilejson.getState();\n    if (state === 'ready') {\n      var tileJSONDoc = tilejson.getTileJSON();\n      var tiles = Array.isArray(tileJSONDoc.tiles) ? tileJSONDoc.tiles : [tileJSONDoc.tiles];\n      if (glSource.url) {\n        for (var i = 0, ii = tiles.length; i < ii; ++i) {\n          var tile = tiles[i];\n          if (tile.indexOf('http') != 0) {\n            tiles[i] = glSource.url + tile;\n          }\n        }\n      }\n      var tileGrid = tilejson.getTileGrid();\n      var extent = extentFromTileJSON(tileJSONDoc);\n      var minZoom = tileJSONDoc.minzoom || 0;\n      var maxZoom = tileJSONDoc.maxzoom || 22;\n      var source = tilejson.get('ol-source');\n      if (source === undefined) {\n        source = new VectorTileSource({\n          attributions: tilejson.getAttributions(),\n          format: new MVT(),\n          tileGrid: new TileGrid({\n            origin: tileGrid.getOrigin(0),\n            extent: extent || tileGrid.getExtent(),\n            minZoom: minZoom,\n            resolutions: defaultResolutions.slice(0, maxZoom + 1),\n            tileSize: 512\n          }),\n          urls: tiles\n        });\n        tilejson.set('ol-source', source);\n      }\n      unByKey(key);\n      layer.setSource(source);\n    } else if (state === 'error') {\n      tilejson.set('ol-source', null);\n      unByKey(key);\n      layer.setSource(undefined);\n    }\n  });\n  if (tilejson.getState() === 'ready') {\n    tilejson.changed();\n  }\n  return layer;\n}\nfunction setupRasterLayer(glSource, url) {\n  var layer = new TileLayer();\n  var source = new TileJSON({\n    transition: 0,\n    url: glSource.tiles ? undefined : url,\n    tileJSON: glSource.tiles ? glSource : undefined,\n    crossOrigin: 'anonymous'\n  });\n  var key = source.on('change', function () {\n    var state = source.getState();\n    if (state === 'ready') {\n      unByKey(key);\n      var tileJSONDoc = /** @type {Object} */source.getTileJSON();\n      var extent = extentFromTileJSON(tileJSONDoc);\n      var tileGrid = source.getTileGrid();\n      var tileSize = glSource.tileSize || tileJSONDoc.tileSize || 512;\n      var minZoom = tileJSONDoc.minzoom || 0;\n      var maxZoom = tileJSONDoc.maxzoom || 22;\n      // Only works when using ES modules\n      source.tileGrid = new TileGrid({\n        origin: tileGrid.getOrigin(0),\n        extent: extent || tileGrid.getExtent(),\n        minZoom: minZoom,\n        resolutions: createXYZ({\n          maxZoom: maxZoom,\n          tileSize: tileSize\n        }).getResolutions(),\n        tileSize: tileSize\n      });\n      layer.setSource(source);\n    } else if (state === 'error') {\n      unByKey(key);\n      layer.setSource(undefined);\n    }\n  });\n  source.setTileLoadFunction(function (tile, src) {\n    if (src.indexOf('{bbox-epsg-3857}') != -1) {\n      var bbox = source.getTileGrid().getTileCoordExtent(tile.getTileCoord());\n      src = src.replace('{bbox-epsg-3857}', bbox.toString());\n    }\n    var img = /** @type {import(\"ol/ImageTile\").default} */tile.getImage();\n    /** @type {HTMLImageElement} */\n    img.src = src;\n  });\n  return layer;\n}\nvar geoJsonFormat = new GeoJSON();\nfunction setupGeoJSONLayer(glSource, path) {\n  var data = glSource.data;\n  var features, geoJsonUrl;\n  if (typeof data == 'string') {\n    geoJsonUrl = withPath(data, path);\n  } else {\n    features = geoJsonFormat.readFeatures(data, {\n      featureProjection: 'EPSG:3857'\n    });\n  }\n  return new VectorLayer({\n    source: new VectorSource({\n      attributions: glSource.attribution,\n      features: features,\n      format: geoJsonFormat,\n      url: geoJsonUrl\n    }),\n    visible: false\n  });\n}\nfunction updateRasterLayerProperties(glLayer, layer, view) {\n  var zoom = view.getZoom();\n  var opacity = getValue(glLayer, 'paint', 'raster-opacity', zoom, emptyObj);\n  layer.setOpacity(opacity);\n}\nfunction processStyle(glStyle, map, baseUrl, host, path, accessToken) {\n  var promises = [];\n  var view = map.getView();\n  if (!view.isDef() && !view.getRotation() && !view.getResolutions()) {\n    view = new View({\n      maxResolution: defaultResolutions[0]\n    });\n    map.setView(view);\n  }\n  if ('center' in glStyle && !view.getCenter()) {\n    view.setCenter(fromLonLat(glStyle.center));\n  }\n  if ('zoom' in glStyle && view.getZoom() === undefined) {\n    view.setResolution(defaultResolutions[0] / Math.pow(2, glStyle.zoom));\n  }\n  if (!view.getCenter() || view.getZoom() === undefined) {\n    view.fit(view.getProjection().getExtent(), {\n      nearest: true,\n      size: map.getSize()\n    });\n  }\n  if (glStyle.sprite) {\n    if (glStyle.sprite.indexOf('mapbox://') == 0) {\n      glStyle.sprite = baseUrl + '/sprite' + accessToken;\n    } else if (glStyle.sprite.indexOf('http') != 0) {\n      glStyle.sprite = (host ? host + path : '') + glStyle.sprite + accessToken;\n    }\n  }\n  var glLayers = glStyle.layers;\n  var layerIds = [];\n  var glLayer, glSource, glSourceId, id, layer, url;\n  var _loop_1 = function _loop_1(i, ii) {\n    glLayer = glLayers[i];\n    var type = glLayer.type;\n    if (type == 'heatmap' || type == 'fill-extrusion' || type == 'hillshade') {\n      //FIXME Unsupported layer type\n    } else if (type == 'background') {\n      setBackground(map, glLayer);\n    } else {\n      id = glLayer.source || getSourceIdByRef(glLayers, glLayer.ref);\n      // this technique assumes gl layers will be in a particular order\n      if (id != glSourceId) {\n        if (layerIds.length) {\n          promises.push(finalizeLayer(layer, layerIds, glStyle, path, map));\n          layerIds = [];\n        }\n        glSource = glStyle.sources[id];\n        url = glSource.url;\n        if (url) {\n          url = withPath(url, path);\n          if (url.indexOf('mapbox://') == 0) {\n            var mapid_1 = url.replace('mapbox://', '');\n            glSource.tiles = ['a', 'b', 'c', 'd'].map(function (host) {\n              return 'https://' + host + '.tiles.mapbox.com/v4/' + mapid_1 + '/{z}/{x}/{y}.' + (glSource.type == 'vector' ? 'vector.pbf' : 'png') + accessToken;\n            });\n          }\n        }\n        if (glSource.type == 'vector') {\n          layer = setupVectorLayer(glSource, accessToken, url);\n        } else if (glSource.type == 'raster') {\n          layer = setupRasterLayer(glSource, url);\n          layer.setVisible(glLayer.layout ? glLayer.layout.visibility !== 'none' : true);\n          view.on('change:resolution', updateRasterLayerProperties.bind(this_1, glLayer, layer, view));\n          updateRasterLayerProperties(glLayer, layer, view);\n        } else if (glSource.type == 'geojson') {\n          layer = setupGeoJSONLayer(glSource, path);\n        }\n        glSourceId = id;\n        if (layer) {\n          layer.set('mapbox-source', glSourceId);\n        }\n      }\n      layerIds.push(glLayer.id);\n    }\n  };\n  var this_1 = this;\n  for (var i = 0, ii = glLayers.length; i < ii; ++i) {\n    _loop_1(i, ii);\n  }\n  promises.push(finalizeLayer(layer, layerIds, glStyle, path, map));\n  map.set('mapbox-style', glStyle);\n  return Promise.all(promises);\n}\n/**\n * ```js\n * import olms from 'ol-mapbox-style';\n * ```\n *\n * Loads and applies a Mapbox Style object to an OpenLayers Map. This includes\n * the map background, the layers, the center and the zoom.\n *\n * The center and zoom will only be set if present in the Mapbox Style document,\n * and if not already set on the OpenLayers map.\n *\n * Layers will be added to the OpenLayers map, without affecting any layers that\n * might already be set on the map.\n *\n * Layers added by `apply()` will have two additional properties:\n *\n *  * `mapbox-source`: The `id` of the Mapbox Style document's source that the\n *    OpenLayers layer was created from. Usually `apply()` creates one\n *    OpenLayers layer per Mapbox Style source, unless the layer stack has\n *    layers from different sources in between.\n *  * `mapbox-layers`: The `id`s of the Mapbox Style document's layers that are\n *    included in the OpenLayers layer.\n *\n * This function sets an additional `mapbox-style` property on the OpenLayers\n * map instance, which holds the Mapbox Style object.\n *\n * @param {PluggableMap|HTMLElement|string} map Either an existing OpenLayers Map\n * instance, or a HTML element, or the id of a HTML element that will be the\n * target of a new OpenLayers Map.\n * @param {string|Object} style JSON style object or style url pointing to a\n * Mapbox Style object. When using Mapbox APIs, the url must contain an access\n * token and look like\n * `https://api.mapbox.com/styles/v1/mapbox/bright-v9?access_token=[your_access_token_here]`.\n * When passed as JSON style object, all OpenLayers layers created by `apply()`\n * will be immediately available, but they may not have a source yet (i.e. when\n * they are defined by a TileJSON url in the Mapbox Style document). When passed\n * as style url, layers will be added to the map when the Mapbox Style document\n * is loaded and parsed.\n * @return {Promise} A promise that resolves after all layers have been added to\n * the OpenLayers Map instance, their sources set, and their styles applied. the\n * `resolve` callback will be called with the OpenLayers Map instance as\n * argument.\n */\nexport default function olms(map, style) {\n  var accessToken, baseUrl, host, path, promise;\n  accessToken = baseUrl = host = path = '';\n  if (typeof map === 'string' || map instanceof HTMLElement) {\n    map = new Map({\n      target: map\n    });\n  }\n  if (typeof style === 'string') {\n    var parts = style.match(spriteRegEx);\n    if (parts) {\n      baseUrl = parts[1];\n      accessToken = parts.length > 2 ? parts[2] : '';\n    }\n    promise = new Promise(function (resolve, reject) {\n      fetch(style, {\n        credentials: 'same-origin'\n      }).then(function (response) {\n        return response.json();\n      }).then(function (glStyle) {\n        var a = /** @type {HTMLAnchorElement} */document.createElement('A');\n        a.href = style;\n        var href = a.href;\n        path = a.pathname.split('/').slice(0, -1).join('/') + '/';\n        host = href.substr(0, href.indexOf(path));\n        processStyle(glStyle, map, baseUrl, host, path, accessToken).then(function () {\n          resolve(map);\n        }).catch(reject);\n      }).catch(function (err) {\n        reject(new Error(\"Could not load \" + style + \": \" + err.message));\n      });\n    });\n  } else {\n    promise = new Promise(function (resolve, reject) {\n      processStyle(style, map).then(function () {\n        resolve(map);\n      }).catch(reject);\n    });\n  }\n  return promise;\n}\n/**\n * ```js\n * import {apply} from 'ol-mapbox-style';\n * ```\n * Like `olms`, but returns an `ol/Map` instance instead of a `Promise`.\n *\n * @param {PluggableMap|HTMLElement|string} map Either an existing OpenLayers Map\n * instance, or a HTML element, or the id of a HTML element that will be the\n * target of a new OpenLayers Map.\n * @param {string|Object} style JSON style object or style url pointing to a\n * Mapbox Style object. When using Mapbox APIs, the url must contain an access\n * token and look like\n * `https://api.mapbox.com/styles/v1/mapbox/bright-v9?access_token=[your_access_token_here]`.\n * When passed as JSON style object, all OpenLayers layers created by `apply()`\n * will be immediately available, but they may not have a source yet (i.e. when\n * they are defined by a TileJSON url in the Mapbox Style document). When passed\n * as style url, layers will be added to the map when the Mapbox Style document\n * is loaded and parsed.\n * @return {PluggableMap} The OpenLayers Map instance that will be populated with the\n * contents described in the Mapbox Style object.\n */\nexport function apply(map, style) {\n  if (typeof map === 'string' || map instanceof HTMLElement) {\n    map = new Map({\n      target: map\n    });\n  }\n  setTimeout(function () {\n    olms(map, style);\n  }, 0);\n  return map;\n}\n/**\n * @private\n * If layerIds is not empty, applies the style specified in glStyle to the layer,\n * and adds the layer to the map.\n *\n * The layer may not yet have a source when the function is called.  If so, the style\n * is applied to the layer via a once listener on the 'change:source' event.\n *\n * @param {Layer} layer An OpenLayers layer instance.\n * @param {Array<string>} layerIds Array containing layer ids of already-processed layers.\n * @param {Object} glStyle Style as a JSON object.\n * @param {string|undefined} path The path part of the style URL. Only required\n * when a relative path is used with the `\"sprite\"` property of the style.\n * @param {PluggableMap} map OpenLayers Map.\n * @return {Promise} Returns a promise that resolves after the source has\n * been set on the specified layer, and the style has been applied.\n */\nfunction finalizeLayer(layer, layerIds, glStyle, path, map) {\n  var minZoom = 24;\n  var maxZoom = 0;\n  var glLayers = glStyle.layers;\n  for (var i = 0, ii = glLayers.length; i < ii; ++i) {\n    var glLayer = glLayers[i];\n    if (layerIds.indexOf(glLayer.id) !== -1) {\n      minZoom = Math.min('minzoom' in glLayer ? glLayer.minzoom : 0, minZoom);\n      maxZoom = Math.max('maxzoom' in glLayer ? glLayer.maxzoom : 24, maxZoom);\n    }\n  }\n  return new Promise(function (resolve, reject) {\n    var setStyle = function setStyle() {\n      var source = layer.getSource();\n      if (!source || source.getState() === 'error') {\n        reject(new Error('Error accessing data for source ' + layer.get('mapbox-source')));\n        return;\n      }\n      if (typeof source.getTileGrid === 'function') {\n        var tileGrid = source.getTileGrid();\n        if (tileGrid) {\n          var sourceMinZoom = tileGrid.getMinZoom();\n          if (minZoom > 0 || sourceMinZoom > 0) {\n            layer.setMaxResolution(Math.min(defaultResolutions[minZoom], tileGrid.getResolution(sourceMinZoom)) + 1e-9);\n          }\n          if (maxZoom < 24) {\n            layer.setMinResolution(defaultResolutions[maxZoom] + 1e-9);\n          }\n        }\n      }\n      if (source instanceof VectorSource || source instanceof VectorTileSource) {\n        applyStyle( /** @type {import(\"ol/layer/Vector\").default|import(\"ol/layer/VectorTile\").default} */layer, glStyle, layerIds, path).then(function () {\n          layer.setVisible(true);\n          resolve();\n        }, function (e) {\n          reject(e);\n        });\n      } else {\n        resolve();\n      }\n    };\n    layer.set('mapbox-layers', layerIds);\n    if (map.getLayers().getArray().indexOf(layer) === -1) {\n      map.addLayer(layer);\n    }\n    if (layer.getSource()) {\n      setStyle();\n    } else {\n      layer.once('change:source', setStyle);\n    }\n  });\n}\n/**\n * ```js\n * import {getLayer} from 'ol-mapbox-style';\n * ```\n * Get the OpenLayers layer instance that contains the provided Mapbox Style\n * `layer`. Note that multiple Mapbox Style layers are combined in a single\n * OpenLayers layer instance when they use the same Mapbox Style `source`.\n * @param {PluggableMap} map OpenLayers Map.\n * @param {string} layerId Mapbox Style layer id.\n * @return {Layer} OpenLayers layer instance.\n */\nexport function getLayer(map, layerId) {\n  var layers = map.getLayers().getArray();\n  for (var i = 0, ii = layers.length; i < ii; ++i) {\n    var mapboxLayers = layers[i].get('mapbox-layers');\n    if (mapboxLayers && mapboxLayers.indexOf(layerId) !== -1) {\n      return (/** @type {Layer} */layers[i]\n      );\n    }\n  }\n}\n/**\n * ```js\n * import {getLayers} from 'ol-mapbox-style';\n * ```\n * Get the OpenLayers layer instances for the provided Mapbox Style `source`.\n * @param {PluggableMap} map OpenLayers Map.\n * @param {string} sourceId Mapbox Style source id.\n * @return {Array<Layer>} OpenLayers layer instances.\n */\nexport function getLayers(map, sourceId) {\n  var result = [];\n  var layers = map.getLayers().getArray();\n  for (var i = 0, ii = layers.length; i < ii; ++i) {\n    if (layers[i].get('mapbox-source') === sourceId) {\n      result.push( /** @type {Layer} */layers[i]);\n    }\n  }\n  return result;\n}\n/**\n * ```js\n * import {getSource} from 'ol-mapbox-style';\n * ```\n * Get the OpenLayers source instance for the provided Mapbox Style `source`.\n * @param {PluggableMap} map OpenLayers Map.\n * @param {string} sourceId Mapbox Style source id.\n * @return {Source} OpenLayers source instance.\n */\nexport function getSource(map, sourceId) {\n  var layers = map.getLayers().getArray();\n  for (var i = 0, ii = layers.length; i < ii; ++i) {\n    var source = /** @type {Layer} */layers[i].getSource();\n    if (layers[i].get('mapbox-source') === sourceId) {\n      return source;\n    }\n  }\n}\nexport { finalizeLayer as _finalizeLayer, getFonts as _getFonts };","map":{"version":3,"names":["mb2css","applyStyleFunction","getValue","googleFonts","fromLonLat","createXYZ","TileGrid","Map","View","GeoJSON","MVT","unByKey","TileLayer","VectorLayer","VectorTileLayer","TileJSON","VectorSource","VectorTileSource","Color","assign","defaultResolutions","tilejsonCache","fontFamilyRegEx","stripQuotesRegEx","loadedFontFamilies","hasFontFamily","family","styleSheets","document","i","ii","length","styleSheet","cssRules","rules","j","jj","cssRule","type","match","cssText","replace","e","processedFontFamilies","googleFamilies","getNames","getFonts","fonts","fontsKey","toString","googleFontDescriptions","map","font","parts","split","slice","join","googleFontDescription","indexOf","fontUrl","querySelector","markup","createElement","href","rel","head","appendChild","spriteRegEx","withPath","url","path","toSpriteUrl","extension","applyStyle","layer","glStyle","source","resolutions","Promise","resolve","reject","JSON","parse","version","Error","spriteScale","spriteData","spriteImageUrl","style","onChange","sprite","getStyle","setStyle","window","devicePixelRatio","sizeFactor_1","spriteUrl_1","fetch","credentials","then","response","ok","json","statusText","spritesJson","undefined","Object","keys","catch","err","message","emptyObj","setBackground","background","updateStyle","element","getTargetElement","layout","paint","id","zoom","getView","getZoom","bg","opacity","visibility","backgroundColor","on","applyBackground","layers","some","l","getSourceIdByRef","ref","sourceId","extentFromTileJSON","tileJSON","bounds","ll","tr","setupVectorLayer","glSource","accessToken","declutter","visible","cacheKey","stringify","tilejson","tiles","key","state","getState","tileJSONDoc","getTileJSON","Array","isArray","tile","tileGrid","getTileGrid","extent","minZoom","minzoom","maxZoom","maxzoom","get","attributions","getAttributions","format","origin","getOrigin","getExtent","tileSize","urls","set","setSource","changed","setupRasterLayer","transition","crossOrigin","getResolutions","setTileLoadFunction","src","bbox","getTileCoordExtent","getTileCoord","img","getImage","geoJsonFormat","setupGeoJSONLayer","data","features","geoJsonUrl","readFeatures","featureProjection","attribution","updateRasterLayerProperties","glLayer","view","setOpacity","processStyle","baseUrl","host","promises","isDef","getRotation","maxResolution","setView","getCenter","setCenter","center","setResolution","Math","pow","fit","getProjection","nearest","size","getSize","glLayers","layerIds","glSourceId","push","finalizeLayer","sources","mapid_1","setVisible","bind","this_1","all","olms","promise","HTMLElement","target","a","pathname","substr","apply","setTimeout","min","max","getSource","sourceMinZoom","getMinZoom","setMaxResolution","getResolution","setMinResolution","getLayers","getArray","addLayer","once","getLayer","layerId","mapboxLayers","result","_finalizeLayer","_getFonts"],"sources":["/Users/mariovicky/Skripsi_OpenLayers/node_modules/ol-mapbox-style/src/index.js"],"sourcesContent":["/*\nol-mapbox-style - Use Mapbox Style objects with OpenLayers\nCopyright 2016-present ol-mapbox-style contributors\nLicense: https://raw.githubusercontent.com/openlayers/ol-mapbox-style/master/LICENSE\n*/\n\nimport mb2css from 'mapbox-to-css-font';\nimport applyStyleFunction, {getValue} from './stylefunction';\nimport googleFonts from 'webfont-matcher/lib/fonts/google';\nimport {fromLonLat} from 'ol/proj';\nimport {createXYZ} from 'ol/tilegrid';\nimport TileGrid from 'ol/tilegrid/TileGrid';\nimport Map from 'ol/Map';\nimport View from 'ol/View';\nimport GeoJSON from 'ol/format/GeoJSON';\nimport MVT from 'ol/format/MVT';\nimport {unByKey} from 'ol/Observable';\nimport TileLayer from 'ol/layer/Tile';\nimport VectorLayer from 'ol/layer/Vector';\nimport VectorTileLayer from 'ol/layer/VectorTile';\nimport TileJSON from 'ol/source/TileJSON';\nimport VectorSource from 'ol/source/Vector';\nimport VectorTileSource from 'ol/source/VectorTile';\nimport {Color} from '@mapbox/mapbox-gl-style-spec';\nimport {assign, defaultResolutions} from './util';\n\n/**\n * @typedef {import(\"ol/Map\").default} PluggableMap\n * @typedef {import(\"ol/layer/Layer\").default} Layer\n * @typedef {import(\"ol/source/Source\").default} Source\n * @private\n */\n\nconst tilejsonCache = {};\n\nconst fontFamilyRegEx = /font-family: ?([^;]*);/;\nconst stripQuotesRegEx = /(\"|')/g;\nlet loadedFontFamilies;\nfunction hasFontFamily(family) {\n  if (!loadedFontFamilies) {\n    loadedFontFamilies = {};\n    const styleSheets = document.styleSheets;\n    for (let i = 0, ii = styleSheets.length; i < ii; ++i) {\n      const styleSheet = /** @type {CSSStyleSheet} */ (styleSheets[i]);\n      try {\n        const cssRules = styleSheet.rules || styleSheet.cssRules;\n        if (cssRules) {\n          for (let j = 0, jj = cssRules.length; j < jj; ++j) {\n            const cssRule = cssRules[j];\n            if (cssRule.type == 5) {\n              const match = cssRule.cssText.match(fontFamilyRegEx);\n              loadedFontFamilies[match[1].replace(stripQuotesRegEx, '')] = true;\n            }\n          }\n        }\n      } catch (e) {\n        // empty catch block\n      }\n    }\n  }\n  return family in loadedFontFamilies;\n}\n\nconst processedFontFamilies = {};\nconst googleFamilies = googleFonts.getNames();\n\n/**\n * @private\n * @param {Array} fonts Fonts.\n * @return {Array} Processed fonts.\n */\nfunction getFonts(fonts) {\n  const fontsKey = fonts.toString();\n  if (fontsKey in processedFontFamilies) {\n    return fonts;\n  }\n  const googleFontDescriptions = fonts.map(function(font) {\n    const parts = mb2css(font, 1).split(' ');\n    return [parts.slice(3).join(' ').replace(/\"/g, ''), parts[1] + parts[0]];\n  });\n  for (let i = 0, ii = googleFontDescriptions.length; i < ii; ++i) {\n    const googleFontDescription = googleFontDescriptions[i];\n    const family = googleFontDescription[0];\n    if (!hasFontFamily(family) && googleFamilies.indexOf(family) !== -1) {\n      const fontUrl = 'https://fonts.googleapis.com/css?family=' + family.replace(/ /g, '+') + ':' + googleFontDescription[1];\n      if (!document.querySelector('link[href=\"' + fontUrl + '\"]')) {\n        const markup = document.createElement('link');\n        markup.href = fontUrl;\n        markup.rel = 'stylesheet';\n        document.head.appendChild(markup);\n      }\n    }\n  }\n  processedFontFamilies[fontsKey] = true;\n  return fonts;\n}\n\nconst spriteRegEx = /^(.*)(\\?.*)$/;\n\nfunction withPath(url, path) {\n  if (path && url.indexOf('.') === 0) {\n    url = path + url;\n  }\n  return url;\n}\n\nfunction toSpriteUrl(url, path, extension) {\n  url = withPath(url, path);\n  const parts = url.match(spriteRegEx);\n  return parts ?\n    parts[1] + extension + (parts.length > 2 ? parts[2] : '') :\n    url + extension;\n}\n\n/**\n * ```js\n * import {applyStyle} from 'ol-mapbox-style';\n * ```\n *\n * Applies a style function to an `ol.layer.VectorTile` or `ol.layer.Vector`\n * with an `ol.source.VectorTile` or an `ol.source.Vector`. The style function\n * will render all layers from the `glStyle` object that use the specified\n * `source`, or a subset of layers from the same source. The source needs to be\n * a `\"type\": \"vector\"` or `\"type\": \"geojson\"` source.\n *\n * Two additional properties will be set on the provided layer:\n *\n *  * `mapbox-source`: The `id` of the Mapbox Style document's source that the\n *    OpenLayers layer was created from. Usually `apply()` creates one\n *    OpenLayers layer per Mapbox Style source, unless the layer stack has\n *    layers from different sources in between.\n *  * `mapbox-layers`: The `id`s of the Mapbox Style document's layers that are\n *    included in the OpenLayers layer.\n *\n * @param {VectorTileLayer|VectorLayer} layer OpenLayers layer.\n * @param {string|Object} glStyle Mapbox Style object.\n * @param {string|Array<string>} source `source` key or an array of layer `id`s from the\n * Mapbox Style object. When a `source` key is provided, all layers for the\n * specified source will be included in the style function. When layer `id`s\n * are provided, they must be from layers that use the same source.\n * @param {string} [path=undefined] Path of the style file. Only required when\n * a relative path is used with the `\"sprite\"` property of the style.\n * @param {Array<number>} [resolutions=undefined] Resolutions for mapping resolution to zoom level.\n * @return {Promise} Promise which will be resolved when the style can be used\n * for rendering.\n */\nexport function applyStyle(layer, glStyle, source, path, resolutions) {\n  return new Promise(function(resolve, reject) {\n\n    // TODO: figure out where best place to check source type is\n    // Note that the source arg is an array of gl layer ids and each must be\n    // dereferenced to get source type to validate\n    if (typeof glStyle != 'object') {\n      glStyle = JSON.parse(glStyle);\n    }\n    if (glStyle.version != 8) {\n      return reject(new Error('glStyle version 8 required.'));\n    }\n    if (!(layer instanceof VectorLayer || layer instanceof VectorTileLayer)) {\n      return reject(new Error('Can only apply to VectorLayer or VectorTileLayer'));\n    }\n\n    let spriteScale, spriteData, spriteImageUrl, style;\n    function onChange() {\n      if (!style && (!glStyle.sprite || spriteData)) {\n        style = applyStyleFunction(layer, glStyle, source, resolutions, spriteData, spriteImageUrl, getFonts);\n        if (!layer.getStyle()) {\n          reject(new Error(`Nothing to show for source [${source}]`));\n        } else {\n          resolve();\n        }\n      } else if (style) {\n        layer.setStyle(style);\n        resolve();\n      } else {\n        reject(new Error('Something went wrong trying to apply style.'));\n      }\n    }\n\n    if (glStyle.sprite) {\n      spriteScale = window.devicePixelRatio >= 1.5 ? 0.5 : 1;\n      const sizeFactor = spriteScale == 0.5 ? '@2x' : '';\n      let spriteUrl = toSpriteUrl(glStyle.sprite, path, sizeFactor + '.json');\n\n      fetch(spriteUrl, {credentials: 'same-origin'})\n        .then(function(response) {\n          if (!response.ok && (sizeFactor !== '')) {\n            spriteUrl = toSpriteUrl(glStyle.sprite, path, '.json');\n            return fetch(spriteUrl, {credentials: 'same-origin'});\n          } else {\n            return response;\n          }\n        })\n        .then(function(response) {\n          if (response.ok) {\n            return response.json();\n          } else {\n            reject(new Error(`Problem fetching sprite from ${spriteUrl}: ${response.statusText}`));\n          }\n        })\n        .then(function(spritesJson) {\n          if ((spritesJson === undefined) || (Object.keys(spritesJson).length === 0)) {\n            return reject(new Error('No sprites found.'));\n          }\n          spriteData = spritesJson;\n          spriteImageUrl = toSpriteUrl(glStyle.sprite, path, sizeFactor + '.png');\n          onChange();\n        })\n        .catch(function(err) {\n          reject(new Error(`Sprites cannot be loaded: ${spriteUrl}: ${err.message}`));\n        });\n    } else {\n      onChange();\n    }\n\n  });\n}\n\nconst emptyObj = {};\n\nfunction setBackground(map, layer) {\n  const background = {\n    type: layer.type\n  };\n  function updateStyle() {\n    const element = map.getTargetElement();\n    if (!element) {\n      return;\n    }\n    const layout = layer.layout || {};\n    const paint = layer.paint || {};\n    background['paint'] = paint;\n    background.id = 'olms-bg-' + paint['background-opacity'] + paint['background-color'];\n    const zoom = map.getView().getZoom();\n    if (paint['background-color'] !== undefined) {\n      const bg = getValue(background, 'paint', 'background-color', zoom, emptyObj);\n      element.style.background = Color.parse(bg).toString();\n    }\n    if (paint['background-opacity'] !== undefined) {\n      element.style.opacity = getValue(background, 'paint', 'background-opacity', zoom, emptyObj);\n    }\n    if (layout.visibility == 'none') {\n      element.style.backgroundColor = '';\n      element.style.opacity = '';\n    }\n  }\n  if (map.getTargetElement()) {\n    updateStyle();\n  }\n  map.on(['change:resolution', 'change:target'], updateStyle);\n}\n\n/**\n * ```js\n * import {applyBackground} from 'ol-mapbox-style';\n * ```\n * Applies properties of the Mapbox Style's first `background` layer to the map.\n * @param {PluggableMap} map OpenLayers Map.\n * @param {Object} glStyle Mapbox Style object.\n */\nexport function applyBackground(map, glStyle) {\n  glStyle.layers.some(function(l) {\n    if (l.type == 'background') {\n      setBackground(map, l);\n      return true;\n    }\n  });\n}\n\nfunction getSourceIdByRef(layers, ref) {\n  let sourceId;\n  layers.some(function(layer) {\n    if (layer.id == ref) {\n      sourceId = layer.source;\n      return true;\n    }\n  });\n  return sourceId;\n}\n\nfunction extentFromTileJSON(tileJSON) {\n  const bounds = tileJSON.bounds;\n  if (bounds) {\n    const ll = fromLonLat([bounds[0], bounds[1]]);\n    const tr = fromLonLat([bounds[2], bounds[3]]);\n    return [ll[0], ll[1], tr[0], tr[1]];\n  }\n}\n\nfunction setupVectorLayer(glSource, accessToken, url) {\n  glSource = assign({}, glSource);\n  const layer = new VectorTileLayer({\n    declutter: true,\n    visible: false\n  });\n  const cacheKey = JSON.stringify(glSource);\n  let tilejson = tilejsonCache[cacheKey];\n  if (!tilejson) {\n    tilejson = tilejsonCache[cacheKey] = new TileJSON({\n      url: glSource.tiles ? undefined : url,\n      tileJSON: glSource.tiles ? glSource : undefined\n    });\n  }\n  const key = tilejson.on('change', function() {\n    const state = tilejson.getState();\n    if (state === 'ready') {\n      const tileJSONDoc = tilejson.getTileJSON();\n      const tiles = Array.isArray(tileJSONDoc.tiles) ? tileJSONDoc.tiles : [tileJSONDoc.tiles];\n      if (glSource.url) {\n        for (let i = 0, ii = tiles.length; i < ii; ++i) {\n          const tile = tiles[i];\n          if (tile.indexOf('http') != 0) {\n            tiles[i] = glSource.url + tile;\n          }\n        }\n      }\n      const tileGrid = tilejson.getTileGrid();\n      const extent = extentFromTileJSON(tileJSONDoc);\n      const minZoom = tileJSONDoc.minzoom || 0;\n      const maxZoom = tileJSONDoc.maxzoom || 22;\n      let source = tilejson.get('ol-source');\n      if (source === undefined) {\n        source = new VectorTileSource({\n          attributions: tilejson.getAttributions(),\n          format: new MVT(),\n          tileGrid: new TileGrid({\n            origin: tileGrid.getOrigin(0),\n            extent: extent || tileGrid.getExtent(),\n            minZoom: minZoom,\n            resolutions: defaultResolutions.slice(0, maxZoom + 1),\n            tileSize: 512\n          }),\n          urls: tiles\n        });\n        tilejson.set('ol-source', source);\n      }\n      unByKey(key);\n      layer.setSource(source);\n    } else if (state === 'error') {\n      tilejson.set('ol-source', null);\n      unByKey(key);\n      layer.setSource(undefined);\n    }\n  });\n  if (tilejson.getState() === 'ready') {\n    tilejson.changed();\n  }\n  return layer;\n}\n\nfunction setupRasterLayer(glSource, url) {\n  const layer = new TileLayer();\n  const source = new TileJSON({\n    transition: 0,\n    url: glSource.tiles ? undefined : url,\n    tileJSON: glSource.tiles ? glSource : undefined,\n    crossOrigin: 'anonymous'\n  });\n  const key = source.on('change', function() {\n    const state = source.getState();\n    if (state === 'ready') {\n      unByKey(key);\n      const tileJSONDoc = /** @type {Object} */ (source.getTileJSON());\n      const extent = extentFromTileJSON(tileJSONDoc);\n      const tileGrid = source.getTileGrid();\n      const tileSize = glSource.tileSize || tileJSONDoc.tileSize || 512;\n      const minZoom = tileJSONDoc.minzoom || 0;\n      const maxZoom = tileJSONDoc.maxzoom || 22;\n      // Only works when using ES modules\n      source.tileGrid = new TileGrid({\n        origin: tileGrid.getOrigin(0),\n        extent: extent || tileGrid.getExtent(),\n        minZoom: minZoom,\n        resolutions: createXYZ({\n          maxZoom: maxZoom,\n          tileSize: tileSize\n        }).getResolutions(),\n        tileSize: tileSize\n      });\n      layer.setSource(source);\n    } else if (state === 'error') {\n      unByKey(key);\n      layer.setSource(undefined);\n    }\n  });\n  source.setTileLoadFunction(function(tile, src) {\n    if (src.indexOf('{bbox-epsg-3857}') != -1) {\n      const bbox = source.getTileGrid().getTileCoordExtent(tile.getTileCoord());\n      src = src.replace('{bbox-epsg-3857}', bbox.toString());\n    }\n    const img = /** @type {import(\"ol/ImageTile\").default} */ (tile).getImage();\n    /** @type {HTMLImageElement} */ (img).src = src;\n  });\n  return layer;\n}\n\nconst geoJsonFormat = new GeoJSON();\nfunction setupGeoJSONLayer(glSource, path) {\n  const data = glSource.data;\n  let features, geoJsonUrl;\n  if (typeof data == 'string') {\n    geoJsonUrl = withPath(data, path);\n  } else {\n    features = geoJsonFormat.readFeatures(data, {featureProjection: 'EPSG:3857'});\n  }\n  return new VectorLayer({\n    source: new VectorSource({\n      attributions: glSource.attribution,\n      features: features,\n      format: geoJsonFormat,\n      url: geoJsonUrl\n    }),\n    visible: false\n  });\n}\n\nfunction updateRasterLayerProperties(glLayer, layer, view) {\n  const zoom = view.getZoom();\n  const opacity = getValue(glLayer, 'paint', 'raster-opacity', zoom, emptyObj);\n  layer.setOpacity(opacity);\n}\n\nfunction processStyle(glStyle, map, baseUrl, host, path, accessToken) {\n  const promises = [];\n  let view = map.getView();\n  if (!view.isDef() && !view.getRotation() && !view.getResolutions()) {\n    view = new View({\n      maxResolution: defaultResolutions[0]\n    });\n    map.setView(view);\n  }\n\n  if ('center' in glStyle && !view.getCenter()) {\n    view.setCenter(fromLonLat(glStyle.center));\n  }\n  if ('zoom' in glStyle && view.getZoom() === undefined) {\n    view.setResolution(defaultResolutions[0] / Math.pow(2, glStyle.zoom));\n  }\n  if (!view.getCenter() || view.getZoom() === undefined) {\n    view.fit(view.getProjection().getExtent(), {\n      nearest: true,\n      size: map.getSize()\n    });\n  }\n  if (glStyle.sprite) {\n    if (glStyle.sprite.indexOf('mapbox://') == 0) {\n      glStyle.sprite = baseUrl + '/sprite' + accessToken;\n    } else if (glStyle.sprite.indexOf('http') != 0) {\n      glStyle.sprite = (host ? (host + path) : '') + glStyle.sprite + accessToken;\n    }\n  }\n\n  const glLayers = glStyle.layers;\n  let layerIds = [];\n\n  let glLayer, glSource, glSourceId, id, layer, url;\n  for (let i = 0, ii = glLayers.length; i < ii; ++i) {\n    glLayer = glLayers[i];\n    const type = glLayer.type;\n    if (type == 'heatmap' || type == 'fill-extrusion' || type == 'hillshade') {\n      //FIXME Unsupported layer type\n    } else if (type == 'background') {\n      setBackground(map, glLayer);\n    } else {\n      id = glLayer.source || getSourceIdByRef(glLayers, glLayer.ref);\n      // this technique assumes gl layers will be in a particular order\n      if (id != glSourceId) {\n        if (layerIds.length) {\n          promises.push(finalizeLayer(layer, layerIds, glStyle, path, map));\n          layerIds = [];\n        }\n        glSource = glStyle.sources[id];\n        url = glSource.url;\n        if (url) {\n          url = withPath(url, path);\n          if (url.indexOf('mapbox://') == 0) {\n            const mapid = url.replace('mapbox://', '');\n            glSource.tiles = ['a', 'b', 'c', 'd'].map(function(host) {\n              return 'https://' + host + '.tiles.mapbox.com/v4/' + mapid +\n                  '/{z}/{x}/{y}.' +\n                  (glSource.type == 'vector' ? 'vector.pbf' : 'png') +\n                  accessToken;\n            });\n          }\n        }\n\n\n        if (glSource.type == 'vector') {\n          layer = setupVectorLayer(glSource, accessToken, url);\n        } else if (glSource.type == 'raster') {\n          layer = setupRasterLayer(glSource, url);\n          layer.setVisible(glLayer.layout ? glLayer.layout.visibility !== 'none' : true);\n          view.on('change:resolution', updateRasterLayerProperties.bind(this, glLayer, layer, view));\n          updateRasterLayerProperties(glLayer, layer, view);\n        } else if (glSource.type == 'geojson') {\n          layer = setupGeoJSONLayer(glSource, path);\n        }\n        glSourceId = id;\n        if (layer) {\n          layer.set('mapbox-source', glSourceId);\n        }\n      }\n      layerIds.push(glLayer.id);\n    }\n  }\n  promises.push(finalizeLayer(layer, layerIds, glStyle, path, map));\n  map.set('mapbox-style', glStyle);\n  return Promise.all(promises);\n}\n\n/**\n * ```js\n * import olms from 'ol-mapbox-style';\n * ```\n *\n * Loads and applies a Mapbox Style object to an OpenLayers Map. This includes\n * the map background, the layers, the center and the zoom.\n *\n * The center and zoom will only be set if present in the Mapbox Style document,\n * and if not already set on the OpenLayers map.\n *\n * Layers will be added to the OpenLayers map, without affecting any layers that\n * might already be set on the map.\n *\n * Layers added by `apply()` will have two additional properties:\n *\n *  * `mapbox-source`: The `id` of the Mapbox Style document's source that the\n *    OpenLayers layer was created from. Usually `apply()` creates one\n *    OpenLayers layer per Mapbox Style source, unless the layer stack has\n *    layers from different sources in between.\n *  * `mapbox-layers`: The `id`s of the Mapbox Style document's layers that are\n *    included in the OpenLayers layer.\n *\n * This function sets an additional `mapbox-style` property on the OpenLayers\n * map instance, which holds the Mapbox Style object.\n *\n * @param {PluggableMap|HTMLElement|string} map Either an existing OpenLayers Map\n * instance, or a HTML element, or the id of a HTML element that will be the\n * target of a new OpenLayers Map.\n * @param {string|Object} style JSON style object or style url pointing to a\n * Mapbox Style object. When using Mapbox APIs, the url must contain an access\n * token and look like\n * `https://api.mapbox.com/styles/v1/mapbox/bright-v9?access_token=[your_access_token_here]`.\n * When passed as JSON style object, all OpenLayers layers created by `apply()`\n * will be immediately available, but they may not have a source yet (i.e. when\n * they are defined by a TileJSON url in the Mapbox Style document). When passed\n * as style url, layers will be added to the map when the Mapbox Style document\n * is loaded and parsed.\n * @return {Promise} A promise that resolves after all layers have been added to\n * the OpenLayers Map instance, their sources set, and their styles applied. the\n * `resolve` callback will be called with the OpenLayers Map instance as\n * argument.\n */\nexport default function olms(map, style) {\n\n  let accessToken, baseUrl, host, path, promise;\n  accessToken = baseUrl = host = path = '';\n\n  if (typeof map === 'string' || map instanceof HTMLElement) {\n    map = new Map({\n      target: map\n    });\n  }\n\n  if (typeof style === 'string') {\n    const parts = style.match(spriteRegEx);\n    if (parts) {\n      baseUrl = parts[1];\n      accessToken = parts.length > 2 ? parts[2] : '';\n    }\n    promise = new Promise(function(resolve, reject) {\n      fetch(style, {\n        credentials: 'same-origin'\n      })\n        .then(function(response) {\n          return response.json();\n        })\n        .then(function(glStyle) {\n          const a = /** @type {HTMLAnchorElement} */ (document.createElement('A'));\n          a.href = style;\n          const href = a.href;\n          path = a.pathname.split('/').slice(0, -1).join('/') + '/';\n          host = href.substr(0, href.indexOf(path));\n\n          processStyle(glStyle, map, baseUrl, host, path, accessToken)\n            .then(function() {\n              resolve(map);\n            })\n            .catch(reject);\n        })\n        .catch(function(err) {\n          reject(new Error(`Could not load ${style}: ${err.message}`));\n        });\n    });\n  } else {\n    promise = new Promise(function(resolve, reject) {\n      processStyle(style, map)\n        .then(function() {\n          resolve(map);\n        })\n        .catch(reject);\n    });\n  }\n\n  return promise;\n}\n\n/**\n * ```js\n * import {apply} from 'ol-mapbox-style';\n * ```\n * Like `olms`, but returns an `ol/Map` instance instead of a `Promise`.\n *\n * @param {PluggableMap|HTMLElement|string} map Either an existing OpenLayers Map\n * instance, or a HTML element, or the id of a HTML element that will be the\n * target of a new OpenLayers Map.\n * @param {string|Object} style JSON style object or style url pointing to a\n * Mapbox Style object. When using Mapbox APIs, the url must contain an access\n * token and look like\n * `https://api.mapbox.com/styles/v1/mapbox/bright-v9?access_token=[your_access_token_here]`.\n * When passed as JSON style object, all OpenLayers layers created by `apply()`\n * will be immediately available, but they may not have a source yet (i.e. when\n * they are defined by a TileJSON url in the Mapbox Style document). When passed\n * as style url, layers will be added to the map when the Mapbox Style document\n * is loaded and parsed.\n * @return {PluggableMap} The OpenLayers Map instance that will be populated with the\n * contents described in the Mapbox Style object.\n */\nexport function apply(map, style) {\n  if (typeof map === 'string' || map instanceof HTMLElement) {\n    map = new Map({\n      target: map\n    });\n  }\n  setTimeout(function() {\n    olms(map, style);\n  }, 0);\n  return map;\n}\n\n\n/**\n * @private\n * If layerIds is not empty, applies the style specified in glStyle to the layer,\n * and adds the layer to the map.\n *\n * The layer may not yet have a source when the function is called.  If so, the style\n * is applied to the layer via a once listener on the 'change:source' event.\n *\n * @param {Layer} layer An OpenLayers layer instance.\n * @param {Array<string>} layerIds Array containing layer ids of already-processed layers.\n * @param {Object} glStyle Style as a JSON object.\n * @param {string|undefined} path The path part of the style URL. Only required\n * when a relative path is used with the `\"sprite\"` property of the style.\n * @param {PluggableMap} map OpenLayers Map.\n * @return {Promise} Returns a promise that resolves after the source has\n * been set on the specified layer, and the style has been applied.\n */\nfunction finalizeLayer(layer, layerIds, glStyle, path, map) {\n  let minZoom = 24;\n  let maxZoom = 0;\n  const glLayers = glStyle.layers;\n  for (let i = 0, ii = glLayers.length; i < ii; ++i) {\n    const glLayer = glLayers[i];\n    if (layerIds.indexOf(glLayer.id) !== -1) {\n      minZoom = Math.min('minzoom' in glLayer ? glLayer.minzoom : 0, minZoom);\n      maxZoom = Math.max('maxzoom' in glLayer ? glLayer.maxzoom : 24, maxZoom);\n    }\n  }\n  return new Promise(function(resolve, reject) {\n    const setStyle = function() {\n      const source = layer.getSource();\n      if (!source || source.getState() === 'error') {\n        reject(new Error('Error accessing data for source ' + layer.get('mapbox-source')));\n        return;\n      }\n      if (typeof source.getTileGrid === 'function') {\n        const tileGrid = source.getTileGrid();\n        if (tileGrid) {\n          const sourceMinZoom = tileGrid.getMinZoom();\n          if (minZoom > 0 || sourceMinZoom > 0) {\n            layer.setMaxResolution(Math.min(defaultResolutions[minZoom], tileGrid.getResolution(sourceMinZoom)) + 1e-9);\n          }\n          if (maxZoom < 24) {\n            layer.setMinResolution(defaultResolutions[maxZoom] + 1e-9);\n          }\n        }\n      }\n      if (source instanceof VectorSource || source instanceof VectorTileSource) {\n        applyStyle(/** @type {import(\"ol/layer/Vector\").default|import(\"ol/layer/VectorTile\").default} */ (layer), glStyle, layerIds, path).then(function() {\n          layer.setVisible(true);\n          resolve();\n        }, function(e) {\n          reject(e);\n        });\n      } else {\n        resolve();\n      }\n    };\n\n    layer.set('mapbox-layers', layerIds);\n    if (map.getLayers().getArray().indexOf(layer) === -1) {\n      map.addLayer(layer);\n    }\n\n    if (layer.getSource()) {\n      setStyle();\n    } else {\n      layer.once('change:source', setStyle);\n    }\n  });\n}\n\n\n/**\n * ```js\n * import {getLayer} from 'ol-mapbox-style';\n * ```\n * Get the OpenLayers layer instance that contains the provided Mapbox Style\n * `layer`. Note that multiple Mapbox Style layers are combined in a single\n * OpenLayers layer instance when they use the same Mapbox Style `source`.\n * @param {PluggableMap} map OpenLayers Map.\n * @param {string} layerId Mapbox Style layer id.\n * @return {Layer} OpenLayers layer instance.\n */\nexport function getLayer(map, layerId) {\n  const layers = map.getLayers().getArray();\n  for (let i = 0, ii = layers.length; i < ii; ++i) {\n    const mapboxLayers = layers[i].get('mapbox-layers');\n    if (mapboxLayers && mapboxLayers.indexOf(layerId) !== -1) {\n      return /** @type {Layer} */ (layers[i]);\n    }\n  }\n}\n\n/**\n * ```js\n * import {getLayers} from 'ol-mapbox-style';\n * ```\n * Get the OpenLayers layer instances for the provided Mapbox Style `source`.\n * @param {PluggableMap} map OpenLayers Map.\n * @param {string} sourceId Mapbox Style source id.\n * @return {Array<Layer>} OpenLayers layer instances.\n */\nexport function getLayers(map, sourceId) {\n  const result = [];\n  const layers = map.getLayers().getArray();\n  for (let i = 0, ii = layers.length; i < ii; ++i) {\n    if (layers[i].get('mapbox-source') === sourceId) {\n      result.push(/** @type {Layer} */ (layers[i]));\n    }\n  }\n  return result;\n}\n\n/**\n * ```js\n * import {getSource} from 'ol-mapbox-style';\n * ```\n * Get the OpenLayers source instance for the provided Mapbox Style `source`.\n * @param {PluggableMap} map OpenLayers Map.\n * @param {string} sourceId Mapbox Style source id.\n * @return {Source} OpenLayers source instance.\n */\nexport function getSource(map, sourceId) {\n  const layers = map.getLayers().getArray();\n  for (let i = 0, ii = layers.length; i < ii; ++i) {\n    const source = /** @type {Layer} */ (layers[i]).getSource();\n    if (layers[i].get('mapbox-source') === sourceId) {\n      return source;\n    }\n  }\n}\n\nexport {\n  finalizeLayer as _finalizeLayer,\n  getFonts as _getFonts\n};\n"],"mappings":"AAAA;;;;;AAMA,OAAOA,MAAM,MAAM,oBAAoB;AACvC,OAAOC,kBAAkB,IAAGC,QAAQ,QAAO,iBAAiB;AAC5D,OAAOC,WAAW,MAAM,kCAAkC;AAC1D,SAAQC,UAAU,QAAO,SAAS;AAClC,SAAQC,SAAS,QAAO,aAAa;AACrC,OAAOC,QAAQ,MAAM,sBAAsB;AAC3C,OAAOC,GAAG,MAAM,QAAQ;AACxB,OAAOC,IAAI,MAAM,SAAS;AAC1B,OAAOC,OAAO,MAAM,mBAAmB;AACvC,OAAOC,GAAG,MAAM,eAAe;AAC/B,SAAQC,OAAO,QAAO,eAAe;AACrC,OAAOC,SAAS,MAAM,eAAe;AACrC,OAAOC,WAAW,MAAM,iBAAiB;AACzC,OAAOC,eAAe,MAAM,qBAAqB;AACjD,OAAOC,QAAQ,MAAM,oBAAoB;AACzC,OAAOC,YAAY,MAAM,kBAAkB;AAC3C,OAAOC,gBAAgB,MAAM,sBAAsB;AACnD,SAAQC,KAAK,QAAO,8BAA8B;AAClD,SAAQC,MAAM,EAAEC,kBAAkB,QAAO,QAAQ;AAEjD;;;;;;AAOA,IAAMC,aAAa,GAAG,EAAE;AAExB,IAAMC,eAAe,GAAG,wBAAwB;AAChD,IAAMC,gBAAgB,GAAG,QAAQ;AACjC,IAAIC,kBAAkB;AACtB,SAASC,aAAaA,CAACC,MAAM;EAC3B,IAAI,CAACF,kBAAkB,EAAE;IACvBA,kBAAkB,GAAG,EAAE;IACvB,IAAMG,WAAW,GAAGC,QAAQ,CAACD,WAAW;IACxC,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGH,WAAW,CAACI,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAE,EAAED,CAAC,EAAE;MACpD,IAAMG,UAAU,GAAG,4BAA8BL,WAAW,CAACE,CAAC,CAAE;MAChE,IAAI;QACF,IAAMI,QAAQ,GAAGD,UAAU,CAACE,KAAK,IAAIF,UAAU,CAACC,QAAQ;QACxD,IAAIA,QAAQ,EAAE;UACZ,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGH,QAAQ,CAACF,MAAM,EAAEI,CAAC,GAAGC,EAAE,EAAE,EAAED,CAAC,EAAE;YACjD,IAAME,OAAO,GAAGJ,QAAQ,CAACE,CAAC,CAAC;YAC3B,IAAIE,OAAO,CAACC,IAAI,IAAI,CAAC,EAAE;cACrB,IAAMC,KAAK,GAAGF,OAAO,CAACG,OAAO,CAACD,KAAK,CAACjB,eAAe,CAAC;cACpDE,kBAAkB,CAACe,KAAK,CAAC,CAAC,CAAC,CAACE,OAAO,CAAClB,gBAAgB,EAAE,EAAE,CAAC,CAAC,GAAG,IAAI;;;;OAIxE,CAAC,OAAOmB,CAAC,EAAE;QACV;MAAA;;;EAIN,OAAOhB,MAAM,IAAIF,kBAAkB;AACrC;AAEA,IAAMmB,qBAAqB,GAAG,EAAE;AAChC,IAAMC,cAAc,GAAGzC,WAAW,CAAC0C,QAAQ,EAAE;AAE7C;;;;;AAKA,SAASC,QAAQA,CAACC,KAAK;EACrB,IAAMC,QAAQ,GAAGD,KAAK,CAACE,QAAQ,EAAE;EACjC,IAAID,QAAQ,IAAIL,qBAAqB,EAAE;IACrC,OAAOI,KAAK;;EAEd,IAAMG,sBAAsB,GAAGH,KAAK,CAACI,GAAG,CAAC,UAASC,IAAI;IACpD,IAAMC,KAAK,GAAGrD,MAAM,CAACoD,IAAI,EAAE,CAAC,CAAC,CAACE,KAAK,CAAC,GAAG,CAAC;IACxC,OAAO,CAACD,KAAK,CAACE,KAAK,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,GAAG,CAAC,CAACf,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,EAAEY,KAAK,CAAC,CAAC,CAAC,GAAGA,KAAK,CAAC,CAAC,CAAC,CAAC;EAC1E,CAAC,CAAC;EACF,KAAK,IAAIxB,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGoB,sBAAsB,CAACnB,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAE,EAAED,CAAC,EAAE;IAC/D,IAAM4B,qBAAqB,GAAGP,sBAAsB,CAACrB,CAAC,CAAC;IACvD,IAAMH,MAAM,GAAG+B,qBAAqB,CAAC,CAAC,CAAC;IACvC,IAAI,CAAChC,aAAa,CAACC,MAAM,CAAC,IAAIkB,cAAc,CAACc,OAAO,CAAChC,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE;MACnE,IAAMiC,OAAO,GAAG,0CAA0C,GAAGjC,MAAM,CAACe,OAAO,CAAC,IAAI,EAAE,GAAG,CAAC,GAAG,GAAG,GAAGgB,qBAAqB,CAAC,CAAC,CAAC;MACvH,IAAI,CAAC7B,QAAQ,CAACgC,aAAa,CAAC,aAAa,GAAGD,OAAO,GAAG,IAAI,CAAC,EAAE;QAC3D,IAAME,MAAM,GAAGjC,QAAQ,CAACkC,aAAa,CAAC,MAAM,CAAC;QAC7CD,MAAM,CAACE,IAAI,GAAGJ,OAAO;QACrBE,MAAM,CAACG,GAAG,GAAG,YAAY;QACzBpC,QAAQ,CAACqC,IAAI,CAACC,WAAW,CAACL,MAAM,CAAC;;;;EAIvClB,qBAAqB,CAACK,QAAQ,CAAC,GAAG,IAAI;EACtC,OAAOD,KAAK;AACd;AAEA,IAAMoB,WAAW,GAAG,cAAc;AAElC,SAASC,QAAQA,CAACC,GAAG,EAAEC,IAAI;EACzB,IAAIA,IAAI,IAAID,GAAG,CAACX,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;IAClCW,GAAG,GAAGC,IAAI,GAAGD,GAAG;;EAElB,OAAOA,GAAG;AACZ;AAEA,SAASE,WAAWA,CAACF,GAAG,EAAEC,IAAI,EAAEE,SAAS;EACvCH,GAAG,GAAGD,QAAQ,CAACC,GAAG,EAAEC,IAAI,CAAC;EACzB,IAAMjB,KAAK,GAAGgB,GAAG,CAAC9B,KAAK,CAAC4B,WAAW,CAAC;EACpC,OAAOd,KAAK,GACVA,KAAK,CAAC,CAAC,CAAC,GAAGmB,SAAS,IAAInB,KAAK,CAACtB,MAAM,GAAG,CAAC,GAAGsB,KAAK,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,GACzDgB,GAAG,GAAGG,SAAS;AACnB;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgCA,OAAM,SAAUC,UAAUA,CAACC,KAAK,EAAEC,OAAO,EAAEC,MAAM,EAAEN,IAAI,EAAEO,WAAW;EAClE,OAAO,IAAIC,OAAO,CAAC,UAASC,OAAO,EAAEC,MAAM;IAEzC;IACA;IACA;IACA,IAAI,OAAOL,OAAO,IAAI,QAAQ,EAAE;MAC9BA,OAAO,GAAGM,IAAI,CAACC,KAAK,CAACP,OAAO,CAAC;;IAE/B,IAAIA,OAAO,CAACQ,OAAO,IAAI,CAAC,EAAE;MACxB,OAAOH,MAAM,CAAC,IAAII,KAAK,CAAC,6BAA6B,CAAC,CAAC;;IAEzD,IAAI,EAAEV,KAAK,YAAY7D,WAAW,IAAI6D,KAAK,YAAY5D,eAAe,CAAC,EAAE;MACvE,OAAOkE,MAAM,CAAC,IAAII,KAAK,CAAC,kDAAkD,CAAC,CAAC;;IAG9E,IAAIC,WAAW,EAAEC,UAAU,EAAEC,cAAc,EAAEC,KAAK;IAClD,SAASC,QAAQA,CAAA;MACf,IAAI,CAACD,KAAK,KAAK,CAACb,OAAO,CAACe,MAAM,IAAIJ,UAAU,CAAC,EAAE;QAC7CE,KAAK,GAAGvF,kBAAkB,CAACyE,KAAK,EAAEC,OAAO,EAAEC,MAAM,EAAEC,WAAW,EAAES,UAAU,EAAEC,cAAc,EAAEzC,QAAQ,CAAC;QACrG,IAAI,CAAC4B,KAAK,CAACiB,QAAQ,EAAE,EAAE;UACrBX,MAAM,CAAC,IAAII,KAAK,CAAC,iCAA+BR,MAAM,MAAG,CAAC,CAAC;SAC5D,MAAM;UACLG,OAAO,EAAE;;OAEZ,MAAM,IAAIS,KAAK,EAAE;QAChBd,KAAK,CAACkB,QAAQ,CAACJ,KAAK,CAAC;QACrBT,OAAO,EAAE;OACV,MAAM;QACLC,MAAM,CAAC,IAAII,KAAK,CAAC,6CAA6C,CAAC,CAAC;;IAEpE;IAEA,IAAIT,OAAO,CAACe,MAAM,EAAE;MAClBL,WAAW,GAAGQ,MAAM,CAACC,gBAAgB,IAAI,GAAG,GAAG,GAAG,GAAG,CAAC;MACtD,IAAMC,YAAU,GAAGV,WAAW,IAAI,GAAG,GAAG,KAAK,GAAG,EAAE;MAClD,IAAIW,WAAS,GAAGzB,WAAW,CAACI,OAAO,CAACe,MAAM,EAAEpB,IAAI,EAAEyB,YAAU,GAAG,OAAO,CAAC;MAEvEE,KAAK,CAACD,WAAS,EAAE;QAACE,WAAW,EAAE;MAAa,CAAC,CAAC,CAC3CC,IAAI,CAAC,UAASC,QAAQ;QACrB,IAAI,CAACA,QAAQ,CAACC,EAAE,IAAKN,YAAU,KAAK,EAAG,EAAE;UACvCC,WAAS,GAAGzB,WAAW,CAACI,OAAO,CAACe,MAAM,EAAEpB,IAAI,EAAE,OAAO,CAAC;UACtD,OAAO2B,KAAK,CAACD,WAAS,EAAE;YAACE,WAAW,EAAE;UAAa,CAAC,CAAC;SACtD,MAAM;UACL,OAAOE,QAAQ;;MAEnB,CAAC,CAAC,CACDD,IAAI,CAAC,UAASC,QAAQ;QACrB,IAAIA,QAAQ,CAACC,EAAE,EAAE;UACf,OAAOD,QAAQ,CAACE,IAAI,EAAE;SACvB,MAAM;UACLtB,MAAM,CAAC,IAAII,KAAK,CAAC,kCAAgCY,WAAS,UAAKI,QAAQ,CAACG,UAAY,CAAC,CAAC;;MAE1F,CAAC,CAAC,CACDJ,IAAI,CAAC,UAASK,WAAW;QACxB,IAAKA,WAAW,KAAKC,SAAS,IAAMC,MAAM,CAACC,IAAI,CAACH,WAAW,CAAC,CAACzE,MAAM,KAAK,CAAE,EAAE;UAC1E,OAAOiD,MAAM,CAAC,IAAII,KAAK,CAAC,mBAAmB,CAAC,CAAC;;QAE/CE,UAAU,GAAGkB,WAAW;QACxBjB,cAAc,GAAGhB,WAAW,CAACI,OAAO,CAACe,MAAM,EAAEpB,IAAI,EAAEyB,YAAU,GAAG,MAAM,CAAC;QACvEN,QAAQ,EAAE;MACZ,CAAC,CAAC,CACDmB,KAAK,CAAC,UAASC,GAAG;QACjB7B,MAAM,CAAC,IAAII,KAAK,CAAC,+BAA6BY,WAAS,UAAKa,GAAG,CAACC,OAAS,CAAC,CAAC;MAC7E,CAAC,CAAC;KACL,MAAM;MACLrB,QAAQ,EAAE;;EAGd,CAAC,CAAC;AACJ;AAEA,IAAMsB,QAAQ,GAAG,EAAE;AAEnB,SAASC,aAAaA,CAAC7D,GAAG,EAAEuB,KAAK;EAC/B,IAAMuC,UAAU,GAAG;IACjB3E,IAAI,EAAEoC,KAAK,CAACpC;GACb;EACD,SAAS4E,WAAWA,CAAA;IAClB,IAAMC,OAAO,GAAGhE,GAAG,CAACiE,gBAAgB,EAAE;IACtC,IAAI,CAACD,OAAO,EAAE;MACZ;;IAEF,IAAME,MAAM,GAAG3C,KAAK,CAAC2C,MAAM,IAAI,EAAE;IACjC,IAAMC,KAAK,GAAG5C,KAAK,CAAC4C,KAAK,IAAI,EAAE;IAC/BL,UAAU,CAAC,OAAO,CAAC,GAAGK,KAAK;IAC3BL,UAAU,CAACM,EAAE,GAAG,UAAU,GAAGD,KAAK,CAAC,oBAAoB,CAAC,GAAGA,KAAK,CAAC,kBAAkB,CAAC;IACpF,IAAME,IAAI,GAAGrE,GAAG,CAACsE,OAAO,EAAE,CAACC,OAAO,EAAE;IACpC,IAAIJ,KAAK,CAAC,kBAAkB,CAAC,KAAKb,SAAS,EAAE;MAC3C,IAAMkB,EAAE,GAAGzH,QAAQ,CAAC+G,UAAU,EAAE,OAAO,EAAE,kBAAkB,EAAEO,IAAI,EAAET,QAAQ,CAAC;MAC5EI,OAAO,CAAC3B,KAAK,CAACyB,UAAU,GAAG/F,KAAK,CAACgE,KAAK,CAACyC,EAAE,CAAC,CAAC1E,QAAQ,EAAE;;IAEvD,IAAIqE,KAAK,CAAC,oBAAoB,CAAC,KAAKb,SAAS,EAAE;MAC7CU,OAAO,CAAC3B,KAAK,CAACoC,OAAO,GAAG1H,QAAQ,CAAC+G,UAAU,EAAE,OAAO,EAAE,oBAAoB,EAAEO,IAAI,EAAET,QAAQ,CAAC;;IAE7F,IAAIM,MAAM,CAACQ,UAAU,IAAI,MAAM,EAAE;MAC/BV,OAAO,CAAC3B,KAAK,CAACsC,eAAe,GAAG,EAAE;MAClCX,OAAO,CAAC3B,KAAK,CAACoC,OAAO,GAAG,EAAE;;EAE9B;EACA,IAAIzE,GAAG,CAACiE,gBAAgB,EAAE,EAAE;IAC1BF,WAAW,EAAE;;EAEf/D,GAAG,CAAC4E,EAAE,CAAC,CAAC,mBAAmB,EAAE,eAAe,CAAC,EAAEb,WAAW,CAAC;AAC7D;AAEA;;;;;;;;AAQA,OAAM,SAAUc,eAAeA,CAAC7E,GAAG,EAAEwB,OAAO;EAC1CA,OAAO,CAACsD,MAAM,CAACC,IAAI,CAAC,UAASC,CAAC;IAC5B,IAAIA,CAAC,CAAC7F,IAAI,IAAI,YAAY,EAAE;MAC1B0E,aAAa,CAAC7D,GAAG,EAAEgF,CAAC,CAAC;MACrB,OAAO,IAAI;;EAEf,CAAC,CAAC;AACJ;AAEA,SAASC,gBAAgBA,CAACH,MAAM,EAAEI,GAAG;EACnC,IAAIC,QAAQ;EACZL,MAAM,CAACC,IAAI,CAAC,UAASxD,KAAK;IACxB,IAAIA,KAAK,CAAC6C,EAAE,IAAIc,GAAG,EAAE;MACnBC,QAAQ,GAAG5D,KAAK,CAACE,MAAM;MACvB,OAAO,IAAI;;EAEf,CAAC,CAAC;EACF,OAAO0D,QAAQ;AACjB;AAEA,SAASC,kBAAkBA,CAACC,QAAQ;EAClC,IAAMC,MAAM,GAAGD,QAAQ,CAACC,MAAM;EAC9B,IAAIA,MAAM,EAAE;IACV,IAAMC,EAAE,GAAGtI,UAAU,CAAC,CAACqI,MAAM,CAAC,CAAC,CAAC,EAAEA,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;IAC7C,IAAME,EAAE,GAAGvI,UAAU,CAAC,CAACqI,MAAM,CAAC,CAAC,CAAC,EAAEA,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;IAC7C,OAAO,CAACC,EAAE,CAAC,CAAC,CAAC,EAAEA,EAAE,CAAC,CAAC,CAAC,EAAEC,EAAE,CAAC,CAAC,CAAC,EAAEA,EAAE,CAAC,CAAC,CAAC,CAAC;;AAEvC;AAEA,SAASC,gBAAgBA,CAACC,QAAQ,EAAEC,WAAW,EAAEzE,GAAG;EAClDwE,QAAQ,GAAG1H,MAAM,CAAC,EAAE,EAAE0H,QAAQ,CAAC;EAC/B,IAAMnE,KAAK,GAAG,IAAI5D,eAAe,CAAC;IAChCiI,SAAS,EAAE,IAAI;IACfC,OAAO,EAAE;GACV,CAAC;EACF,IAAMC,QAAQ,GAAGhE,IAAI,CAACiE,SAAS,CAACL,QAAQ,CAAC;EACzC,IAAIM,QAAQ,GAAG9H,aAAa,CAAC4H,QAAQ,CAAC;EACtC,IAAI,CAACE,QAAQ,EAAE;IACbA,QAAQ,GAAG9H,aAAa,CAAC4H,QAAQ,CAAC,GAAG,IAAIlI,QAAQ,CAAC;MAChDsD,GAAG,EAAEwE,QAAQ,CAACO,KAAK,GAAG3C,SAAS,GAAGpC,GAAG;MACrCmE,QAAQ,EAAEK,QAAQ,CAACO,KAAK,GAAGP,QAAQ,GAAGpC;KACvC,CAAC;;EAEJ,IAAM4C,GAAG,GAAGF,QAAQ,CAACpB,EAAE,CAAC,QAAQ,EAAE;IAChC,IAAMuB,KAAK,GAAGH,QAAQ,CAACI,QAAQ,EAAE;IACjC,IAAID,KAAK,KAAK,OAAO,EAAE;MACrB,IAAME,WAAW,GAAGL,QAAQ,CAACM,WAAW,EAAE;MAC1C,IAAML,KAAK,GAAGM,KAAK,CAACC,OAAO,CAACH,WAAW,CAACJ,KAAK,CAAC,GAAGI,WAAW,CAACJ,KAAK,GAAG,CAACI,WAAW,CAACJ,KAAK,CAAC;MACxF,IAAIP,QAAQ,CAACxE,GAAG,EAAE;QAChB,KAAK,IAAIxC,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGsH,KAAK,CAACrH,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAE,EAAED,CAAC,EAAE;UAC9C,IAAM+H,IAAI,GAAGR,KAAK,CAACvH,CAAC,CAAC;UACrB,IAAI+H,IAAI,CAAClG,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE;YAC7B0F,KAAK,CAACvH,CAAC,CAAC,GAAGgH,QAAQ,CAACxE,GAAG,GAAGuF,IAAI;;;;MAIpC,IAAMC,QAAQ,GAAGV,QAAQ,CAACW,WAAW,EAAE;MACvC,IAAMC,MAAM,GAAGxB,kBAAkB,CAACiB,WAAW,CAAC;MAC9C,IAAMQ,OAAO,GAAGR,WAAW,CAACS,OAAO,IAAI,CAAC;MACxC,IAAMC,OAAO,GAAGV,WAAW,CAACW,OAAO,IAAI,EAAE;MACzC,IAAIvF,MAAM,GAAGuE,QAAQ,CAACiB,GAAG,CAAC,WAAW,CAAC;MACtC,IAAIxF,MAAM,KAAK6B,SAAS,EAAE;QACxB7B,MAAM,GAAG,IAAI3D,gBAAgB,CAAC;UAC5BoJ,YAAY,EAAElB,QAAQ,CAACmB,eAAe,EAAE;UACxCC,MAAM,EAAE,IAAI7J,GAAG,EAAE;UACjBmJ,QAAQ,EAAE,IAAIvJ,QAAQ,CAAC;YACrBkK,MAAM,EAAEX,QAAQ,CAACY,SAAS,CAAC,CAAC,CAAC;YAC7BV,MAAM,EAAEA,MAAM,IAAIF,QAAQ,CAACa,SAAS,EAAE;YACtCV,OAAO,EAAEA,OAAO;YAChBnF,WAAW,EAAEzD,kBAAkB,CAACmC,KAAK,CAAC,CAAC,EAAE2G,OAAO,GAAG,CAAC,CAAC;YACrDS,QAAQ,EAAE;WACX,CAAC;UACFC,IAAI,EAAExB;SACP,CAAC;QACFD,QAAQ,CAAC0B,GAAG,CAAC,WAAW,EAAEjG,MAAM,CAAC;;MAEnCjE,OAAO,CAAC0I,GAAG,CAAC;MACZ3E,KAAK,CAACoG,SAAS,CAAClG,MAAM,CAAC;KACxB,MAAM,IAAI0E,KAAK,KAAK,OAAO,EAAE;MAC5BH,QAAQ,CAAC0B,GAAG,CAAC,WAAW,EAAE,IAAI,CAAC;MAC/BlK,OAAO,CAAC0I,GAAG,CAAC;MACZ3E,KAAK,CAACoG,SAAS,CAACrE,SAAS,CAAC;;EAE9B,CAAC,CAAC;EACF,IAAI0C,QAAQ,CAACI,QAAQ,EAAE,KAAK,OAAO,EAAE;IACnCJ,QAAQ,CAAC4B,OAAO,EAAE;;EAEpB,OAAOrG,KAAK;AACd;AAEA,SAASsG,gBAAgBA,CAACnC,QAAQ,EAAExE,GAAG;EACrC,IAAMK,KAAK,GAAG,IAAI9D,SAAS,EAAE;EAC7B,IAAMgE,MAAM,GAAG,IAAI7D,QAAQ,CAAC;IAC1BkK,UAAU,EAAE,CAAC;IACb5G,GAAG,EAAEwE,QAAQ,CAACO,KAAK,GAAG3C,SAAS,GAAGpC,GAAG;IACrCmE,QAAQ,EAAEK,QAAQ,CAACO,KAAK,GAAGP,QAAQ,GAAGpC,SAAS;IAC/CyE,WAAW,EAAE;GACd,CAAC;EACF,IAAM7B,GAAG,GAAGzE,MAAM,CAACmD,EAAE,CAAC,QAAQ,EAAE;IAC9B,IAAMuB,KAAK,GAAG1E,MAAM,CAAC2E,QAAQ,EAAE;IAC/B,IAAID,KAAK,KAAK,OAAO,EAAE;MACrB3I,OAAO,CAAC0I,GAAG,CAAC;MACZ,IAAMG,WAAW,GAAG,qBAAuB5E,MAAM,CAAC6E,WAAW,EAAG;MAChE,IAAMM,MAAM,GAAGxB,kBAAkB,CAACiB,WAAW,CAAC;MAC9C,IAAMK,QAAQ,GAAGjF,MAAM,CAACkF,WAAW,EAAE;MACrC,IAAMa,QAAQ,GAAG9B,QAAQ,CAAC8B,QAAQ,IAAInB,WAAW,CAACmB,QAAQ,IAAI,GAAG;MACjE,IAAMX,OAAO,GAAGR,WAAW,CAACS,OAAO,IAAI,CAAC;MACxC,IAAMC,OAAO,GAAGV,WAAW,CAACW,OAAO,IAAI,EAAE;MACzC;MACAvF,MAAM,CAACiF,QAAQ,GAAG,IAAIvJ,QAAQ,CAAC;QAC7BkK,MAAM,EAAEX,QAAQ,CAACY,SAAS,CAAC,CAAC,CAAC;QAC7BV,MAAM,EAAEA,MAAM,IAAIF,QAAQ,CAACa,SAAS,EAAE;QACtCV,OAAO,EAAEA,OAAO;QAChBnF,WAAW,EAAExE,SAAS,CAAC;UACrB6J,OAAO,EAAEA,OAAO;UAChBS,QAAQ,EAAEA;SACX,CAAC,CAACQ,cAAc,EAAE;QACnBR,QAAQ,EAAEA;OACX,CAAC;MACFjG,KAAK,CAACoG,SAAS,CAAClG,MAAM,CAAC;KACxB,MAAM,IAAI0E,KAAK,KAAK,OAAO,EAAE;MAC5B3I,OAAO,CAAC0I,GAAG,CAAC;MACZ3E,KAAK,CAACoG,SAAS,CAACrE,SAAS,CAAC;;EAE9B,CAAC,CAAC;EACF7B,MAAM,CAACwG,mBAAmB,CAAC,UAASxB,IAAI,EAAEyB,GAAG;IAC3C,IAAIA,GAAG,CAAC3H,OAAO,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC,EAAE;MACzC,IAAM4H,IAAI,GAAG1G,MAAM,CAACkF,WAAW,EAAE,CAACyB,kBAAkB,CAAC3B,IAAI,CAAC4B,YAAY,EAAE,CAAC;MACzEH,GAAG,GAAGA,GAAG,CAAC5I,OAAO,CAAC,kBAAkB,EAAE6I,IAAI,CAACrI,QAAQ,EAAE,CAAC;;IAExD,IAAMwI,GAAG,GAAG,6CAA+C7B,IAAI,CAAE8B,QAAQ,EAAE;IAC3E;IAAiCD,GAAG,CAAEJ,GAAG,GAAGA,GAAG;EACjD,CAAC,CAAC;EACF,OAAO3G,KAAK;AACd;AAEA,IAAMiH,aAAa,GAAG,IAAIlL,OAAO,EAAE;AACnC,SAASmL,iBAAiBA,CAAC/C,QAAQ,EAAEvE,IAAI;EACvC,IAAMuH,IAAI,GAAGhD,QAAQ,CAACgD,IAAI;EAC1B,IAAIC,QAAQ,EAAEC,UAAU;EACxB,IAAI,OAAOF,IAAI,IAAI,QAAQ,EAAE;IAC3BE,UAAU,GAAG3H,QAAQ,CAACyH,IAAI,EAAEvH,IAAI,CAAC;GAClC,MAAM;IACLwH,QAAQ,GAAGH,aAAa,CAACK,YAAY,CAACH,IAAI,EAAE;MAACI,iBAAiB,EAAE;IAAW,CAAC,CAAC;;EAE/E,OAAO,IAAIpL,WAAW,CAAC;IACrB+D,MAAM,EAAE,IAAI5D,YAAY,CAAC;MACvBqJ,YAAY,EAAExB,QAAQ,CAACqD,WAAW;MAClCJ,QAAQ,EAAEA,QAAQ;MAClBvB,MAAM,EAAEoB,aAAa;MACrBtH,GAAG,EAAE0H;KACN,CAAC;IACF/C,OAAO,EAAE;GACV,CAAC;AACJ;AAEA,SAASmD,2BAA2BA,CAACC,OAAO,EAAE1H,KAAK,EAAE2H,IAAI;EACvD,IAAM7E,IAAI,GAAG6E,IAAI,CAAC3E,OAAO,EAAE;EAC3B,IAAME,OAAO,GAAG1H,QAAQ,CAACkM,OAAO,EAAE,OAAO,EAAE,gBAAgB,EAAE5E,IAAI,EAAET,QAAQ,CAAC;EAC5ErC,KAAK,CAAC4H,UAAU,CAAC1E,OAAO,CAAC;AAC3B;AAEA,SAAS2E,YAAYA,CAAC5H,OAAO,EAAExB,GAAG,EAAEqJ,OAAO,EAAEC,IAAI,EAAEnI,IAAI,EAAEwE,WAAW;EAClE,IAAM4D,QAAQ,GAAG,EAAE;EACnB,IAAIL,IAAI,GAAGlJ,GAAG,CAACsE,OAAO,EAAE;EACxB,IAAI,CAAC4E,IAAI,CAACM,KAAK,EAAE,IAAI,CAACN,IAAI,CAACO,WAAW,EAAE,IAAI,CAACP,IAAI,CAAClB,cAAc,EAAE,EAAE;IAClEkB,IAAI,GAAG,IAAI7L,IAAI,CAAC;MACdqM,aAAa,EAAEzL,kBAAkB,CAAC,CAAC;KACpC,CAAC;IACF+B,GAAG,CAAC2J,OAAO,CAACT,IAAI,CAAC;;EAGnB,IAAI,QAAQ,IAAI1H,OAAO,IAAI,CAAC0H,IAAI,CAACU,SAAS,EAAE,EAAE;IAC5CV,IAAI,CAACW,SAAS,CAAC5M,UAAU,CAACuE,OAAO,CAACsI,MAAM,CAAC,CAAC;;EAE5C,IAAI,MAAM,IAAItI,OAAO,IAAI0H,IAAI,CAAC3E,OAAO,EAAE,KAAKjB,SAAS,EAAE;IACrD4F,IAAI,CAACa,aAAa,CAAC9L,kBAAkB,CAAC,CAAC,CAAC,GAAG+L,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEzI,OAAO,CAAC6C,IAAI,CAAC,CAAC;;EAEvE,IAAI,CAAC6E,IAAI,CAACU,SAAS,EAAE,IAAIV,IAAI,CAAC3E,OAAO,EAAE,KAAKjB,SAAS,EAAE;IACrD4F,IAAI,CAACgB,GAAG,CAAChB,IAAI,CAACiB,aAAa,EAAE,CAAC5C,SAAS,EAAE,EAAE;MACzC6C,OAAO,EAAE,IAAI;MACbC,IAAI,EAAErK,GAAG,CAACsK,OAAO;KAClB,CAAC;;EAEJ,IAAI9I,OAAO,CAACe,MAAM,EAAE;IAClB,IAAIf,OAAO,CAACe,MAAM,CAAChC,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,EAAE;MAC5CiB,OAAO,CAACe,MAAM,GAAG8G,OAAO,GAAG,SAAS,GAAG1D,WAAW;KACnD,MAAM,IAAInE,OAAO,CAACe,MAAM,CAAChC,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE;MAC9CiB,OAAO,CAACe,MAAM,GAAG,CAAC+G,IAAI,GAAIA,IAAI,GAAGnI,IAAI,GAAI,EAAE,IAAIK,OAAO,CAACe,MAAM,GAAGoD,WAAW;;;EAI/E,IAAM4E,QAAQ,GAAG/I,OAAO,CAACsD,MAAM;EAC/B,IAAI0F,QAAQ,GAAG,EAAE;EAEjB,IAAIvB,OAAO,EAAEvD,QAAQ,EAAE+E,UAAU,EAAErG,EAAE,EAAE7C,KAAK,EAAEL,GAAG;iCACxCxC,CAAC,EAAMC,EAAE;IAChBsK,OAAO,GAAGsB,QAAQ,CAAC7L,CAAC,CAAC;IACrB,IAAMS,IAAI,GAAG8J,OAAO,CAAC9J,IAAI;IACzB,IAAIA,IAAI,IAAI,SAAS,IAAIA,IAAI,IAAI,gBAAgB,IAAIA,IAAI,IAAI,WAAW,EAAE;MACxE;IAAA,CACD,MAAM,IAAIA,IAAI,IAAI,YAAY,EAAE;MAC/B0E,aAAa,CAAC7D,GAAG,EAAEiJ,OAAO,CAAC;KAC5B,MAAM;MACL7E,EAAE,GAAG6E,OAAO,CAACxH,MAAM,IAAIwD,gBAAgB,CAACsF,QAAQ,EAAEtB,OAAO,CAAC/D,GAAG,CAAC;MAC9D;MACA,IAAId,EAAE,IAAIqG,UAAU,EAAE;QACpB,IAAID,QAAQ,CAAC5L,MAAM,EAAE;UACnB2K,QAAQ,CAACmB,IAAI,CAACC,aAAa,CAACpJ,KAAK,EAAEiJ,QAAQ,EAAEhJ,OAAO,EAAEL,IAAI,EAAEnB,GAAG,CAAC,CAAC;UACjEwK,QAAQ,GAAG,EAAE;;QAEf9E,QAAQ,GAAGlE,OAAO,CAACoJ,OAAO,CAACxG,EAAE,CAAC;QAC9BlD,GAAG,GAAGwE,QAAQ,CAACxE,GAAG;QAClB,IAAIA,GAAG,EAAE;UACPA,GAAG,GAAGD,QAAQ,CAACC,GAAG,EAAEC,IAAI,CAAC;UACzB,IAAID,GAAG,CAACX,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,EAAE;YACjC,IAAMsK,OAAK,GAAG3J,GAAG,CAAC5B,OAAO,CAAC,WAAW,EAAE,EAAE,CAAC;YAC1CoG,QAAQ,CAACO,KAAK,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAACjG,GAAG,CAAC,UAASsJ,IAAI;cACrD,OAAO,UAAU,GAAGA,IAAI,GAAG,uBAAuB,GAAGuB,OAAK,GACtD,eAAe,IACdnF,QAAQ,CAACvG,IAAI,IAAI,QAAQ,GAAG,YAAY,GAAG,KAAK,CAAC,GAClDwG,WAAW;YACjB,CAAC,CAAC;;;QAKN,IAAID,QAAQ,CAACvG,IAAI,IAAI,QAAQ,EAAE;UAC7BoC,KAAK,GAAGkE,gBAAgB,CAACC,QAAQ,EAAEC,WAAW,EAAEzE,GAAG,CAAC;SACrD,MAAM,IAAIwE,QAAQ,CAACvG,IAAI,IAAI,QAAQ,EAAE;UACpCoC,KAAK,GAAGsG,gBAAgB,CAACnC,QAAQ,EAAExE,GAAG,CAAC;UACvCK,KAAK,CAACuJ,UAAU,CAAC7B,OAAO,CAAC/E,MAAM,GAAG+E,OAAO,CAAC/E,MAAM,CAACQ,UAAU,KAAK,MAAM,GAAG,IAAI,CAAC;UAC9EwE,IAAI,CAACtE,EAAE,CAAC,mBAAmB,EAAEoE,2BAA2B,CAAC+B,IAAI,CAAAC,MAAA,EAAO/B,OAAO,EAAE1H,KAAK,EAAE2H,IAAI,CAAC,CAAC;UAC1FF,2BAA2B,CAACC,OAAO,EAAE1H,KAAK,EAAE2H,IAAI,CAAC;SAClD,MAAM,IAAIxD,QAAQ,CAACvG,IAAI,IAAI,SAAS,EAAE;UACrCoC,KAAK,GAAGkH,iBAAiB,CAAC/C,QAAQ,EAAEvE,IAAI,CAAC;;QAE3CsJ,UAAU,GAAGrG,EAAE;QACf,IAAI7C,KAAK,EAAE;UACTA,KAAK,CAACmG,GAAG,CAAC,eAAe,EAAE+C,UAAU,CAAC;;;MAG1CD,QAAQ,CAACE,IAAI,CAACzB,OAAO,CAAC7E,EAAE,CAAC;;;;EA9C7B,KAAK,IAAI1F,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG4L,QAAQ,CAAC3L,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAE,EAAED,CAAC;YAAxCA,CAAC,EAAMC,EAAE;;EAiDlB4K,QAAQ,CAACmB,IAAI,CAACC,aAAa,CAACpJ,KAAK,EAAEiJ,QAAQ,EAAEhJ,OAAO,EAAEL,IAAI,EAAEnB,GAAG,CAAC,CAAC;EACjEA,GAAG,CAAC0H,GAAG,CAAC,cAAc,EAAElG,OAAO,CAAC;EAChC,OAAOG,OAAO,CAACsJ,GAAG,CAAC1B,QAAQ,CAAC;AAC9B;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2CA,eAAc,SAAU2B,IAAIA,CAAClL,GAAG,EAAEqC,KAAK;EAErC,IAAIsD,WAAW,EAAE0D,OAAO,EAAEC,IAAI,EAAEnI,IAAI,EAAEgK,OAAO;EAC7CxF,WAAW,GAAG0D,OAAO,GAAGC,IAAI,GAAGnI,IAAI,GAAG,EAAE;EAExC,IAAI,OAAOnB,GAAG,KAAK,QAAQ,IAAIA,GAAG,YAAYoL,WAAW,EAAE;IACzDpL,GAAG,GAAG,IAAI5C,GAAG,CAAC;MACZiO,MAAM,EAAErL;KACT,CAAC;;EAGJ,IAAI,OAAOqC,KAAK,KAAK,QAAQ,EAAE;IAC7B,IAAMnC,KAAK,GAAGmC,KAAK,CAACjD,KAAK,CAAC4B,WAAW,CAAC;IACtC,IAAId,KAAK,EAAE;MACTmJ,OAAO,GAAGnJ,KAAK,CAAC,CAAC,CAAC;MAClByF,WAAW,GAAGzF,KAAK,CAACtB,MAAM,GAAG,CAAC,GAAGsB,KAAK,CAAC,CAAC,CAAC,GAAG,EAAE;;IAEhDiL,OAAO,GAAG,IAAIxJ,OAAO,CAAC,UAASC,OAAO,EAAEC,MAAM;MAC5CiB,KAAK,CAACT,KAAK,EAAE;QACXU,WAAW,EAAE;OACd,CAAC,CACCC,IAAI,CAAC,UAASC,QAAQ;QACrB,OAAOA,QAAQ,CAACE,IAAI,EAAE;MACxB,CAAC,CAAC,CACDH,IAAI,CAAC,UAASxB,OAAO;QACpB,IAAM8J,CAAC,GAAG,gCAAkC7M,QAAQ,CAACkC,aAAa,CAAC,GAAG,CAAE;QACxE2K,CAAC,CAAC1K,IAAI,GAAGyB,KAAK;QACd,IAAMzB,IAAI,GAAG0K,CAAC,CAAC1K,IAAI;QACnBO,IAAI,GAAGmK,CAAC,CAACC,QAAQ,CAACpL,KAAK,CAAC,GAAG,CAAC,CAACC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG;QACzDiJ,IAAI,GAAG1I,IAAI,CAAC4K,MAAM,CAAC,CAAC,EAAE5K,IAAI,CAACL,OAAO,CAACY,IAAI,CAAC,CAAC;QAEzCiI,YAAY,CAAC5H,OAAO,EAAExB,GAAG,EAAEqJ,OAAO,EAAEC,IAAI,EAAEnI,IAAI,EAAEwE,WAAW,CAAC,CACzD3C,IAAI,CAAC;UACJpB,OAAO,CAAC5B,GAAG,CAAC;QACd,CAAC,CAAC,CACDyD,KAAK,CAAC5B,MAAM,CAAC;MAClB,CAAC,CAAC,CACD4B,KAAK,CAAC,UAASC,GAAG;QACjB7B,MAAM,CAAC,IAAII,KAAK,CAAC,oBAAkBI,KAAK,UAAKqB,GAAG,CAACC,OAAS,CAAC,CAAC;MAC9D,CAAC,CAAC;IACN,CAAC,CAAC;GACH,MAAM;IACLwH,OAAO,GAAG,IAAIxJ,OAAO,CAAC,UAASC,OAAO,EAAEC,MAAM;MAC5CuH,YAAY,CAAC/G,KAAK,EAAErC,GAAG,CAAC,CACrBgD,IAAI,CAAC;QACJpB,OAAO,CAAC5B,GAAG,CAAC;MACd,CAAC,CAAC,CACDyD,KAAK,CAAC5B,MAAM,CAAC;IAClB,CAAC,CAAC;;EAGJ,OAAOsJ,OAAO;AAChB;AAEA;;;;;;;;;;;;;;;;;;;;;AAqBA,OAAM,SAAUM,KAAKA,CAACzL,GAAG,EAAEqC,KAAK;EAC9B,IAAI,OAAOrC,GAAG,KAAK,QAAQ,IAAIA,GAAG,YAAYoL,WAAW,EAAE;IACzDpL,GAAG,GAAG,IAAI5C,GAAG,CAAC;MACZiO,MAAM,EAAErL;KACT,CAAC;;EAEJ0L,UAAU,CAAC;IACTR,IAAI,CAAClL,GAAG,EAAEqC,KAAK,CAAC;EAClB,CAAC,EAAE,CAAC,CAAC;EACL,OAAOrC,GAAG;AACZ;AAGA;;;;;;;;;;;;;;;;;AAiBA,SAAS2K,aAAaA,CAACpJ,KAAK,EAAEiJ,QAAQ,EAAEhJ,OAAO,EAAEL,IAAI,EAAEnB,GAAG;EACxD,IAAI6G,OAAO,GAAG,EAAE;EAChB,IAAIE,OAAO,GAAG,CAAC;EACf,IAAMwD,QAAQ,GAAG/I,OAAO,CAACsD,MAAM;EAC/B,KAAK,IAAIpG,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG4L,QAAQ,CAAC3L,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAE,EAAED,CAAC,EAAE;IACjD,IAAMuK,OAAO,GAAGsB,QAAQ,CAAC7L,CAAC,CAAC;IAC3B,IAAI8L,QAAQ,CAACjK,OAAO,CAAC0I,OAAO,CAAC7E,EAAE,CAAC,KAAK,CAAC,CAAC,EAAE;MACvCyC,OAAO,GAAGmD,IAAI,CAAC2B,GAAG,CAAC,SAAS,IAAI1C,OAAO,GAAGA,OAAO,CAACnC,OAAO,GAAG,CAAC,EAAED,OAAO,CAAC;MACvEE,OAAO,GAAGiD,IAAI,CAAC4B,GAAG,CAAC,SAAS,IAAI3C,OAAO,GAAGA,OAAO,CAACjC,OAAO,GAAG,EAAE,EAAED,OAAO,CAAC;;;EAG5E,OAAO,IAAIpF,OAAO,CAAC,UAASC,OAAO,EAAEC,MAAM;IACzC,IAAMY,QAAQ,GAAG,SAAXA,QAAQA,CAAA,EAAG;MACf,IAAMhB,MAAM,GAAGF,KAAK,CAACsK,SAAS,EAAE;MAChC,IAAI,CAACpK,MAAM,IAAIA,MAAM,CAAC2E,QAAQ,EAAE,KAAK,OAAO,EAAE;QAC5CvE,MAAM,CAAC,IAAII,KAAK,CAAC,kCAAkC,GAAGV,KAAK,CAAC0F,GAAG,CAAC,eAAe,CAAC,CAAC,CAAC;QAClF;;MAEF,IAAI,OAAOxF,MAAM,CAACkF,WAAW,KAAK,UAAU,EAAE;QAC5C,IAAMD,QAAQ,GAAGjF,MAAM,CAACkF,WAAW,EAAE;QACrC,IAAID,QAAQ,EAAE;UACZ,IAAMoF,aAAa,GAAGpF,QAAQ,CAACqF,UAAU,EAAE;UAC3C,IAAIlF,OAAO,GAAG,CAAC,IAAIiF,aAAa,GAAG,CAAC,EAAE;YACpCvK,KAAK,CAACyK,gBAAgB,CAAChC,IAAI,CAAC2B,GAAG,CAAC1N,kBAAkB,CAAC4I,OAAO,CAAC,EAAEH,QAAQ,CAACuF,aAAa,CAACH,aAAa,CAAC,CAAC,GAAG,IAAI,CAAC;;UAE7G,IAAI/E,OAAO,GAAG,EAAE,EAAE;YAChBxF,KAAK,CAAC2K,gBAAgB,CAACjO,kBAAkB,CAAC8I,OAAO,CAAC,GAAG,IAAI,CAAC;;;;MAIhE,IAAItF,MAAM,YAAY5D,YAAY,IAAI4D,MAAM,YAAY3D,gBAAgB,EAAE;QACxEwD,UAAU,EAAC,sFAAwFC,KAAK,EAAGC,OAAO,EAAEgJ,QAAQ,EAAErJ,IAAI,CAAC,CAAC6B,IAAI,CAAC;UACvIzB,KAAK,CAACuJ,UAAU,CAAC,IAAI,CAAC;UACtBlJ,OAAO,EAAE;QACX,CAAC,EAAE,UAASrC,CAAC;UACXsC,MAAM,CAACtC,CAAC,CAAC;QACX,CAAC,CAAC;OACH,MAAM;QACLqC,OAAO,EAAE;;IAEb,CAAC;IAEDL,KAAK,CAACmG,GAAG,CAAC,eAAe,EAAE8C,QAAQ,CAAC;IACpC,IAAIxK,GAAG,CAACmM,SAAS,EAAE,CAACC,QAAQ,EAAE,CAAC7L,OAAO,CAACgB,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE;MACpDvB,GAAG,CAACqM,QAAQ,CAAC9K,KAAK,CAAC;;IAGrB,IAAIA,KAAK,CAACsK,SAAS,EAAE,EAAE;MACrBpJ,QAAQ,EAAE;KACX,MAAM;MACLlB,KAAK,CAAC+K,IAAI,CAAC,eAAe,EAAE7J,QAAQ,CAAC;;EAEzC,CAAC,CAAC;AACJ;AAGA;;;;;;;;;;;AAWA,OAAM,SAAU8J,QAAQA,CAACvM,GAAG,EAAEwM,OAAO;EACnC,IAAM1H,MAAM,GAAG9E,GAAG,CAACmM,SAAS,EAAE,CAACC,QAAQ,EAAE;EACzC,KAAK,IAAI1N,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGmG,MAAM,CAAClG,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAE,EAAED,CAAC,EAAE;IAC/C,IAAM+N,YAAY,GAAG3H,MAAM,CAACpG,CAAC,CAAC,CAACuI,GAAG,CAAC,eAAe,CAAC;IACnD,IAAIwF,YAAY,IAAIA,YAAY,CAAClM,OAAO,CAACiM,OAAO,CAAC,KAAK,CAAC,CAAC,EAAE;MACxD,OAAO,qBAAsB1H,MAAM,CAACpG,CAAC;MAAC;;;AAG5C;AAEA;;;;;;;;;AASA,OAAM,SAAUyN,SAASA,CAACnM,GAAG,EAAEmF,QAAQ;EACrC,IAAMuH,MAAM,GAAG,EAAE;EACjB,IAAM5H,MAAM,GAAG9E,GAAG,CAACmM,SAAS,EAAE,CAACC,QAAQ,EAAE;EACzC,KAAK,IAAI1N,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGmG,MAAM,CAAClG,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAE,EAAED,CAAC,EAAE;IAC/C,IAAIoG,MAAM,CAACpG,CAAC,CAAC,CAACuI,GAAG,CAAC,eAAe,CAAC,KAAK9B,QAAQ,EAAE;MAC/CuH,MAAM,CAAChC,IAAI,EAAC,oBAAsB5F,MAAM,CAACpG,CAAC,CAAE,CAAC;;;EAGjD,OAAOgO,MAAM;AACf;AAEA;;;;;;;;;AASA,OAAM,SAAUb,SAASA,CAAC7L,GAAG,EAAEmF,QAAQ;EACrC,IAAML,MAAM,GAAG9E,GAAG,CAACmM,SAAS,EAAE,CAACC,QAAQ,EAAE;EACzC,KAAK,IAAI1N,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGmG,MAAM,CAAClG,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAE,EAAED,CAAC,EAAE;IAC/C,IAAM+C,MAAM,GAAG,oBAAsBqD,MAAM,CAACpG,CAAC,CAAC,CAAEmN,SAAS,EAAE;IAC3D,IAAI/G,MAAM,CAACpG,CAAC,CAAC,CAACuI,GAAG,CAAC,eAAe,CAAC,KAAK9B,QAAQ,EAAE;MAC/C,OAAO1D,MAAM;;;AAGnB;AAEA,SACEkJ,aAAa,IAAIgC,cAAc,EAC/BhN,QAAQ,IAAIiN,SAAS"},"metadata":{},"sourceType":"module","externalDependencies":[]}
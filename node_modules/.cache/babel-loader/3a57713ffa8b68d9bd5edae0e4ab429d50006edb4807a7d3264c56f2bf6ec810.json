{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/renderer/canvas/VectorTileLayer\n */\nimport CanvasBuilderGroup from '../../render/canvas/BuilderGroup.js';\nimport CanvasExecutorGroup, { replayDeclutter } from '../../render/canvas/ExecutorGroup.js';\nimport CanvasTileLayerRenderer from './TileLayer.js';\nimport EventType from '../../events/EventType.js';\nimport ReplayType from '../../render/canvas/BuilderType.js';\nimport TileState from '../../TileState.js';\nimport VectorTileRenderType from '../../layer/VectorTileRenderType.js';\nimport ViewHint from '../../ViewHint.js';\nimport { apply as applyTransform, create as createTransform, multiply, reset as resetTransform, scale, scale as scaleTransform, translate as translateTransform } from '../../transform.js';\nimport { buffer, containsCoordinate, containsExtent, equals, getIntersection, getTopLeft, intersects } from '../../extent.js';\nimport { clear } from '../../obj.js';\nimport { createHitDetectionImageData, hitDetect } from '../../render/canvas/hitdetect.js';\nimport { getSquaredTolerance as getSquaredRenderTolerance, renderFeature } from '../vector.js';\nimport { getUid } from '../../util.js';\nimport { listen, unlistenByKey } from '../../events.js';\nimport { toSize } from '../../size.js';\nimport { wrapX } from '../../coordinate.js';\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas/BuilderType.js\").default>>}\n */\nvar IMAGE_REPLAYS = {\n  'image': [ReplayType.POLYGON, ReplayType.CIRCLE, ReplayType.LINE_STRING, ReplayType.IMAGE, ReplayType.TEXT],\n  'hybrid': [ReplayType.POLYGON, ReplayType.LINE_STRING],\n  'vector': []\n};\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas/BuilderType.js\").default>>}\n */\nvar VECTOR_REPLAYS = {\n  'image': [ReplayType.DEFAULT],\n  'hybrid': [ReplayType.IMAGE, ReplayType.TEXT, ReplayType.DEFAULT],\n  'vector': [ReplayType.POLYGON, ReplayType.CIRCLE, ReplayType.LINE_STRING, ReplayType.IMAGE, ReplayType.TEXT, ReplayType.DEFAULT]\n};\n/**\n * @classdesc\n * Canvas renderer for vector tile layers.\n * @api\n */\nvar CanvasVectorTileLayerRenderer = /** @class */function (_super) {\n  __extends(CanvasVectorTileLayerRenderer, _super);\n  /**\n   * @param {import(\"../../layer/VectorTile.js\").default} layer VectorTile layer.\n   */\n  function CanvasVectorTileLayerRenderer(layer) {\n    var _this = _super.call(this, layer) || this;\n    /** @private */\n    _this.boundHandleStyleImageChange_ = _this.handleStyleImageChange_.bind(_this);\n    /**\n     * @private\n     * @type {boolean}\n     */\n    _this.dirty_ = false;\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.renderedLayerRevision_;\n    /**\n     * @private\n     * @type {import(\"../../transform\").Transform}\n     */\n    _this.renderedPixelToCoordinateTransform_ = null;\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.renderedRotation_;\n    /**\n     * @private\n     * @type {!Object<string, import(\"../../VectorRenderTile.js\").default>}\n     */\n    _this.renderTileImageQueue_ = {};\n    /**\n     * @type {Object<string, import(\"../../events.js\").EventsKey>}\n     */\n    _this.tileListenerKeys_ = {};\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    _this.tmpTransform_ = createTransform();\n    return _this;\n  }\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection\").default} projection Projection.\n   * @param {boolean} queue Queue tile for rendering.\n   * @return {boolean|undefined} Tile needs to be rendered.\n   */\n  CanvasVectorTileLayerRenderer.prototype.prepareTile = function (tile, pixelRatio, projection, queue) {\n    var render;\n    var tileUid = getUid(tile);\n    var state = tile.getState();\n    if ((state === TileState.LOADED && tile.hifi || state === TileState.ERROR) && tileUid in this.tileListenerKeys_) {\n      unlistenByKey(this.tileListenerKeys_[tileUid]);\n      delete this.tileListenerKeys_[tileUid];\n    }\n    if (state === TileState.LOADED || state === TileState.ERROR) {\n      this.updateExecutorGroup_(tile, pixelRatio, projection);\n      if (this.tileImageNeedsRender_(tile, pixelRatio, projection)) {\n        render = true;\n        if (queue) {\n          this.renderTileImageQueue_[tileUid] = tile;\n        }\n      }\n    }\n    return render;\n  };\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {!import(\"../../Tile.js\").default} Tile.\n   */\n  CanvasVectorTileLayerRenderer.prototype.getTile = function (z, x, y, frameState) {\n    var pixelRatio = frameState.pixelRatio;\n    var viewState = frameState.viewState;\n    var resolution = viewState.resolution;\n    var projection = viewState.projection;\n    var layer = this.getLayer();\n    var tile = layer.getSource().getTile(z, x, y, pixelRatio, projection);\n    if (tile.getState() < TileState.LOADED) {\n      tile.wantedResolution = resolution;\n      var tileUid = getUid(tile);\n      if (!(tileUid in this.tileListenerKeys_)) {\n        var listenerKey = listen(tile, EventType.CHANGE, this.prepareTile.bind(this, tile, pixelRatio, projection, true));\n        this.tileListenerKeys_[tileUid] = listenerKey;\n      }\n    } else {\n      var viewHints = frameState.viewHints;\n      var hifi = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);\n      if (hifi || !tile.wantedResolution) {\n        tile.wantedResolution = resolution;\n      }\n      var render = this.prepareTile(tile, pixelRatio, projection, false);\n      if (render && layer.getRenderMode() !== VectorTileRenderType.VECTOR) {\n        this.renderTileImage_(tile, frameState);\n      }\n    }\n    return _super.prototype.getTile.call(this, z, x, y, frameState);\n  };\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n  CanvasVectorTileLayerRenderer.prototype.isDrawableTile = function (tile) {\n    var layer = this.getLayer();\n    return _super.prototype.isDrawableTile.call(this, tile) && (layer.getRenderMode() === VectorTileRenderType.VECTOR ? getUid(layer) in tile.executorGroups : tile.hasContext(layer));\n  };\n  /**\n   * @inheritDoc\n   */\n  CanvasVectorTileLayerRenderer.prototype.getTileImage = function (tile) {\n    return tile.getImage(this.getLayer());\n  };\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  CanvasVectorTileLayerRenderer.prototype.prepareFrame = function (frameState) {\n    var layerRevision = this.getLayer().getRevision();\n    if (this.renderedLayerRevision_ != layerRevision) {\n      this.renderedTiles.length = 0;\n    }\n    this.renderedLayerRevision_ = layerRevision;\n    return _super.prototype.prepareFrame.call(this, frameState);\n  };\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @private\n   */\n  CanvasVectorTileLayerRenderer.prototype.updateExecutorGroup_ = function (tile, pixelRatio, projection) {\n    var layer = /** @type {import(\"../../layer/VectorTile.js\").default} */this.getLayer();\n    var revision = layer.getRevision();\n    var renderOrder = layer.getRenderOrder() || null;\n    var resolution = tile.wantedResolution;\n    var builderState = tile.getReplayState(layer);\n    if (!builderState.dirty && builderState.renderedResolution === resolution && builderState.renderedRevision == revision && builderState.renderedRenderOrder == renderOrder && builderState.renderedZ === tile.sourceZ) {\n      return;\n    }\n    var source = layer.getSource();\n    var sourceTileGrid = source.getTileGrid();\n    var tileGrid = source.getTileGridForProjection(projection);\n    var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n    var sourceTiles = source.getSourceTiles(pixelRatio, projection, tile);\n    var layerUid = getUid(layer);\n    delete tile.hitDetectionImageData[layerUid];\n    tile.executorGroups[layerUid] = [];\n    var _loop_1 = function (t, tt) {\n      var sourceTile = sourceTiles[t];\n      if (sourceTile.getState() != TileState.LOADED) {\n        return \"continue\";\n      }\n      var sourceTileCoord = sourceTile.tileCoord;\n      var sourceTileExtent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n      var sharedExtent = getIntersection(tileExtent, sourceTileExtent);\n      var bufferedExtent = equals(sourceTileExtent, sharedExtent) ? null : buffer(sharedExtent, layer.getRenderBuffer() * resolution, this_1.tmpExtent);\n      builderState.dirty = false;\n      var builderGroup = new CanvasBuilderGroup(0, sharedExtent, resolution, pixelRatio, layer.getDeclutter());\n      var squaredTolerance = getSquaredRenderTolerance(resolution, pixelRatio);\n      /**\n       * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n       * @this {CanvasVectorTileLayerRenderer}\n       */\n      var render = function (feature) {\n        var styles;\n        var styleFunction = feature.getStyleFunction() || layer.getStyleFunction();\n        if (styleFunction) {\n          styles = styleFunction(feature, resolution);\n        }\n        if (styles) {\n          var dirty = this.renderFeature(feature, squaredTolerance, styles, builderGroup);\n          this.dirty_ = this.dirty_ || dirty;\n          builderState.dirty = builderState.dirty || dirty;\n        }\n      };\n      var features = sourceTile.getFeatures();\n      if (renderOrder && renderOrder !== builderState.renderedRenderOrder) {\n        features.sort(renderOrder);\n      }\n      for (var i = 0, ii = features.length; i < ii; ++i) {\n        var feature = features[i];\n        if (!bufferedExtent || intersects(bufferedExtent, feature.getGeometry().getExtent())) {\n          render.call(this_1, feature);\n        }\n      }\n      var executorGroupInstructions = builderGroup.finish();\n      // no need to clip when the render tile is covered by a single source tile\n      var replayExtent = layer.getRenderMode() !== VectorTileRenderType.VECTOR && layer.getDeclutter() && sourceTiles.length === 1 ? null : sharedExtent;\n      var renderingReplayGroup = new CanvasExecutorGroup(replayExtent, resolution, pixelRatio, source.getOverlaps(), executorGroupInstructions, layer.getRenderBuffer());\n      tile.executorGroups[layerUid].push(renderingReplayGroup);\n    };\n    var this_1 = this;\n    for (var t = 0, tt = sourceTiles.length; t < tt; ++t) {\n      _loop_1(t, tt);\n    }\n    builderState.renderedRevision = revision;\n    builderState.renderedZ = tile.sourceZ;\n    builderState.renderedRenderOrder = renderOrder;\n    builderState.renderedResolution = resolution;\n  };\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {function(import(\"../../Feature.js\").FeatureLike, import(\"../../layer/Layer.js\").default): T} callback Feature callback.\n   * @param {Array<import(\"../../Feature.js\").FeatureLike>} declutteredFeatures Decluttered features.\n   * @return {T|void} Callback result.\n   * @template T\n   */\n  CanvasVectorTileLayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, declutteredFeatures) {\n    var resolution = frameState.viewState.resolution;\n    var rotation = frameState.viewState.rotation;\n    hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;\n    var layer = this.getLayer();\n    var declutter = layer.getDeclutter();\n    var source = layer.getSource();\n    var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);\n    /** @type {!Object<string, boolean>} */\n    var features = {};\n    var renderedTiles = /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */this.renderedTiles;\n    var found;\n    var i, ii;\n    var _loop_2 = function () {\n      var tile = renderedTiles[i];\n      var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      var tileContainsCoordinate = containsCoordinate(tileExtent, coordinate);\n      if (!declutter) {\n        // When not decluttering, we only need to consider the tile that contains the given\n        // coordinate, because each feature will be rendered for each tile that contains it.\n        if (!tileContainsCoordinate) {\n          return \"continue\";\n        }\n      }\n      var executorGroups = tile.executorGroups[getUid(layer)];\n      for (var t = 0, tt = executorGroups.length; t < tt; ++t) {\n        var executorGroup = executorGroups[t];\n        found = found || executorGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance,\n        /**\n         * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n         * @return {?} Callback result.\n         */\n        function (feature) {\n          if (tileContainsCoordinate || declutteredFeatures && declutteredFeatures.indexOf(feature) !== -1) {\n            var key = feature.getId();\n            if (key === undefined) {\n              key = getUid(feature);\n            }\n            if (!(key in features)) {\n              features[key] = true;\n              return callback(feature, layer);\n            }\n          }\n        }, layer.getDeclutter() ? declutteredFeatures : null);\n      }\n    };\n    for (i = 0, ii = renderedTiles.length; i < ii; ++i) {\n      _loop_2();\n    }\n    return found;\n  };\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../../Feature\").default>>} Promise that resolves with an array of features.\n   */\n  CanvasVectorTileLayerRenderer.prototype.getFeatures = function (pixel) {\n    return new Promise(function (resolve, reject) {\n      var layer = /** @type {import(\"../../layer/VectorTile.js\").default} */this.getLayer();\n      var layerUid = getUid(layer);\n      var source = layer.getSource();\n      var projection = this.renderedProjection;\n      var projectionExtent = projection.getExtent();\n      var resolution = this.renderedResolution;\n      var tileGrid = source.getTileGridForProjection(projection);\n      var coordinate = applyTransform(this.renderedPixelToCoordinateTransform_, pixel.slice());\n      var tileCoord = tileGrid.getTileCoordForCoordAndResolution(coordinate, resolution);\n      var tile;\n      for (var i = 0, ii = this.renderedTiles.length; i < ii; ++i) {\n        if (tileCoord.toString() === this.renderedTiles[i].tileCoord.toString()) {\n          tile = this.renderedTiles[i];\n          if (tile.getState() === TileState.LOADED && tile.hifi) {\n            var extent_1 = tileGrid.getTileCoordExtent(tile.tileCoord);\n            if (source.getWrapX() && projection.canWrapX() && !containsExtent(projectionExtent, extent_1)) {\n              wrapX(coordinate, projection);\n            }\n            break;\n          }\n          tile = undefined;\n        }\n      }\n      if (!tile || tile.loadingSourceTiles > 0) {\n        resolve([]);\n        return;\n      }\n      var extent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      var corner = getTopLeft(extent);\n      var tilePixel = [(coordinate[0] - corner[0]) / resolution, (corner[1] - coordinate[1]) / resolution];\n      var features = tile.getSourceTiles().reduce(function (accumulator, sourceTile) {\n        return accumulator.concat(sourceTile.getFeatures());\n      }, []);\n      var hitDetectionImageData = tile.hitDetectionImageData[layerUid];\n      if (!hitDetectionImageData && !this.animatingOrInteracting_) {\n        var tileSize = toSize(tileGrid.getTileSize(tileGrid.getZForResolution(resolution)));\n        var size = [tileSize[0] / 2, tileSize[1] / 2];\n        var rotation = this.renderedRotation_;\n        var transforms = [this.getRenderTransform(tileGrid.getTileCoordCenter(tile.wrappedTileCoord), resolution, 0, 0.5, size[0], size[1], 0)];\n        hitDetectionImageData = createHitDetectionImageData(tileSize, transforms, features, layer.getStyleFunction(), tileGrid.getTileCoordExtent(tile.wrappedTileCoord), tile.getReplayState(layer).renderedResolution, rotation);\n        tile.hitDetectionImageData[layerUid] = hitDetectionImageData;\n      }\n      resolve(hitDetect(tilePixel, features, hitDetectionImageData));\n    }.bind(this));\n  };\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   */\n  CanvasVectorTileLayerRenderer.prototype.handleFontsChanged = function () {\n    clear(this.renderTileImageQueue_);\n    var layer = this.getLayer();\n    if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {\n      layer.changed();\n    }\n  };\n  /**\n   * Handle changes in image style state.\n   * @param {import(\"../../events/Event.js\").default} event Image style change event.\n   * @private\n   */\n  CanvasVectorTileLayerRenderer.prototype.handleStyleImageChange_ = function (event) {\n    this.renderIfReadyAndVisible();\n  };\n  /**\n   * Render the layer.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n  CanvasVectorTileLayerRenderer.prototype.renderFrame = function (frameState, target) {\n    var viewHints = frameState.viewHints;\n    var hifi = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);\n    this.renderQueuedTileImages_(hifi, frameState);\n    _super.prototype.renderFrame.call(this, frameState, target);\n    this.renderedPixelToCoordinateTransform_ = frameState.pixelToCoordinateTransform.slice();\n    this.renderedRotation_ = frameState.viewState.rotation;\n    var layer = /** @type {import(\"../../layer/VectorTile.js\").default} */this.getLayer();\n    var renderMode = layer.getRenderMode();\n    if (renderMode === VectorTileRenderType.IMAGE) {\n      return this.container;\n    }\n    var source = layer.getSource();\n    // Unqueue tiles from the image queue when we don't need any more\n    var usedTiles = frameState.usedTiles[getUid(source)];\n    for (var tileUid in this.renderTileImageQueue_) {\n      if (!usedTiles || !(tileUid in usedTiles)) {\n        delete this.renderTileImageQueue_[tileUid];\n      }\n    }\n    var context = this.context;\n    var declutterReplays = layer.getDeclutter() ? {} : null;\n    var replayTypes = VECTOR_REPLAYS[renderMode];\n    var pixelRatio = frameState.pixelRatio;\n    var viewState = frameState.viewState;\n    var center = viewState.center;\n    var resolution = viewState.resolution;\n    var rotation = viewState.rotation;\n    var size = frameState.size;\n    var width = Math.round(size[0] * pixelRatio);\n    var height = Math.round(size[1] * pixelRatio);\n    var tiles = this.renderedTiles;\n    var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);\n    var clips = [];\n    var clipZs = [];\n    for (var i = tiles.length - 1; i >= 0; --i) {\n      var tile = /** @type {import(\"../../VectorRenderTile.js\").default} */tiles[i];\n      var tileCoord = tile.tileCoord;\n      var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      var worldOffset = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent)[0] - tileExtent[0];\n      var transform = multiply(scale(this.inversePixelTransform.slice(), 1 / pixelRatio, 1 / pixelRatio), this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, worldOffset));\n      var executorGroups = tile.executorGroups[getUid(layer)];\n      var clipped = false;\n      for (var t = 0, tt = executorGroups.length; t < tt; ++t) {\n        var executorGroup = executorGroups[t];\n        if (!executorGroup.hasExecutors(replayTypes)) {\n          // sourceTile has no instructions of the types we want to render\n          continue;\n        }\n        var currentZ = tile.tileCoord[0];\n        var currentClip = void 0;\n        if (!declutterReplays && !clipped) {\n          currentClip = executorGroup.getClipCoords(transform);\n          context.save();\n          // Create a clip mask for regions in this low resolution tile that are\n          // already filled by a higher resolution tile\n          for (var j = 0, jj = clips.length; j < jj; ++j) {\n            var clip = clips[j];\n            if (currentZ < clipZs[j]) {\n              context.beginPath();\n              // counter-clockwise (outer ring) for current tile\n              context.moveTo(currentClip[0], currentClip[1]);\n              context.lineTo(currentClip[2], currentClip[3]);\n              context.lineTo(currentClip[4], currentClip[5]);\n              context.lineTo(currentClip[6], currentClip[7]);\n              // clockwise (inner ring) for higher resolution tile\n              context.moveTo(clip[6], clip[7]);\n              context.lineTo(clip[4], clip[5]);\n              context.lineTo(clip[2], clip[3]);\n              context.lineTo(clip[0], clip[1]);\n              context.clip();\n            }\n          }\n        }\n        executorGroup.execute(context, 1, transform, rotation, hifi, replayTypes, declutterReplays);\n        if (!declutterReplays && !clipped) {\n          context.restore();\n          clips.push(currentClip);\n          clipZs.push(currentZ);\n          clipped = true;\n        }\n      }\n    }\n    if (declutterReplays) {\n      var layerState = frameState.layerStatesArray[frameState.layerIndex];\n      replayDeclutter(declutterReplays, context, rotation, layerState.opacity, hifi, frameState.declutterItems);\n    }\n    return this.container;\n  };\n  /**\n   * @param {boolean} hifi We have time to render a high fidelity map image.\n   * @param {import('../../PluggableMap.js').FrameState} frameState Frame state.\n   */\n  CanvasVectorTileLayerRenderer.prototype.renderQueuedTileImages_ = function (hifi, frameState) {\n    // When we don't have time to render hifi, only render tiles until we have used up\n    // half of the frame budget of 16 ms\n    for (var uid in this.renderTileImageQueue_) {\n      if (!hifi && Date.now() - frameState.time > 8) {\n        frameState.animate = true;\n        break;\n      }\n      var tile = this.renderTileImageQueue_[uid];\n      delete this.renderTileImageQueue_[uid];\n      this.renderTileImage_(tile, frameState);\n    }\n  };\n  /**\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n   * @param {import(\"../../render/canvas/BuilderGroup.js\").default} executorGroup Replay group.\n   * @return {boolean} `true` if an image is loading.\n   */\n  CanvasVectorTileLayerRenderer.prototype.renderFeature = function (feature, squaredTolerance, styles, executorGroup) {\n    if (!styles) {\n      return false;\n    }\n    var loading = false;\n    if (Array.isArray(styles)) {\n      for (var i = 0, ii = styles.length; i < ii; ++i) {\n        loading = renderFeature(executorGroup, feature, styles[i], squaredTolerance, this.boundHandleStyleImageChange_) || loading;\n      }\n    } else {\n      loading = renderFeature(executorGroup, feature, styles, squaredTolerance, this.boundHandleStyleImageChange_);\n    }\n    return loading;\n  };\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @return {boolean} A new tile image was rendered.\n   * @private\n   */\n  CanvasVectorTileLayerRenderer.prototype.tileImageNeedsRender_ = function (tile, pixelRatio, projection) {\n    var layer = /** @type {import(\"../../layer/VectorTile.js\").default} */this.getLayer();\n    var replayState = tile.getReplayState(layer);\n    var revision = layer.getRevision();\n    var sourceZ = tile.sourceZ;\n    var resolution = tile.wantedResolution;\n    return replayState.renderedTileResolution !== resolution || replayState.renderedTileRevision !== revision || replayState.renderedTileZ !== sourceZ;\n  };\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {import(\"../../PluggableMap\").FrameState} frameState Frame state.\n   * @private\n   */\n  CanvasVectorTileLayerRenderer.prototype.renderTileImage_ = function (tile, frameState) {\n    var layer = /** @type {import(\"../../layer/VectorTile.js\").default} */this.getLayer();\n    var replayState = tile.getReplayState(layer);\n    var revision = layer.getRevision();\n    var executorGroups = tile.executorGroups[getUid(layer)];\n    replayState.renderedTileRevision = revision;\n    replayState.renderedTileZ = tile.sourceZ;\n    var tileCoord = tile.wrappedTileCoord;\n    var z = tileCoord[0];\n    var source = layer.getSource();\n    var pixelRatio = frameState.pixelRatio;\n    var viewState = frameState.viewState;\n    var projection = viewState.projection;\n    var tileGrid = source.getTileGridForProjection(projection);\n    var tileResolution = tileGrid.getResolution(tile.tileCoord[0]);\n    var renderPixelRatio = frameState.pixelRatio / tile.wantedResolution * tileResolution;\n    var resolution = tileGrid.getResolution(z);\n    var context = tile.getContext(layer);\n    // Increase tile size when overzooming for low pixel ratio, to avoid blurry tiles\n    pixelRatio = Math.max(pixelRatio, renderPixelRatio / pixelRatio);\n    var size = source.getTilePixelSize(z, pixelRatio, projection);\n    context.canvas.width = size[0];\n    context.canvas.height = size[1];\n    var renderScale = pixelRatio / renderPixelRatio;\n    if (renderScale !== 1) {\n      var canvasTransform = resetTransform(this.tmpTransform_);\n      scaleTransform(canvasTransform, renderScale, renderScale);\n      context.setTransform.apply(context, canvasTransform);\n    }\n    var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);\n    var pixelScale = renderPixelRatio / resolution;\n    var transform = resetTransform(this.tmpTransform_);\n    scaleTransform(transform, pixelScale, -pixelScale);\n    translateTransform(transform, -tileExtent[0], -tileExtent[3]);\n    for (var i = 0, ii = executorGroups.length; i < ii; ++i) {\n      var executorGroup = executorGroups[i];\n      executorGroup.execute(context, renderScale, transform, 0, true, IMAGE_REPLAYS[layer.getRenderMode()]);\n    }\n    replayState.renderedTileResolution = tile.wantedResolution;\n  };\n  return CanvasVectorTileLayerRenderer;\n}(CanvasTileLayerRenderer);\nexport default CanvasVectorTileLayerRenderer;","map":{"version":3,"names":["CanvasBuilderGroup","CanvasExecutorGroup","replayDeclutter","CanvasTileLayerRenderer","EventType","ReplayType","TileState","VectorTileRenderType","ViewHint","apply","applyTransform","create","createTransform","multiply","reset","resetTransform","scale","scaleTransform","translate","translateTransform","buffer","containsCoordinate","containsExtent","equals","getIntersection","getTopLeft","intersects","clear","createHitDetectionImageData","hitDetect","getSquaredTolerance","getSquaredRenderTolerance","renderFeature","getUid","listen","unlistenByKey","toSize","wrapX","IMAGE_REPLAYS","POLYGON","CIRCLE","LINE_STRING","IMAGE","TEXT","VECTOR_REPLAYS","DEFAULT","CanvasVectorTileLayerRenderer","_super","__extends","layer","_this","call","boundHandleStyleImageChange_","handleStyleImageChange_","bind","dirty_","renderedLayerRevision_","renderedPixelToCoordinateTransform_","renderedRotation_","renderTileImageQueue_","tileListenerKeys_","tmpTransform_","prototype","prepareTile","tile","pixelRatio","projection","queue","render","tileUid","state","getState","LOADED","hifi","ERROR","updateExecutorGroup_","tileImageNeedsRender_","getTile","z","x","y","frameState","viewState","resolution","getLayer","getSource","wantedResolution","listenerKey","CHANGE","viewHints","ANIMATING","INTERACTING","getRenderMode","VECTOR","renderTileImage_","isDrawableTile","executorGroups","hasContext","getTileImage","getImage","prepareFrame","layerRevision","getRevision","renderedTiles","length","revision","renderOrder","getRenderOrder","builderState","getReplayState","dirty","renderedResolution","renderedRevision","renderedRenderOrder","renderedZ","sourceZ","source","sourceTileGrid","getTileGrid","tileGrid","getTileGridForProjection","tileExtent","getTileCoordExtent","wrappedTileCoord","sourceTiles","getSourceTiles","layerUid","hitDetectionImageData","t","tt","sourceTile","sourceTileCoord","tileCoord","sourceTileExtent","sharedExtent","bufferedExtent","getRenderBuffer","this_1","tmpExtent","builderGroup","getDeclutter","squaredTolerance","feature","styles","styleFunction","getStyleFunction","features","getFeatures","sort","i","ii","getGeometry","getExtent","executorGroupInstructions","finish","replayExtent","renderingReplayGroup","getOverlaps","push","forEachFeatureAtCoordinate","coordinate","hitTolerance","callback","declutteredFeatures","rotation","undefined","declutter","found","tileContainsCoordinate","executorGroup","indexOf","key","getId","pixel","Promise","resolve","reject","renderedProjection","projectionExtent","slice","getTileCoordForCoordAndResolution","toString","extent_1","getWrapX","canWrapX","loadingSourceTiles","extent","corner","tilePixel","reduce","accumulator","concat","animatingOrInteracting_","tileSize","getTileSize","getZForResolution","size","transforms","getRenderTransform","getTileCoordCenter","handleFontsChanged","getVisible","changed","event","renderIfReadyAndVisible","renderFrame","target","renderQueuedTileImages_","pixelToCoordinateTransform","renderMode","container","usedTiles","context","declutterReplays","replayTypes","center","width","Math","round","height","tiles","clips","clipZs","worldOffset","transform","inversePixelTransform","clipped","hasExecutors","currentZ","currentClip","getClipCoords","save","j","jj","clip","beginPath","moveTo","lineTo","execute","restore","layerState","layerStatesArray","layerIndex","opacity","declutterItems","uid","Date","now","time","animate","loading","Array","isArray","replayState","renderedTileResolution","renderedTileRevision","renderedTileZ","tileResolution","getResolution","renderPixelRatio","getContext","max","getTilePixelSize","canvas","renderScale","canvasTransform","setTransform","pixelScale"],"sources":["/Users/mariovicky/Skripsi_OpenLayers/node_modules/ol/src/renderer/canvas/VectorTileLayer.js"],"sourcesContent":["/**\n * @module ol/renderer/canvas/VectorTileLayer\n */\nimport CanvasBuilderGroup from '../../render/canvas/BuilderGroup.js';\nimport CanvasExecutorGroup, {\n  replayDeclutter,\n} from '../../render/canvas/ExecutorGroup.js';\nimport CanvasTileLayerRenderer from './TileLayer.js';\nimport EventType from '../../events/EventType.js';\nimport ReplayType from '../../render/canvas/BuilderType.js';\nimport TileState from '../../TileState.js';\nimport VectorTileRenderType from '../../layer/VectorTileRenderType.js';\nimport ViewHint from '../../ViewHint.js';\nimport {\n  apply as applyTransform,\n  create as createTransform,\n  multiply,\n  reset as resetTransform,\n  scale,\n  scale as scaleTransform,\n  translate as translateTransform,\n} from '../../transform.js';\nimport {\n  buffer,\n  containsCoordinate,\n  containsExtent,\n  equals,\n  getIntersection,\n  getTopLeft,\n  intersects,\n} from '../../extent.js';\nimport {clear} from '../../obj.js';\nimport {\n  createHitDetectionImageData,\n  hitDetect,\n} from '../../render/canvas/hitdetect.js';\nimport {\n  getSquaredTolerance as getSquaredRenderTolerance,\n  renderFeature,\n} from '../vector.js';\nimport {getUid} from '../../util.js';\nimport {listen, unlistenByKey} from '../../events.js';\nimport {toSize} from '../../size.js';\nimport {wrapX} from '../../coordinate.js';\n\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas/BuilderType.js\").default>>}\n */\nconst IMAGE_REPLAYS = {\n  'image': [\n    ReplayType.POLYGON,\n    ReplayType.CIRCLE,\n    ReplayType.LINE_STRING,\n    ReplayType.IMAGE,\n    ReplayType.TEXT,\n  ],\n  'hybrid': [ReplayType.POLYGON, ReplayType.LINE_STRING],\n  'vector': [],\n};\n\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas/BuilderType.js\").default>>}\n */\nconst VECTOR_REPLAYS = {\n  'image': [ReplayType.DEFAULT],\n  'hybrid': [ReplayType.IMAGE, ReplayType.TEXT, ReplayType.DEFAULT],\n  'vector': [\n    ReplayType.POLYGON,\n    ReplayType.CIRCLE,\n    ReplayType.LINE_STRING,\n    ReplayType.IMAGE,\n    ReplayType.TEXT,\n    ReplayType.DEFAULT,\n  ],\n};\n\n/**\n * @classdesc\n * Canvas renderer for vector tile layers.\n * @api\n */\nclass CanvasVectorTileLayerRenderer extends CanvasTileLayerRenderer {\n  /**\n   * @param {import(\"../../layer/VectorTile.js\").default} layer VectorTile layer.\n   */\n  constructor(layer) {\n    super(layer);\n\n    /** @private */\n    this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.dirty_ = false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedLayerRevision_;\n\n    /**\n     * @private\n     * @type {import(\"../../transform\").Transform}\n     */\n    this.renderedPixelToCoordinateTransform_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRotation_;\n\n    /**\n     * @private\n     * @type {!Object<string, import(\"../../VectorRenderTile.js\").default>}\n     */\n    this.renderTileImageQueue_ = {};\n\n    /**\n     * @type {Object<string, import(\"../../events.js\").EventsKey>}\n     */\n    this.tileListenerKeys_ = {};\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.tmpTransform_ = createTransform();\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection\").default} projection Projection.\n   * @param {boolean} queue Queue tile for rendering.\n   * @return {boolean|undefined} Tile needs to be rendered.\n   */\n  prepareTile(tile, pixelRatio, projection, queue) {\n    let render;\n    const tileUid = getUid(tile);\n    const state = tile.getState();\n    if (\n      ((state === TileState.LOADED && tile.hifi) ||\n        state === TileState.ERROR) &&\n      tileUid in this.tileListenerKeys_\n    ) {\n      unlistenByKey(this.tileListenerKeys_[tileUid]);\n      delete this.tileListenerKeys_[tileUid];\n    }\n    if (state === TileState.LOADED || state === TileState.ERROR) {\n      this.updateExecutorGroup_(tile, pixelRatio, projection);\n      if (this.tileImageNeedsRender_(tile, pixelRatio, projection)) {\n        render = true;\n        if (queue) {\n          this.renderTileImageQueue_[tileUid] = tile;\n        }\n      }\n    }\n    return render;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {!import(\"../../Tile.js\").default} Tile.\n   */\n  getTile(z, x, y, frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const resolution = viewState.resolution;\n    const projection = viewState.projection;\n    const layer = this.getLayer();\n    const tile = layer.getSource().getTile(z, x, y, pixelRatio, projection);\n    if (tile.getState() < TileState.LOADED) {\n      tile.wantedResolution = resolution;\n      const tileUid = getUid(tile);\n      if (!(tileUid in this.tileListenerKeys_)) {\n        const listenerKey = listen(\n          tile,\n          EventType.CHANGE,\n          this.prepareTile.bind(this, tile, pixelRatio, projection, true)\n        );\n        this.tileListenerKeys_[tileUid] = listenerKey;\n      }\n    } else {\n      const viewHints = frameState.viewHints;\n      const hifi = !(\n        viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n      );\n      if (hifi || !tile.wantedResolution) {\n        tile.wantedResolution = resolution;\n      }\n      const render = this.prepareTile(tile, pixelRatio, projection, false);\n      if (render && layer.getRenderMode() !== VectorTileRenderType.VECTOR) {\n        this.renderTileImage_(tile, frameState);\n      }\n    }\n    return super.getTile(z, x, y, frameState);\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n  isDrawableTile(tile) {\n    const layer = this.getLayer();\n    return (\n      super.isDrawableTile(tile) &&\n      (layer.getRenderMode() === VectorTileRenderType.VECTOR\n        ? getUid(layer) in tile.executorGroups\n        : tile.hasContext(layer))\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getTileImage(tile) {\n    return tile.getImage(this.getLayer());\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    const layerRevision = this.getLayer().getRevision();\n    if (this.renderedLayerRevision_ != layerRevision) {\n      this.renderedTiles.length = 0;\n    }\n    this.renderedLayerRevision_ = layerRevision;\n    return super.prepareFrame(frameState);\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @private\n   */\n  updateExecutorGroup_(tile, pixelRatio, projection) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (this.getLayer());\n    const revision = layer.getRevision();\n    const renderOrder = layer.getRenderOrder() || null;\n\n    const resolution = tile.wantedResolution;\n    const builderState = tile.getReplayState(layer);\n    if (\n      !builderState.dirty &&\n      builderState.renderedResolution === resolution &&\n      builderState.renderedRevision == revision &&\n      builderState.renderedRenderOrder == renderOrder &&\n      builderState.renderedZ === tile.sourceZ\n    ) {\n      return;\n    }\n\n    const source = layer.getSource();\n    const sourceTileGrid = source.getTileGrid();\n    const tileGrid = source.getTileGridForProjection(projection);\n    const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n\n    const sourceTiles = source.getSourceTiles(pixelRatio, projection, tile);\n    const layerUid = getUid(layer);\n    delete tile.hitDetectionImageData[layerUid];\n    tile.executorGroups[layerUid] = [];\n    for (let t = 0, tt = sourceTiles.length; t < tt; ++t) {\n      const sourceTile = sourceTiles[t];\n      if (sourceTile.getState() != TileState.LOADED) {\n        continue;\n      }\n      const sourceTileCoord = sourceTile.tileCoord;\n      const sourceTileExtent = sourceTileGrid.getTileCoordExtent(\n        sourceTileCoord\n      );\n      const sharedExtent = getIntersection(tileExtent, sourceTileExtent);\n      const bufferedExtent = equals(sourceTileExtent, sharedExtent)\n        ? null\n        : buffer(\n            sharedExtent,\n            layer.getRenderBuffer() * resolution,\n            this.tmpExtent\n          );\n      builderState.dirty = false;\n      const builderGroup = new CanvasBuilderGroup(\n        0,\n        sharedExtent,\n        resolution,\n        pixelRatio,\n        layer.getDeclutter()\n      );\n      const squaredTolerance = getSquaredRenderTolerance(\n        resolution,\n        pixelRatio\n      );\n\n      /**\n       * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n       * @this {CanvasVectorTileLayerRenderer}\n       */\n      const render = function (feature) {\n        let styles;\n        const styleFunction =\n          feature.getStyleFunction() || layer.getStyleFunction();\n        if (styleFunction) {\n          styles = styleFunction(feature, resolution);\n        }\n        if (styles) {\n          const dirty = this.renderFeature(\n            feature,\n            squaredTolerance,\n            styles,\n            builderGroup\n          );\n          this.dirty_ = this.dirty_ || dirty;\n          builderState.dirty = builderState.dirty || dirty;\n        }\n      };\n\n      const features = sourceTile.getFeatures();\n      if (renderOrder && renderOrder !== builderState.renderedRenderOrder) {\n        features.sort(renderOrder);\n      }\n      for (let i = 0, ii = features.length; i < ii; ++i) {\n        const feature = features[i];\n        if (\n          !bufferedExtent ||\n          intersects(bufferedExtent, feature.getGeometry().getExtent())\n        ) {\n          render.call(this, feature);\n        }\n      }\n      const executorGroupInstructions = builderGroup.finish();\n      // no need to clip when the render tile is covered by a single source tile\n      const replayExtent =\n        layer.getRenderMode() !== VectorTileRenderType.VECTOR &&\n        layer.getDeclutter() &&\n        sourceTiles.length === 1\n          ? null\n          : sharedExtent;\n      const renderingReplayGroup = new CanvasExecutorGroup(\n        replayExtent,\n        resolution,\n        pixelRatio,\n        source.getOverlaps(),\n        executorGroupInstructions,\n        layer.getRenderBuffer()\n      );\n      tile.executorGroups[layerUid].push(renderingReplayGroup);\n    }\n    builderState.renderedRevision = revision;\n    builderState.renderedZ = tile.sourceZ;\n    builderState.renderedRenderOrder = renderOrder;\n    builderState.renderedResolution = resolution;\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {function(import(\"../../Feature.js\").FeatureLike, import(\"../../layer/Layer.js\").default): T} callback Feature callback.\n   * @param {Array<import(\"../../Feature.js\").FeatureLike>} declutteredFeatures Decluttered features.\n   * @return {T|void} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    declutteredFeatures\n  ) {\n    const resolution = frameState.viewState.resolution;\n    const rotation = frameState.viewState.rotation;\n    hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;\n    const layer = this.getLayer();\n    const declutter = layer.getDeclutter();\n    const source = layer.getSource();\n    const tileGrid = source.getTileGridForProjection(\n      frameState.viewState.projection\n    );\n    /** @type {!Object<string, boolean>} */\n    const features = {};\n\n    const renderedTiles = /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (this\n      .renderedTiles);\n\n    let found;\n    let i, ii;\n    for (i = 0, ii = renderedTiles.length; i < ii; ++i) {\n      const tile = renderedTiles[i];\n      const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      const tileContainsCoordinate = containsCoordinate(tileExtent, coordinate);\n\n      if (!declutter) {\n        // When not decluttering, we only need to consider the tile that contains the given\n        // coordinate, because each feature will be rendered for each tile that contains it.\n        if (!tileContainsCoordinate) {\n          continue;\n        }\n      }\n      const executorGroups = tile.executorGroups[getUid(layer)];\n      for (let t = 0, tt = executorGroups.length; t < tt; ++t) {\n        const executorGroup = executorGroups[t];\n        found =\n          found ||\n          executorGroup.forEachFeatureAtCoordinate(\n            coordinate,\n            resolution,\n            rotation,\n            hitTolerance,\n            /**\n             * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n             * @return {?} Callback result.\n             */\n            function (feature) {\n              if (\n                tileContainsCoordinate ||\n                (declutteredFeatures &&\n                  declutteredFeatures.indexOf(feature) !== -1)\n              ) {\n                let key = feature.getId();\n                if (key === undefined) {\n                  key = getUid(feature);\n                }\n                if (!(key in features)) {\n                  features[key] = true;\n                  return callback(feature, layer);\n                }\n              }\n            },\n            layer.getDeclutter() ? declutteredFeatures : null\n          );\n      }\n    }\n    return found;\n  }\n\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../../Feature\").default>>} Promise that resolves with an array of features.\n   */\n  getFeatures(pixel) {\n    return new Promise(\n      function (resolve, reject) {\n        const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (this.getLayer());\n        const layerUid = getUid(layer);\n        const source = layer.getSource();\n        const projection = this.renderedProjection;\n        const projectionExtent = projection.getExtent();\n        const resolution = this.renderedResolution;\n        const tileGrid = source.getTileGridForProjection(projection);\n        const coordinate = applyTransform(\n          this.renderedPixelToCoordinateTransform_,\n          pixel.slice()\n        );\n        const tileCoord = tileGrid.getTileCoordForCoordAndResolution(\n          coordinate,\n          resolution\n        );\n        let tile;\n        for (let i = 0, ii = this.renderedTiles.length; i < ii; ++i) {\n          if (\n            tileCoord.toString() === this.renderedTiles[i].tileCoord.toString()\n          ) {\n            tile = this.renderedTiles[i];\n            if (tile.getState() === TileState.LOADED && tile.hifi) {\n              const extent = tileGrid.getTileCoordExtent(tile.tileCoord);\n              if (\n                source.getWrapX() &&\n                projection.canWrapX() &&\n                !containsExtent(projectionExtent, extent)\n              ) {\n                wrapX(coordinate, projection);\n              }\n              break;\n            }\n            tile = undefined;\n          }\n        }\n        if (!tile || tile.loadingSourceTiles > 0) {\n          resolve([]);\n          return;\n        }\n        const extent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n        const corner = getTopLeft(extent);\n        const tilePixel = [\n          (coordinate[0] - corner[0]) / resolution,\n          (corner[1] - coordinate[1]) / resolution,\n        ];\n        const features = tile\n          .getSourceTiles()\n          .reduce(function (accumulator, sourceTile) {\n            return accumulator.concat(sourceTile.getFeatures());\n          }, []);\n        let hitDetectionImageData = tile.hitDetectionImageData[layerUid];\n        if (!hitDetectionImageData && !this.animatingOrInteracting_) {\n          const tileSize = toSize(\n            tileGrid.getTileSize(tileGrid.getZForResolution(resolution))\n          );\n          const size = [tileSize[0] / 2, tileSize[1] / 2];\n          const rotation = this.renderedRotation_;\n          const transforms = [\n            this.getRenderTransform(\n              tileGrid.getTileCoordCenter(tile.wrappedTileCoord),\n              resolution,\n              0,\n              0.5,\n              size[0],\n              size[1],\n              0\n            ),\n          ];\n          hitDetectionImageData = createHitDetectionImageData(\n            tileSize,\n            transforms,\n            features,\n            layer.getStyleFunction(),\n            tileGrid.getTileCoordExtent(tile.wrappedTileCoord),\n            tile.getReplayState(layer).renderedResolution,\n            rotation\n          );\n          tile.hitDetectionImageData[layerUid] = hitDetectionImageData;\n        }\n        resolve(hitDetect(tilePixel, features, hitDetectionImageData));\n      }.bind(this)\n    );\n  }\n\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   */\n  handleFontsChanged() {\n    clear(this.renderTileImageQueue_);\n    const layer = this.getLayer();\n    if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {\n      layer.changed();\n    }\n  }\n\n  /**\n   * Handle changes in image style state.\n   * @param {import(\"../../events/Event.js\").default} event Image style change event.\n   * @private\n   */\n  handleStyleImageChange_(event) {\n    this.renderIfReadyAndVisible();\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    const viewHints = frameState.viewHints;\n    const hifi = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n    this.renderQueuedTileImages_(hifi, frameState);\n\n    super.renderFrame(frameState, target);\n    this.renderedPixelToCoordinateTransform_ = frameState.pixelToCoordinateTransform.slice();\n    this.renderedRotation_ = frameState.viewState.rotation;\n\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (this.getLayer());\n    const renderMode = layer.getRenderMode();\n    if (renderMode === VectorTileRenderType.IMAGE) {\n      return this.container;\n    }\n\n    const source = layer.getSource();\n    // Unqueue tiles from the image queue when we don't need any more\n    const usedTiles = frameState.usedTiles[getUid(source)];\n    for (const tileUid in this.renderTileImageQueue_) {\n      if (!usedTiles || !(tileUid in usedTiles)) {\n        delete this.renderTileImageQueue_[tileUid];\n      }\n    }\n\n    const context = this.context;\n    const declutterReplays = layer.getDeclutter() ? {} : null;\n    const replayTypes = VECTOR_REPLAYS[renderMode];\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const center = viewState.center;\n    const resolution = viewState.resolution;\n    const rotation = viewState.rotation;\n    const size = frameState.size;\n\n    const width = Math.round(size[0] * pixelRatio);\n    const height = Math.round(size[1] * pixelRatio);\n\n    const tiles = this.renderedTiles;\n    const tileGrid = source.getTileGridForProjection(\n      frameState.viewState.projection\n    );\n    const clips = [];\n    const clipZs = [];\n    for (let i = tiles.length - 1; i >= 0; --i) {\n      const tile = /** @type {import(\"../../VectorRenderTile.js\").default} */ (tiles[\n        i\n      ]);\n      const tileCoord = tile.tileCoord;\n      const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      const worldOffset =\n        tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent)[0] -\n        tileExtent[0];\n      const transform = multiply(\n        scale(\n          this.inversePixelTransform.slice(),\n          1 / pixelRatio,\n          1 / pixelRatio\n        ),\n        this.getRenderTransform(\n          center,\n          resolution,\n          rotation,\n          pixelRatio,\n          width,\n          height,\n          worldOffset\n        )\n      );\n      const executorGroups = tile.executorGroups[getUid(layer)];\n      let clipped = false;\n      for (let t = 0, tt = executorGroups.length; t < tt; ++t) {\n        const executorGroup = executorGroups[t];\n        if (!executorGroup.hasExecutors(replayTypes)) {\n          // sourceTile has no instructions of the types we want to render\n          continue;\n        }\n        const currentZ = tile.tileCoord[0];\n        let currentClip;\n        if (!declutterReplays && !clipped) {\n          currentClip = executorGroup.getClipCoords(transform);\n          context.save();\n\n          // Create a clip mask for regions in this low resolution tile that are\n          // already filled by a higher resolution tile\n          for (let j = 0, jj = clips.length; j < jj; ++j) {\n            const clip = clips[j];\n            if (currentZ < clipZs[j]) {\n              context.beginPath();\n              // counter-clockwise (outer ring) for current tile\n              context.moveTo(currentClip[0], currentClip[1]);\n              context.lineTo(currentClip[2], currentClip[3]);\n              context.lineTo(currentClip[4], currentClip[5]);\n              context.lineTo(currentClip[6], currentClip[7]);\n              // clockwise (inner ring) for higher resolution tile\n              context.moveTo(clip[6], clip[7]);\n              context.lineTo(clip[4], clip[5]);\n              context.lineTo(clip[2], clip[3]);\n              context.lineTo(clip[0], clip[1]);\n              context.clip();\n            }\n          }\n        }\n        executorGroup.execute(\n          context,\n          1,\n          transform,\n          rotation,\n          hifi,\n          replayTypes,\n          declutterReplays\n        );\n        if (!declutterReplays && !clipped) {\n          context.restore();\n          clips.push(currentClip);\n          clipZs.push(currentZ);\n          clipped = true;\n        }\n      }\n    }\n    if (declutterReplays) {\n      const layerState = frameState.layerStatesArray[frameState.layerIndex];\n      replayDeclutter(\n        declutterReplays,\n        context,\n        rotation,\n        layerState.opacity,\n        hifi,\n        frameState.declutterItems\n      );\n    }\n\n    return this.container;\n  }\n\n  /**\n   * @param {boolean} hifi We have time to render a high fidelity map image.\n   * @param {import('../../PluggableMap.js').FrameState} frameState Frame state.\n   */\n  renderQueuedTileImages_(hifi, frameState) {\n    // When we don't have time to render hifi, only render tiles until we have used up\n    // half of the frame budget of 16 ms\n    for (const uid in this.renderTileImageQueue_) {\n      if (!hifi && Date.now() - frameState.time > 8) {\n        frameState.animate = true;\n        break;\n      }\n      const tile = this.renderTileImageQueue_[uid];\n      delete this.renderTileImageQueue_[uid];\n      this.renderTileImage_(tile, frameState);\n    }\n  }\n\n  /**\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n   * @param {import(\"../../render/canvas/BuilderGroup.js\").default} executorGroup Replay group.\n   * @return {boolean} `true` if an image is loading.\n   */\n  renderFeature(feature, squaredTolerance, styles, executorGroup) {\n    if (!styles) {\n      return false;\n    }\n    let loading = false;\n    if (Array.isArray(styles)) {\n      for (let i = 0, ii = styles.length; i < ii; ++i) {\n        loading =\n          renderFeature(\n            executorGroup,\n            feature,\n            styles[i],\n            squaredTolerance,\n            this.boundHandleStyleImageChange_\n          ) || loading;\n      }\n    } else {\n      loading = renderFeature(\n        executorGroup,\n        feature,\n        styles,\n        squaredTolerance,\n        this.boundHandleStyleImageChange_\n      );\n    }\n    return loading;\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @return {boolean} A new tile image was rendered.\n   * @private\n   */\n  tileImageNeedsRender_(tile, pixelRatio, projection) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (this.getLayer());\n    const replayState = tile.getReplayState(layer);\n    const revision = layer.getRevision();\n    const sourceZ = tile.sourceZ;\n    const resolution = tile.wantedResolution;\n    return (\n      replayState.renderedTileResolution !== resolution ||\n      replayState.renderedTileRevision !== revision ||\n      replayState.renderedTileZ !== sourceZ\n    );\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {import(\"../../PluggableMap\").FrameState} frameState Frame state.\n   * @private\n   */\n  renderTileImage_(tile, frameState) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (this.getLayer());\n    const replayState = tile.getReplayState(layer);\n    const revision = layer.getRevision();\n    const executorGroups = tile.executorGroups[getUid(layer)];\n    replayState.renderedTileRevision = revision;\n    replayState.renderedTileZ = tile.sourceZ;\n\n    const tileCoord = tile.wrappedTileCoord;\n    const z = tileCoord[0];\n    const source = layer.getSource();\n    let pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const tileGrid = source.getTileGridForProjection(projection);\n    const tileResolution = tileGrid.getResolution(tile.tileCoord[0]);\n    const renderPixelRatio =\n      (frameState.pixelRatio / tile.wantedResolution) * tileResolution;\n    const resolution = tileGrid.getResolution(z);\n    const context = tile.getContext(layer);\n\n    // Increase tile size when overzooming for low pixel ratio, to avoid blurry tiles\n    pixelRatio = Math.max(pixelRatio, renderPixelRatio / pixelRatio);\n    const size = source.getTilePixelSize(z, pixelRatio, projection);\n    context.canvas.width = size[0];\n    context.canvas.height = size[1];\n    const renderScale = pixelRatio / renderPixelRatio;\n    if (renderScale !== 1) {\n      const canvasTransform = resetTransform(this.tmpTransform_);\n      scaleTransform(canvasTransform, renderScale, renderScale);\n      context.setTransform.apply(context, canvasTransform);\n    }\n    const tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);\n    const pixelScale = renderPixelRatio / resolution;\n    const transform = resetTransform(this.tmpTransform_);\n    scaleTransform(transform, pixelScale, -pixelScale);\n    translateTransform(transform, -tileExtent[0], -tileExtent[3]);\n    for (let i = 0, ii = executorGroups.length; i < ii; ++i) {\n      const executorGroup = executorGroups[i];\n      executorGroup.execute(\n        context,\n        renderScale,\n        transform,\n        0,\n        true,\n        IMAGE_REPLAYS[layer.getRenderMode()]\n      );\n    }\n    replayState.renderedTileResolution = tile.wantedResolution;\n  }\n}\n\nexport default CanvasVectorTileLayerRenderer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
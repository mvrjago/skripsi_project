{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/renderer/webgl/Layer\n */\nimport LayerRenderer from '../Layer.js';\nimport WebGLHelper from '../../webgl/Helper.js';\n/**\n * @enum {string}\n */\nexport var WebGLWorkerMessageType = {\n  GENERATE_BUFFERS: 'GENERATE_BUFFERS'\n};\n/**\n * @typedef {Object} WebGLWorkerGenerateBuffersMessage\n * This message will trigger the generation of a vertex and an index buffer based on the given render instructions.\n * When the buffers are generated, the worked will send a message of the same type to the main thread, with\n * the generated buffers in it.\n * Note that any addition properties present in the message *will* be sent back to the main thread.\n * @property {WebGLWorkerMessageType} type Message type\n * @property {ArrayBuffer} renderInstructions Render instructions raw binary buffer.\n * @property {ArrayBuffer} [vertexBuffer] Vertices array raw binary buffer (sent by the worker).\n * @property {ArrayBuffer} [indexBuffer] Indices array raw binary buffer (sent by the worker).\n * @property {number} [customAttributesCount] Amount of custom attributes count in the render instructions.\n */\n/**\n * @typedef {Object} PostProcessesOptions\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\n * the main canvas that will then be sampled up (useful for saving resource on blur steps).\n * @property {string} [vertexShader] Vertex shader source\n * @property {string} [fragmentShader] Fragment shader source\n * @property {Object.<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process step\n */\n/**\n * @typedef {Object} Options\n * @property {Object.<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n/**\n * @classdesc\n * Base WebGL renderer class.\n * Holds all logic related to data manipulation & some common rendering logic\n * @template {import(\"../../layer/Layer.js\").default} LayerType\n */\nvar WebGLLayerRenderer = /** @class */function (_super) {\n  __extends(WebGLLayerRenderer, _super);\n  /**\n   * @param {LayerType} layer Layer.\n   * @param {Options=} [opt_options] Options.\n   */\n  function WebGLLayerRenderer(layer, opt_options) {\n    var _this = _super.call(this, layer) || this;\n    var options = opt_options || {};\n    /**\n     * @type {WebGLHelper}\n     * @protected\n     */\n    _this.helper = new WebGLHelper({\n      postProcesses: options.postProcesses,\n      uniforms: options.uniforms\n    });\n    return _this;\n  }\n  /**\n   * Clean up.\n   */\n  WebGLLayerRenderer.prototype.disposeInternal = function () {\n    this.helper.dispose();\n    _super.prototype.disposeInternal.call(this);\n  };\n  /**\n   * Will return the last shader compilation errors. If no error happened, will return null;\n   * @return {string|null} Errors, or null if last compilation was successful\n   * @api\n   */\n  WebGLLayerRenderer.prototype.getShaderCompileErrors = function () {\n    return this.helper.getShaderCompileErrors();\n  };\n  return WebGLLayerRenderer;\n}(LayerRenderer);\nvar tmpArray_ = [];\nvar bufferPositions_ = {\n  vertexPosition: 0,\n  indexPosition: 0\n};\nfunction writePointVertex(buffer, pos, x, y, index) {\n  buffer[pos + 0] = x;\n  buffer[pos + 1] = y;\n  buffer[pos + 2] = index;\n}\n/**\n * An object holding positions both in an index and a vertex buffer.\n * @typedef {Object} BufferPositions\n * @property {number} vertexPosition Position in the vertex buffer\n * @property {number} indexPosition Position in the index buffer\n */\n/**\n * Pushes a quad (two triangles) based on a point geometry\n * @param {Float32Array} instructions Array of render instructions for points.\n * @param {number} elementIndex Index from which render instructions will be read.\n * @param {Float32Array} vertexBuffer Buffer in the form of a typed array.\n * @param {Uint32Array} indexBuffer Buffer in the form of a typed array.\n * @param {number} customAttributesCount Amount of custom attributes for each element.\n * @param {BufferPositions} [bufferPositions] Buffer write positions; if not specified, positions will be set at 0.\n * @return {BufferPositions} New buffer positions where to write next\n * @property {number} vertexPosition New position in the vertex buffer where future writes should start.\n * @property {number} indexPosition New position in the index buffer where future writes should start.\n * @private\n */\nexport function writePointFeatureToBuffers(instructions, elementIndex, vertexBuffer, indexBuffer, customAttributesCount, bufferPositions) {\n  // This is for x, y and index\n  var baseVertexAttrsCount = 3;\n  var baseInstructionsCount = 2;\n  var stride = baseVertexAttrsCount + customAttributesCount;\n  var x = instructions[elementIndex + 0];\n  var y = instructions[elementIndex + 1];\n  // read custom numerical attributes on the feature\n  var customAttrs = tmpArray_;\n  customAttrs.length = customAttributesCount;\n  for (var i = 0; i < customAttrs.length; i++) {\n    customAttrs[i] = instructions[elementIndex + baseInstructionsCount + i];\n  }\n  var vPos = bufferPositions ? bufferPositions.vertexPosition : 0;\n  var iPos = bufferPositions ? bufferPositions.indexPosition : 0;\n  var baseIndex = vPos / stride;\n  // push vertices for each of the four quad corners (first standard then custom attributes)\n  writePointVertex(vertexBuffer, vPos, x, y, 0);\n  customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n  writePointVertex(vertexBuffer, vPos, x, y, 1);\n  customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n  writePointVertex(vertexBuffer, vPos, x, y, 2);\n  customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n  writePointVertex(vertexBuffer, vPos, x, y, 3);\n  customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n  indexBuffer[iPos++] = baseIndex;\n  indexBuffer[iPos++] = baseIndex + 1;\n  indexBuffer[iPos++] = baseIndex + 3;\n  indexBuffer[iPos++] = baseIndex + 1;\n  indexBuffer[iPos++] = baseIndex + 2;\n  indexBuffer[iPos++] = baseIndex + 3;\n  bufferPositions_.vertexPosition = vPos;\n  bufferPositions_.indexPosition = iPos;\n  return bufferPositions_;\n}\n/**\n * Returns a texture of 1x1 pixel, white\n * @private\n * @return {ImageData} Image data.\n */\nexport function getBlankImageData() {\n  var canvas = document.createElement('canvas');\n  var image = canvas.getContext('2d').createImageData(1, 1);\n  image.data[0] = 255;\n  image.data[1] = 255;\n  image.data[2] = 255;\n  image.data[3] = 255;\n  return image;\n}\n/**\n * Generates a color array based on a numerical id\n * Note: the range for each component is 0 to 1 with 256 steps\n * @param {number} id Id\n * @param {Array<number>} [opt_array] Reusable array\n * @return {Array<number>} Color array containing the encoded id\n */\nexport function colorEncodeId(id, opt_array) {\n  var array = opt_array || [];\n  var radix = 256;\n  var divide = radix - 1;\n  array[0] = Math.floor(id / radix / radix / radix) / divide;\n  array[1] = Math.floor(id / radix / radix) % radix / divide;\n  array[2] = Math.floor(id / radix) % radix / divide;\n  array[3] = id % radix / divide;\n  return array;\n}\n/**\n * Reads an id from a color-encoded array\n * Note: the expected range for each component is 0 to 1 with 256 steps.\n * @param {Array<number>} color Color array containing the encoded id\n * @return {number} Decoded id\n */\nexport function colorDecodeId(color) {\n  var id = 0;\n  var radix = 256;\n  var mult = radix - 1;\n  id += Math.round(color[0] * radix * radix * radix * mult);\n  id += Math.round(color[1] * radix * radix * mult);\n  id += Math.round(color[2] * radix * mult);\n  id += Math.round(color[3] * mult);\n  return id;\n}\nexport default WebGLLayerRenderer;","map":{"version":3,"names":["LayerRenderer","WebGLHelper","WebGLWorkerMessageType","GENERATE_BUFFERS","WebGLLayerRenderer","_super","__extends","layer","opt_options","_this","call","options","helper","postProcesses","uniforms","prototype","disposeInternal","dispose","getShaderCompileErrors","tmpArray_","bufferPositions_","vertexPosition","indexPosition","writePointVertex","buffer","pos","x","y","index","writePointFeatureToBuffers","instructions","elementIndex","vertexBuffer","indexBuffer","customAttributesCount","bufferPositions","baseVertexAttrsCount","baseInstructionsCount","stride","customAttrs","length","i","vPos","iPos","baseIndex","set","getBlankImageData","canvas","document","createElement","image","getContext","createImageData","data","colorEncodeId","id","opt_array","array","radix","divide","Math","floor","colorDecodeId","color","mult","round"],"sources":["/Users/mariovicky/Skripsi_OpenLayers/node_modules/ol/src/renderer/webgl/Layer.js"],"sourcesContent":["/**\n * @module ol/renderer/webgl/Layer\n */\nimport LayerRenderer from '../Layer.js';\nimport WebGLHelper from '../../webgl/Helper.js';\n\n/**\n * @enum {string}\n */\nexport const WebGLWorkerMessageType = {\n  GENERATE_BUFFERS: 'GENERATE_BUFFERS',\n};\n\n/**\n * @typedef {Object} WebGLWorkerGenerateBuffersMessage\n * This message will trigger the generation of a vertex and an index buffer based on the given render instructions.\n * When the buffers are generated, the worked will send a message of the same type to the main thread, with\n * the generated buffers in it.\n * Note that any addition properties present in the message *will* be sent back to the main thread.\n * @property {WebGLWorkerMessageType} type Message type\n * @property {ArrayBuffer} renderInstructions Render instructions raw binary buffer.\n * @property {ArrayBuffer} [vertexBuffer] Vertices array raw binary buffer (sent by the worker).\n * @property {ArrayBuffer} [indexBuffer] Indices array raw binary buffer (sent by the worker).\n * @property {number} [customAttributesCount] Amount of custom attributes count in the render instructions.\n */\n\n/**\n * @typedef {Object} PostProcessesOptions\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\n * the main canvas that will then be sampled up (useful for saving resource on blur steps).\n * @property {string} [vertexShader] Vertex shader source\n * @property {string} [fragmentShader] Fragment shader source\n * @property {Object.<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process step\n */\n\n/**\n * @typedef {Object} Options\n * @property {Object.<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n\n/**\n * @classdesc\n * Base WebGL renderer class.\n * Holds all logic related to data manipulation & some common rendering logic\n * @template {import(\"../../layer/Layer.js\").default} LayerType\n */\nclass WebGLLayerRenderer extends LayerRenderer {\n  /**\n   * @param {LayerType} layer Layer.\n   * @param {Options=} [opt_options] Options.\n   */\n  constructor(layer, opt_options) {\n    super(layer);\n\n    const options = opt_options || {};\n\n    /**\n     * @type {WebGLHelper}\n     * @protected\n     */\n    this.helper = new WebGLHelper({\n      postProcesses: options.postProcesses,\n      uniforms: options.uniforms,\n    });\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    this.helper.dispose();\n    super.disposeInternal();\n  }\n\n  /**\n   * Will return the last shader compilation errors. If no error happened, will return null;\n   * @return {string|null} Errors, or null if last compilation was successful\n   * @api\n   */\n  getShaderCompileErrors() {\n    return this.helper.getShaderCompileErrors();\n  }\n}\n\nconst tmpArray_ = [];\nconst bufferPositions_ = {vertexPosition: 0, indexPosition: 0};\n\nfunction writePointVertex(buffer, pos, x, y, index) {\n  buffer[pos + 0] = x;\n  buffer[pos + 1] = y;\n  buffer[pos + 2] = index;\n}\n\n/**\n * An object holding positions both in an index and a vertex buffer.\n * @typedef {Object} BufferPositions\n * @property {number} vertexPosition Position in the vertex buffer\n * @property {number} indexPosition Position in the index buffer\n */\n\n/**\n * Pushes a quad (two triangles) based on a point geometry\n * @param {Float32Array} instructions Array of render instructions for points.\n * @param {number} elementIndex Index from which render instructions will be read.\n * @param {Float32Array} vertexBuffer Buffer in the form of a typed array.\n * @param {Uint32Array} indexBuffer Buffer in the form of a typed array.\n * @param {number} customAttributesCount Amount of custom attributes for each element.\n * @param {BufferPositions} [bufferPositions] Buffer write positions; if not specified, positions will be set at 0.\n * @return {BufferPositions} New buffer positions where to write next\n * @property {number} vertexPosition New position in the vertex buffer where future writes should start.\n * @property {number} indexPosition New position in the index buffer where future writes should start.\n * @private\n */\nexport function writePointFeatureToBuffers(\n  instructions,\n  elementIndex,\n  vertexBuffer,\n  indexBuffer,\n  customAttributesCount,\n  bufferPositions\n) {\n  // This is for x, y and index\n  const baseVertexAttrsCount = 3;\n  const baseInstructionsCount = 2;\n  const stride = baseVertexAttrsCount + customAttributesCount;\n\n  const x = instructions[elementIndex + 0];\n  const y = instructions[elementIndex + 1];\n\n  // read custom numerical attributes on the feature\n  const customAttrs = tmpArray_;\n  customAttrs.length = customAttributesCount;\n  for (let i = 0; i < customAttrs.length; i++) {\n    customAttrs[i] = instructions[elementIndex + baseInstructionsCount + i];\n  }\n\n  let vPos = bufferPositions ? bufferPositions.vertexPosition : 0;\n  let iPos = bufferPositions ? bufferPositions.indexPosition : 0;\n  const baseIndex = vPos / stride;\n\n  // push vertices for each of the four quad corners (first standard then custom attributes)\n  writePointVertex(vertexBuffer, vPos, x, y, 0);\n  customAttrs.length &&\n    vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n\n  writePointVertex(vertexBuffer, vPos, x, y, 1);\n  customAttrs.length &&\n    vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n\n  writePointVertex(vertexBuffer, vPos, x, y, 2);\n  customAttrs.length &&\n    vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n\n  writePointVertex(vertexBuffer, vPos, x, y, 3);\n  customAttrs.length &&\n    vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n\n  indexBuffer[iPos++] = baseIndex;\n  indexBuffer[iPos++] = baseIndex + 1;\n  indexBuffer[iPos++] = baseIndex + 3;\n  indexBuffer[iPos++] = baseIndex + 1;\n  indexBuffer[iPos++] = baseIndex + 2;\n  indexBuffer[iPos++] = baseIndex + 3;\n\n  bufferPositions_.vertexPosition = vPos;\n  bufferPositions_.indexPosition = iPos;\n\n  return bufferPositions_;\n}\n\n/**\n * Returns a texture of 1x1 pixel, white\n * @private\n * @return {ImageData} Image data.\n */\nexport function getBlankImageData() {\n  const canvas = document.createElement('canvas');\n  const image = canvas.getContext('2d').createImageData(1, 1);\n  image.data[0] = 255;\n  image.data[1] = 255;\n  image.data[2] = 255;\n  image.data[3] = 255;\n  return image;\n}\n\n/**\n * Generates a color array based on a numerical id\n * Note: the range for each component is 0 to 1 with 256 steps\n * @param {number} id Id\n * @param {Array<number>} [opt_array] Reusable array\n * @return {Array<number>} Color array containing the encoded id\n */\nexport function colorEncodeId(id, opt_array) {\n  const array = opt_array || [];\n  const radix = 256;\n  const divide = radix - 1;\n  array[0] = Math.floor(id / radix / radix / radix) / divide;\n  array[1] = (Math.floor(id / radix / radix) % radix) / divide;\n  array[2] = (Math.floor(id / radix) % radix) / divide;\n  array[3] = (id % radix) / divide;\n  return array;\n}\n\n/**\n * Reads an id from a color-encoded array\n * Note: the expected range for each component is 0 to 1 with 256 steps.\n * @param {Array<number>} color Color array containing the encoded id\n * @return {number} Decoded id\n */\nexport function colorDecodeId(color) {\n  let id = 0;\n  const radix = 256;\n  const mult = radix - 1;\n  id += Math.round(color[0] * radix * radix * radix * mult);\n  id += Math.round(color[1] * radix * radix * mult);\n  id += Math.round(color[2] * radix * mult);\n  id += Math.round(color[3] * mult);\n  return id;\n}\n\nexport default WebGLLayerRenderer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
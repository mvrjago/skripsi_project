{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/geom/MultiPolygon\n */\nimport GeometryLayout from './GeometryLayout.js';\nimport GeometryType from './GeometryType.js';\nimport MultiPoint from './MultiPoint.js';\nimport Polygon from './Polygon.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { assignClosestMultiArrayPoint, multiArrayMaxSquaredDelta } from './flat/closest.js';\nimport { closestSquaredDistanceXY } from '../extent.js';\nimport { deflateMultiCoordinatesArray } from './flat/deflate.js';\nimport { extend } from '../array.js';\nimport { getInteriorPointsOfMultiArray } from './flat/interiorpoint.js';\nimport { inflateMultiCoordinatesArray } from './flat/inflate.js';\nimport { intersectsLinearRingMultiArray } from './flat/intersectsextent.js';\nimport { linearRingssAreOriented, orientLinearRingsArray } from './flat/orient.js';\nimport { linearRingss as linearRingssArea } from './flat/area.js';\nimport { linearRingss as linearRingssCenter } from './flat/center.js';\nimport { linearRingssContainsXY } from './flat/contains.js';\nimport { quantizeMultiArray } from './flat/simplify.js';\n/**\n * @classdesc\n * Multi-polygon geometry.\n *\n * @api\n */\nvar MultiPolygon = /** @class */function (_super) {\n  __extends(MultiPolygon, _super);\n  /**\n   * @param {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.\n   *     For internal use, flat coordinates in combination with `opt_layout` and `opt_endss` are also accepted.\n   * @param {import(\"./GeometryLayout.js\").default=} opt_layout Layout.\n   * @param {Array<Array<number>>=} opt_endss Array of ends for internal use with flat coordinates.\n   */\n  function MultiPolygon(coordinates, opt_layout, opt_endss) {\n    var _this = _super.call(this) || this;\n    /**\n     * @type {Array<Array<number>>}\n     * @private\n     */\n    _this.endss_ = [];\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.flatInteriorPointsRevision_ = -1;\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    _this.flatInteriorPoints_ = null;\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.maxDelta_ = -1;\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.maxDeltaRevision_ = -1;\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.orientedRevision_ = -1;\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    _this.orientedFlatCoordinates_ = null;\n    if (!opt_endss && !Array.isArray(coordinates[0])) {\n      var layout = _this.getLayout();\n      var polygons = /** @type {Array<Polygon>} */coordinates;\n      var flatCoordinates = [];\n      var endss = [];\n      for (var i = 0, ii = polygons.length; i < ii; ++i) {\n        var polygon = polygons[i];\n        if (i === 0) {\n          layout = polygon.getLayout();\n        }\n        var offset = flatCoordinates.length;\n        var ends = polygon.getEnds();\n        for (var j = 0, jj = ends.length; j < jj; ++j) {\n          ends[j] += offset;\n        }\n        extend(flatCoordinates, polygon.getFlatCoordinates());\n        endss.push(ends);\n      }\n      opt_layout = layout;\n      coordinates = flatCoordinates;\n      opt_endss = endss;\n    }\n    if (opt_layout !== undefined && opt_endss) {\n      _this.setFlatCoordinates(opt_layout, /** @type {Array<number>} */coordinates);\n      _this.endss_ = opt_endss;\n    } else {\n      _this.setCoordinates( /** @type {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} */coordinates, opt_layout);\n    }\n    return _this;\n  }\n  /**\n   * Append the passed polygon to this multipolygon.\n   * @param {Polygon} polygon Polygon.\n   * @api\n   */\n  MultiPolygon.prototype.appendPolygon = function (polygon) {\n    /** @type {Array<number>} */\n    var ends;\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = polygon.getFlatCoordinates().slice();\n      ends = polygon.getEnds().slice();\n      this.endss_.push();\n    } else {\n      var offset = this.flatCoordinates.length;\n      extend(this.flatCoordinates, polygon.getFlatCoordinates());\n      ends = polygon.getEnds().slice();\n      for (var i = 0, ii = ends.length; i < ii; ++i) {\n        ends[i] += offset;\n      }\n    }\n    this.endss_.push(ends);\n    this.changed();\n  };\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!MultiPolygon} Clone.\n   * @api\n   */\n  MultiPolygon.prototype.clone = function () {\n    var len = this.endss_.length;\n    var newEndss = new Array(len);\n    for (var i = 0; i < len; ++i) {\n      newEndss[i] = this.endss_[i].slice();\n    }\n    return new MultiPolygon(this.flatCoordinates.slice(), this.layout, newEndss);\n  };\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  MultiPolygon.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(multiArrayMaxSquaredDelta(this.flatCoordinates, 0, this.endss_, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestMultiArrayPoint(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n  };\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   */\n  MultiPolygon.prototype.containsXY = function (x, y) {\n    return linearRingssContainsXY(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);\n  };\n  /**\n   * Return the area of the multipolygon on projected plane.\n   * @return {number} Area (on projected plane).\n   * @api\n   */\n  MultiPolygon.prototype.getArea = function () {\n    return linearRingssArea(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);\n  };\n  /**\n   * Get the coordinate array for this geometry.  This array has the structure\n   * of a GeoJSON coordinate array for multi-polygons.\n   *\n   * @param {boolean=} opt_right Orient coordinates according to the right-hand\n   *     rule (counter-clockwise for exterior and clockwise for interior rings).\n   *     If `false`, coordinates will be oriented according to the left-hand rule\n   *     (clockwise for exterior and counter-clockwise for interior rings).\n   *     By default, coordinate orientation will depend on how the geometry was\n   *     constructed.\n   * @return {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} Coordinates.\n   * @api\n   */\n  MultiPolygon.prototype.getCoordinates = function (opt_right) {\n    var flatCoordinates;\n    if (opt_right !== undefined) {\n      flatCoordinates = this.getOrientedFlatCoordinates().slice();\n      orientLinearRingsArray(flatCoordinates, 0, this.endss_, this.stride, opt_right);\n    } else {\n      flatCoordinates = this.flatCoordinates;\n    }\n    return inflateMultiCoordinatesArray(flatCoordinates, 0, this.endss_, this.stride);\n  };\n  /**\n   * @return {Array<Array<number>>} Endss.\n   */\n  MultiPolygon.prototype.getEndss = function () {\n    return this.endss_;\n  };\n  /**\n   * @return {Array<number>} Flat interior points.\n   */\n  MultiPolygon.prototype.getFlatInteriorPoints = function () {\n    if (this.flatInteriorPointsRevision_ != this.getRevision()) {\n      var flatCenters = linearRingssCenter(this.flatCoordinates, 0, this.endss_, this.stride);\n      this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, flatCenters);\n      this.flatInteriorPointsRevision_ = this.getRevision();\n    }\n    return this.flatInteriorPoints_;\n  };\n  /**\n   * Return the interior points as {@link module:ol/geom/MultiPoint multipoint}.\n   * @return {MultiPoint} Interior points as XYM coordinates, where M is\n   * the length of the horizontal intersection that the point belongs to.\n   * @api\n   */\n  MultiPolygon.prototype.getInteriorPoints = function () {\n    return new MultiPoint(this.getFlatInteriorPoints().slice(), GeometryLayout.XYM);\n  };\n  /**\n   * @return {Array<number>} Oriented flat coordinates.\n   */\n  MultiPolygon.prototype.getOrientedFlatCoordinates = function () {\n    if (this.orientedRevision_ != this.getRevision()) {\n      var flatCoordinates = this.flatCoordinates;\n      if (linearRingssAreOriented(flatCoordinates, 0, this.endss_, this.stride)) {\n        this.orientedFlatCoordinates_ = flatCoordinates;\n      } else {\n        this.orientedFlatCoordinates_ = flatCoordinates.slice();\n        this.orientedFlatCoordinates_.length = orientLinearRingsArray(this.orientedFlatCoordinates_, 0, this.endss_, this.stride);\n      }\n      this.orientedRevision_ = this.getRevision();\n    }\n    return this.orientedFlatCoordinates_;\n  };\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {MultiPolygon} Simplified MultiPolygon.\n   * @protected\n   */\n  MultiPolygon.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {\n    var simplifiedFlatCoordinates = [];\n    var simplifiedEndss = [];\n    simplifiedFlatCoordinates.length = quantizeMultiArray(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEndss);\n    return new MultiPolygon(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEndss);\n  };\n  /**\n   * Return the polygon at the specified index.\n   * @param {number} index Index.\n   * @return {Polygon} Polygon.\n   * @api\n   */\n  MultiPolygon.prototype.getPolygon = function (index) {\n    if (index < 0 || this.endss_.length <= index) {\n      return null;\n    }\n    var offset;\n    if (index === 0) {\n      offset = 0;\n    } else {\n      var prevEnds = this.endss_[index - 1];\n      offset = prevEnds[prevEnds.length - 1];\n    }\n    var ends = this.endss_[index].slice();\n    var end = ends[ends.length - 1];\n    if (offset !== 0) {\n      for (var i = 0, ii = ends.length; i < ii; ++i) {\n        ends[i] -= offset;\n      }\n    }\n    return new Polygon(this.flatCoordinates.slice(offset, end), this.layout, ends);\n  };\n  /**\n   * Return the polygons of this multipolygon.\n   * @return {Array<Polygon>} Polygons.\n   * @api\n   */\n  MultiPolygon.prototype.getPolygons = function () {\n    var layout = this.layout;\n    var flatCoordinates = this.flatCoordinates;\n    var endss = this.endss_;\n    var polygons = [];\n    var offset = 0;\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n      var ends = endss[i].slice();\n      var end = ends[ends.length - 1];\n      if (offset !== 0) {\n        for (var j = 0, jj = ends.length; j < jj; ++j) {\n          ends[j] -= offset;\n        }\n      }\n      var polygon = new Polygon(flatCoordinates.slice(offset, end), layout, ends);\n      polygons.push(polygon);\n      offset = end;\n    }\n    return polygons;\n  };\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./GeometryType.js\").default} Geometry type.\n   * @api\n   */\n  MultiPolygon.prototype.getType = function () {\n    return GeometryType.MULTI_POLYGON;\n  };\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n  MultiPolygon.prototype.intersectsExtent = function (extent) {\n    return intersectsLinearRingMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);\n  };\n  /**\n   * Set the coordinates of the multipolygon.\n   * @param {!Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} coordinates Coordinates.\n   * @param {import(\"./GeometryLayout.js\").default=} opt_layout Layout.\n   * @api\n   */\n  MultiPolygon.prototype.setCoordinates = function (coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 3);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    var endss = deflateMultiCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.endss_);\n    if (endss.length === 0) {\n      this.flatCoordinates.length = 0;\n    } else {\n      var lastEnds = endss[endss.length - 1];\n      this.flatCoordinates.length = lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];\n    }\n    this.changed();\n  };\n  return MultiPolygon;\n}(SimpleGeometry);\nexport default MultiPolygon;","map":{"version":3,"names":["GeometryLayout","GeometryType","MultiPoint","Polygon","SimpleGeometry","assignClosestMultiArrayPoint","multiArrayMaxSquaredDelta","closestSquaredDistanceXY","deflateMultiCoordinatesArray","extend","getInteriorPointsOfMultiArray","inflateMultiCoordinatesArray","intersectsLinearRingMultiArray","linearRingssAreOriented","orientLinearRingsArray","linearRingss","linearRingssArea","linearRingssCenter","linearRingssContainsXY","quantizeMultiArray","MultiPolygon","_super","__extends","coordinates","opt_layout","opt_endss","_this","call","endss_","flatInteriorPointsRevision_","flatInteriorPoints_","maxDelta_","maxDeltaRevision_","orientedRevision_","orientedFlatCoordinates_","Array","isArray","layout","getLayout","polygons","flatCoordinates","endss","i","ii","length","polygon","offset","ends","getEnds","j","jj","getFlatCoordinates","push","undefined","setFlatCoordinates","setCoordinates","prototype","appendPolygon","slice","changed","clone","len","newEndss","closestPointXY","x","y","closestPoint","minSquaredDistance","getExtent","getRevision","Math","sqrt","stride","getOrientedFlatCoordinates","containsXY","getArea","getCoordinates","opt_right","getEndss","getFlatInteriorPoints","flatCenters","getInteriorPoints","XYM","getSimplifiedGeometryInternal","squaredTolerance","simplifiedFlatCoordinates","simplifiedEndss","XY","getPolygon","index","prevEnds","end","getPolygons","getType","MULTI_POLYGON","intersectsExtent","extent","setLayout","lastEnds"],"sources":["/Users/mariovicky/Skripsi_OpenLayers/node_modules/ol/src/geom/MultiPolygon.js"],"sourcesContent":["/**\n * @module ol/geom/MultiPolygon\n */\nimport GeometryLayout from './GeometryLayout.js';\nimport GeometryType from './GeometryType.js';\nimport MultiPoint from './MultiPoint.js';\nimport Polygon from './Polygon.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {\n  assignClosestMultiArrayPoint,\n  multiArrayMaxSquaredDelta,\n} from './flat/closest.js';\nimport {closestSquaredDistanceXY} from '../extent.js';\nimport {deflateMultiCoordinatesArray} from './flat/deflate.js';\nimport {extend} from '../array.js';\nimport {getInteriorPointsOfMultiArray} from './flat/interiorpoint.js';\nimport {inflateMultiCoordinatesArray} from './flat/inflate.js';\nimport {intersectsLinearRingMultiArray} from './flat/intersectsextent.js';\nimport {\n  linearRingssAreOriented,\n  orientLinearRingsArray,\n} from './flat/orient.js';\nimport {linearRingss as linearRingssArea} from './flat/area.js';\nimport {linearRingss as linearRingssCenter} from './flat/center.js';\nimport {linearRingssContainsXY} from './flat/contains.js';\nimport {quantizeMultiArray} from './flat/simplify.js';\n\n/**\n * @classdesc\n * Multi-polygon geometry.\n *\n * @api\n */\nclass MultiPolygon extends SimpleGeometry {\n  /**\n   * @param {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.\n   *     For internal use, flat coordinates in combination with `opt_layout` and `opt_endss` are also accepted.\n   * @param {import(\"./GeometryLayout.js\").default=} opt_layout Layout.\n   * @param {Array<Array<number>>=} opt_endss Array of ends for internal use with flat coordinates.\n   */\n  constructor(coordinates, opt_layout, opt_endss) {\n    super();\n\n    /**\n     * @type {Array<Array<number>>}\n     * @private\n     */\n    this.endss_ = [];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.flatInteriorPointsRevision_ = -1;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.flatInteriorPoints_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.orientedRevision_ = -1;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.orientedFlatCoordinates_ = null;\n\n    if (!opt_endss && !Array.isArray(coordinates[0])) {\n      let layout = this.getLayout();\n      const polygons = /** @type {Array<Polygon>} */ (coordinates);\n      const flatCoordinates = [];\n      const endss = [];\n      for (let i = 0, ii = polygons.length; i < ii; ++i) {\n        const polygon = polygons[i];\n        if (i === 0) {\n          layout = polygon.getLayout();\n        }\n        const offset = flatCoordinates.length;\n        const ends = polygon.getEnds();\n        for (let j = 0, jj = ends.length; j < jj; ++j) {\n          ends[j] += offset;\n        }\n        extend(flatCoordinates, polygon.getFlatCoordinates());\n        endss.push(ends);\n      }\n      opt_layout = layout;\n      coordinates = flatCoordinates;\n      opt_endss = endss;\n    }\n    if (opt_layout !== undefined && opt_endss) {\n      this.setFlatCoordinates(\n        opt_layout,\n        /** @type {Array<number>} */ (coordinates)\n      );\n      this.endss_ = opt_endss;\n    } else {\n      this.setCoordinates(\n        /** @type {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} */ (coordinates),\n        opt_layout\n      );\n    }\n  }\n\n  /**\n   * Append the passed polygon to this multipolygon.\n   * @param {Polygon} polygon Polygon.\n   * @api\n   */\n  appendPolygon(polygon) {\n    /** @type {Array<number>} */\n    let ends;\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = polygon.getFlatCoordinates().slice();\n      ends = polygon.getEnds().slice();\n      this.endss_.push();\n    } else {\n      const offset = this.flatCoordinates.length;\n      extend(this.flatCoordinates, polygon.getFlatCoordinates());\n      ends = polygon.getEnds().slice();\n      for (let i = 0, ii = ends.length; i < ii; ++i) {\n        ends[i] += offset;\n      }\n    }\n    this.endss_.push(ends);\n    this.changed();\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!MultiPolygon} Clone.\n   * @api\n   */\n  clone() {\n    const len = this.endss_.length;\n    const newEndss = new Array(len);\n    for (let i = 0; i < len; ++i) {\n      newEndss[i] = this.endss_[i].slice();\n    }\n\n    return new MultiPolygon(\n      this.flatCoordinates.slice(),\n      this.layout,\n      newEndss\n    );\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(\n        multiArrayMaxSquaredDelta(\n          this.flatCoordinates,\n          0,\n          this.endss_,\n          this.stride,\n          0\n        )\n      );\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestMultiArrayPoint(\n      this.getOrientedFlatCoordinates(),\n      0,\n      this.endss_,\n      this.stride,\n      this.maxDelta_,\n      true,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance\n    );\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   */\n  containsXY(x, y) {\n    return linearRingssContainsXY(\n      this.getOrientedFlatCoordinates(),\n      0,\n      this.endss_,\n      this.stride,\n      x,\n      y\n    );\n  }\n\n  /**\n   * Return the area of the multipolygon on projected plane.\n   * @return {number} Area (on projected plane).\n   * @api\n   */\n  getArea() {\n    return linearRingssArea(\n      this.getOrientedFlatCoordinates(),\n      0,\n      this.endss_,\n      this.stride\n    );\n  }\n\n  /**\n   * Get the coordinate array for this geometry.  This array has the structure\n   * of a GeoJSON coordinate array for multi-polygons.\n   *\n   * @param {boolean=} opt_right Orient coordinates according to the right-hand\n   *     rule (counter-clockwise for exterior and clockwise for interior rings).\n   *     If `false`, coordinates will be oriented according to the left-hand rule\n   *     (clockwise for exterior and counter-clockwise for interior rings).\n   *     By default, coordinate orientation will depend on how the geometry was\n   *     constructed.\n   * @return {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} Coordinates.\n   * @api\n   */\n  getCoordinates(opt_right) {\n    let flatCoordinates;\n    if (opt_right !== undefined) {\n      flatCoordinates = this.getOrientedFlatCoordinates().slice();\n      orientLinearRingsArray(\n        flatCoordinates,\n        0,\n        this.endss_,\n        this.stride,\n        opt_right\n      );\n    } else {\n      flatCoordinates = this.flatCoordinates;\n    }\n\n    return inflateMultiCoordinatesArray(\n      flatCoordinates,\n      0,\n      this.endss_,\n      this.stride\n    );\n  }\n\n  /**\n   * @return {Array<Array<number>>} Endss.\n   */\n  getEndss() {\n    return this.endss_;\n  }\n\n  /**\n   * @return {Array<number>} Flat interior points.\n   */\n  getFlatInteriorPoints() {\n    if (this.flatInteriorPointsRevision_ != this.getRevision()) {\n      const flatCenters = linearRingssCenter(\n        this.flatCoordinates,\n        0,\n        this.endss_,\n        this.stride\n      );\n      this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(\n        this.getOrientedFlatCoordinates(),\n        0,\n        this.endss_,\n        this.stride,\n        flatCenters\n      );\n      this.flatInteriorPointsRevision_ = this.getRevision();\n    }\n    return this.flatInteriorPoints_;\n  }\n\n  /**\n   * Return the interior points as {@link module:ol/geom/MultiPoint multipoint}.\n   * @return {MultiPoint} Interior points as XYM coordinates, where M is\n   * the length of the horizontal intersection that the point belongs to.\n   * @api\n   */\n  getInteriorPoints() {\n    return new MultiPoint(\n      this.getFlatInteriorPoints().slice(),\n      GeometryLayout.XYM\n    );\n  }\n\n  /**\n   * @return {Array<number>} Oriented flat coordinates.\n   */\n  getOrientedFlatCoordinates() {\n    if (this.orientedRevision_ != this.getRevision()) {\n      const flatCoordinates = this.flatCoordinates;\n      if (\n        linearRingssAreOriented(flatCoordinates, 0, this.endss_, this.stride)\n      ) {\n        this.orientedFlatCoordinates_ = flatCoordinates;\n      } else {\n        this.orientedFlatCoordinates_ = flatCoordinates.slice();\n        this.orientedFlatCoordinates_.length = orientLinearRingsArray(\n          this.orientedFlatCoordinates_,\n          0,\n          this.endss_,\n          this.stride\n        );\n      }\n      this.orientedRevision_ = this.getRevision();\n    }\n    return this.orientedFlatCoordinates_;\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {MultiPolygon} Simplified MultiPolygon.\n   * @protected\n   */\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    const simplifiedFlatCoordinates = [];\n    const simplifiedEndss = [];\n    simplifiedFlatCoordinates.length = quantizeMultiArray(\n      this.flatCoordinates,\n      0,\n      this.endss_,\n      this.stride,\n      Math.sqrt(squaredTolerance),\n      simplifiedFlatCoordinates,\n      0,\n      simplifiedEndss\n    );\n    return new MultiPolygon(\n      simplifiedFlatCoordinates,\n      GeometryLayout.XY,\n      simplifiedEndss\n    );\n  }\n\n  /**\n   * Return the polygon at the specified index.\n   * @param {number} index Index.\n   * @return {Polygon} Polygon.\n   * @api\n   */\n  getPolygon(index) {\n    if (index < 0 || this.endss_.length <= index) {\n      return null;\n    }\n    let offset;\n    if (index === 0) {\n      offset = 0;\n    } else {\n      const prevEnds = this.endss_[index - 1];\n      offset = prevEnds[prevEnds.length - 1];\n    }\n    const ends = this.endss_[index].slice();\n    const end = ends[ends.length - 1];\n    if (offset !== 0) {\n      for (let i = 0, ii = ends.length; i < ii; ++i) {\n        ends[i] -= offset;\n      }\n    }\n    return new Polygon(\n      this.flatCoordinates.slice(offset, end),\n      this.layout,\n      ends\n    );\n  }\n\n  /**\n   * Return the polygons of this multipolygon.\n   * @return {Array<Polygon>} Polygons.\n   * @api\n   */\n  getPolygons() {\n    const layout = this.layout;\n    const flatCoordinates = this.flatCoordinates;\n    const endss = this.endss_;\n    const polygons = [];\n    let offset = 0;\n    for (let i = 0, ii = endss.length; i < ii; ++i) {\n      const ends = endss[i].slice();\n      const end = ends[ends.length - 1];\n      if (offset !== 0) {\n        for (let j = 0, jj = ends.length; j < jj; ++j) {\n          ends[j] -= offset;\n        }\n      }\n      const polygon = new Polygon(\n        flatCoordinates.slice(offset, end),\n        layout,\n        ends\n      );\n      polygons.push(polygon);\n      offset = end;\n    }\n    return polygons;\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./GeometryType.js\").default} Geometry type.\n   * @api\n   */\n  getType() {\n    return GeometryType.MULTI_POLYGON;\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n  intersectsExtent(extent) {\n    return intersectsLinearRingMultiArray(\n      this.getOrientedFlatCoordinates(),\n      0,\n      this.endss_,\n      this.stride,\n      extent\n    );\n  }\n\n  /**\n   * Set the coordinates of the multipolygon.\n   * @param {!Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} coordinates Coordinates.\n   * @param {import(\"./GeometryLayout.js\").default=} opt_layout Layout.\n   * @api\n   */\n  setCoordinates(coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 3);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    const endss = deflateMultiCoordinatesArray(\n      this.flatCoordinates,\n      0,\n      coordinates,\n      this.stride,\n      this.endss_\n    );\n    if (endss.length === 0) {\n      this.flatCoordinates.length = 0;\n    } else {\n      const lastEnds = endss[endss.length - 1];\n      this.flatCoordinates.length =\n        lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];\n    }\n    this.changed();\n  }\n}\n\nexport default MultiPolygon;\n"],"mappings":";;;;;;;;;;;;;;;;;;;AAAA;;;AAGA,OAAOA,cAAc,MAAM,qBAAqB;AAChD,OAAOC,YAAY,MAAM,mBAAmB;AAC5C,OAAOC,UAAU,MAAM,iBAAiB;AACxC,OAAOC,OAAO,MAAM,cAAc;AAClC,OAAOC,cAAc,MAAM,qBAAqB;AAChD,SACEC,4BAA4B,EAC5BC,yBAAyB,QACpB,mBAAmB;AAC1B,SAAQC,wBAAwB,QAAO,cAAc;AACrD,SAAQC,4BAA4B,QAAO,mBAAmB;AAC9D,SAAQC,MAAM,QAAO,aAAa;AAClC,SAAQC,6BAA6B,QAAO,yBAAyB;AACrE,SAAQC,4BAA4B,QAAO,mBAAmB;AAC9D,SAAQC,8BAA8B,QAAO,4BAA4B;AACzE,SACEC,uBAAuB,EACvBC,sBAAsB,QACjB,kBAAkB;AACzB,SAAQC,YAAY,IAAIC,gBAAgB,QAAO,gBAAgB;AAC/D,SAAQD,YAAY,IAAIE,kBAAkB,QAAO,kBAAkB;AACnE,SAAQC,sBAAsB,QAAO,oBAAoB;AACzD,SAAQC,kBAAkB,QAAO,oBAAoB;AAErD;;;;;;AAMA,IAAAC,YAAA,0BAAAC,MAAA;EAA2BC,SAAA,CAAAF,YAAA,EAAAC,MAAA;EACzB;;;;;;EAMA,SAAAD,aAAYG,WAAW,EAAEC,UAAU,EAAEC,SAAS;IAA9C,IAAAC,KAAA,GACEL,MAAA,CAAAM,IAAA,MAAO;IAEP;;;;IAIAD,KAAI,CAACE,MAAM,GAAG,EAAE;IAEhB;;;;IAIAF,KAAI,CAACG,2BAA2B,GAAG,CAAC,CAAC;IAErC;;;;IAIAH,KAAI,CAACI,mBAAmB,GAAG,IAAI;IAE/B;;;;IAIAJ,KAAI,CAACK,SAAS,GAAG,CAAC,CAAC;IAEnB;;;;IAIAL,KAAI,CAACM,iBAAiB,GAAG,CAAC,CAAC;IAE3B;;;;IAIAN,KAAI,CAACO,iBAAiB,GAAG,CAAC,CAAC;IAE3B;;;;IAIAP,KAAI,CAACQ,wBAAwB,GAAG,IAAI;IAEpC,IAAI,CAACT,SAAS,IAAI,CAACU,KAAK,CAACC,OAAO,CAACb,WAAW,CAAC,CAAC,CAAC,CAAC,EAAE;MAChD,IAAIc,MAAM,GAAGX,KAAI,CAACY,SAAS,EAAE;MAC7B,IAAMC,QAAQ,GAAG,6BAA+BhB,WAAY;MAC5D,IAAMiB,eAAe,GAAG,EAAE;MAC1B,IAAMC,KAAK,GAAG,EAAE;MAChB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGJ,QAAQ,CAACK,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAE,EAAED,CAAC,EAAE;QACjD,IAAMG,OAAO,GAAGN,QAAQ,CAACG,CAAC,CAAC;QAC3B,IAAIA,CAAC,KAAK,CAAC,EAAE;UACXL,MAAM,GAAGQ,OAAO,CAACP,SAAS,EAAE;;QAE9B,IAAMQ,MAAM,GAAGN,eAAe,CAACI,MAAM;QACrC,IAAMG,IAAI,GAAGF,OAAO,CAACG,OAAO,EAAE;QAC9B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGH,IAAI,CAACH,MAAM,EAAEK,CAAC,GAAGC,EAAE,EAAE,EAAED,CAAC,EAAE;UAC7CF,IAAI,CAACE,CAAC,CAAC,IAAIH,MAAM;;QAEnBrC,MAAM,CAAC+B,eAAe,EAAEK,OAAO,CAACM,kBAAkB,EAAE,CAAC;QACrDV,KAAK,CAACW,IAAI,CAACL,IAAI,CAAC;;MAElBvB,UAAU,GAAGa,MAAM;MACnBd,WAAW,GAAGiB,eAAe;MAC7Bf,SAAS,GAAGgB,KAAK;;IAEnB,IAAIjB,UAAU,KAAK6B,SAAS,IAAI5B,SAAS,EAAE;MACzCC,KAAI,CAAC4B,kBAAkB,CACrB9B,UAAU,EACV,4BAA8BD,WAAY,CAC3C;MACDG,KAAI,CAACE,MAAM,GAAGH,SAAS;KACxB,MAAM;MACLC,KAAI,CAAC6B,cAAc,EACjB,yEAA2EhC,WAAW,EACtFC,UAAU,CACX;;;EAEL;EAEA;;;;;EAKAJ,YAAA,CAAAoC,SAAA,CAAAC,aAAa,GAAb,UAAcZ,OAAO;IACnB;IACA,IAAIE,IAAI;IACR,IAAI,CAAC,IAAI,CAACP,eAAe,EAAE;MACzB,IAAI,CAACA,eAAe,GAAGK,OAAO,CAACM,kBAAkB,EAAE,CAACO,KAAK,EAAE;MAC3DX,IAAI,GAAGF,OAAO,CAACG,OAAO,EAAE,CAACU,KAAK,EAAE;MAChC,IAAI,CAAC9B,MAAM,CAACwB,IAAI,EAAE;KACnB,MAAM;MACL,IAAMN,MAAM,GAAG,IAAI,CAACN,eAAe,CAACI,MAAM;MAC1CnC,MAAM,CAAC,IAAI,CAAC+B,eAAe,EAAEK,OAAO,CAACM,kBAAkB,EAAE,CAAC;MAC1DJ,IAAI,GAAGF,OAAO,CAACG,OAAO,EAAE,CAACU,KAAK,EAAE;MAChC,KAAK,IAAIhB,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGI,IAAI,CAACH,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAE,EAAED,CAAC,EAAE;QAC7CK,IAAI,CAACL,CAAC,CAAC,IAAII,MAAM;;;IAGrB,IAAI,CAAClB,MAAM,CAACwB,IAAI,CAACL,IAAI,CAAC;IACtB,IAAI,CAACY,OAAO,EAAE;EAChB,CAAC;EAED;;;;;EAKAvC,YAAA,CAAAoC,SAAA,CAAAI,KAAK,GAAL;IACE,IAAMC,GAAG,GAAG,IAAI,CAACjC,MAAM,CAACgB,MAAM;IAC9B,IAAMkB,QAAQ,GAAG,IAAI3B,KAAK,CAAC0B,GAAG,CAAC;IAC/B,KAAK,IAAInB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmB,GAAG,EAAE,EAAEnB,CAAC,EAAE;MAC5BoB,QAAQ,CAACpB,CAAC,CAAC,GAAG,IAAI,CAACd,MAAM,CAACc,CAAC,CAAC,CAACgB,KAAK,EAAE;;IAGtC,OAAO,IAAItC,YAAY,CACrB,IAAI,CAACoB,eAAe,CAACkB,KAAK,EAAE,EAC5B,IAAI,CAACrB,MAAM,EACXyB,QAAQ,CACT;EACH,CAAC;EAED;;;;;;;EAOA1C,YAAA,CAAAoC,SAAA,CAAAO,cAAc,GAAd,UAAeC,CAAC,EAAEC,CAAC,EAAEC,YAAY,EAAEC,kBAAkB;IACnD,IAAIA,kBAAkB,GAAG5D,wBAAwB,CAAC,IAAI,CAAC6D,SAAS,EAAE,EAAEJ,CAAC,EAAEC,CAAC,CAAC,EAAE;MACzE,OAAOE,kBAAkB;;IAE3B,IAAI,IAAI,CAACnC,iBAAiB,IAAI,IAAI,CAACqC,WAAW,EAAE,EAAE;MAChD,IAAI,CAACtC,SAAS,GAAGuC,IAAI,CAACC,IAAI,CACxBjE,yBAAyB,CACvB,IAAI,CAACkC,eAAe,EACpB,CAAC,EACD,IAAI,CAACZ,MAAM,EACX,IAAI,CAAC4C,MAAM,EACX,CAAC,CACF,CACF;MACD,IAAI,CAACxC,iBAAiB,GAAG,IAAI,CAACqC,WAAW,EAAE;;IAE7C,OAAOhE,4BAA4B,CACjC,IAAI,CAACoE,0BAA0B,EAAE,EACjC,CAAC,EACD,IAAI,CAAC7C,MAAM,EACX,IAAI,CAAC4C,MAAM,EACX,IAAI,CAACzC,SAAS,EACd,IAAI,EACJiC,CAAC,EACDC,CAAC,EACDC,YAAY,EACZC,kBAAkB,CACnB;EACH,CAAC;EAED;;;;;EAKA/C,YAAA,CAAAoC,SAAA,CAAAkB,UAAU,GAAV,UAAWV,CAAC,EAAEC,CAAC;IACb,OAAO/C,sBAAsB,CAC3B,IAAI,CAACuD,0BAA0B,EAAE,EACjC,CAAC,EACD,IAAI,CAAC7C,MAAM,EACX,IAAI,CAAC4C,MAAM,EACXR,CAAC,EACDC,CAAC,CACF;EACH,CAAC;EAED;;;;;EAKA7C,YAAA,CAAAoC,SAAA,CAAAmB,OAAO,GAAP;IACE,OAAO3D,gBAAgB,CACrB,IAAI,CAACyD,0BAA0B,EAAE,EACjC,CAAC,EACD,IAAI,CAAC7C,MAAM,EACX,IAAI,CAAC4C,MAAM,CACZ;EACH,CAAC;EAED;;;;;;;;;;;;;EAaApD,YAAA,CAAAoC,SAAA,CAAAoB,cAAc,GAAd,UAAeC,SAAS;IACtB,IAAIrC,eAAe;IACnB,IAAIqC,SAAS,KAAKxB,SAAS,EAAE;MAC3Bb,eAAe,GAAG,IAAI,CAACiC,0BAA0B,EAAE,CAACf,KAAK,EAAE;MAC3D5C,sBAAsB,CACpB0B,eAAe,EACf,CAAC,EACD,IAAI,CAACZ,MAAM,EACX,IAAI,CAAC4C,MAAM,EACXK,SAAS,CACV;KACF,MAAM;MACLrC,eAAe,GAAG,IAAI,CAACA,eAAe;;IAGxC,OAAO7B,4BAA4B,CACjC6B,eAAe,EACf,CAAC,EACD,IAAI,CAACZ,MAAM,EACX,IAAI,CAAC4C,MAAM,CACZ;EACH,CAAC;EAED;;;EAGApD,YAAA,CAAAoC,SAAA,CAAAsB,QAAQ,GAAR;IACE,OAAO,IAAI,CAAClD,MAAM;EACpB,CAAC;EAED;;;EAGAR,YAAA,CAAAoC,SAAA,CAAAuB,qBAAqB,GAArB;IACE,IAAI,IAAI,CAAClD,2BAA2B,IAAI,IAAI,CAACwC,WAAW,EAAE,EAAE;MAC1D,IAAMW,WAAW,GAAG/D,kBAAkB,CACpC,IAAI,CAACuB,eAAe,EACpB,CAAC,EACD,IAAI,CAACZ,MAAM,EACX,IAAI,CAAC4C,MAAM,CACZ;MACD,IAAI,CAAC1C,mBAAmB,GAAGpB,6BAA6B,CACtD,IAAI,CAAC+D,0BAA0B,EAAE,EACjC,CAAC,EACD,IAAI,CAAC7C,MAAM,EACX,IAAI,CAAC4C,MAAM,EACXQ,WAAW,CACZ;MACD,IAAI,CAACnD,2BAA2B,GAAG,IAAI,CAACwC,WAAW,EAAE;;IAEvD,OAAO,IAAI,CAACvC,mBAAmB;EACjC,CAAC;EAED;;;;;;EAMAV,YAAA,CAAAoC,SAAA,CAAAyB,iBAAiB,GAAjB;IACE,OAAO,IAAI/E,UAAU,CACnB,IAAI,CAAC6E,qBAAqB,EAAE,CAACrB,KAAK,EAAE,EACpC1D,cAAc,CAACkF,GAAG,CACnB;EACH,CAAC;EAED;;;EAGA9D,YAAA,CAAAoC,SAAA,CAAAiB,0BAA0B,GAA1B;IACE,IAAI,IAAI,CAACxC,iBAAiB,IAAI,IAAI,CAACoC,WAAW,EAAE,EAAE;MAChD,IAAM7B,eAAe,GAAG,IAAI,CAACA,eAAe;MAC5C,IACE3B,uBAAuB,CAAC2B,eAAe,EAAE,CAAC,EAAE,IAAI,CAACZ,MAAM,EAAE,IAAI,CAAC4C,MAAM,CAAC,EACrE;QACA,IAAI,CAACtC,wBAAwB,GAAGM,eAAe;OAChD,MAAM;QACL,IAAI,CAACN,wBAAwB,GAAGM,eAAe,CAACkB,KAAK,EAAE;QACvD,IAAI,CAACxB,wBAAwB,CAACU,MAAM,GAAG9B,sBAAsB,CAC3D,IAAI,CAACoB,wBAAwB,EAC7B,CAAC,EACD,IAAI,CAACN,MAAM,EACX,IAAI,CAAC4C,MAAM,CACZ;;MAEH,IAAI,CAACvC,iBAAiB,GAAG,IAAI,CAACoC,WAAW,EAAE;;IAE7C,OAAO,IAAI,CAACnC,wBAAwB;EACtC,CAAC;EAED;;;;;EAKAd,YAAA,CAAAoC,SAAA,CAAA2B,6BAA6B,GAA7B,UAA8BC,gBAAgB;IAC5C,IAAMC,yBAAyB,GAAG,EAAE;IACpC,IAAMC,eAAe,GAAG,EAAE;IAC1BD,yBAAyB,CAACzC,MAAM,GAAGzB,kBAAkB,CACnD,IAAI,CAACqB,eAAe,EACpB,CAAC,EACD,IAAI,CAACZ,MAAM,EACX,IAAI,CAAC4C,MAAM,EACXF,IAAI,CAACC,IAAI,CAACa,gBAAgB,CAAC,EAC3BC,yBAAyB,EACzB,CAAC,EACDC,eAAe,CAChB;IACD,OAAO,IAAIlE,YAAY,CACrBiE,yBAAyB,EACzBrF,cAAc,CAACuF,EAAE,EACjBD,eAAe,CAChB;EACH,CAAC;EAED;;;;;;EAMAlE,YAAA,CAAAoC,SAAA,CAAAgC,UAAU,GAAV,UAAWC,KAAK;IACd,IAAIA,KAAK,GAAG,CAAC,IAAI,IAAI,CAAC7D,MAAM,CAACgB,MAAM,IAAI6C,KAAK,EAAE;MAC5C,OAAO,IAAI;;IAEb,IAAI3C,MAAM;IACV,IAAI2C,KAAK,KAAK,CAAC,EAAE;MACf3C,MAAM,GAAG,CAAC;KACX,MAAM;MACL,IAAM4C,QAAQ,GAAG,IAAI,CAAC9D,MAAM,CAAC6D,KAAK,GAAG,CAAC,CAAC;MACvC3C,MAAM,GAAG4C,QAAQ,CAACA,QAAQ,CAAC9C,MAAM,GAAG,CAAC,CAAC;;IAExC,IAAMG,IAAI,GAAG,IAAI,CAACnB,MAAM,CAAC6D,KAAK,CAAC,CAAC/B,KAAK,EAAE;IACvC,IAAMiC,GAAG,GAAG5C,IAAI,CAACA,IAAI,CAACH,MAAM,GAAG,CAAC,CAAC;IACjC,IAAIE,MAAM,KAAK,CAAC,EAAE;MAChB,KAAK,IAAIJ,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGI,IAAI,CAACH,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAE,EAAED,CAAC,EAAE;QAC7CK,IAAI,CAACL,CAAC,CAAC,IAAII,MAAM;;;IAGrB,OAAO,IAAI3C,OAAO,CAChB,IAAI,CAACqC,eAAe,CAACkB,KAAK,CAACZ,MAAM,EAAE6C,GAAG,CAAC,EACvC,IAAI,CAACtD,MAAM,EACXU,IAAI,CACL;EACH,CAAC;EAED;;;;;EAKA3B,YAAA,CAAAoC,SAAA,CAAAoC,WAAW,GAAX;IACE,IAAMvD,MAAM,GAAG,IAAI,CAACA,MAAM;IAC1B,IAAMG,eAAe,GAAG,IAAI,CAACA,eAAe;IAC5C,IAAMC,KAAK,GAAG,IAAI,CAACb,MAAM;IACzB,IAAMW,QAAQ,GAAG,EAAE;IACnB,IAAIO,MAAM,GAAG,CAAC;IACd,KAAK,IAAIJ,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGF,KAAK,CAACG,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAE,EAAED,CAAC,EAAE;MAC9C,IAAMK,IAAI,GAAGN,KAAK,CAACC,CAAC,CAAC,CAACgB,KAAK,EAAE;MAC7B,IAAMiC,GAAG,GAAG5C,IAAI,CAACA,IAAI,CAACH,MAAM,GAAG,CAAC,CAAC;MACjC,IAAIE,MAAM,KAAK,CAAC,EAAE;QAChB,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGH,IAAI,CAACH,MAAM,EAAEK,CAAC,GAAGC,EAAE,EAAE,EAAED,CAAC,EAAE;UAC7CF,IAAI,CAACE,CAAC,CAAC,IAAIH,MAAM;;;MAGrB,IAAMD,OAAO,GAAG,IAAI1C,OAAO,CACzBqC,eAAe,CAACkB,KAAK,CAACZ,MAAM,EAAE6C,GAAG,CAAC,EAClCtD,MAAM,EACNU,IAAI,CACL;MACDR,QAAQ,CAACa,IAAI,CAACP,OAAO,CAAC;MACtBC,MAAM,GAAG6C,GAAG;;IAEd,OAAOpD,QAAQ;EACjB,CAAC;EAED;;;;;EAKAnB,YAAA,CAAAoC,SAAA,CAAAqC,OAAO,GAAP;IACE,OAAO5F,YAAY,CAAC6F,aAAa;EACnC,CAAC;EAED;;;;;;EAMA1E,YAAA,CAAAoC,SAAA,CAAAuC,gBAAgB,GAAhB,UAAiBC,MAAM;IACrB,OAAOpF,8BAA8B,CACnC,IAAI,CAAC6D,0BAA0B,EAAE,EACjC,CAAC,EACD,IAAI,CAAC7C,MAAM,EACX,IAAI,CAAC4C,MAAM,EACXwB,MAAM,CACP;EACH,CAAC;EAED;;;;;;EAMA5E,YAAA,CAAAoC,SAAA,CAAAD,cAAc,GAAd,UAAehC,WAAW,EAAEC,UAAU;IACpC,IAAI,CAACyE,SAAS,CAACzE,UAAU,EAAED,WAAW,EAAE,CAAC,CAAC;IAC1C,IAAI,CAAC,IAAI,CAACiB,eAAe,EAAE;MACzB,IAAI,CAACA,eAAe,GAAG,EAAE;;IAE3B,IAAMC,KAAK,GAAGjC,4BAA4B,CACxC,IAAI,CAACgC,eAAe,EACpB,CAAC,EACDjB,WAAW,EACX,IAAI,CAACiD,MAAM,EACX,IAAI,CAAC5C,MAAM,CACZ;IACD,IAAIa,KAAK,CAACG,MAAM,KAAK,CAAC,EAAE;MACtB,IAAI,CAACJ,eAAe,CAACI,MAAM,GAAG,CAAC;KAChC,MAAM;MACL,IAAMsD,QAAQ,GAAGzD,KAAK,CAACA,KAAK,CAACG,MAAM,GAAG,CAAC,CAAC;MACxC,IAAI,CAACJ,eAAe,CAACI,MAAM,GACzBsD,QAAQ,CAACtD,MAAM,KAAK,CAAC,GAAG,CAAC,GAAGsD,QAAQ,CAACA,QAAQ,CAACtD,MAAM,GAAG,CAAC,CAAC;;IAE7D,IAAI,CAACe,OAAO,EAAE;EAChB,CAAC;EACH,OAAAvC,YAAC;AAAD,CAAC,CAvb0BhB,cAAc;AAybzC,eAAegB,YAAY"},"metadata":{},"sourceType":"module","externalDependencies":[]}
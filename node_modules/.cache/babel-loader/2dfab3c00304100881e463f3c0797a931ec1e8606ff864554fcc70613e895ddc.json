{"ast":null,"code":"/**\n * @module ol/geom/flat/orient\n */\nimport { coordinates as reverseCoordinates } from './reverse.js';\n/**\n * Is the linear ring oriented clockwise in a coordinate system with a bottom-left\n * coordinate origin? For a coordinate system with a top-left coordinate origin,\n * the ring's orientation is clockwise when this function returns false.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {boolean} Is clockwise.\n */\nexport function linearRingIsClockwise(flatCoordinates, offset, end, stride) {\n  // https://stackoverflow.com/a/1180256/2389327\n  // https://en.wikipedia.org/wiki/Curve_orientation#Orientation_of_a_simple_polygon\n  var firstVertexRepeated = true;\n  for (var i = 0; i < stride; ++i) {\n    if (flatCoordinates[offset + i] !== flatCoordinates[end - stride + i]) {\n      firstVertexRepeated = false;\n      break;\n    }\n  }\n  if (firstVertexRepeated) {\n    end -= stride;\n  }\n  var iMinVertex = findCornerVertex(flatCoordinates, offset, end, stride);\n  // Orientation matrix:\n  //     [ 1  xa  ya ]\n  // O = | 1  xb  yb |\n  //     [ 1  xc  yc ]\n  var iPreviousVertex = iMinVertex - stride;\n  if (iPreviousVertex < offset) {\n    iPreviousVertex = end - stride;\n  }\n  var iNextVertex = iMinVertex + stride;\n  if (iNextVertex >= end) {\n    iNextVertex = offset;\n  }\n  var aX = flatCoordinates[iPreviousVertex];\n  var aY = flatCoordinates[iPreviousVertex + 1];\n  var bX = flatCoordinates[iMinVertex];\n  var bY = flatCoordinates[iMinVertex + 1];\n  var cX = flatCoordinates[iNextVertex];\n  var cY = flatCoordinates[iNextVertex + 1];\n  var determinant = bX * cY + aX * bY + aY * cX - (aY * bX + bY * cX + aX * cY);\n  return determinant < 0;\n}\n// Find vertex along one edge of bounding box.\n// In this case, we find smallest y; in case of tie also smallest x.\nfunction findCornerVertex(flatCoordinates, offset, end, stride) {\n  var iMinVertex = -1;\n  var minY = Infinity;\n  var minXAtMinY = Infinity;\n  for (var i = offset; i < end; i += stride) {\n    var x = flatCoordinates[i];\n    var y = flatCoordinates[i + 1];\n    if (y > minY) {\n      continue;\n    }\n    if (y == minY) {\n      if (x >= minXAtMinY) {\n        continue;\n      }\n    }\n    // Minimum so far.\n    iMinVertex = i;\n    minY = y;\n    minXAtMinY = x;\n  }\n  return iMinVertex;\n}\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\nexport function linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right) {\n  var right = opt_right !== undefined ? opt_right : false;\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);\n    if (i === 0) {\n      if (right && isClockwise || !right && !isClockwise) {\n        return false;\n      }\n    } else {\n      if (right && !isClockwise || !right && isClockwise) {\n        return false;\n      }\n    }\n    offset = end;\n  }\n  return true;\n}\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\nexport function linearRingssAreOriented(flatCoordinates, offset, endss, stride, opt_right) {\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    if (!linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right)) {\n      return false;\n    }\n    if (ends.length) {\n      offset = ends[ends.length - 1];\n    }\n  }\n  return true;\n}\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Follow the right-hand rule for orientation.\n * @return {number} End.\n */\nexport function orientLinearRings(flatCoordinates, offset, ends, stride, opt_right) {\n  var right = opt_right !== undefined ? opt_right : false;\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);\n    var reverse = i === 0 ? right && isClockwise || !right && !isClockwise : right && !isClockwise || !right && isClockwise;\n    if (reverse) {\n      reverseCoordinates(flatCoordinates, offset, end, stride);\n    }\n    offset = end;\n  }\n  return offset;\n}\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Follow the right-hand rule for orientation.\n * @return {number} End.\n */\nexport function orientLinearRingsArray(flatCoordinates, offset, endss, stride, opt_right) {\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    offset = orientLinearRings(flatCoordinates, offset, endss[i], stride, opt_right);\n  }\n  return offset;\n}","map":{"version":3,"names":["coordinates","reverseCoordinates","linearRingIsClockwise","flatCoordinates","offset","end","stride","firstVertexRepeated","i","iMinVertex","findCornerVertex","iPreviousVertex","iNextVertex","aX","aY","bX","bY","cX","cY","determinant","minY","Infinity","minXAtMinY","x","y","linearRingsAreOriented","ends","opt_right","right","undefined","ii","length","isClockwise","linearRingssAreOriented","endss","orientLinearRings","reverse","orientLinearRingsArray"],"sources":["/Users/mariovicky/Skripsi_OpenLayers/node_modules/ol/src/geom/flat/orient.js"],"sourcesContent":["/**\n * @module ol/geom/flat/orient\n */\nimport {coordinates as reverseCoordinates} from './reverse.js';\n\n/**\n * Is the linear ring oriented clockwise in a coordinate system with a bottom-left\n * coordinate origin? For a coordinate system with a top-left coordinate origin,\n * the ring's orientation is clockwise when this function returns false.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {boolean} Is clockwise.\n */\nexport function linearRingIsClockwise(flatCoordinates, offset, end, stride) {\n  // https://stackoverflow.com/a/1180256/2389327\n  // https://en.wikipedia.org/wiki/Curve_orientation#Orientation_of_a_simple_polygon\n\n  let firstVertexRepeated = true;\n  for (let i = 0; i < stride; ++i) {\n    if (flatCoordinates[offset + i] !== flatCoordinates[end - stride + i]) {\n      firstVertexRepeated = false;\n      break;\n    }\n  }\n  if (firstVertexRepeated) {\n    end -= stride;\n  }\n  const iMinVertex = findCornerVertex(flatCoordinates, offset, end, stride);\n  // Orientation matrix:\n  //     [ 1  xa  ya ]\n  // O = | 1  xb  yb |\n  //     [ 1  xc  yc ]\n  let iPreviousVertex = iMinVertex - stride;\n  if (iPreviousVertex < offset) {\n    iPreviousVertex = end - stride;\n  }\n  let iNextVertex = iMinVertex + stride;\n  if (iNextVertex >= end) {\n    iNextVertex = offset;\n  }\n  const aX = flatCoordinates[iPreviousVertex];\n  const aY = flatCoordinates[iPreviousVertex + 1];\n  const bX = flatCoordinates[iMinVertex];\n  const bY = flatCoordinates[iMinVertex + 1];\n  const cX = flatCoordinates[iNextVertex];\n  const cY = flatCoordinates[iNextVertex + 1];\n  const determinant =\n    bX * cY + aX * bY + aY * cX - (aY * bX + bY * cX + aX * cY);\n\n  return determinant < 0;\n}\n\n// Find vertex along one edge of bounding box.\n// In this case, we find smallest y; in case of tie also smallest x.\nfunction findCornerVertex(flatCoordinates, offset, end, stride) {\n  let iMinVertex = -1;\n  let minY = Infinity;\n  let minXAtMinY = Infinity;\n  for (let i = offset; i < end; i += stride) {\n    const x = flatCoordinates[i];\n    const y = flatCoordinates[i + 1];\n    if (y > minY) {\n      continue;\n    }\n    if (y == minY) {\n      if (x >= minXAtMinY) {\n        continue;\n      }\n    }\n\n    // Minimum so far.\n    iMinVertex = i;\n    minY = y;\n    minXAtMinY = x;\n  }\n\n  return iMinVertex;\n}\n\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\nexport function linearRingsAreOriented(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  opt_right\n) {\n  const right = opt_right !== undefined ? opt_right : false;\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    const isClockwise = linearRingIsClockwise(\n      flatCoordinates,\n      offset,\n      end,\n      stride\n    );\n    if (i === 0) {\n      if ((right && isClockwise) || (!right && !isClockwise)) {\n        return false;\n      }\n    } else {\n      if ((right && !isClockwise) || (!right && isClockwise)) {\n        return false;\n      }\n    }\n    offset = end;\n  }\n  return true;\n}\n\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\nexport function linearRingssAreOriented(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  opt_right\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    if (\n      !linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right)\n    ) {\n      return false;\n    }\n    if (ends.length) {\n      offset = ends[ends.length - 1];\n    }\n  }\n  return true;\n}\n\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Follow the right-hand rule for orientation.\n * @return {number} End.\n */\nexport function orientLinearRings(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  opt_right\n) {\n  const right = opt_right !== undefined ? opt_right : false;\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    const isClockwise = linearRingIsClockwise(\n      flatCoordinates,\n      offset,\n      end,\n      stride\n    );\n    const reverse =\n      i === 0\n        ? (right && isClockwise) || (!right && !isClockwise)\n        : (right && !isClockwise) || (!right && isClockwise);\n    if (reverse) {\n      reverseCoordinates(flatCoordinates, offset, end, stride);\n    }\n    offset = end;\n  }\n  return offset;\n}\n\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Follow the right-hand rule for orientation.\n * @return {number} End.\n */\nexport function orientLinearRingsArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  opt_right\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    offset = orientLinearRings(\n      flatCoordinates,\n      offset,\n      endss[i],\n      stride,\n      opt_right\n    );\n  }\n  return offset;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
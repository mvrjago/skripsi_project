{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/source/Raster\n */\nimport Disposable from '../Disposable.js';\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport ImageCanvas from '../ImageCanvas.js';\nimport ImageLayer from '../layer/Image.js';\nimport ImageSource from './Image.js';\nimport Source from './Source.js';\nimport SourceState from './State.js';\nimport TileLayer from '../layer/Tile.js';\nimport TileQueue from '../TileQueue.js';\nimport TileSource from './Tile.js';\nimport { assign } from '../obj.js';\nimport { createCanvasContext2D } from '../dom.js';\nimport { create as createTransform } from '../transform.js';\nimport { equals, getCenter, getHeight, getWidth } from '../extent.js';\nvar hasImageData = true;\ntry {\n  new ImageData(10, 10);\n} catch (_) {\n  hasImageData = false;\n}\nvar context = document.createElement('canvas').getContext('2d');\n/**\n * @param {Uint8ClampedArray} data Image data.\n * @param {number} width Number of columns.\n * @param {number} height Number of rows.\n * @return {ImageData} Image data.\n */\nexport function newImageData(data, width, height) {\n  if (hasImageData) {\n    return new ImageData(data, width, height);\n  } else {\n    var imageData = context.createImageData(width, height);\n    imageData.data.set(data);\n    return imageData;\n  }\n}\n/* istanbul ignore next */\n/**\n * Create a function for running operations.  This function is serialized for\n * use in a worker.\n * @param {function(Array, Object):*} operation The operation.\n * @return {function(Object):ArrayBuffer} A function that takes an object with\n * buffers, meta, imageOps, width, and height properties and returns an array\n * buffer.\n */\nfunction createMinion(operation) {\n  var workerHasImageData = true;\n  try {\n    new ImageData(10, 10);\n  } catch (_) {\n    workerHasImageData = false;\n  }\n  function newWorkerImageData(data, width, height) {\n    if (workerHasImageData) {\n      return new ImageData(data, width, height);\n    } else {\n      return {\n        data: data,\n        width: width,\n        height: height\n      };\n    }\n  }\n  return function (data) {\n    // bracket notation for minification support\n    var buffers = data['buffers'];\n    var meta = data['meta'];\n    var imageOps = data['imageOps'];\n    var width = data['width'];\n    var height = data['height'];\n    var numBuffers = buffers.length;\n    var numBytes = buffers[0].byteLength;\n    var output, b;\n    if (imageOps) {\n      var images = new Array(numBuffers);\n      for (b = 0; b < numBuffers; ++b) {\n        images[b] = newWorkerImageData(new Uint8ClampedArray(buffers[b]), width, height);\n      }\n      output = operation(images, meta).data;\n    } else {\n      output = new Uint8ClampedArray(numBytes);\n      var arrays = new Array(numBuffers);\n      var pixels = new Array(numBuffers);\n      for (b = 0; b < numBuffers; ++b) {\n        arrays[b] = new Uint8ClampedArray(buffers[b]);\n        pixels[b] = [0, 0, 0, 0];\n      }\n      for (var i = 0; i < numBytes; i += 4) {\n        for (var j = 0; j < numBuffers; ++j) {\n          var array = arrays[j];\n          pixels[j][0] = array[i];\n          pixels[j][1] = array[i + 1];\n          pixels[j][2] = array[i + 2];\n          pixels[j][3] = array[i + 3];\n        }\n        var pixel = operation(pixels, meta);\n        output[i] = pixel[0];\n        output[i + 1] = pixel[1];\n        output[i + 2] = pixel[2];\n        output[i + 3] = pixel[3];\n      }\n    }\n    return output.buffer;\n  };\n}\n/**\n * Create a worker for running operations.\n * @param {Object} config Configuration.\n * @param {function(MessageEvent): void} onMessage Called with a message event.\n * @return {Worker} The worker.\n */\nfunction createWorker(config, onMessage) {\n  var lib = Object.keys(config.lib || {}).map(function (name) {\n    return 'var ' + name + ' = ' + config.lib[name].toString() + ';';\n  });\n  var lines = lib.concat(['var __minion__ = (' + createMinion.toString() + ')(', config.operation.toString(), ');', 'self.addEventListener(\"message\", function(event) {', '  var buffer = __minion__(event.data);', '  self.postMessage({buffer: buffer, meta: event.data.meta}, [buffer]);', '});']);\n  var blob = new Blob(lines, {\n    type: 'text/javascript'\n  });\n  var source = URL.createObjectURL(blob);\n  var worker = new Worker(source);\n  worker.addEventListener('message', onMessage);\n  return worker;\n}\n/**\n * @typedef {Object} FauxMessageEvent\n * @property {Object} data Message data.\n */\n/**\n * Create a faux worker for running operations.\n * @param {ProcessorOptions} config Configuration.\n * @param {function(FauxMessageEvent): void} onMessage Called with a message event.\n * @return {Object} The faux worker.\n */\nfunction createFauxWorker(config, onMessage) {\n  var minion = createMinion(config.operation);\n  var terminated = false;\n  return {\n    postMessage: function (data) {\n      setTimeout(function () {\n        if (terminated) {\n          return;\n        }\n        onMessage({\n          data: {\n            buffer: minion(data),\n            meta: data['meta']\n          }\n        });\n      }, 0);\n    },\n    terminate: function () {\n      terminated = true;\n    }\n  };\n}\n/**\n * @typedef {Object} ProcessorOptions\n * @property {number} threads Number of workers to spawn.\n * @property {function(Array, Object):*} operation The operation.\n * @property {Object} [lib] Functions that will be made available to operations run in a worker.\n * @property {number} queue The number of queued jobs to allow.\n * @property {boolean} [imageOps=false] Pass all the image data to the operation instead of a single pixel.\n */\n/**\n * @classdesc\n * A processor runs pixel or image operations in workers.\n */\nvar Processor = /** @class */function (_super) {\n  __extends(Processor, _super);\n  /**\n   * @param {ProcessorOptions} config Configuration.\n   */\n  function Processor(config) {\n    var _this = _super.call(this) || this;\n    _this._imageOps = !!config.imageOps;\n    var threads;\n    if (config.threads === 0) {\n      threads = 0;\n    } else if (_this._imageOps) {\n      threads = 1;\n    } else {\n      threads = config.threads || 1;\n    }\n    var workers = [];\n    if (threads) {\n      for (var i = 0; i < threads; ++i) {\n        workers[i] = createWorker(config, _this._onWorkerMessage.bind(_this, i));\n      }\n    } else {\n      workers[0] = createFauxWorker(config, _this._onWorkerMessage.bind(_this, 0));\n    }\n    _this._workers = workers;\n    _this._queue = [];\n    _this._maxQueueLength = config.queue || Infinity;\n    _this._running = 0;\n    _this._dataLookup = {};\n    _this._job = null;\n    return _this;\n  }\n  /**\n   * Run operation on input data.\n   * @param {Array.<Array|ImageData>} inputs Array of pixels or image data\n   *     (depending on the operation type).\n   * @param {Object} meta A user data object.  This is passed to all operations\n   *     and must be serializable.\n   * @param {function(Error, ImageData, Object): void} callback Called when work\n   *     completes.  The first argument is any error.  The second is the ImageData\n   *     generated by operations.  The third is the user data object.\n   */\n  Processor.prototype.process = function (inputs, meta, callback) {\n    this._enqueue({\n      inputs: inputs,\n      meta: meta,\n      callback: callback\n    });\n    this._dispatch();\n  };\n  /**\n   * Add a job to the queue.\n   * @param {Object} job The job.\n   */\n  Processor.prototype._enqueue = function (job) {\n    this._queue.push(job);\n    while (this._queue.length > this._maxQueueLength) {\n      this._queue.shift().callback(null, null);\n    }\n  };\n  /**\n   * Dispatch a job.\n   */\n  Processor.prototype._dispatch = function () {\n    if (this._running === 0 && this._queue.length > 0) {\n      var job = this._queue.shift();\n      this._job = job;\n      var width = job.inputs[0].width;\n      var height = job.inputs[0].height;\n      var buffers = job.inputs.map(function (input) {\n        return input.data.buffer;\n      });\n      var threads = this._workers.length;\n      this._running = threads;\n      if (threads === 1) {\n        this._workers[0].postMessage({\n          buffers: buffers,\n          meta: job.meta,\n          imageOps: this._imageOps,\n          width: width,\n          height: height\n        }, buffers);\n      } else {\n        var length_1 = job.inputs[0].data.length;\n        var segmentLength = 4 * Math.ceil(length_1 / 4 / threads);\n        for (var i = 0; i < threads; ++i) {\n          var offset = i * segmentLength;\n          var slices = [];\n          for (var j = 0, jj = buffers.length; j < jj; ++j) {\n            slices.push(buffers[i].slice(offset, offset + segmentLength));\n          }\n          this._workers[i].postMessage({\n            buffers: slices,\n            meta: job.meta,\n            imageOps: this._imageOps,\n            width: width,\n            height: height\n          }, slices);\n        }\n      }\n    }\n  };\n  /**\n   * Handle messages from the worker.\n   * @param {number} index The worker index.\n   * @param {MessageEvent} event The message event.\n   */\n  Processor.prototype._onWorkerMessage = function (index, event) {\n    if (this.disposed) {\n      return;\n    }\n    this._dataLookup[index] = event.data;\n    --this._running;\n    if (this._running === 0) {\n      this._resolveJob();\n    }\n  };\n  /**\n   * Resolve a job.  If there are no more worker threads, the processor callback\n   * will be called.\n   */\n  Processor.prototype._resolveJob = function () {\n    var job = this._job;\n    var threads = this._workers.length;\n    var data, meta;\n    if (threads === 1) {\n      data = new Uint8ClampedArray(this._dataLookup[0]['buffer']);\n      meta = this._dataLookup[0]['meta'];\n    } else {\n      var length_2 = job.inputs[0].data.length;\n      data = new Uint8ClampedArray(length_2);\n      meta = new Array(length_2);\n      var segmentLength = 4 * Math.ceil(length_2 / 4 / threads);\n      for (var i = 0; i < threads; ++i) {\n        var buffer = this._dataLookup[i]['buffer'];\n        var offset = i * segmentLength;\n        data.set(new Uint8ClampedArray(buffer), offset);\n        meta[i] = this._dataLookup[i]['meta'];\n      }\n    }\n    this._job = null;\n    this._dataLookup = {};\n    job.callback(null, newImageData(data, job.inputs[0].width, job.inputs[0].height), meta);\n    this._dispatch();\n  };\n  /**\n   * Terminate all workers associated with the processor.\n   */\n  Processor.prototype.disposeInternal = function () {\n    for (var i = 0; i < this._workers.length; ++i) {\n      this._workers[i].terminate();\n    }\n    this._workers.length = 0;\n  };\n  return Processor;\n}(Disposable);\nexport { Processor };\n/**\n * A function that takes an array of input data, performs some operation, and\n * returns an array of output data.\n * For `pixel` type operations, the function will be called with an array of\n * pixels, where each pixel is an array of four numbers (`[r, g, b, a]`) in the\n * range of 0 - 255. It should return a single pixel array.\n * For `'image'` type operations, functions will be called with an array of\n * {@link ImageData https://developer.mozilla.org/en-US/docs/Web/API/ImageData}\n * and should return a single {@link ImageData\n * https://developer.mozilla.org/en-US/docs/Web/API/ImageData}.  The operations\n * are called with a second \"data\" argument, which can be used for storage.  The\n * data object is accessible from raster events, where it can be initialized in\n * \"beforeoperations\" and accessed again in \"afteroperations\".\n *\n * @typedef {function((Array<Array<number>>|Array<ImageData>), Object):\n *     (Array<number>|ImageData)} Operation\n */\n/**\n * @enum {string}\n */\nvar RasterEventType = {\n  /**\n   * Triggered before operations are run.\n   * @event module:ol/source/Raster.RasterSourceEvent#beforeoperations\n   * @api\n   */\n  BEFOREOPERATIONS: 'beforeoperations',\n  /**\n   * Triggered after operations are run.\n   * @event module:ol/source/Raster.RasterSourceEvent#afteroperations\n   * @api\n   */\n  AFTEROPERATIONS: 'afteroperations'\n};\n/**\n * Raster operation type. Supported values are `'pixel'` and `'image'`.\n * @enum {string}\n */\nvar RasterOperationType = {\n  PIXEL: 'pixel',\n  IMAGE: 'image'\n};\n/**\n * @classdesc\n * Events emitted by {@link module:ol/source/Raster} instances are instances of this\n * type.\n */\nvar RasterSourceEvent = /** @class */function (_super) {\n  __extends(RasterSourceEvent, _super);\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState The frame state.\n   * @param {Object} data An object made available to operations.\n   */\n  function RasterSourceEvent(type, frameState, data) {\n    var _this = _super.call(this, type) || this;\n    /**\n     * The raster extent.\n     * @type {import(\"../extent.js\").Extent}\n     * @api\n     */\n    _this.extent = frameState.extent;\n    /**\n     * The pixel resolution (map units per pixel).\n     * @type {number}\n     * @api\n     */\n    _this.resolution = frameState.viewState.resolution / frameState.pixelRatio;\n    /**\n     * An object made available to all operations.  This can be used by operations\n     * as a storage object (e.g. for calculating statistics).\n     * @type {Object}\n     * @api\n     */\n    _this.data = data;\n    return _this;\n  }\n  return RasterSourceEvent;\n}(Event);\nexport { RasterSourceEvent };\n/**\n * @typedef {Object} Options\n * @property {Array<import(\"./Source.js\").default|import(\"../layer/Layer.js\").default>} sources Input\n * sources or layers.  For vector data, use an VectorImage layer.\n * @property {Operation} [operation] Raster operation.\n * The operation will be called with data from input sources\n * and the output will be assigned to the raster source.\n * @property {Object} [lib] Functions that will be made available to operations run in a worker.\n * @property {number} [threads] By default, operations will be run in a single worker thread.\n * To avoid using workers altogether, set `threads: 0`.  For pixel operations, operations can\n * be run in multiple worker threads.  Note that there is additional overhead in\n * transferring data to multiple workers, and that depending on the user's\n * system, it may not be possible to parallelize the work.\n * @property {RasterOperationType} [operationType='pixel'] Operation type.\n * Supported values are `'pixel'` and `'image'`.  By default,\n * `'pixel'` operations are assumed, and operations will be called with an\n * array of pixels from input sources.  If set to `'image'`, operations will\n * be called with an array of ImageData objects from input sources.\n */\n/**\n * @classdesc\n * A source that transforms data from any number of input sources using an\n * {@link module:ol/source/Raster~Operation} function to transform input pixel values into\n * output pixel values.\n *\n * @fires module:ol/source/Raster.RasterSourceEvent\n * @api\n */\nvar RasterSource = /** @class */function (_super) {\n  __extends(RasterSource, _super);\n  /**\n   * @param {Options} options Options.\n   */\n  function RasterSource(options) {\n    var _this = _super.call(this, {\n      projection: null\n    }) || this;\n    /**\n     * @private\n     * @type {Processor}\n     */\n    _this.processor_ = null;\n    /**\n     * @private\n     * @type {RasterOperationType}\n     */\n    _this.operationType_ = options.operationType !== undefined ? options.operationType : RasterOperationType.PIXEL;\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.threads_ = options.threads !== undefined ? options.threads : 1;\n    /**\n     * @private\n     * @type {Array<import(\"../layer/Layer.js\").default>}\n     */\n    _this.layers_ = createLayers(options.sources);\n    var changed = _this.changed.bind(_this);\n    for (var i = 0, ii = _this.layers_.length; i < ii; ++i) {\n      _this.layers_[i].addEventListener(EventType.CHANGE, changed);\n    }\n    /**\n     * @private\n     * @type {import(\"../TileQueue.js\").default}\n     */\n    _this.tileQueue_ = new TileQueue(function () {\n      return 1;\n    }, _this.changed.bind(_this));\n    /**\n     * The most recently requested frame state.\n     * @type {import(\"../PluggableMap.js\").FrameState}\n     * @private\n     */\n    _this.requestedFrameState_;\n    /**\n     * The most recently rendered image canvas.\n     * @type {import(\"../ImageCanvas.js\").default}\n     * @private\n     */\n    _this.renderedImageCanvas_ = null;\n    /**\n     * The most recently rendered revision.\n     * @type {number}\n     */\n    _this.renderedRevision_;\n    /**\n     * @private\n     * @type {import(\"../PluggableMap.js\").FrameState}\n     */\n    _this.frameState_ = {\n      animate: false,\n      coordinateToPixelTransform: createTransform(),\n      extent: null,\n      index: 0,\n      layerIndex: 0,\n      layerStatesArray: getLayerStatesArray(_this.layers_),\n      pixelRatio: 1,\n      pixelToCoordinateTransform: createTransform(),\n      postRenderFunctions: [],\n      size: [0, 0],\n      tileQueue: _this.tileQueue_,\n      time: Date.now(),\n      usedTiles: {},\n      viewState: /** @type {import(\"../View.js\").State} */{\n        rotation: 0\n      },\n      viewHints: [],\n      wantedTiles: {},\n      declutterItems: []\n    };\n    _this.setAttributions(function (frameState) {\n      var attributions = [];\n      for (var index = 0, iMax = options.sources.length; index < iMax; ++index) {\n        var sourceOrLayer = options.sources[index];\n        var source = sourceOrLayer instanceof Source ? sourceOrLayer : sourceOrLayer.getSource();\n        var attributionGetter = source.getAttributions();\n        if (typeof attributionGetter === 'function') {\n          var sourceAttribution = attributionGetter(frameState);\n          attributions.push.apply(attributions, sourceAttribution);\n        }\n      }\n      return attributions.length !== 0 ? attributions : null;\n    });\n    if (options.operation !== undefined) {\n      _this.setOperation(options.operation, options.lib);\n    }\n    return _this;\n  }\n  /**\n   * Set the operation.\n   * @param {Operation} operation New operation.\n   * @param {Object=} opt_lib Functions that will be available to operations run\n   *     in a worker.\n   * @api\n   */\n  RasterSource.prototype.setOperation = function (operation, opt_lib) {\n    if (this.processor_) {\n      this.processor_.dispose();\n    }\n    this.processor_ = new Processor({\n      operation: operation,\n      imageOps: this.operationType_ === RasterOperationType.IMAGE,\n      queue: 1,\n      lib: opt_lib,\n      threads: this.threads_\n    });\n    this.changed();\n  };\n  /**\n   * Update the stored frame state.\n   * @param {import(\"../extent.js\").Extent} extent The view extent (in map units).\n   * @param {number} resolution The view resolution.\n   * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n   * @return {import(\"../PluggableMap.js\").FrameState} The updated frame state.\n   * @private\n   */\n  RasterSource.prototype.updateFrameState_ = function (extent, resolution, projection) {\n    var frameState = /** @type {import(\"../PluggableMap.js\").FrameState} */assign({}, this.frameState_);\n    frameState.viewState = /** @type {import(\"../View.js\").State} */assign({}, frameState.viewState);\n    var center = getCenter(extent);\n    frameState.extent = extent.slice();\n    frameState.size[0] = Math.round(getWidth(extent) / resolution);\n    frameState.size[1] = Math.round(getHeight(extent) / resolution);\n    frameState.time = Infinity;\n    var viewState = frameState.viewState;\n    viewState.center = center;\n    viewState.projection = projection;\n    viewState.resolution = resolution;\n    return frameState;\n  };\n  /**\n   * Determine if all sources are ready.\n   * @return {boolean} All sources are ready.\n   * @private\n   */\n  RasterSource.prototype.allSourcesReady_ = function () {\n    var ready = true;\n    var source;\n    for (var i = 0, ii = this.layers_.length; i < ii; ++i) {\n      source = this.layers_[i].getSource();\n      if (source.getState() !== SourceState.READY) {\n        ready = false;\n        break;\n      }\n    }\n    return ready;\n  };\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../ImageCanvas.js\").default} Single image.\n   */\n  RasterSource.prototype.getImage = function (extent, resolution, pixelRatio, projection) {\n    if (!this.allSourcesReady_()) {\n      return null;\n    }\n    var frameState = this.updateFrameState_(extent, resolution, projection);\n    this.requestedFrameState_ = frameState;\n    // check if we can't reuse the existing ol/ImageCanvas\n    if (this.renderedImageCanvas_) {\n      var renderedResolution = this.renderedImageCanvas_.getResolution();\n      var renderedExtent = this.renderedImageCanvas_.getExtent();\n      if (resolution !== renderedResolution || !equals(extent, renderedExtent)) {\n        this.renderedImageCanvas_ = null;\n      }\n    }\n    if (!this.renderedImageCanvas_ || this.getRevision() !== this.renderedRevision_) {\n      this.processSources_();\n    }\n    frameState.tileQueue.loadMoreTiles(16, 16);\n    if (frameState.animate) {\n      requestAnimationFrame(this.changed.bind(this));\n    }\n    return this.renderedImageCanvas_;\n  };\n  /**\n   * Start processing source data.\n   * @private\n   */\n  RasterSource.prototype.processSources_ = function () {\n    var frameState = this.requestedFrameState_;\n    var len = this.layers_.length;\n    var imageDatas = new Array(len);\n    for (var i = 0; i < len; ++i) {\n      frameState.layerIndex = i;\n      var imageData = getImageData(this.layers_[i], frameState);\n      if (imageData) {\n        imageDatas[i] = imageData;\n      } else {\n        return;\n      }\n    }\n    var data = {};\n    this.dispatchEvent(new RasterSourceEvent(RasterEventType.BEFOREOPERATIONS, frameState, data));\n    this.processor_.process(imageDatas, data, this.onWorkerComplete_.bind(this, frameState));\n  };\n  /**\n   * Called when pixel processing is complete.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState The frame state.\n   * @param {Error} err Any error during processing.\n   * @param {ImageData} output The output image data.\n   * @param {Object} data The user data.\n   * @private\n   */\n  RasterSource.prototype.onWorkerComplete_ = function (frameState, err, output, data) {\n    if (err || !output) {\n      return;\n    }\n    // do nothing if extent or resolution changed\n    var extent = frameState.extent;\n    var resolution = frameState.viewState.resolution;\n    if (resolution !== this.requestedFrameState_.viewState.resolution || !equals(extent, this.requestedFrameState_.extent)) {\n      return;\n    }\n    var context;\n    if (this.renderedImageCanvas_) {\n      context = this.renderedImageCanvas_.getImage().getContext('2d');\n    } else {\n      var width = Math.round(getWidth(extent) / resolution);\n      var height = Math.round(getHeight(extent) / resolution);\n      context = createCanvasContext2D(width, height);\n      this.renderedImageCanvas_ = new ImageCanvas(extent, resolution, 1, context.canvas);\n    }\n    context.putImageData(output, 0, 0);\n    this.changed();\n    this.renderedRevision_ = this.getRevision();\n    this.dispatchEvent(new RasterSourceEvent(RasterEventType.AFTEROPERATIONS, frameState, data));\n  };\n  /**\n   * @return {null} not implemented\n   */\n  RasterSource.prototype.getImageInternal = function () {\n    return null; // not implemented\n  };\n\n  RasterSource.prototype.disposeInternal = function () {\n    if (this.processor_) {\n      this.processor_.dispose();\n    }\n    _super.prototype.disposeInternal.call(this);\n  };\n  return RasterSource;\n}(ImageSource);\n/**\n * Clean up and unregister the worker.\n * @function\n * @api\n */\nRasterSource.prototype.dispose;\n/**\n * A reusable canvas context.\n * @type {CanvasRenderingContext2D}\n * @private\n */\nvar sharedContext = null;\n/**\n * Get image data from a layer.\n * @param {import(\"../layer/Layer.js\").default} layer Layer to render.\n * @param {import(\"../PluggableMap.js\").FrameState} frameState The frame state.\n * @return {ImageData} The image data.\n */\nfunction getImageData(layer, frameState) {\n  var renderer = layer.getRenderer();\n  if (!renderer) {\n    throw new Error('Unsupported layer type: ' + layer);\n  }\n  if (!renderer.prepareFrame(frameState)) {\n    return null;\n  }\n  var width = frameState.size[0];\n  var height = frameState.size[1];\n  var container = renderer.renderFrame(frameState, null);\n  var element;\n  if (container) {\n    element = container.firstElementChild;\n  }\n  if (!(element instanceof HTMLCanvasElement)) {\n    throw new Error('Unsupported rendered element: ' + element);\n  }\n  if (element.width === width && element.height === height) {\n    var context_1 = element.getContext('2d');\n    return context_1.getImageData(0, 0, width, height);\n  }\n  if (!sharedContext) {\n    sharedContext = createCanvasContext2D(width, height);\n  } else {\n    var canvas = sharedContext.canvas;\n    if (canvas.width !== width || canvas.height !== height) {\n      sharedContext = createCanvasContext2D(width, height);\n    } else {\n      sharedContext.clearRect(0, 0, width, height);\n    }\n  }\n  sharedContext.drawImage(element, 0, 0, width, height);\n  return sharedContext.getImageData(0, 0, width, height);\n}\n/**\n * Get a list of layer states from a list of layers.\n * @param {Array<import(\"../layer/Layer.js\").default>} layers Layers.\n * @return {Array<import(\"../layer/Layer.js\").State>} The layer states.\n */\nfunction getLayerStatesArray(layers) {\n  return layers.map(function (layer) {\n    return layer.getLayerState();\n  });\n}\n/**\n * Create layers for all sources.\n * @param {Array<import(\"./Source.js\").default|import(\"../layer/Layer.js\").default>} sources The sources.\n * @return {Array<import(\"../layer/Layer.js\").default>} Array of layers.\n */\nfunction createLayers(sources) {\n  var len = sources.length;\n  var layers = new Array(len);\n  for (var i = 0; i < len; ++i) {\n    layers[i] = createLayer(sources[i]);\n  }\n  return layers;\n}\n/**\n * Create a layer for the provided source.\n * @param {import(\"./Source.js\").default|import(\"../layer/Layer.js\").default} layerOrSource The layer or source.\n * @return {import(\"../layer/Layer.js\").default} The layer.\n */\nfunction createLayer(layerOrSource) {\n  // @type {import(\"../layer/Layer.js\").default}\n  var layer;\n  if (layerOrSource instanceof Source) {\n    if (layerOrSource instanceof TileSource) {\n      layer = new TileLayer({\n        source: layerOrSource\n      });\n    } else if (layerOrSource instanceof ImageSource) {\n      layer = new ImageLayer({\n        source: layerOrSource\n      });\n    }\n  } else {\n    layer = layerOrSource;\n  }\n  return layer;\n}\nexport default RasterSource;","map":{"version":3,"names":["Disposable","Event","EventType","ImageCanvas","ImageLayer","ImageSource","Source","SourceState","TileLayer","TileQueue","TileSource","assign","createCanvasContext2D","create","createTransform","equals","getCenter","getHeight","getWidth","hasImageData","ImageData","_","context","document","createElement","getContext","newImageData","data","width","height","imageData","createImageData","set","createMinion","operation","workerHasImageData","newWorkerImageData","buffers","meta","imageOps","numBuffers","length","numBytes","byteLength","output","b","images","Array","Uint8ClampedArray","arrays","pixels","i","j","array","pixel","buffer","createWorker","config","onMessage","lib","Object","keys","map","name","toString","lines","concat","blob","Blob","type","source","URL","createObjectURL","worker","Worker","addEventListener","createFauxWorker","minion","terminated","postMessage","setTimeout","terminate","Processor","_super","__extends","_this","call","_imageOps","threads","workers","_onWorkerMessage","bind","_workers","_queue","_maxQueueLength","queue","Infinity","_running","_dataLookup","_job","prototype","process","inputs","callback","_enqueue","_dispatch","job","push","shift","input","length_1","segmentLength","Math","ceil","offset","slices","jj","slice","index","event","disposed","_resolveJob","length_2","disposeInternal","RasterEventType","BEFOREOPERATIONS","AFTEROPERATIONS","RasterOperationType","PIXEL","IMAGE","RasterSourceEvent","frameState","extent","resolution","viewState","pixelRatio","RasterSource","options","projection","processor_","operationType_","operationType","undefined","threads_","layers_","createLayers","sources","changed","ii","CHANGE","tileQueue_","requestedFrameState_","renderedImageCanvas_","renderedRevision_","frameState_","animate","coordinateToPixelTransform","layerIndex","layerStatesArray","getLayerStatesArray","pixelToCoordinateTransform","postRenderFunctions","size","tileQueue","time","Date","now","usedTiles","rotation","viewHints","wantedTiles","declutterItems","setAttributions","attributions","iMax","sourceOrLayer","getSource","attributionGetter","getAttributions","sourceAttribution","apply","setOperation","opt_lib","dispose","updateFrameState_","center","round","allSourcesReady_","ready","getState","READY","getImage","renderedResolution","getResolution","renderedExtent","getExtent","getRevision","processSources_","loadMoreTiles","requestAnimationFrame","len","imageDatas","getImageData","dispatchEvent","onWorkerComplete_","err","canvas","putImageData","getImageInternal","sharedContext","layer","renderer","getRenderer","Error","prepareFrame","container","renderFrame","element","firstElementChild","HTMLCanvasElement","context_1","clearRect","drawImage","layers","getLayerState","createLayer","layerOrSource"],"sources":["/Users/mariovicky/Skripsi_OpenLayers/node_modules/ol/src/source/Raster.js"],"sourcesContent":["/**\n * @module ol/source/Raster\n */\nimport Disposable from '../Disposable.js';\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport ImageCanvas from '../ImageCanvas.js';\nimport ImageLayer from '../layer/Image.js';\nimport ImageSource from './Image.js';\nimport Source from './Source.js';\nimport SourceState from './State.js';\nimport TileLayer from '../layer/Tile.js';\nimport TileQueue from '../TileQueue.js';\nimport TileSource from './Tile.js';\nimport {assign} from '../obj.js';\nimport {createCanvasContext2D} from '../dom.js';\nimport {create as createTransform} from '../transform.js';\nimport {equals, getCenter, getHeight, getWidth} from '../extent.js';\n\nlet hasImageData = true;\ntry {\n  new ImageData(10, 10);\n} catch (_) {\n  hasImageData = false;\n}\n\nconst context = document.createElement('canvas').getContext('2d');\n\n/**\n * @param {Uint8ClampedArray} data Image data.\n * @param {number} width Number of columns.\n * @param {number} height Number of rows.\n * @return {ImageData} Image data.\n */\nexport function newImageData(data, width, height) {\n  if (hasImageData) {\n    return new ImageData(data, width, height);\n  } else {\n    const imageData = context.createImageData(width, height);\n    imageData.data.set(data);\n    return imageData;\n  }\n}\n\n/* istanbul ignore next */\n/**\n * Create a function for running operations.  This function is serialized for\n * use in a worker.\n * @param {function(Array, Object):*} operation The operation.\n * @return {function(Object):ArrayBuffer} A function that takes an object with\n * buffers, meta, imageOps, width, and height properties and returns an array\n * buffer.\n */\nfunction createMinion(operation) {\n  let workerHasImageData = true;\n  try {\n    new ImageData(10, 10);\n  } catch (_) {\n    workerHasImageData = false;\n  }\n\n  function newWorkerImageData(data, width, height) {\n    if (workerHasImageData) {\n      return new ImageData(data, width, height);\n    } else {\n      return {data: data, width: width, height: height};\n    }\n  }\n\n  return function (data) {\n    // bracket notation for minification support\n    const buffers = data['buffers'];\n    const meta = data['meta'];\n    const imageOps = data['imageOps'];\n    const width = data['width'];\n    const height = data['height'];\n\n    const numBuffers = buffers.length;\n    const numBytes = buffers[0].byteLength;\n    let output, b;\n\n    if (imageOps) {\n      const images = new Array(numBuffers);\n      for (b = 0; b < numBuffers; ++b) {\n        images[b] = newWorkerImageData(\n          new Uint8ClampedArray(buffers[b]),\n          width,\n          height\n        );\n      }\n      output = operation(images, meta).data;\n    } else {\n      output = new Uint8ClampedArray(numBytes);\n      const arrays = new Array(numBuffers);\n      const pixels = new Array(numBuffers);\n      for (b = 0; b < numBuffers; ++b) {\n        arrays[b] = new Uint8ClampedArray(buffers[b]);\n        pixels[b] = [0, 0, 0, 0];\n      }\n      for (let i = 0; i < numBytes; i += 4) {\n        for (let j = 0; j < numBuffers; ++j) {\n          const array = arrays[j];\n          pixels[j][0] = array[i];\n          pixels[j][1] = array[i + 1];\n          pixels[j][2] = array[i + 2];\n          pixels[j][3] = array[i + 3];\n        }\n        const pixel = operation(pixels, meta);\n        output[i] = pixel[0];\n        output[i + 1] = pixel[1];\n        output[i + 2] = pixel[2];\n        output[i + 3] = pixel[3];\n      }\n    }\n    return output.buffer;\n  };\n}\n\n/**\n * Create a worker for running operations.\n * @param {Object} config Configuration.\n * @param {function(MessageEvent): void} onMessage Called with a message event.\n * @return {Worker} The worker.\n */\nfunction createWorker(config, onMessage) {\n  const lib = Object.keys(config.lib || {}).map(function (name) {\n    return 'var ' + name + ' = ' + config.lib[name].toString() + ';';\n  });\n\n  const lines = lib.concat([\n    'var __minion__ = (' + createMinion.toString() + ')(',\n    config.operation.toString(),\n    ');',\n    'self.addEventListener(\"message\", function(event) {',\n    '  var buffer = __minion__(event.data);',\n    '  self.postMessage({buffer: buffer, meta: event.data.meta}, [buffer]);',\n    '});',\n  ]);\n\n  const blob = new Blob(lines, {type: 'text/javascript'});\n  const source = URL.createObjectURL(blob);\n  const worker = new Worker(source);\n  worker.addEventListener('message', onMessage);\n  return worker;\n}\n\n/**\n * @typedef {Object} FauxMessageEvent\n * @property {Object} data Message data.\n */\n\n/**\n * Create a faux worker for running operations.\n * @param {ProcessorOptions} config Configuration.\n * @param {function(FauxMessageEvent): void} onMessage Called with a message event.\n * @return {Object} The faux worker.\n */\nfunction createFauxWorker(config, onMessage) {\n  const minion = createMinion(config.operation);\n  let terminated = false;\n  return {\n    postMessage: function (data) {\n      setTimeout(function () {\n        if (terminated) {\n          return;\n        }\n        onMessage({data: {buffer: minion(data), meta: data['meta']}});\n      }, 0);\n    },\n    terminate: function () {\n      terminated = true;\n    },\n  };\n}\n\n/**\n * @typedef {Object} ProcessorOptions\n * @property {number} threads Number of workers to spawn.\n * @property {function(Array, Object):*} operation The operation.\n * @property {Object} [lib] Functions that will be made available to operations run in a worker.\n * @property {number} queue The number of queued jobs to allow.\n * @property {boolean} [imageOps=false] Pass all the image data to the operation instead of a single pixel.\n */\n\n/**\n * @classdesc\n * A processor runs pixel or image operations in workers.\n */\nexport class Processor extends Disposable {\n  /**\n   * @param {ProcessorOptions} config Configuration.\n   */\n  constructor(config) {\n    super();\n\n    this._imageOps = !!config.imageOps;\n    let threads;\n    if (config.threads === 0) {\n      threads = 0;\n    } else if (this._imageOps) {\n      threads = 1;\n    } else {\n      threads = config.threads || 1;\n    }\n    const workers = [];\n    if (threads) {\n      for (let i = 0; i < threads; ++i) {\n        workers[i] = createWorker(config, this._onWorkerMessage.bind(this, i));\n      }\n    } else {\n      workers[0] = createFauxWorker(\n        config,\n        this._onWorkerMessage.bind(this, 0)\n      );\n    }\n    this._workers = workers;\n    this._queue = [];\n    this._maxQueueLength = config.queue || Infinity;\n    this._running = 0;\n    this._dataLookup = {};\n    this._job = null;\n  }\n\n  /**\n   * Run operation on input data.\n   * @param {Array.<Array|ImageData>} inputs Array of pixels or image data\n   *     (depending on the operation type).\n   * @param {Object} meta A user data object.  This is passed to all operations\n   *     and must be serializable.\n   * @param {function(Error, ImageData, Object): void} callback Called when work\n   *     completes.  The first argument is any error.  The second is the ImageData\n   *     generated by operations.  The third is the user data object.\n   */\n  process(inputs, meta, callback) {\n    this._enqueue({\n      inputs: inputs,\n      meta: meta,\n      callback: callback,\n    });\n    this._dispatch();\n  }\n\n  /**\n   * Add a job to the queue.\n   * @param {Object} job The job.\n   */\n  _enqueue(job) {\n    this._queue.push(job);\n    while (this._queue.length > this._maxQueueLength) {\n      this._queue.shift().callback(null, null);\n    }\n  }\n\n  /**\n   * Dispatch a job.\n   */\n  _dispatch() {\n    if (this._running === 0 && this._queue.length > 0) {\n      const job = this._queue.shift();\n      this._job = job;\n      const width = job.inputs[0].width;\n      const height = job.inputs[0].height;\n      const buffers = job.inputs.map(function (input) {\n        return input.data.buffer;\n      });\n      const threads = this._workers.length;\n      this._running = threads;\n      if (threads === 1) {\n        this._workers[0].postMessage(\n          {\n            buffers: buffers,\n            meta: job.meta,\n            imageOps: this._imageOps,\n            width: width,\n            height: height,\n          },\n          buffers\n        );\n      } else {\n        const length = job.inputs[0].data.length;\n        const segmentLength = 4 * Math.ceil(length / 4 / threads);\n        for (let i = 0; i < threads; ++i) {\n          const offset = i * segmentLength;\n          const slices = [];\n          for (let j = 0, jj = buffers.length; j < jj; ++j) {\n            slices.push(buffers[i].slice(offset, offset + segmentLength));\n          }\n          this._workers[i].postMessage(\n            {\n              buffers: slices,\n              meta: job.meta,\n              imageOps: this._imageOps,\n              width: width,\n              height: height,\n            },\n            slices\n          );\n        }\n      }\n    }\n  }\n\n  /**\n   * Handle messages from the worker.\n   * @param {number} index The worker index.\n   * @param {MessageEvent} event The message event.\n   */\n  _onWorkerMessage(index, event) {\n    if (this.disposed) {\n      return;\n    }\n    this._dataLookup[index] = event.data;\n    --this._running;\n    if (this._running === 0) {\n      this._resolveJob();\n    }\n  }\n\n  /**\n   * Resolve a job.  If there are no more worker threads, the processor callback\n   * will be called.\n   */\n  _resolveJob() {\n    const job = this._job;\n    const threads = this._workers.length;\n    let data, meta;\n    if (threads === 1) {\n      data = new Uint8ClampedArray(this._dataLookup[0]['buffer']);\n      meta = this._dataLookup[0]['meta'];\n    } else {\n      const length = job.inputs[0].data.length;\n      data = new Uint8ClampedArray(length);\n      meta = new Array(length);\n      const segmentLength = 4 * Math.ceil(length / 4 / threads);\n      for (let i = 0; i < threads; ++i) {\n        const buffer = this._dataLookup[i]['buffer'];\n        const offset = i * segmentLength;\n        data.set(new Uint8ClampedArray(buffer), offset);\n        meta[i] = this._dataLookup[i]['meta'];\n      }\n    }\n    this._job = null;\n    this._dataLookup = {};\n    job.callback(\n      null,\n      newImageData(data, job.inputs[0].width, job.inputs[0].height),\n      meta\n    );\n    this._dispatch();\n  }\n\n  /**\n   * Terminate all workers associated with the processor.\n   */\n  disposeInternal() {\n    for (let i = 0; i < this._workers.length; ++i) {\n      this._workers[i].terminate();\n    }\n    this._workers.length = 0;\n  }\n}\n\n/**\n * A function that takes an array of input data, performs some operation, and\n * returns an array of output data.\n * For `pixel` type operations, the function will be called with an array of\n * pixels, where each pixel is an array of four numbers (`[r, g, b, a]`) in the\n * range of 0 - 255. It should return a single pixel array.\n * For `'image'` type operations, functions will be called with an array of\n * {@link ImageData https://developer.mozilla.org/en-US/docs/Web/API/ImageData}\n * and should return a single {@link ImageData\n * https://developer.mozilla.org/en-US/docs/Web/API/ImageData}.  The operations\n * are called with a second \"data\" argument, which can be used for storage.  The\n * data object is accessible from raster events, where it can be initialized in\n * \"beforeoperations\" and accessed again in \"afteroperations\".\n *\n * @typedef {function((Array<Array<number>>|Array<ImageData>), Object):\n *     (Array<number>|ImageData)} Operation\n */\n\n/**\n * @enum {string}\n */\nconst RasterEventType = {\n  /**\n   * Triggered before operations are run.\n   * @event module:ol/source/Raster.RasterSourceEvent#beforeoperations\n   * @api\n   */\n  BEFOREOPERATIONS: 'beforeoperations',\n\n  /**\n   * Triggered after operations are run.\n   * @event module:ol/source/Raster.RasterSourceEvent#afteroperations\n   * @api\n   */\n  AFTEROPERATIONS: 'afteroperations',\n};\n\n/**\n * Raster operation type. Supported values are `'pixel'` and `'image'`.\n * @enum {string}\n */\nconst RasterOperationType = {\n  PIXEL: 'pixel',\n  IMAGE: 'image',\n};\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/source/Raster} instances are instances of this\n * type.\n */\nexport class RasterSourceEvent extends Event {\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState The frame state.\n   * @param {Object} data An object made available to operations.\n   */\n  constructor(type, frameState, data) {\n    super(type);\n\n    /**\n     * The raster extent.\n     * @type {import(\"../extent.js\").Extent}\n     * @api\n     */\n    this.extent = frameState.extent;\n\n    /**\n     * The pixel resolution (map units per pixel).\n     * @type {number}\n     * @api\n     */\n    this.resolution = frameState.viewState.resolution / frameState.pixelRatio;\n\n    /**\n     * An object made available to all operations.  This can be used by operations\n     * as a storage object (e.g. for calculating statistics).\n     * @type {Object}\n     * @api\n     */\n    this.data = data;\n  }\n}\n\n/**\n * @typedef {Object} Options\n * @property {Array<import(\"./Source.js\").default|import(\"../layer/Layer.js\").default>} sources Input\n * sources or layers.  For vector data, use an VectorImage layer.\n * @property {Operation} [operation] Raster operation.\n * The operation will be called with data from input sources\n * and the output will be assigned to the raster source.\n * @property {Object} [lib] Functions that will be made available to operations run in a worker.\n * @property {number} [threads] By default, operations will be run in a single worker thread.\n * To avoid using workers altogether, set `threads: 0`.  For pixel operations, operations can\n * be run in multiple worker threads.  Note that there is additional overhead in\n * transferring data to multiple workers, and that depending on the user's\n * system, it may not be possible to parallelize the work.\n * @property {RasterOperationType} [operationType='pixel'] Operation type.\n * Supported values are `'pixel'` and `'image'`.  By default,\n * `'pixel'` operations are assumed, and operations will be called with an\n * array of pixels from input sources.  If set to `'image'`, operations will\n * be called with an array of ImageData objects from input sources.\n */\n\n/**\n * @classdesc\n * A source that transforms data from any number of input sources using an\n * {@link module:ol/source/Raster~Operation} function to transform input pixel values into\n * output pixel values.\n *\n * @fires module:ol/source/Raster.RasterSourceEvent\n * @api\n */\nclass RasterSource extends ImageSource {\n  /**\n   * @param {Options} options Options.\n   */\n  constructor(options) {\n    super({\n      projection: null,\n    });\n\n    /**\n     * @private\n     * @type {Processor}\n     */\n    this.processor_ = null;\n\n    /**\n     * @private\n     * @type {RasterOperationType}\n     */\n    this.operationType_ =\n      options.operationType !== undefined\n        ? options.operationType\n        : RasterOperationType.PIXEL;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.threads_ = options.threads !== undefined ? options.threads : 1;\n\n    /**\n     * @private\n     * @type {Array<import(\"../layer/Layer.js\").default>}\n     */\n    this.layers_ = createLayers(options.sources);\n\n    const changed = this.changed.bind(this);\n    for (let i = 0, ii = this.layers_.length; i < ii; ++i) {\n      this.layers_[i].addEventListener(EventType.CHANGE, changed);\n    }\n\n    /**\n     * @private\n     * @type {import(\"../TileQueue.js\").default}\n     */\n    this.tileQueue_ = new TileQueue(function () {\n      return 1;\n    }, this.changed.bind(this));\n\n    /**\n     * The most recently requested frame state.\n     * @type {import(\"../PluggableMap.js\").FrameState}\n     * @private\n     */\n    this.requestedFrameState_;\n\n    /**\n     * The most recently rendered image canvas.\n     * @type {import(\"../ImageCanvas.js\").default}\n     * @private\n     */\n    this.renderedImageCanvas_ = null;\n\n    /**\n     * The most recently rendered revision.\n     * @type {number}\n     */\n    this.renderedRevision_;\n\n    /**\n     * @private\n     * @type {import(\"../PluggableMap.js\").FrameState}\n     */\n    this.frameState_ = {\n      animate: false,\n      coordinateToPixelTransform: createTransform(),\n      extent: null,\n      index: 0,\n      layerIndex: 0,\n      layerStatesArray: getLayerStatesArray(this.layers_),\n      pixelRatio: 1,\n      pixelToCoordinateTransform: createTransform(),\n      postRenderFunctions: [],\n      size: [0, 0],\n      tileQueue: this.tileQueue_,\n      time: Date.now(),\n      usedTiles: {},\n      viewState: /** @type {import(\"../View.js\").State} */ ({\n        rotation: 0,\n      }),\n      viewHints: [],\n      wantedTiles: {},\n      declutterItems: [],\n    };\n\n    this.setAttributions(function (frameState) {\n      const attributions = [];\n      for (\n        let index = 0, iMax = options.sources.length;\n        index < iMax;\n        ++index\n      ) {\n        const sourceOrLayer = options.sources[index];\n        const source =\n          sourceOrLayer instanceof Source\n            ? sourceOrLayer\n            : sourceOrLayer.getSource();\n        const attributionGetter = source.getAttributions();\n        if (typeof attributionGetter === 'function') {\n          const sourceAttribution = attributionGetter(frameState);\n          attributions.push.apply(attributions, sourceAttribution);\n        }\n      }\n      return attributions.length !== 0 ? attributions : null;\n    });\n\n    if (options.operation !== undefined) {\n      this.setOperation(options.operation, options.lib);\n    }\n  }\n\n  /**\n   * Set the operation.\n   * @param {Operation} operation New operation.\n   * @param {Object=} opt_lib Functions that will be available to operations run\n   *     in a worker.\n   * @api\n   */\n  setOperation(operation, opt_lib) {\n    if (this.processor_) {\n      this.processor_.dispose();\n    }\n\n    this.processor_ = new Processor({\n      operation: operation,\n      imageOps: this.operationType_ === RasterOperationType.IMAGE,\n      queue: 1,\n      lib: opt_lib,\n      threads: this.threads_,\n    });\n    this.changed();\n  }\n\n  /**\n   * Update the stored frame state.\n   * @param {import(\"../extent.js\").Extent} extent The view extent (in map units).\n   * @param {number} resolution The view resolution.\n   * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n   * @return {import(\"../PluggableMap.js\").FrameState} The updated frame state.\n   * @private\n   */\n  updateFrameState_(extent, resolution, projection) {\n    const frameState = /** @type {import(\"../PluggableMap.js\").FrameState} */ (assign(\n      {},\n      this.frameState_\n    ));\n\n    frameState.viewState = /** @type {import(\"../View.js\").State} */ (assign(\n      {},\n      frameState.viewState\n    ));\n\n    const center = getCenter(extent);\n\n    frameState.extent = extent.slice();\n    frameState.size[0] = Math.round(getWidth(extent) / resolution);\n    frameState.size[1] = Math.round(getHeight(extent) / resolution);\n    frameState.time = Infinity;\n\n    const viewState = frameState.viewState;\n    viewState.center = center;\n    viewState.projection = projection;\n    viewState.resolution = resolution;\n    return frameState;\n  }\n\n  /**\n   * Determine if all sources are ready.\n   * @return {boolean} All sources are ready.\n   * @private\n   */\n  allSourcesReady_() {\n    let ready = true;\n    let source;\n    for (let i = 0, ii = this.layers_.length; i < ii; ++i) {\n      source = this.layers_[i].getSource();\n      if (source.getState() !== SourceState.READY) {\n        ready = false;\n        break;\n      }\n    }\n    return ready;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../ImageCanvas.js\").default} Single image.\n   */\n  getImage(extent, resolution, pixelRatio, projection) {\n    if (!this.allSourcesReady_()) {\n      return null;\n    }\n\n    const frameState = this.updateFrameState_(extent, resolution, projection);\n    this.requestedFrameState_ = frameState;\n\n    // check if we can't reuse the existing ol/ImageCanvas\n    if (this.renderedImageCanvas_) {\n      const renderedResolution = this.renderedImageCanvas_.getResolution();\n      const renderedExtent = this.renderedImageCanvas_.getExtent();\n      if (\n        resolution !== renderedResolution ||\n        !equals(extent, renderedExtent)\n      ) {\n        this.renderedImageCanvas_ = null;\n      }\n    }\n\n    if (\n      !this.renderedImageCanvas_ ||\n      this.getRevision() !== this.renderedRevision_\n    ) {\n      this.processSources_();\n    }\n\n    frameState.tileQueue.loadMoreTiles(16, 16);\n\n    if (frameState.animate) {\n      requestAnimationFrame(this.changed.bind(this));\n    }\n\n    return this.renderedImageCanvas_;\n  }\n\n  /**\n   * Start processing source data.\n   * @private\n   */\n  processSources_() {\n    const frameState = this.requestedFrameState_;\n    const len = this.layers_.length;\n    const imageDatas = new Array(len);\n    for (let i = 0; i < len; ++i) {\n      frameState.layerIndex = i;\n      const imageData = getImageData(this.layers_[i], frameState);\n      if (imageData) {\n        imageDatas[i] = imageData;\n      } else {\n        return;\n      }\n    }\n\n    const data = {};\n    this.dispatchEvent(\n      new RasterSourceEvent(RasterEventType.BEFOREOPERATIONS, frameState, data)\n    );\n    this.processor_.process(\n      imageDatas,\n      data,\n      this.onWorkerComplete_.bind(this, frameState)\n    );\n  }\n\n  /**\n   * Called when pixel processing is complete.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState The frame state.\n   * @param {Error} err Any error during processing.\n   * @param {ImageData} output The output image data.\n   * @param {Object} data The user data.\n   * @private\n   */\n  onWorkerComplete_(frameState, err, output, data) {\n    if (err || !output) {\n      return;\n    }\n\n    // do nothing if extent or resolution changed\n    const extent = frameState.extent;\n    const resolution = frameState.viewState.resolution;\n    if (\n      resolution !== this.requestedFrameState_.viewState.resolution ||\n      !equals(extent, this.requestedFrameState_.extent)\n    ) {\n      return;\n    }\n\n    let context;\n    if (this.renderedImageCanvas_) {\n      context = this.renderedImageCanvas_.getImage().getContext('2d');\n    } else {\n      const width = Math.round(getWidth(extent) / resolution);\n      const height = Math.round(getHeight(extent) / resolution);\n      context = createCanvasContext2D(width, height);\n      this.renderedImageCanvas_ = new ImageCanvas(\n        extent,\n        resolution,\n        1,\n        context.canvas\n      );\n    }\n    context.putImageData(output, 0, 0);\n\n    this.changed();\n    this.renderedRevision_ = this.getRevision();\n\n    this.dispatchEvent(\n      new RasterSourceEvent(RasterEventType.AFTEROPERATIONS, frameState, data)\n    );\n  }\n\n  /**\n   * @return {null} not implemented\n   */\n  getImageInternal() {\n    return null; // not implemented\n  }\n\n  disposeInternal() {\n    if (this.processor_) {\n      this.processor_.dispose();\n    }\n    super.disposeInternal();\n  }\n}\n\n/**\n * Clean up and unregister the worker.\n * @function\n * @api\n */\nRasterSource.prototype.dispose;\n\n/**\n * A reusable canvas context.\n * @type {CanvasRenderingContext2D}\n * @private\n */\nlet sharedContext = null;\n\n/**\n * Get image data from a layer.\n * @param {import(\"../layer/Layer.js\").default} layer Layer to render.\n * @param {import(\"../PluggableMap.js\").FrameState} frameState The frame state.\n * @return {ImageData} The image data.\n */\nfunction getImageData(layer, frameState) {\n  const renderer = layer.getRenderer();\n  if (!renderer) {\n    throw new Error('Unsupported layer type: ' + layer);\n  }\n\n  if (!renderer.prepareFrame(frameState)) {\n    return null;\n  }\n  const width = frameState.size[0];\n  const height = frameState.size[1];\n  const container = renderer.renderFrame(frameState, null);\n  let element;\n  if (container) {\n    element = container.firstElementChild;\n  }\n  if (!(element instanceof HTMLCanvasElement)) {\n    throw new Error('Unsupported rendered element: ' + element);\n  }\n  if (element.width === width && element.height === height) {\n    const context = element.getContext('2d');\n    return context.getImageData(0, 0, width, height);\n  }\n\n  if (!sharedContext) {\n    sharedContext = createCanvasContext2D(width, height);\n  } else {\n    const canvas = sharedContext.canvas;\n    if (canvas.width !== width || canvas.height !== height) {\n      sharedContext = createCanvasContext2D(width, height);\n    } else {\n      sharedContext.clearRect(0, 0, width, height);\n    }\n  }\n  sharedContext.drawImage(element, 0, 0, width, height);\n  return sharedContext.getImageData(0, 0, width, height);\n}\n\n/**\n * Get a list of layer states from a list of layers.\n * @param {Array<import(\"../layer/Layer.js\").default>} layers Layers.\n * @return {Array<import(\"../layer/Layer.js\").State>} The layer states.\n */\nfunction getLayerStatesArray(layers) {\n  return layers.map(function (layer) {\n    return layer.getLayerState();\n  });\n}\n\n/**\n * Create layers for all sources.\n * @param {Array<import(\"./Source.js\").default|import(\"../layer/Layer.js\").default>} sources The sources.\n * @return {Array<import(\"../layer/Layer.js\").default>} Array of layers.\n */\nfunction createLayers(sources) {\n  const len = sources.length;\n  const layers = new Array(len);\n  for (let i = 0; i < len; ++i) {\n    layers[i] = createLayer(sources[i]);\n  }\n  return layers;\n}\n\n/**\n * Create a layer for the provided source.\n * @param {import(\"./Source.js\").default|import(\"../layer/Layer.js\").default} layerOrSource The layer or source.\n * @return {import(\"../layer/Layer.js\").default} The layer.\n */\nfunction createLayer(layerOrSource) {\n  // @type {import(\"../layer/Layer.js\").default}\n  let layer;\n  if (layerOrSource instanceof Source) {\n    if (layerOrSource instanceof TileSource) {\n      layer = new TileLayer({source: layerOrSource});\n    } else if (layerOrSource instanceof ImageSource) {\n      layer = new ImageLayer({source: layerOrSource});\n    }\n  } else {\n    layer = layerOrSource;\n  }\n  return layer;\n}\n\nexport default RasterSource;\n"],"mappings":";;;;;;;;;;;;;;;;;;;AAAA;;;AAGA,OAAOA,UAAU,MAAM,kBAAkB;AACzC,OAAOC,KAAK,MAAM,oBAAoB;AACtC,OAAOC,SAAS,MAAM,wBAAwB;AAC9C,OAAOC,WAAW,MAAM,mBAAmB;AAC3C,OAAOC,UAAU,MAAM,mBAAmB;AAC1C,OAAOC,WAAW,MAAM,YAAY;AACpC,OAAOC,MAAM,MAAM,aAAa;AAChC,OAAOC,WAAW,MAAM,YAAY;AACpC,OAAOC,SAAS,MAAM,kBAAkB;AACxC,OAAOC,SAAS,MAAM,iBAAiB;AACvC,OAAOC,UAAU,MAAM,WAAW;AAClC,SAAQC,MAAM,QAAO,WAAW;AAChC,SAAQC,qBAAqB,QAAO,WAAW;AAC/C,SAAQC,MAAM,IAAIC,eAAe,QAAO,iBAAiB;AACzD,SAAQC,MAAM,EAAEC,SAAS,EAAEC,SAAS,EAAEC,QAAQ,QAAO,cAAc;AAEnE,IAAIC,YAAY,GAAG,IAAI;AACvB,IAAI;EACF,IAAIC,SAAS,CAAC,EAAE,EAAE,EAAE,CAAC;CACtB,CAAC,OAAOC,CAAC,EAAE;EACVF,YAAY,GAAG,KAAK;;AAGtB,IAAMG,OAAO,GAAGC,QAAQ,CAACC,aAAa,CAAC,QAAQ,CAAC,CAACC,UAAU,CAAC,IAAI,CAAC;AAEjE;;;;;;AAMA,OAAM,SAAUC,YAAYA,CAACC,IAAI,EAAEC,KAAK,EAAEC,MAAM;EAC9C,IAAIV,YAAY,EAAE;IAChB,OAAO,IAAIC,SAAS,CAACO,IAAI,EAAEC,KAAK,EAAEC,MAAM,CAAC;GAC1C,MAAM;IACL,IAAMC,SAAS,GAAGR,OAAO,CAACS,eAAe,CAACH,KAAK,EAAEC,MAAM,CAAC;IACxDC,SAAS,CAACH,IAAI,CAACK,GAAG,CAACL,IAAI,CAAC;IACxB,OAAOG,SAAS;;AAEpB;AAEA;AACA;;;;;;;;AAQA,SAASG,YAAYA,CAACC,SAAS;EAC7B,IAAIC,kBAAkB,GAAG,IAAI;EAC7B,IAAI;IACF,IAAIf,SAAS,CAAC,EAAE,EAAE,EAAE,CAAC;GACtB,CAAC,OAAOC,CAAC,EAAE;IACVc,kBAAkB,GAAG,KAAK;;EAG5B,SAASC,kBAAkBA,CAACT,IAAI,EAAEC,KAAK,EAAEC,MAAM;IAC7C,IAAIM,kBAAkB,EAAE;MACtB,OAAO,IAAIf,SAAS,CAACO,IAAI,EAAEC,KAAK,EAAEC,MAAM,CAAC;KAC1C,MAAM;MACL,OAAO;QAACF,IAAI,EAAEA,IAAI;QAAEC,KAAK,EAAEA,KAAK;QAAEC,MAAM,EAAEA;MAAM,CAAC;;EAErD;EAEA,OAAO,UAAUF,IAAI;IACnB;IACA,IAAMU,OAAO,GAAGV,IAAI,CAAC,SAAS,CAAC;IAC/B,IAAMW,IAAI,GAAGX,IAAI,CAAC,MAAM,CAAC;IACzB,IAAMY,QAAQ,GAAGZ,IAAI,CAAC,UAAU,CAAC;IACjC,IAAMC,KAAK,GAAGD,IAAI,CAAC,OAAO,CAAC;IAC3B,IAAME,MAAM,GAAGF,IAAI,CAAC,QAAQ,CAAC;IAE7B,IAAMa,UAAU,GAAGH,OAAO,CAACI,MAAM;IACjC,IAAMC,QAAQ,GAAGL,OAAO,CAAC,CAAC,CAAC,CAACM,UAAU;IACtC,IAAIC,MAAM,EAAEC,CAAC;IAEb,IAAIN,QAAQ,EAAE;MACZ,IAAMO,MAAM,GAAG,IAAIC,KAAK,CAACP,UAAU,CAAC;MACpC,KAAKK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,UAAU,EAAE,EAAEK,CAAC,EAAE;QAC/BC,MAAM,CAACD,CAAC,CAAC,GAAGT,kBAAkB,CAC5B,IAAIY,iBAAiB,CAACX,OAAO,CAACQ,CAAC,CAAC,CAAC,EACjCjB,KAAK,EACLC,MAAM,CACP;;MAEHe,MAAM,GAAGV,SAAS,CAACY,MAAM,EAAER,IAAI,CAAC,CAACX,IAAI;KACtC,MAAM;MACLiB,MAAM,GAAG,IAAII,iBAAiB,CAACN,QAAQ,CAAC;MACxC,IAAMO,MAAM,GAAG,IAAIF,KAAK,CAACP,UAAU,CAAC;MACpC,IAAMU,MAAM,GAAG,IAAIH,KAAK,CAACP,UAAU,CAAC;MACpC,KAAKK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,UAAU,EAAE,EAAEK,CAAC,EAAE;QAC/BI,MAAM,CAACJ,CAAC,CAAC,GAAG,IAAIG,iBAAiB,CAACX,OAAO,CAACQ,CAAC,CAAC,CAAC;QAC7CK,MAAM,CAACL,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;;MAE1B,KAAK,IAAIM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,QAAQ,EAAES,CAAC,IAAI,CAAC,EAAE;QACpC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGZ,UAAU,EAAE,EAAEY,CAAC,EAAE;UACnC,IAAMC,KAAK,GAAGJ,MAAM,CAACG,CAAC,CAAC;UACvBF,MAAM,CAACE,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGC,KAAK,CAACF,CAAC,CAAC;UACvBD,MAAM,CAACE,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGC,KAAK,CAACF,CAAC,GAAG,CAAC,CAAC;UAC3BD,MAAM,CAACE,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGC,KAAK,CAACF,CAAC,GAAG,CAAC,CAAC;UAC3BD,MAAM,CAACE,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGC,KAAK,CAACF,CAAC,GAAG,CAAC,CAAC;;QAE7B,IAAMG,KAAK,GAAGpB,SAAS,CAACgB,MAAM,EAAEZ,IAAI,CAAC;QACrCM,MAAM,CAACO,CAAC,CAAC,GAAGG,KAAK,CAAC,CAAC,CAAC;QACpBV,MAAM,CAACO,CAAC,GAAG,CAAC,CAAC,GAAGG,KAAK,CAAC,CAAC,CAAC;QACxBV,MAAM,CAACO,CAAC,GAAG,CAAC,CAAC,GAAGG,KAAK,CAAC,CAAC,CAAC;QACxBV,MAAM,CAACO,CAAC,GAAG,CAAC,CAAC,GAAGG,KAAK,CAAC,CAAC,CAAC;;;IAG5B,OAAOV,MAAM,CAACW,MAAM;EACtB,CAAC;AACH;AAEA;;;;;;AAMA,SAASC,YAAYA,CAACC,MAAM,EAAEC,SAAS;EACrC,IAAMC,GAAG,GAAGC,MAAM,CAACC,IAAI,CAACJ,MAAM,CAACE,GAAG,IAAI,EAAE,CAAC,CAACG,GAAG,CAAC,UAAUC,IAAI;IAC1D,OAAO,MAAM,GAAGA,IAAI,GAAG,KAAK,GAAGN,MAAM,CAACE,GAAG,CAACI,IAAI,CAAC,CAACC,QAAQ,EAAE,GAAG,GAAG;EAClE,CAAC,CAAC;EAEF,IAAMC,KAAK,GAAGN,GAAG,CAACO,MAAM,CAAC,CACvB,oBAAoB,GAAGjC,YAAY,CAAC+B,QAAQ,EAAE,GAAG,IAAI,EACrDP,MAAM,CAACvB,SAAS,CAAC8B,QAAQ,EAAE,EAC3B,IAAI,EACJ,oDAAoD,EACpD,wCAAwC,EACxC,wEAAwE,EACxE,KAAK,CACN,CAAC;EAEF,IAAMG,IAAI,GAAG,IAAIC,IAAI,CAACH,KAAK,EAAE;IAACI,IAAI,EAAE;EAAiB,CAAC,CAAC;EACvD,IAAMC,MAAM,GAAGC,GAAG,CAACC,eAAe,CAACL,IAAI,CAAC;EACxC,IAAMM,MAAM,GAAG,IAAIC,MAAM,CAACJ,MAAM,CAAC;EACjCG,MAAM,CAACE,gBAAgB,CAAC,SAAS,EAAEjB,SAAS,CAAC;EAC7C,OAAOe,MAAM;AACf;AAEA;;;;AAKA;;;;;;AAMA,SAASG,gBAAgBA,CAACnB,MAAM,EAAEC,SAAS;EACzC,IAAMmB,MAAM,GAAG5C,YAAY,CAACwB,MAAM,CAACvB,SAAS,CAAC;EAC7C,IAAI4C,UAAU,GAAG,KAAK;EACtB,OAAO;IACLC,WAAW,EAAE,SAAAA,CAAUpD,IAAI;MACzBqD,UAAU,CAAC;QACT,IAAIF,UAAU,EAAE;UACd;;QAEFpB,SAAS,CAAC;UAAC/B,IAAI,EAAE;YAAC4B,MAAM,EAAEsB,MAAM,CAAClD,IAAI,CAAC;YAAEW,IAAI,EAAEX,IAAI,CAAC,MAAM;UAAC;QAAC,CAAC,CAAC;MAC/D,CAAC,EAAE,CAAC,CAAC;IACP,CAAC;IACDsD,SAAS,EAAE,SAAAA,CAAA;MACTH,UAAU,GAAG,IAAI;IACnB;GACD;AACH;AAEA;;;;;;;;AASA;;;;AAIA,IAAAI,SAAA,0BAAAC,MAAA;EAA+BC,SAAA,CAAAF,SAAA,EAAAC,MAAA;EAC7B;;;EAGA,SAAAD,UAAYzB,MAAM;IAAlB,IAAA4B,KAAA,GACEF,MAAA,CAAAG,IAAA,MAAO;IAEPD,KAAI,CAACE,SAAS,GAAG,CAAC,CAAC9B,MAAM,CAAClB,QAAQ;IAClC,IAAIiD,OAAO;IACX,IAAI/B,MAAM,CAAC+B,OAAO,KAAK,CAAC,EAAE;MACxBA,OAAO,GAAG,CAAC;KACZ,MAAM,IAAIH,KAAI,CAACE,SAAS,EAAE;MACzBC,OAAO,GAAG,CAAC;KACZ,MAAM;MACLA,OAAO,GAAG/B,MAAM,CAAC+B,OAAO,IAAI,CAAC;;IAE/B,IAAMC,OAAO,GAAG,EAAE;IAClB,IAAID,OAAO,EAAE;MACX,KAAK,IAAIrC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqC,OAAO,EAAE,EAAErC,CAAC,EAAE;QAChCsC,OAAO,CAACtC,CAAC,CAAC,GAAGK,YAAY,CAACC,MAAM,EAAE4B,KAAI,CAACK,gBAAgB,CAACC,IAAI,CAACN,KAAI,EAAElC,CAAC,CAAC,CAAC;;KAEzE,MAAM;MACLsC,OAAO,CAAC,CAAC,CAAC,GAAGb,gBAAgB,CAC3BnB,MAAM,EACN4B,KAAI,CAACK,gBAAgB,CAACC,IAAI,CAACN,KAAI,EAAE,CAAC,CAAC,CACpC;;IAEHA,KAAI,CAACO,QAAQ,GAAGH,OAAO;IACvBJ,KAAI,CAACQ,MAAM,GAAG,EAAE;IAChBR,KAAI,CAACS,eAAe,GAAGrC,MAAM,CAACsC,KAAK,IAAIC,QAAQ;IAC/CX,KAAI,CAACY,QAAQ,GAAG,CAAC;IACjBZ,KAAI,CAACa,WAAW,GAAG,EAAE;IACrBb,KAAI,CAACc,IAAI,GAAG,IAAI;;EAClB;EAEA;;;;;;;;;;EAUAjB,SAAA,CAAAkB,SAAA,CAAAC,OAAO,GAAP,UAAQC,MAAM,EAAEhE,IAAI,EAAEiE,QAAQ;IAC5B,IAAI,CAACC,QAAQ,CAAC;MACZF,MAAM,EAAEA,MAAM;MACdhE,IAAI,EAAEA,IAAI;MACViE,QAAQ,EAAEA;KACX,CAAC;IACF,IAAI,CAACE,SAAS,EAAE;EAClB,CAAC;EAED;;;;EAIAvB,SAAA,CAAAkB,SAAA,CAAAI,QAAQ,GAAR,UAASE,GAAG;IACV,IAAI,CAACb,MAAM,CAACc,IAAI,CAACD,GAAG,CAAC;IACrB,OAAO,IAAI,CAACb,MAAM,CAACpD,MAAM,GAAG,IAAI,CAACqD,eAAe,EAAE;MAChD,IAAI,CAACD,MAAM,CAACe,KAAK,EAAE,CAACL,QAAQ,CAAC,IAAI,EAAE,IAAI,CAAC;;EAE5C,CAAC;EAED;;;EAGArB,SAAA,CAAAkB,SAAA,CAAAK,SAAS,GAAT;IACE,IAAI,IAAI,CAACR,QAAQ,KAAK,CAAC,IAAI,IAAI,CAACJ,MAAM,CAACpD,MAAM,GAAG,CAAC,EAAE;MACjD,IAAMiE,GAAG,GAAG,IAAI,CAACb,MAAM,CAACe,KAAK,EAAE;MAC/B,IAAI,CAACT,IAAI,GAAGO,GAAG;MACf,IAAM9E,KAAK,GAAG8E,GAAG,CAACJ,MAAM,CAAC,CAAC,CAAC,CAAC1E,KAAK;MACjC,IAAMC,MAAM,GAAG6E,GAAG,CAACJ,MAAM,CAAC,CAAC,CAAC,CAACzE,MAAM;MACnC,IAAMQ,OAAO,GAAGqE,GAAG,CAACJ,MAAM,CAACxC,GAAG,CAAC,UAAU+C,KAAK;QAC5C,OAAOA,KAAK,CAAClF,IAAI,CAAC4B,MAAM;MAC1B,CAAC,CAAC;MACF,IAAMiC,OAAO,GAAG,IAAI,CAACI,QAAQ,CAACnD,MAAM;MACpC,IAAI,CAACwD,QAAQ,GAAGT,OAAO;MACvB,IAAIA,OAAO,KAAK,CAAC,EAAE;QACjB,IAAI,CAACI,QAAQ,CAAC,CAAC,CAAC,CAACb,WAAW,CAC1B;UACE1C,OAAO,EAAEA,OAAO;UAChBC,IAAI,EAAEoE,GAAG,CAACpE,IAAI;UACdC,QAAQ,EAAE,IAAI,CAACgD,SAAS;UACxB3D,KAAK,EAAEA,KAAK;UACZC,MAAM,EAAEA;SACT,EACDQ,OAAO,CACR;OACF,MAAM;QACL,IAAMyE,QAAM,GAAGJ,GAAG,CAACJ,MAAM,CAAC,CAAC,CAAC,CAAC3E,IAAI,CAACc,MAAM;QACxC,IAAMsE,aAAa,GAAG,CAAC,GAAGC,IAAI,CAACC,IAAI,CAACH,QAAM,GAAG,CAAC,GAAGtB,OAAO,CAAC;QACzD,KAAK,IAAIrC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqC,OAAO,EAAE,EAAErC,CAAC,EAAE;UAChC,IAAM+D,MAAM,GAAG/D,CAAC,GAAG4D,aAAa;UAChC,IAAMI,MAAM,GAAG,EAAE;UACjB,KAAK,IAAI/D,CAAC,GAAG,CAAC,EAAEgE,EAAE,GAAG/E,OAAO,CAACI,MAAM,EAAEW,CAAC,GAAGgE,EAAE,EAAE,EAAEhE,CAAC,EAAE;YAChD+D,MAAM,CAACR,IAAI,CAACtE,OAAO,CAACc,CAAC,CAAC,CAACkE,KAAK,CAACH,MAAM,EAAEA,MAAM,GAAGH,aAAa,CAAC,CAAC;;UAE/D,IAAI,CAACnB,QAAQ,CAACzC,CAAC,CAAC,CAAC4B,WAAW,CAC1B;YACE1C,OAAO,EAAE8E,MAAM;YACf7E,IAAI,EAAEoE,GAAG,CAACpE,IAAI;YACdC,QAAQ,EAAE,IAAI,CAACgD,SAAS;YACxB3D,KAAK,EAAEA,KAAK;YACZC,MAAM,EAAEA;WACT,EACDsF,MAAM,CACP;;;;EAIT,CAAC;EAED;;;;;EAKAjC,SAAA,CAAAkB,SAAA,CAAAV,gBAAgB,GAAhB,UAAiB4B,KAAK,EAAEC,KAAK;IAC3B,IAAI,IAAI,CAACC,QAAQ,EAAE;MACjB;;IAEF,IAAI,CAACtB,WAAW,CAACoB,KAAK,CAAC,GAAGC,KAAK,CAAC5F,IAAI;IACpC,EAAE,IAAI,CAACsE,QAAQ;IACf,IAAI,IAAI,CAACA,QAAQ,KAAK,CAAC,EAAE;MACvB,IAAI,CAACwB,WAAW,EAAE;;EAEtB,CAAC;EAED;;;;EAIAvC,SAAA,CAAAkB,SAAA,CAAAqB,WAAW,GAAX;IACE,IAAMf,GAAG,GAAG,IAAI,CAACP,IAAI;IACrB,IAAMX,OAAO,GAAG,IAAI,CAACI,QAAQ,CAACnD,MAAM;IACpC,IAAId,IAAI,EAAEW,IAAI;IACd,IAAIkD,OAAO,KAAK,CAAC,EAAE;MACjB7D,IAAI,GAAG,IAAIqB,iBAAiB,CAAC,IAAI,CAACkD,WAAW,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC;MAC3D5D,IAAI,GAAG,IAAI,CAAC4D,WAAW,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;KACnC,MAAM;MACL,IAAMwB,QAAM,GAAGhB,GAAG,CAACJ,MAAM,CAAC,CAAC,CAAC,CAAC3E,IAAI,CAACc,MAAM;MACxCd,IAAI,GAAG,IAAIqB,iBAAiB,CAAC0E,QAAM,CAAC;MACpCpF,IAAI,GAAG,IAAIS,KAAK,CAAC2E,QAAM,CAAC;MACxB,IAAMX,aAAa,GAAG,CAAC,GAAGC,IAAI,CAACC,IAAI,CAACS,QAAM,GAAG,CAAC,GAAGlC,OAAO,CAAC;MACzD,KAAK,IAAIrC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqC,OAAO,EAAE,EAAErC,CAAC,EAAE;QAChC,IAAMI,MAAM,GAAG,IAAI,CAAC2C,WAAW,CAAC/C,CAAC,CAAC,CAAC,QAAQ,CAAC;QAC5C,IAAM+D,MAAM,GAAG/D,CAAC,GAAG4D,aAAa;QAChCpF,IAAI,CAACK,GAAG,CAAC,IAAIgB,iBAAiB,CAACO,MAAM,CAAC,EAAE2D,MAAM,CAAC;QAC/C5E,IAAI,CAACa,CAAC,CAAC,GAAG,IAAI,CAAC+C,WAAW,CAAC/C,CAAC,CAAC,CAAC,MAAM,CAAC;;;IAGzC,IAAI,CAACgD,IAAI,GAAG,IAAI;IAChB,IAAI,CAACD,WAAW,GAAG,EAAE;IACrBQ,GAAG,CAACH,QAAQ,CACV,IAAI,EACJ7E,YAAY,CAACC,IAAI,EAAE+E,GAAG,CAACJ,MAAM,CAAC,CAAC,CAAC,CAAC1E,KAAK,EAAE8E,GAAG,CAACJ,MAAM,CAAC,CAAC,CAAC,CAACzE,MAAM,CAAC,EAC7DS,IAAI,CACL;IACD,IAAI,CAACmE,SAAS,EAAE;EAClB,CAAC;EAED;;;EAGAvB,SAAA,CAAAkB,SAAA,CAAAuB,eAAe,GAAf;IACE,KAAK,IAAIxE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACyC,QAAQ,CAACnD,MAAM,EAAE,EAAEU,CAAC,EAAE;MAC7C,IAAI,CAACyC,QAAQ,CAACzC,CAAC,CAAC,CAAC8B,SAAS,EAAE;;IAE9B,IAAI,CAACW,QAAQ,CAACnD,MAAM,GAAG,CAAC;EAC1B,CAAC;EACH,OAAAyC,SAAC;AAAD,CAAC,CA5K8BlF,UAAU;;AA8KzC;;;;;;;;;;;;;;;;;AAkBA;;;AAGA,IAAM4H,eAAe,GAAG;EACtB;;;;;EAKAC,gBAAgB,EAAE,kBAAkB;EAEpC;;;;;EAKAC,eAAe,EAAE;CAClB;AAED;;;;AAIA,IAAMC,mBAAmB,GAAG;EAC1BC,KAAK,EAAE,OAAO;EACdC,KAAK,EAAE;CACR;AAED;;;;;AAKA,IAAAC,iBAAA,0BAAA/C,MAAA;EAAuCC,SAAA,CAAA8C,iBAAA,EAAA/C,MAAA;EACrC;;;;;EAKA,SAAA+C,kBAAY7D,IAAI,EAAE8D,UAAU,EAAExG,IAAI;IAAlC,IAAA0D,KAAA,GACEF,MAAA,CAAAG,IAAA,OAAMjB,IAAI,CAAC;IAEX;;;;;IAKAgB,KAAI,CAAC+C,MAAM,GAAGD,UAAU,CAACC,MAAM;IAE/B;;;;;IAKA/C,KAAI,CAACgD,UAAU,GAAGF,UAAU,CAACG,SAAS,CAACD,UAAU,GAAGF,UAAU,CAACI,UAAU;IAEzE;;;;;;IAMAlD,KAAI,CAAC1D,IAAI,GAAGA,IAAI;;EAClB;EACF,OAAAuG,iBAAC;AAAD,CAAC,CA/BsCjI,KAAK;;AAiC5C;;;;;;;;;;;;;;;;;;;AAoBA;;;;;;;;;AASA,IAAAuI,YAAA,0BAAArD,MAAA;EAA2BC,SAAA,CAAAoD,YAAA,EAAArD,MAAA;EACzB;;;EAGA,SAAAqD,aAAYC,OAAO;IAAnB,IAAApD,KAAA,GACEF,MAAA,CAAAG,IAAA,OAAM;MACJoD,UAAU,EAAE;KACb,CAAC;IAEF;;;;IAIArD,KAAI,CAACsD,UAAU,GAAG,IAAI;IAEtB;;;;IAIAtD,KAAI,CAACuD,cAAc,GACjBH,OAAO,CAACI,aAAa,KAAKC,SAAS,GAC/BL,OAAO,CAACI,aAAa,GACrBd,mBAAmB,CAACC,KAAK;IAE/B;;;;IAIA3C,KAAI,CAAC0D,QAAQ,GAAGN,OAAO,CAACjD,OAAO,KAAKsD,SAAS,GAAGL,OAAO,CAACjD,OAAO,GAAG,CAAC;IAEnE;;;;IAIAH,KAAI,CAAC2D,OAAO,GAAGC,YAAY,CAACR,OAAO,CAACS,OAAO,CAAC;IAE5C,IAAMC,OAAO,GAAG9D,KAAI,CAAC8D,OAAO,CAACxD,IAAI,CAACN,KAAI,CAAC;IACvC,KAAK,IAAIlC,CAAC,GAAG,CAAC,EAAEiG,EAAE,GAAG/D,KAAI,CAAC2D,OAAO,CAACvG,MAAM,EAAEU,CAAC,GAAGiG,EAAE,EAAE,EAAEjG,CAAC,EAAE;MACrDkC,KAAI,CAAC2D,OAAO,CAAC7F,CAAC,CAAC,CAACwB,gBAAgB,CAACzE,SAAS,CAACmJ,MAAM,EAAEF,OAAO,CAAC;;IAG7D;;;;IAIA9D,KAAI,CAACiE,UAAU,GAAG,IAAI7I,SAAS,CAAC;MAC9B,OAAO,CAAC;IACV,CAAC,EAAE4E,KAAI,CAAC8D,OAAO,CAACxD,IAAI,CAACN,KAAI,CAAC,CAAC;IAE3B;;;;;IAKAA,KAAI,CAACkE,oBAAoB;IAEzB;;;;;IAKAlE,KAAI,CAACmE,oBAAoB,GAAG,IAAI;IAEhC;;;;IAIAnE,KAAI,CAACoE,iBAAiB;IAEtB;;;;IAIApE,KAAI,CAACqE,WAAW,GAAG;MACjBC,OAAO,EAAE,KAAK;MACdC,0BAA0B,EAAE9I,eAAe,EAAE;MAC7CsH,MAAM,EAAE,IAAI;MACZd,KAAK,EAAE,CAAC;MACRuC,UAAU,EAAE,CAAC;MACbC,gBAAgB,EAAEC,mBAAmB,CAAC1E,KAAI,CAAC2D,OAAO,CAAC;MACnDT,UAAU,EAAE,CAAC;MACbyB,0BAA0B,EAAElJ,eAAe,EAAE;MAC7CmJ,mBAAmB,EAAE,EAAE;MACvBC,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;MACZC,SAAS,EAAE9E,KAAI,CAACiE,UAAU;MAC1Bc,IAAI,EAAEC,IAAI,CAACC,GAAG,EAAE;MAChBC,SAAS,EAAE,EAAE;MACbjC,SAAS,EAAE,yCAA2C;QACpDkC,QAAQ,EAAE;OACV;MACFC,SAAS,EAAE,EAAE;MACbC,WAAW,EAAE,EAAE;MACfC,cAAc,EAAE;KACjB;IAEDtF,KAAI,CAACuF,eAAe,CAAC,UAAUzC,UAAU;MACvC,IAAM0C,YAAY,GAAG,EAAE;MACvB,KACE,IAAIvD,KAAK,GAAG,CAAC,EAAEwD,IAAI,GAAGrC,OAAO,CAACS,OAAO,CAACzG,MAAM,EAC5C6E,KAAK,GAAGwD,IAAI,EACZ,EAAExD,KAAK,EACP;QACA,IAAMyD,aAAa,GAAGtC,OAAO,CAACS,OAAO,CAAC5B,KAAK,CAAC;QAC5C,IAAMhD,MAAM,GACVyG,aAAa,YAAYzK,MAAM,GAC3ByK,aAAa,GACbA,aAAa,CAACC,SAAS,EAAE;QAC/B,IAAMC,iBAAiB,GAAG3G,MAAM,CAAC4G,eAAe,EAAE;QAClD,IAAI,OAAOD,iBAAiB,KAAK,UAAU,EAAE;UAC3C,IAAME,iBAAiB,GAAGF,iBAAiB,CAAC9C,UAAU,CAAC;UACvD0C,YAAY,CAAClE,IAAI,CAACyE,KAAK,CAACP,YAAY,EAAEM,iBAAiB,CAAC;;;MAG5D,OAAON,YAAY,CAACpI,MAAM,KAAK,CAAC,GAAGoI,YAAY,GAAG,IAAI;IACxD,CAAC,CAAC;IAEF,IAAIpC,OAAO,CAACvG,SAAS,KAAK4G,SAAS,EAAE;MACnCzD,KAAI,CAACgG,YAAY,CAAC5C,OAAO,CAACvG,SAAS,EAAEuG,OAAO,CAAC9E,GAAG,CAAC;;;EAErD;EAEA;;;;;;;EAOA6E,YAAA,CAAApC,SAAA,CAAAiF,YAAY,GAAZ,UAAanJ,SAAS,EAAEoJ,OAAO;IAC7B,IAAI,IAAI,CAAC3C,UAAU,EAAE;MACnB,IAAI,CAACA,UAAU,CAAC4C,OAAO,EAAE;;IAG3B,IAAI,CAAC5C,UAAU,GAAG,IAAIzD,SAAS,CAAC;MAC9BhD,SAAS,EAAEA,SAAS;MACpBK,QAAQ,EAAE,IAAI,CAACqG,cAAc,KAAKb,mBAAmB,CAACE,KAAK;MAC3DlC,KAAK,EAAE,CAAC;MACRpC,GAAG,EAAE2H,OAAO;MACZ9F,OAAO,EAAE,IAAI,CAACuD;KACf,CAAC;IACF,IAAI,CAACI,OAAO,EAAE;EAChB,CAAC;EAED;;;;;;;;EAQAX,YAAA,CAAApC,SAAA,CAAAoF,iBAAiB,GAAjB,UAAkBpD,MAAM,EAAEC,UAAU,EAAEK,UAAU;IAC9C,IAAMP,UAAU,GAAG,sDAAwDxH,MAAM,CAC/E,EAAE,EACF,IAAI,CAAC+I,WAAW,CAChB;IAEFvB,UAAU,CAACG,SAAS,GAAG,yCAA2C3H,MAAM,CACtE,EAAE,EACFwH,UAAU,CAACG,SAAS,CACpB;IAEF,IAAMmD,MAAM,GAAGzK,SAAS,CAACoH,MAAM,CAAC;IAEhCD,UAAU,CAACC,MAAM,GAAGA,MAAM,CAACf,KAAK,EAAE;IAClCc,UAAU,CAAC+B,IAAI,CAAC,CAAC,CAAC,GAAGlD,IAAI,CAAC0E,KAAK,CAACxK,QAAQ,CAACkH,MAAM,CAAC,GAAGC,UAAU,CAAC;IAC9DF,UAAU,CAAC+B,IAAI,CAAC,CAAC,CAAC,GAAGlD,IAAI,CAAC0E,KAAK,CAACzK,SAAS,CAACmH,MAAM,CAAC,GAAGC,UAAU,CAAC;IAC/DF,UAAU,CAACiC,IAAI,GAAGpE,QAAQ;IAE1B,IAAMsC,SAAS,GAAGH,UAAU,CAACG,SAAS;IACtCA,SAAS,CAACmD,MAAM,GAAGA,MAAM;IACzBnD,SAAS,CAACI,UAAU,GAAGA,UAAU;IACjCJ,SAAS,CAACD,UAAU,GAAGA,UAAU;IACjC,OAAOF,UAAU;EACnB,CAAC;EAED;;;;;EAKAK,YAAA,CAAApC,SAAA,CAAAuF,gBAAgB,GAAhB;IACE,IAAIC,KAAK,GAAG,IAAI;IAChB,IAAItH,MAAM;IACV,KAAK,IAAInB,CAAC,GAAG,CAAC,EAAEiG,EAAE,GAAG,IAAI,CAACJ,OAAO,CAACvG,MAAM,EAAEU,CAAC,GAAGiG,EAAE,EAAE,EAAEjG,CAAC,EAAE;MACrDmB,MAAM,GAAG,IAAI,CAAC0E,OAAO,CAAC7F,CAAC,CAAC,CAAC6H,SAAS,EAAE;MACpC,IAAI1G,MAAM,CAACuH,QAAQ,EAAE,KAAKtL,WAAW,CAACuL,KAAK,EAAE;QAC3CF,KAAK,GAAG,KAAK;QACb;;;IAGJ,OAAOA,KAAK;EACd,CAAC;EAED;;;;;;;EAOApD,YAAA,CAAApC,SAAA,CAAA2F,QAAQ,GAAR,UAAS3D,MAAM,EAAEC,UAAU,EAAEE,UAAU,EAAEG,UAAU;IACjD,IAAI,CAAC,IAAI,CAACiD,gBAAgB,EAAE,EAAE;MAC5B,OAAO,IAAI;;IAGb,IAAMxD,UAAU,GAAG,IAAI,CAACqD,iBAAiB,CAACpD,MAAM,EAAEC,UAAU,EAAEK,UAAU,CAAC;IACzE,IAAI,CAACa,oBAAoB,GAAGpB,UAAU;IAEtC;IACA,IAAI,IAAI,CAACqB,oBAAoB,EAAE;MAC7B,IAAMwC,kBAAkB,GAAG,IAAI,CAACxC,oBAAoB,CAACyC,aAAa,EAAE;MACpE,IAAMC,cAAc,GAAG,IAAI,CAAC1C,oBAAoB,CAAC2C,SAAS,EAAE;MAC5D,IACE9D,UAAU,KAAK2D,kBAAkB,IACjC,CAACjL,MAAM,CAACqH,MAAM,EAAE8D,cAAc,CAAC,EAC/B;QACA,IAAI,CAAC1C,oBAAoB,GAAG,IAAI;;;IAIpC,IACE,CAAC,IAAI,CAACA,oBAAoB,IAC1B,IAAI,CAAC4C,WAAW,EAAE,KAAK,IAAI,CAAC3C,iBAAiB,EAC7C;MACA,IAAI,CAAC4C,eAAe,EAAE;;IAGxBlE,UAAU,CAACgC,SAAS,CAACmC,aAAa,CAAC,EAAE,EAAE,EAAE,CAAC;IAE1C,IAAInE,UAAU,CAACwB,OAAO,EAAE;MACtB4C,qBAAqB,CAAC,IAAI,CAACpD,OAAO,CAACxD,IAAI,CAAC,IAAI,CAAC,CAAC;;IAGhD,OAAO,IAAI,CAAC6D,oBAAoB;EAClC,CAAC;EAED;;;;EAIAhB,YAAA,CAAApC,SAAA,CAAAiG,eAAe,GAAf;IACE,IAAMlE,UAAU,GAAG,IAAI,CAACoB,oBAAoB;IAC5C,IAAMiD,GAAG,GAAG,IAAI,CAACxD,OAAO,CAACvG,MAAM;IAC/B,IAAMgK,UAAU,GAAG,IAAI1J,KAAK,CAACyJ,GAAG,CAAC;IACjC,KAAK,IAAIrJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqJ,GAAG,EAAE,EAAErJ,CAAC,EAAE;MAC5BgF,UAAU,CAAC0B,UAAU,GAAG1G,CAAC;MACzB,IAAMrB,SAAS,GAAG4K,YAAY,CAAC,IAAI,CAAC1D,OAAO,CAAC7F,CAAC,CAAC,EAAEgF,UAAU,CAAC;MAC3D,IAAIrG,SAAS,EAAE;QACb2K,UAAU,CAACtJ,CAAC,CAAC,GAAGrB,SAAS;OAC1B,MAAM;QACL;;;IAIJ,IAAMH,IAAI,GAAG,EAAE;IACf,IAAI,CAACgL,aAAa,CAChB,IAAIzE,iBAAiB,CAACN,eAAe,CAACC,gBAAgB,EAAEM,UAAU,EAAExG,IAAI,CAAC,CAC1E;IACD,IAAI,CAACgH,UAAU,CAACtC,OAAO,CACrBoG,UAAU,EACV9K,IAAI,EACJ,IAAI,CAACiL,iBAAiB,CAACjH,IAAI,CAAC,IAAI,EAAEwC,UAAU,CAAC,CAC9C;EACH,CAAC;EAED;;;;;;;;EAQAK,YAAA,CAAApC,SAAA,CAAAwG,iBAAiB,GAAjB,UAAkBzE,UAAU,EAAE0E,GAAG,EAAEjK,MAAM,EAAEjB,IAAI;IAC7C,IAAIkL,GAAG,IAAI,CAACjK,MAAM,EAAE;MAClB;;IAGF;IACA,IAAMwF,MAAM,GAAGD,UAAU,CAACC,MAAM;IAChC,IAAMC,UAAU,GAAGF,UAAU,CAACG,SAAS,CAACD,UAAU;IAClD,IACEA,UAAU,KAAK,IAAI,CAACkB,oBAAoB,CAACjB,SAAS,CAACD,UAAU,IAC7D,CAACtH,MAAM,CAACqH,MAAM,EAAE,IAAI,CAACmB,oBAAoB,CAACnB,MAAM,CAAC,EACjD;MACA;;IAGF,IAAI9G,OAAO;IACX,IAAI,IAAI,CAACkI,oBAAoB,EAAE;MAC7BlI,OAAO,GAAG,IAAI,CAACkI,oBAAoB,CAACuC,QAAQ,EAAE,CAACtK,UAAU,CAAC,IAAI,CAAC;KAChE,MAAM;MACL,IAAMG,KAAK,GAAGoF,IAAI,CAAC0E,KAAK,CAACxK,QAAQ,CAACkH,MAAM,CAAC,GAAGC,UAAU,CAAC;MACvD,IAAMxG,MAAM,GAAGmF,IAAI,CAAC0E,KAAK,CAACzK,SAAS,CAACmH,MAAM,CAAC,GAAGC,UAAU,CAAC;MACzD/G,OAAO,GAAGV,qBAAqB,CAACgB,KAAK,EAAEC,MAAM,CAAC;MAC9C,IAAI,CAAC2H,oBAAoB,GAAG,IAAIrJ,WAAW,CACzCiI,MAAM,EACNC,UAAU,EACV,CAAC,EACD/G,OAAO,CAACwL,MAAM,CACf;;IAEHxL,OAAO,CAACyL,YAAY,CAACnK,MAAM,EAAE,CAAC,EAAE,CAAC,CAAC;IAElC,IAAI,CAACuG,OAAO,EAAE;IACd,IAAI,CAACM,iBAAiB,GAAG,IAAI,CAAC2C,WAAW,EAAE;IAE3C,IAAI,CAACO,aAAa,CAChB,IAAIzE,iBAAiB,CAACN,eAAe,CAACE,eAAe,EAAEK,UAAU,EAAExG,IAAI,CAAC,CACzE;EACH,CAAC;EAED;;;EAGA6G,YAAA,CAAApC,SAAA,CAAA4G,gBAAgB,GAAhB;IACE,OAAO,IAAI,CAAC,CAAC;EACf,CAAC;;EAEDxE,YAAA,CAAApC,SAAA,CAAAuB,eAAe,GAAf;IACE,IAAI,IAAI,CAACgB,UAAU,EAAE;MACnB,IAAI,CAACA,UAAU,CAAC4C,OAAO,EAAE;;IAE3BpG,MAAA,CAAAiB,SAAA,CAAMuB,eAAe,CAAArC,IAAA,MAAE;EACzB,CAAC;EACH,OAAAkD,YAAC;AAAD,CAAC,CAtU0BnI,WAAW;AAwUtC;;;;;AAKAmI,YAAY,CAACpC,SAAS,CAACmF,OAAO;AAE9B;;;;;AAKA,IAAI0B,aAAa,GAAG,IAAI;AAExB;;;;;;AAMA,SAASP,YAAYA,CAACQ,KAAK,EAAE/E,UAAU;EACrC,IAAMgF,QAAQ,GAAGD,KAAK,CAACE,WAAW,EAAE;EACpC,IAAI,CAACD,QAAQ,EAAE;IACb,MAAM,IAAIE,KAAK,CAAC,0BAA0B,GAAGH,KAAK,CAAC;;EAGrD,IAAI,CAACC,QAAQ,CAACG,YAAY,CAACnF,UAAU,CAAC,EAAE;IACtC,OAAO,IAAI;;EAEb,IAAMvG,KAAK,GAAGuG,UAAU,CAAC+B,IAAI,CAAC,CAAC,CAAC;EAChC,IAAMrI,MAAM,GAAGsG,UAAU,CAAC+B,IAAI,CAAC,CAAC,CAAC;EACjC,IAAMqD,SAAS,GAAGJ,QAAQ,CAACK,WAAW,CAACrF,UAAU,EAAE,IAAI,CAAC;EACxD,IAAIsF,OAAO;EACX,IAAIF,SAAS,EAAE;IACbE,OAAO,GAAGF,SAAS,CAACG,iBAAiB;;EAEvC,IAAI,EAAED,OAAO,YAAYE,iBAAiB,CAAC,EAAE;IAC3C,MAAM,IAAIN,KAAK,CAAC,gCAAgC,GAAGI,OAAO,CAAC;;EAE7D,IAAIA,OAAO,CAAC7L,KAAK,KAAKA,KAAK,IAAI6L,OAAO,CAAC5L,MAAM,KAAKA,MAAM,EAAE;IACxD,IAAM+L,SAAO,GAAGH,OAAO,CAAChM,UAAU,CAAC,IAAI,CAAC;IACxC,OAAOmM,SAAO,CAAClB,YAAY,CAAC,CAAC,EAAE,CAAC,EAAE9K,KAAK,EAAEC,MAAM,CAAC;;EAGlD,IAAI,CAACoL,aAAa,EAAE;IAClBA,aAAa,GAAGrM,qBAAqB,CAACgB,KAAK,EAAEC,MAAM,CAAC;GACrD,MAAM;IACL,IAAMiL,MAAM,GAAGG,aAAa,CAACH,MAAM;IACnC,IAAIA,MAAM,CAAClL,KAAK,KAAKA,KAAK,IAAIkL,MAAM,CAACjL,MAAM,KAAKA,MAAM,EAAE;MACtDoL,aAAa,GAAGrM,qBAAqB,CAACgB,KAAK,EAAEC,MAAM,CAAC;KACrD,MAAM;MACLoL,aAAa,CAACY,SAAS,CAAC,CAAC,EAAE,CAAC,EAAEjM,KAAK,EAAEC,MAAM,CAAC;;;EAGhDoL,aAAa,CAACa,SAAS,CAACL,OAAO,EAAE,CAAC,EAAE,CAAC,EAAE7L,KAAK,EAAEC,MAAM,CAAC;EACrD,OAAOoL,aAAa,CAACP,YAAY,CAAC,CAAC,EAAE,CAAC,EAAE9K,KAAK,EAAEC,MAAM,CAAC;AACxD;AAEA;;;;;AAKA,SAASkI,mBAAmBA,CAACgE,MAAM;EACjC,OAAOA,MAAM,CAACjK,GAAG,CAAC,UAAUoJ,KAAK;IAC/B,OAAOA,KAAK,CAACc,aAAa,EAAE;EAC9B,CAAC,CAAC;AACJ;AAEA;;;;;AAKA,SAAS/E,YAAYA,CAACC,OAAO;EAC3B,IAAMsD,GAAG,GAAGtD,OAAO,CAACzG,MAAM;EAC1B,IAAMsL,MAAM,GAAG,IAAIhL,KAAK,CAACyJ,GAAG,CAAC;EAC7B,KAAK,IAAIrJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqJ,GAAG,EAAE,EAAErJ,CAAC,EAAE;IAC5B4K,MAAM,CAAC5K,CAAC,CAAC,GAAG8K,WAAW,CAAC/E,OAAO,CAAC/F,CAAC,CAAC,CAAC;;EAErC,OAAO4K,MAAM;AACf;AAEA;;;;;AAKA,SAASE,WAAWA,CAACC,aAAa;EAChC;EACA,IAAIhB,KAAK;EACT,IAAIgB,aAAa,YAAY5N,MAAM,EAAE;IACnC,IAAI4N,aAAa,YAAYxN,UAAU,EAAE;MACvCwM,KAAK,GAAG,IAAI1M,SAAS,CAAC;QAAC8D,MAAM,EAAE4J;MAAa,CAAC,CAAC;KAC/C,MAAM,IAAIA,aAAa,YAAY7N,WAAW,EAAE;MAC/C6M,KAAK,GAAG,IAAI9M,UAAU,CAAC;QAACkE,MAAM,EAAE4J;MAAa,CAAC,CAAC;;GAElD,MAAM;IACLhB,KAAK,GAAGgB,aAAa;;EAEvB,OAAOhB,KAAK;AACd;AAEA,eAAe1E,YAAY"},"metadata":{},"sourceType":"module","externalDependencies":[]}
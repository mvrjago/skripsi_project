{"ast":null,"code":"'use strict';\n\n// Load Modules\nconst RFC3986 = require('./rfc3986');\n\n// Declare internals\n\nconst internals = {\n  Uri: {\n    createUriRegex: function (optionalScheme, allowRelative, relativeOnly, allowQuerySquareBrackets) {\n      let scheme = RFC3986.scheme;\n      let prefix;\n      if (relativeOnly) {\n        prefix = '(?:' + RFC3986.relativeRef + ')';\n      } else {\n        // If we were passed a scheme, use it instead of the generic one\n        if (optionalScheme) {\n          // Have to put this in a non-capturing group to handle the OR statements\n          scheme = '(?:' + optionalScheme + ')';\n        }\n        const withScheme = '(?:' + scheme + ':' + RFC3986.hierPart + ')';\n        prefix = allowRelative ? '(?:' + withScheme + '|' + RFC3986.relativeRef + ')' : withScheme;\n      }\n\n      /**\n       * URI = scheme \":\" hier-part [ \"?\" query ] [ \"#\" fragment ]\n       *\n       * OR\n       *\n       * relative-ref = relative-part [ \"?\" query ] [ \"#\" fragment ]\n       */\n      return new RegExp('^' + prefix + '(?:\\\\?' + (allowQuerySquareBrackets ? RFC3986.queryWithSquareBrackets : RFC3986.query) + ')?' + '(?:#' + RFC3986.fragment + ')?$');\n    }\n  }\n};\nmodule.exports = internals.Uri;","map":{"version":3,"names":["RFC3986","require","internals","Uri","createUriRegex","optionalScheme","allowRelative","relativeOnly","allowQuerySquareBrackets","scheme","prefix","relativeRef","withScheme","hierPart","RegExp","queryWithSquareBrackets","query","fragment","module","exports"],"sources":["/Users/mariovicky/Skripsi_OpenLayers/node_modules/joi/lib/types/string/uri.js"],"sourcesContent":["'use strict';\n\n// Load Modules\n\nconst RFC3986 = require('./rfc3986');\n\n\n// Declare internals\n\nconst internals = {\n    Uri: {\n        createUriRegex: function (optionalScheme, allowRelative, relativeOnly, allowQuerySquareBrackets) {\n\n            let scheme = RFC3986.scheme;\n            let prefix;\n\n            if (relativeOnly) {\n                prefix = '(?:' + RFC3986.relativeRef + ')';\n            }\n            else {\n                // If we were passed a scheme, use it instead of the generic one\n                if (optionalScheme) {\n\n                    // Have to put this in a non-capturing group to handle the OR statements\n                    scheme = '(?:' + optionalScheme + ')';\n                }\n\n                const withScheme = '(?:' + scheme + ':' + RFC3986.hierPart + ')';\n\n                prefix = allowRelative ? '(?:' + withScheme + '|' + RFC3986.relativeRef + ')' : withScheme;\n            }\n\n            /**\n             * URI = scheme \":\" hier-part [ \"?\" query ] [ \"#\" fragment ]\n             *\n             * OR\n             *\n             * relative-ref = relative-part [ \"?\" query ] [ \"#\" fragment ]\n             */\n            return new RegExp('^' + prefix + '(?:\\\\?' + (allowQuerySquareBrackets ? RFC3986.queryWithSquareBrackets : RFC3986.query) + ')?' + '(?:#' + RFC3986.fragment + ')?$');\n        }\n    }\n};\n\n\nmodule.exports = internals.Uri;\n"],"mappings":"AAAA,YAAY;;AAEZ;AAEA,MAAMA,OAAO,GAAGC,OAAO,CAAC,WAAW,CAAC;;AAGpC;;AAEA,MAAMC,SAAS,GAAG;EACdC,GAAG,EAAE;IACDC,cAAc,EAAE,SAAAA,CAAUC,cAAc,EAAEC,aAAa,EAAEC,YAAY,EAAEC,wBAAwB,EAAE;MAE7F,IAAIC,MAAM,GAAGT,OAAO,CAACS,MAAM;MAC3B,IAAIC,MAAM;MAEV,IAAIH,YAAY,EAAE;QACdG,MAAM,GAAG,KAAK,GAAGV,OAAO,CAACW,WAAW,GAAG,GAAG;MAC9C,CAAC,MACI;QACD;QACA,IAAIN,cAAc,EAAE;UAEhB;UACAI,MAAM,GAAG,KAAK,GAAGJ,cAAc,GAAG,GAAG;QACzC;QAEA,MAAMO,UAAU,GAAG,KAAK,GAAGH,MAAM,GAAG,GAAG,GAAGT,OAAO,CAACa,QAAQ,GAAG,GAAG;QAEhEH,MAAM,GAAGJ,aAAa,GAAG,KAAK,GAAGM,UAAU,GAAG,GAAG,GAAGZ,OAAO,CAACW,WAAW,GAAG,GAAG,GAAGC,UAAU;MAC9F;;MAEA;AACZ;AACA;AACA;AACA;AACA;AACA;MACY,OAAO,IAAIE,MAAM,CAAC,GAAG,GAAGJ,MAAM,GAAG,QAAQ,IAAIF,wBAAwB,GAAGR,OAAO,CAACe,uBAAuB,GAAGf,OAAO,CAACgB,KAAK,CAAC,GAAG,IAAI,GAAG,MAAM,GAAGhB,OAAO,CAACiB,QAAQ,GAAG,KAAK,CAAC;IACxK;EACJ;AACJ,CAAC;AAGDC,MAAM,CAACC,OAAO,GAAGjB,SAAS,CAACC,GAAG"},"metadata":{},"sourceType":"script","externalDependencies":[]}
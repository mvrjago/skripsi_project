{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/layer/MapboxVector\n */\nimport BaseEvent from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport MVT from '../format/MVT.js';\nimport SourceState from '../source/State.js';\nimport VectorTileLayer from '../layer/VectorTile.js';\nimport VectorTileSource from '../source/VectorTile.js';\nimport { applyStyle } from 'ol-mapbox-style';\nvar mapboxBaseUrl = 'https://api.mapbox.com';\n/**\n * Gets the path from a mapbox:// URL.\n * @param {string} url The Mapbox URL.\n * @return {string} The path.\n * @private\n */\nexport function getMapboxPath(url) {\n  var startsWith = 'mapbox://';\n  if (url.indexOf(startsWith) !== 0) {\n    return '';\n  }\n  return url.slice(startsWith.length);\n}\n/**\n * Turns mapbox:// sprite URLs into resolvable URLs.\n * @param {string} url The sprite URL.\n * @param {string} token The access token.\n * @return {string} A resolvable URL.\n * @private\n */\nexport function normalizeSpriteUrl(url, token) {\n  var mapboxPath = getMapboxPath(url);\n  if (!mapboxPath) {\n    return url;\n  }\n  var startsWith = 'sprites/';\n  if (mapboxPath.indexOf(startsWith) !== 0) {\n    throw new Error(\"unexpected sprites url: \" + url);\n  }\n  var sprite = mapboxPath.slice(startsWith.length);\n  return mapboxBaseUrl + \"/styles/v1/\" + sprite + \"/sprite?access_token=\" + token;\n}\n/**\n * Turns mapbox:// glyphs URLs into resolvable URLs.\n * @param {string} url The glyphs URL.\n * @param {string} token The access token.\n * @return {string} A resolvable URL.\n * @private\n */\nexport function normalizeGlyphsUrl(url, token) {\n  var mapboxPath = getMapboxPath(url);\n  if (!mapboxPath) {\n    return url;\n  }\n  var startsWith = 'fonts/';\n  if (mapboxPath.indexOf(startsWith) !== 0) {\n    throw new Error(\"unexpected fonts url: \" + url);\n  }\n  var font = mapboxPath.slice(startsWith.length);\n  return mapboxBaseUrl + \"/fonts/v1/\" + font + \"/0-255.pbf?access_token=\" + token;\n}\n/**\n * Turns mapbox:// style URLs into resolvable URLs.\n * @param {string} url The style URL.\n * @param {string} token The access token.\n * @return {string} A resolvable URL.\n * @private\n */\nexport function normalizeStyleUrl(url, token) {\n  var mapboxPath = getMapboxPath(url);\n  if (!mapboxPath) {\n    return url;\n  }\n  var startsWith = 'styles/';\n  if (mapboxPath.indexOf(startsWith) !== 0) {\n    throw new Error(\"unexpected style url: \" + url);\n  }\n  var style = mapboxPath.slice(startsWith.length);\n  return mapboxBaseUrl + \"/styles/v1/\" + style + \"?&access_token=\" + token;\n}\n/**\n * Turns mapbox:// source URLs into vector tile URL templates.\n * @param {string} url The source URL.\n * @param {string} token The access token.\n * @return {string} A vector tile template.\n * @private\n */\nexport function normalizeSourceUrl(url, token) {\n  var mapboxPath = getMapboxPath(url);\n  if (!mapboxPath) {\n    return url;\n  }\n  return \"https://{a-d}.tiles.mapbox.com/v4/\" + mapboxPath + \"/{z}/{x}/{y}.vector.pbf?access_token=\" + token;\n}\n/**\n * @classdesc\n * Event emitted on configuration or loading error.\n */\nvar ErrorEvent = /** @class */function (_super) {\n  __extends(ErrorEvent, _super);\n  /**\n   * @param {Error} error error object.\n   */\n  function ErrorEvent(error) {\n    var _this = _super.call(this, EventType.ERROR) || this;\n    /**\n     * @type {Error}\n     */\n    _this.error = error;\n    return _this;\n  }\n  return ErrorEvent;\n}(BaseEvent);\n/**\n * @typedef {Object} StyleObject\n * @property {Object<string, SourceObject>} sources The style sources.\n * @property {string} sprite The sprite URL.\n * @property {string} glyphs The glyphs URL.\n * @property {Array<LayerObject>} layers The style layers.\n */\n/**\n * @typedef {Object} SourceObject\n * @property {string} url The source URL.\n * @property {SourceType} type The source type.\n */\n/**\n * The Mapbox source type.\n * @enum {string}\n */\nvar SourceType = {\n  VECTOR: 'vector'\n};\n/**\n * @typedef {Object} LayerObject\n * @property {string} id The layer id.\n * @property {string} source The source id.\n */\n/**\n * @typedef {Object} Options\n * @property {string} styleUrl The URL of the Mapbox style object to use for this layer.  For a\n * style created with Mapbox Studio and hosted on Mapbox, this will look like\n * 'mapbox://styles/you/your-style'.\n * @property {string} accessToken The access token for your Mapbox style.\n * @property {string} [source] If your style uses more than one source, you need to use either the\n * `source` property or the `layers` property to limit rendering to a single vector source.  The\n * `source` property corresponds to the id of a vector source in your Mapbox style.\n * @property {Array<string>} [layers] Limit rendering to the list of included layers.  All layers\n * must share the same vector soource.  If your style uses more than one source, you need to use\n * either the `source` property or the `layers` property to limit rendering to a single vector\n * source.\n * @property {boolean} [declutter=true] Declutter images and text. Decluttering is applied to all\n * image and text styles of all Vector and VectorTile layers that have set this to `true`. The priority\n * is defined by the z-index of the layer, the `zIndex` of the style and the render order of features.\n * Higher z-index means higher priority. Within the same z-index, a feature rendered before another has\n * higher priority.\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {import(\"../render.js\").OrderFunction} [renderOrder] Render order. Function to be used when sorting\n * features before rendering. By default features are drawn in the order that they are created. Use\n * `null` to avoid the sort, but get an undefined draw order.\n * @property {number} [renderBuffer=100] The buffer in pixels around the tile extent used by the\n * renderer when getting features from the vector tile for the rendering or hit-detection.\n * Recommended value: Vector tiles are usually generated with a buffer, so this value should match\n * the largest possible buffer of the used tiles. It should be at least the size of the largest\n * point symbol or line width.\n * @property {import(\"./VectorTileRenderType.js\").default|string} [renderMode='hybrid'] Render mode for vector tiles:\n *  * `'image'`: Vector tiles are rendered as images. Great performance, but point symbols and texts\n *    are always rotated with the view and pixels are scaled during zoom animations. When `declutter`\n *    is set to `true`, the decluttering is done per tile resulting in labels and point symbols getting\n *    cut off at tile boundaries.\n *  * `'hybrid'`: Polygon and line elements are rendered as images, so pixels are scaled during zoom\n *    animations. Point symbols and texts are accurately rendered as vectors and can stay upright on\n *    rotated views.\n *  * `'vector'`: Everything is rendered as vectors. Use this mode for improved performance on vector\n *    tile layers with only a few rendered features (e.g. for highlighting a subset of features of\n *    another layer with the same source).\n * @property {import(\"../PluggableMap.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use {@link module:ol/Map#addLayer}.\n * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will be\n * recreated during animations. This means that no vectors will be shown clipped, but the setting\n * will have a performance impact for large amounts of vector data. When set to `false`, batches\n * will be recreated when no animation is active.\n * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will be\n * recreated during interactions. See also `updateWhileAnimating`.\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\n * means no preloading.\n * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.\n */\n/**\n * @classdesc\n * A vector tile layer based on a Mapbox style that uses a single vector source.  Configure\n * the layer with the `styleUrl` and `accessToken` shown in Mapbox Studio's share panel.\n * If the style uses more than one source, use the `source` property to choose a single\n * vector source.  If you want to render a subset of the layers in the style, use the `layers`\n * property (all layers must share the same vector source).  See the constructor options for\n * more detail.\n *\n *     var map = new Map({\n *       view: new View({\n *         center: [0, 0],\n *         zoom: 1\n *       }),\n *       layers: [\n *         new MapboxVector({\n *           styleUrl: 'mapbox://styles/mapbox/bright-v9',\n *           accessToken: 'your-mapbox-access-token-here'\n *         })\n *       ],\n *       target: 'map'\n *     });\n *\n * On configuration or loading error, the layer will trigger an `'error'` event.  Listeners\n * will receive an object with an `error` property that can be used to diagnose the problem.\n *\n * @param {Options} options Options.\n * @extends {VectorTileLayer}\n * @fires module:ol/events/Event~BaseEvent#event:error\n * @api\n */\nvar MapboxVectorLayer = /** @class */function (_super) {\n  __extends(MapboxVectorLayer, _super);\n  /**\n   * @param {Options} options Layer options.  At a minimum, `styleUrl` and `accessToken`\n   * must be provided.\n   */\n  function MapboxVectorLayer(options) {\n    var _this = this;\n    var declutter = 'declutter' in options ? options.declutter : true;\n    var source = new VectorTileSource({\n      state: SourceState.LOADING,\n      format: new MVT()\n    });\n    _this = _super.call(this, {\n      source: source,\n      declutter: declutter,\n      className: options.className,\n      opacity: options.opacity,\n      visible: options.visible,\n      zIndex: options.zIndex,\n      minResolution: options.minResolution,\n      maxResolution: options.maxResolution,\n      minZoom: options.minZoom,\n      maxZoom: options.maxZoom,\n      renderOrder: options.renderOrder,\n      renderBuffer: options.renderBuffer,\n      renderMode: options.renderMode,\n      map: options.map,\n      updateWhileAnimating: options.updateWhileAnimating,\n      updateWhileInteracting: options.updateWhileInteracting,\n      preload: options.preload,\n      useInterimTilesOnError: options.useInterimTilesOnError\n    }) || this;\n    _this.sourceId = options.source;\n    _this.layers = options.layers;\n    _this.accessToken = options.accessToken;\n    _this.fetchStyle(options.styleUrl);\n    return _this;\n  }\n  /**\n   * Fetch the style object.\n   * @param {string} styleUrl The URL of the style to load.\n   * @protected\n   */\n  MapboxVectorLayer.prototype.fetchStyle = function (styleUrl) {\n    var _this = this;\n    var url = normalizeStyleUrl(styleUrl, this.accessToken);\n    fetch(url).then(function (response) {\n      if (!response.ok) {\n        throw new Error(\"unexpected response when fetching style: \" + response.status);\n      }\n      return response.json();\n    }).then(function (style) {\n      _this.onStyleLoad(style);\n    }).catch(function (error) {\n      _this.handleError(error);\n    });\n  };\n  /**\n   * Handle the loaded style object.\n   * @param {StyleObject} style The loaded style.\n   * @protected\n   */\n  MapboxVectorLayer.prototype.onStyleLoad = function (style) {\n    var _this = this;\n    var sourceId;\n    var sourceIdOrLayersList;\n    if (this.layers) {\n      // confirm all layers share the same source\n      var lookup = {};\n      for (var i = 0; i < style.layers.length; ++i) {\n        var layer = style.layers[i];\n        if (layer.source) {\n          lookup[layer.id] = layer.source;\n        }\n      }\n      var firstSource = void 0;\n      for (var i = 0; i < this.layers.length; ++i) {\n        var candidate = lookup[this.layers[i]];\n        if (!candidate) {\n          this.handleError(new Error(\"could not find source for \" + this.layers[i]));\n          return;\n        }\n        if (!firstSource) {\n          firstSource = candidate;\n        } else if (firstSource !== candidate) {\n          this.handleError(new Error(\"layers can only use a single source, found \" + firstSource + \" and \" + candidate));\n          return;\n        }\n      }\n      sourceId = firstSource;\n      sourceIdOrLayersList = this.layers;\n    } else {\n      sourceId = this.sourceId;\n      sourceIdOrLayersList = sourceId;\n    }\n    if (!sourceIdOrLayersList) {\n      // default to the first source in the style\n      sourceId = Object.keys(style.sources)[0];\n      sourceIdOrLayersList = sourceId;\n    }\n    if (style.sprite) {\n      style.sprite = normalizeSpriteUrl(style.sprite, this.accessToken);\n    }\n    if (style.glyphs) {\n      style.glyphs = normalizeGlyphsUrl(style.glyphs, this.accessToken);\n    }\n    var styleSource = style.sources[sourceId];\n    if (styleSource.type !== SourceType.VECTOR) {\n      this.handleError(new Error(\"only works for vector sources, found \" + styleSource.type));\n      return;\n    }\n    var source = this.getSource();\n    source.setUrl(normalizeSourceUrl(styleSource.url, this.accessToken));\n    applyStyle(this, style, sourceIdOrLayersList).then(function () {\n      source.setState(SourceState.READY);\n    }).catch(function (error) {\n      _this.handleError(error);\n    });\n  };\n  /**\n   * Handle configuration or loading error.\n   * @param {Error} error The error.\n   * @protected\n   */\n  MapboxVectorLayer.prototype.handleError = function (error) {\n    this.dispatchEvent(new ErrorEvent(error));\n    var source = this.getSource();\n    source.setState(SourceState.ERROR);\n  };\n  return MapboxVectorLayer;\n}(VectorTileLayer);\nexport default MapboxVectorLayer;","map":{"version":3,"names":["BaseEvent","EventType","MVT","SourceState","VectorTileLayer","VectorTileSource","applyStyle","mapboxBaseUrl","getMapboxPath","url","startsWith","indexOf","slice","length","normalizeSpriteUrl","token","mapboxPath","Error","sprite","normalizeGlyphsUrl","font","normalizeStyleUrl","style","normalizeSourceUrl","ErrorEvent","_super","__extends","error","_this","call","ERROR","SourceType","VECTOR","MapboxVectorLayer","options","declutter","source","state","LOADING","format","className","opacity","visible","zIndex","minResolution","maxResolution","minZoom","maxZoom","renderOrder","renderBuffer","renderMode","map","updateWhileAnimating","updateWhileInteracting","preload","useInterimTilesOnError","sourceId","layers","accessToken","fetchStyle","styleUrl","prototype","fetch","then","response","ok","status","json","onStyleLoad","catch","handleError","sourceIdOrLayersList","lookup","i","layer","id","firstSource","candidate","Object","keys","sources","glyphs","styleSource","type","getSource","setUrl","setState","READY","dispatchEvent"],"sources":["/Users/mariovicky/Skripsi_OpenLayers/node_modules/ol/src/layer/MapboxVector.js"],"sourcesContent":["/**\n * @module ol/layer/MapboxVector\n */\nimport BaseEvent from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport MVT from '../format/MVT.js';\nimport SourceState from '../source/State.js';\nimport VectorTileLayer from '../layer/VectorTile.js';\nimport VectorTileSource from '../source/VectorTile.js';\nimport {applyStyle} from 'ol-mapbox-style';\n\nconst mapboxBaseUrl = 'https://api.mapbox.com';\n\n/**\n * Gets the path from a mapbox:// URL.\n * @param {string} url The Mapbox URL.\n * @return {string} The path.\n * @private\n */\nexport function getMapboxPath(url) {\n  const startsWith = 'mapbox://';\n  if (url.indexOf(startsWith) !== 0) {\n    return '';\n  }\n  return url.slice(startsWith.length);\n}\n\n/**\n * Turns mapbox:// sprite URLs into resolvable URLs.\n * @param {string} url The sprite URL.\n * @param {string} token The access token.\n * @return {string} A resolvable URL.\n * @private\n */\nexport function normalizeSpriteUrl(url, token) {\n  const mapboxPath = getMapboxPath(url);\n  if (!mapboxPath) {\n    return url;\n  }\n  const startsWith = 'sprites/';\n  if (mapboxPath.indexOf(startsWith) !== 0) {\n    throw new Error(`unexpected sprites url: ${url}`);\n  }\n  const sprite = mapboxPath.slice(startsWith.length);\n\n  return `${mapboxBaseUrl}/styles/v1/${sprite}/sprite?access_token=${token}`;\n}\n\n/**\n * Turns mapbox:// glyphs URLs into resolvable URLs.\n * @param {string} url The glyphs URL.\n * @param {string} token The access token.\n * @return {string} A resolvable URL.\n * @private\n */\nexport function normalizeGlyphsUrl(url, token) {\n  const mapboxPath = getMapboxPath(url);\n  if (!mapboxPath) {\n    return url;\n  }\n  const startsWith = 'fonts/';\n  if (mapboxPath.indexOf(startsWith) !== 0) {\n    throw new Error(`unexpected fonts url: ${url}`);\n  }\n  const font = mapboxPath.slice(startsWith.length);\n\n  return `${mapboxBaseUrl}/fonts/v1/${font}/0-255.pbf?access_token=${token}`;\n}\n\n/**\n * Turns mapbox:// style URLs into resolvable URLs.\n * @param {string} url The style URL.\n * @param {string} token The access token.\n * @return {string} A resolvable URL.\n * @private\n */\nexport function normalizeStyleUrl(url, token) {\n  const mapboxPath = getMapboxPath(url);\n  if (!mapboxPath) {\n    return url;\n  }\n  const startsWith = 'styles/';\n  if (mapboxPath.indexOf(startsWith) !== 0) {\n    throw new Error(`unexpected style url: ${url}`);\n  }\n  const style = mapboxPath.slice(startsWith.length);\n\n  return `${mapboxBaseUrl}/styles/v1/${style}?&access_token=${token}`;\n}\n\n/**\n * Turns mapbox:// source URLs into vector tile URL templates.\n * @param {string} url The source URL.\n * @param {string} token The access token.\n * @return {string} A vector tile template.\n * @private\n */\nexport function normalizeSourceUrl(url, token) {\n  const mapboxPath = getMapboxPath(url);\n  if (!mapboxPath) {\n    return url;\n  }\n  return `https://{a-d}.tiles.mapbox.com/v4/${mapboxPath}/{z}/{x}/{y}.vector.pbf?access_token=${token}`;\n}\n\n/**\n * @classdesc\n * Event emitted on configuration or loading error.\n */\nclass ErrorEvent extends BaseEvent {\n  /**\n   * @param {Error} error error object.\n   */\n  constructor(error) {\n    super(EventType.ERROR);\n\n    /**\n     * @type {Error}\n     */\n    this.error = error;\n  }\n}\n\n/**\n * @typedef {Object} StyleObject\n * @property {Object<string, SourceObject>} sources The style sources.\n * @property {string} sprite The sprite URL.\n * @property {string} glyphs The glyphs URL.\n * @property {Array<LayerObject>} layers The style layers.\n */\n\n/**\n * @typedef {Object} SourceObject\n * @property {string} url The source URL.\n * @property {SourceType} type The source type.\n */\n\n/**\n * The Mapbox source type.\n * @enum {string}\n */\nconst SourceType = {\n  VECTOR: 'vector',\n};\n\n/**\n * @typedef {Object} LayerObject\n * @property {string} id The layer id.\n * @property {string} source The source id.\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} styleUrl The URL of the Mapbox style object to use for this layer.  For a\n * style created with Mapbox Studio and hosted on Mapbox, this will look like\n * 'mapbox://styles/you/your-style'.\n * @property {string} accessToken The access token for your Mapbox style.\n * @property {string} [source] If your style uses more than one source, you need to use either the\n * `source` property or the `layers` property to limit rendering to a single vector source.  The\n * `source` property corresponds to the id of a vector source in your Mapbox style.\n * @property {Array<string>} [layers] Limit rendering to the list of included layers.  All layers\n * must share the same vector soource.  If your style uses more than one source, you need to use\n * either the `source` property or the `layers` property to limit rendering to a single vector\n * source.\n * @property {boolean} [declutter=true] Declutter images and text. Decluttering is applied to all\n * image and text styles of all Vector and VectorTile layers that have set this to `true`. The priority\n * is defined by the z-index of the layer, the `zIndex` of the style and the render order of features.\n * Higher z-index means higher priority. Within the same z-index, a feature rendered before another has\n * higher priority.\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {import(\"../render.js\").OrderFunction} [renderOrder] Render order. Function to be used when sorting\n * features before rendering. By default features are drawn in the order that they are created. Use\n * `null` to avoid the sort, but get an undefined draw order.\n * @property {number} [renderBuffer=100] The buffer in pixels around the tile extent used by the\n * renderer when getting features from the vector tile for the rendering or hit-detection.\n * Recommended value: Vector tiles are usually generated with a buffer, so this value should match\n * the largest possible buffer of the used tiles. It should be at least the size of the largest\n * point symbol or line width.\n * @property {import(\"./VectorTileRenderType.js\").default|string} [renderMode='hybrid'] Render mode for vector tiles:\n *  * `'image'`: Vector tiles are rendered as images. Great performance, but point symbols and texts\n *    are always rotated with the view and pixels are scaled during zoom animations. When `declutter`\n *    is set to `true`, the decluttering is done per tile resulting in labels and point symbols getting\n *    cut off at tile boundaries.\n *  * `'hybrid'`: Polygon and line elements are rendered as images, so pixels are scaled during zoom\n *    animations. Point symbols and texts are accurately rendered as vectors and can stay upright on\n *    rotated views.\n *  * `'vector'`: Everything is rendered as vectors. Use this mode for improved performance on vector\n *    tile layers with only a few rendered features (e.g. for highlighting a subset of features of\n *    another layer with the same source).\n * @property {import(\"../PluggableMap.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use {@link module:ol/Map#addLayer}.\n * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will be\n * recreated during animations. This means that no vectors will be shown clipped, but the setting\n * will have a performance impact for large amounts of vector data. When set to `false`, batches\n * will be recreated when no animation is active.\n * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will be\n * recreated during interactions. See also `updateWhileAnimating`.\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\n * means no preloading.\n * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.\n */\n\n/**\n * @classdesc\n * A vector tile layer based on a Mapbox style that uses a single vector source.  Configure\n * the layer with the `styleUrl` and `accessToken` shown in Mapbox Studio's share panel.\n * If the style uses more than one source, use the `source` property to choose a single\n * vector source.  If you want to render a subset of the layers in the style, use the `layers`\n * property (all layers must share the same vector source).  See the constructor options for\n * more detail.\n *\n *     var map = new Map({\n *       view: new View({\n *         center: [0, 0],\n *         zoom: 1\n *       }),\n *       layers: [\n *         new MapboxVector({\n *           styleUrl: 'mapbox://styles/mapbox/bright-v9',\n *           accessToken: 'your-mapbox-access-token-here'\n *         })\n *       ],\n *       target: 'map'\n *     });\n *\n * On configuration or loading error, the layer will trigger an `'error'` event.  Listeners\n * will receive an object with an `error` property that can be used to diagnose the problem.\n *\n * @param {Options} options Options.\n * @extends {VectorTileLayer}\n * @fires module:ol/events/Event~BaseEvent#event:error\n * @api\n */\nclass MapboxVectorLayer extends VectorTileLayer {\n  /**\n   * @param {Options} options Layer options.  At a minimum, `styleUrl` and `accessToken`\n   * must be provided.\n   */\n  constructor(options) {\n    const declutter = 'declutter' in options ? options.declutter : true;\n    const source = new VectorTileSource({\n      state: SourceState.LOADING,\n      format: new MVT(),\n    });\n\n    super({\n      source: source,\n      declutter: declutter,\n      className: options.className,\n      opacity: options.opacity,\n      visible: options.visible,\n      zIndex: options.zIndex,\n      minResolution: options.minResolution,\n      maxResolution: options.maxResolution,\n      minZoom: options.minZoom,\n      maxZoom: options.maxZoom,\n      renderOrder: options.renderOrder,\n      renderBuffer: options.renderBuffer,\n      renderMode: options.renderMode,\n      map: options.map,\n      updateWhileAnimating: options.updateWhileAnimating,\n      updateWhileInteracting: options.updateWhileInteracting,\n      preload: options.preload,\n      useInterimTilesOnError: options.useInterimTilesOnError,\n    });\n\n    this.sourceId = options.source;\n    this.layers = options.layers;\n    this.accessToken = options.accessToken;\n    this.fetchStyle(options.styleUrl);\n  }\n\n  /**\n   * Fetch the style object.\n   * @param {string} styleUrl The URL of the style to load.\n   * @protected\n   */\n  fetchStyle(styleUrl) {\n    const url = normalizeStyleUrl(styleUrl, this.accessToken);\n    fetch(url)\n      .then((response) => {\n        if (!response.ok) {\n          throw new Error(\n            `unexpected response when fetching style: ${response.status}`\n          );\n        }\n        return response.json();\n      })\n      .then((style) => {\n        this.onStyleLoad(style);\n      })\n      .catch((error) => {\n        this.handleError(error);\n      });\n  }\n\n  /**\n   * Handle the loaded style object.\n   * @param {StyleObject} style The loaded style.\n   * @protected\n   */\n  onStyleLoad(style) {\n    let sourceId;\n    let sourceIdOrLayersList;\n    if (this.layers) {\n      // confirm all layers share the same source\n      const lookup = {};\n      for (let i = 0; i < style.layers.length; ++i) {\n        const layer = style.layers[i];\n        if (layer.source) {\n          lookup[layer.id] = layer.source;\n        }\n      }\n      let firstSource;\n      for (let i = 0; i < this.layers.length; ++i) {\n        const candidate = lookup[this.layers[i]];\n        if (!candidate) {\n          this.handleError(\n            new Error(`could not find source for ${this.layers[i]}`)\n          );\n          return;\n        }\n        if (!firstSource) {\n          firstSource = candidate;\n        } else if (firstSource !== candidate) {\n          this.handleError(\n            new Error(\n              `layers can only use a single source, found ${firstSource} and ${candidate}`\n            )\n          );\n          return;\n        }\n      }\n      sourceId = firstSource;\n      sourceIdOrLayersList = this.layers;\n    } else {\n      sourceId = this.sourceId;\n      sourceIdOrLayersList = sourceId;\n    }\n\n    if (!sourceIdOrLayersList) {\n      // default to the first source in the style\n      sourceId = Object.keys(style.sources)[0];\n      sourceIdOrLayersList = sourceId;\n    }\n\n    if (style.sprite) {\n      style.sprite = normalizeSpriteUrl(style.sprite, this.accessToken);\n    }\n\n    if (style.glyphs) {\n      style.glyphs = normalizeGlyphsUrl(style.glyphs, this.accessToken);\n    }\n\n    const styleSource = style.sources[sourceId];\n    if (styleSource.type !== SourceType.VECTOR) {\n      this.handleError(\n        new Error(`only works for vector sources, found ${styleSource.type}`)\n      );\n      return;\n    }\n\n    const source = this.getSource();\n    source.setUrl(normalizeSourceUrl(styleSource.url, this.accessToken));\n\n    applyStyle(this, style, sourceIdOrLayersList)\n      .then(() => {\n        source.setState(SourceState.READY);\n      })\n      .catch((error) => {\n        this.handleError(error);\n      });\n  }\n\n  /**\n   * Handle configuration or loading error.\n   * @param {Error} error The error.\n   * @protected\n   */\n  handleError(error) {\n    this.dispatchEvent(new ErrorEvent(error));\n    const source = this.getSource();\n    source.setState(SourceState.ERROR);\n  }\n}\n\nexport default MapboxVectorLayer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"/**\n * Classes and utilities for generating shaders from literal style objects\n * @module ol/webgl/ShaderBuilder\n */\nimport { ValueTypes, expressionToGlsl, getStringNumberEquivalent } from '../style/expressions.js';\n/**\n * @typedef {Object} VaryingDescription\n * @property {string} name Varying name, as will be declared in the header.\n * @property {string} type Varying type, either `float`, `vec2`, `vec4`...\n * @property {string} expression Expression which will be assigned to the varying in the vertex shader, and\n * passed on to the fragment shader.\n */\n/**\n * @classdesc\n * This class implements a classic builder pattern for generating many different types of shaders.\n * Methods can be chained, e. g.:\n *\n * ```js\n * const shader = new ShaderBuilder()\n *   .addVarying('v_width', 'float', 'a_width')\n *   .addUniform('u_time')\n *   .setColorExpression('...')\n *   .setSizeExpression('...')\n *   .outputSymbolFragmentShader();\n * ```\n */\nvar ShaderBuilder = /** @class */function () {\n  function ShaderBuilder() {\n    /**\n     * Uniforms; these will be declared in the header (should include the type).\n     * @type {Array<string>}\n     * @private\n     */\n    this.uniforms = [];\n    /**\n     * Attributes; these will be declared in the header (should include the type).\n     * @type {Array<string>}\n     * @private\n     */\n    this.attributes = [];\n    /**\n     * Varyings with a name, a type and an expression.\n     * @type {Array<VaryingDescription>}\n     * @private\n     */\n    this.varyings = [];\n    /**\n     * @type {string}\n     * @private\n     */\n    this.sizeExpression = 'vec2(1.0)';\n    /**\n     * @type {string}\n     * @private\n     */\n    this.rotationExpression = '0.0';\n    /**\n     * @type {string}\n     * @private\n     */\n    this.offsetExpression = 'vec2(0.0)';\n    /**\n     * @type {string}\n     * @private\n     */\n    this.colorExpression = 'vec4(1.0)';\n    /**\n     * @type {string}\n     * @private\n     */\n    this.texCoordExpression = 'vec4(0.0, 0.0, 1.0, 1.0)';\n    /**\n     * @type {string}\n     * @private\n     */\n    this.discardExpression = 'false';\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.rotateWithView = false;\n  }\n  /**\n   * Adds a uniform accessible in both fragment and vertex shaders.\n   * The given name should include a type, such as `sampler2D u_texture`.\n   * @param {string} name Uniform name\n   * @return {ShaderBuilder} the builder object\n   */\n  ShaderBuilder.prototype.addUniform = function (name) {\n    this.uniforms.push(name);\n    return this;\n  };\n  /**\n   * Adds an attribute accessible in the vertex shader, read from the geometry buffer.\n   * The given name should include a type, such as `vec2 a_position`.\n   * @param {string} name Attribute name\n   * @return {ShaderBuilder} the builder object\n   */\n  ShaderBuilder.prototype.addAttribute = function (name) {\n    this.attributes.push(name);\n    return this;\n  };\n  /**\n   * Adds a varying defined in the vertex shader and accessible from the fragment shader.\n   * The type and expression of the varying have to be specified separately.\n   * @param {string} name Varying name\n   * @param {'float'|'vec2'|'vec3'|'vec4'} type Type\n   * @param {string} expression Expression used to assign a value to the varying.\n   * @return {ShaderBuilder} the builder object\n   */\n  ShaderBuilder.prototype.addVarying = function (name, type, expression) {\n    this.varyings.push({\n      name: name,\n      type: type,\n      expression: expression\n    });\n    return this;\n  };\n  /**\n   * Sets an expression to compute the size of the shape.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `vec2` value.\n   * @param {string} expression Size expression\n   * @return {ShaderBuilder} the builder object\n   */\n  ShaderBuilder.prototype.setSizeExpression = function (expression) {\n    this.sizeExpression = expression;\n    return this;\n  };\n  /**\n   * Sets an expression to compute the rotation of the shape.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `float` value in radians.\n   * @param {string} expression Size expression\n   * @return {ShaderBuilder} the builder object\n   */\n  ShaderBuilder.prototype.setRotationExpression = function (expression) {\n    this.rotationExpression = expression;\n    return this;\n  };\n  /**\n   * Sets an expression to compute the offset of the symbol from the point center.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `vec2` value.\n   * Note: will only be used for point geometry shaders.\n   * @param {string} expression Offset expression\n   * @return {ShaderBuilder} the builder object\n   */\n  ShaderBuilder.prototype.setSymbolOffsetExpression = function (expression) {\n    this.offsetExpression = expression;\n    return this;\n  };\n  /**\n   * Sets an expression to compute the color of the shape.\n   * This expression can use all the uniforms, varyings and attributes available\n   * in the fragment shader, and should evaluate to a `vec4` value.\n   * @param {string} expression Color expression\n   * @return {ShaderBuilder} the builder object\n   */\n  ShaderBuilder.prototype.setColorExpression = function (expression) {\n    this.colorExpression = expression;\n    return this;\n  };\n  /**\n   * Sets an expression to compute the texture coordinates of the vertices.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `vec4` value.\n   * @param {string} expression Texture coordinate expression\n   * @return {ShaderBuilder} the builder object\n   */\n  ShaderBuilder.prototype.setTextureCoordinateExpression = function (expression) {\n    this.texCoordExpression = expression;\n    return this;\n  };\n  /**\n   * Sets an expression to determine whether a fragment (pixel) should be discarded,\n   * i.e. not drawn at all.\n   * This expression can use all the uniforms, varyings and attributes available\n   * in the fragment shader, and should evaluate to a `bool` value (it will be\n   * used in an `if` statement)\n   * @param {string} expression Fragment discard expression\n   * @return {ShaderBuilder} the builder object\n   */\n  ShaderBuilder.prototype.setFragmentDiscardExpression = function (expression) {\n    this.discardExpression = expression;\n    return this;\n  };\n  /**\n   * Sets whether the symbols should rotate with the view or stay aligned with the map.\n   * Note: will only be used for point geometry shaders.\n   * @param {boolean} rotateWithView Rotate with view\n   * @return {ShaderBuilder} the builder object\n   */\n  ShaderBuilder.prototype.setSymbolRotateWithView = function (rotateWithView) {\n    this.rotateWithView = rotateWithView;\n    return this;\n  };\n  /**\n   * @returns {string} Previously set size expression\n   */\n  ShaderBuilder.prototype.getSizeExpression = function () {\n    return this.sizeExpression;\n  };\n  /**\n   * @returns {string} Previously set symbol offset expression\n   */\n  ShaderBuilder.prototype.getOffsetExpression = function () {\n    return this.offsetExpression;\n  };\n  /**\n   * @returns {string} Previously set color expression\n   */\n  ShaderBuilder.prototype.getColorExpression = function () {\n    return this.colorExpression;\n  };\n  /**\n   * @returns {string} Previously set texture coordinate expression\n   */\n  ShaderBuilder.prototype.getTextureCoordinateExpression = function () {\n    return this.texCoordExpression;\n  };\n  /**\n   * @returns {string} Previously set fragment discard expression\n   */\n  ShaderBuilder.prototype.getFragmentDiscardExpression = function () {\n    return this.discardExpression;\n  };\n  /**\n   * Generates a symbol vertex shader from the builder parameters,\n   * intended to be used on point geometries.\n   *\n   * Three uniforms are hardcoded in all shaders: `u_projectionMatrix`, `u_offsetScaleMatrix`,\n   * `u_offsetRotateMatrix`, `u_time`.\n   *\n   * The following attributes are hardcoded and expected to be present in the vertex buffers:\n   * `vec2 a_position`, `float a_index` (being the index of the vertex in the quad, 0 to 3).\n   *\n   * The following varyings are hardcoded and gives the coordinate of the pixel both in the quad and on the texture:\n   * `vec2 v_quadCoord`, `vec2 v_texCoord`\n   *\n   * @param {boolean} [forHitDetection] If true, the shader will be modified to include hit detection variables\n   * (namely, hit color with encoded feature id).\n   * @returns {string} The full shader as a string.\n   */\n  ShaderBuilder.prototype.getSymbolVertexShader = function (forHitDetection) {\n    var offsetMatrix = this.rotateWithView ? 'u_offsetScaleMatrix * u_offsetRotateMatrix' : 'u_offsetScaleMatrix';\n    var attributes = this.attributes;\n    var varyings = this.varyings;\n    if (forHitDetection) {\n      attributes = attributes.concat('vec4 a_hitColor');\n      varyings = varyings.concat({\n        name: 'v_hitColor',\n        type: 'vec4',\n        expression: 'a_hitColor'\n      });\n    }\n    return \"precision mediump float;\\nuniform mat4 u_projectionMatrix;\\nuniform mat4 u_offsetScaleMatrix;\\nuniform mat4 u_offsetRotateMatrix;\\nuniform float u_time;\\nuniform float u_zoom;\\nuniform float u_resolution;\\n\" + this.uniforms.map(function (uniform) {\n      return 'uniform ' + uniform + ';';\n    }).join('\\n') + \"\\nattribute vec2 a_position;\\nattribute float a_index;\\n\" + attributes.map(function (attribute) {\n      return 'attribute ' + attribute + ';';\n    }).join('\\n') + \"\\nvarying vec2 v_texCoord;\\nvarying vec2 v_quadCoord;\\n\" + varyings.map(function (varying) {\n      return 'varying ' + varying.type + ' ' + varying.name + ';';\n    }).join('\\n') + \"\\nvoid main(void) {\\n  mat4 offsetMatrix = \" + offsetMatrix + \";\\n  vec2 halfSize = \" + this.sizeExpression + \" * 0.5;\\n  vec2 offset = \" + this.offsetExpression + \";\\n  float angle = \" + this.rotationExpression + \";\\n  float offsetX;\\n  float offsetY;\\n  if (a_index == 0.0) {\\n    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);\\n    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);\\n  } else if (a_index == 1.0) {\\n    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);\\n    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);\\n  } else if (a_index == 2.0) {\\n    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);\\n    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);\\n  } else {\\n    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);\\n    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);\\n  }\\n  vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\\n  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\\n  vec4 texCoord = \" + this.texCoordExpression + \";\\n  float u = a_index == 0.0 || a_index == 3.0 ? texCoord.s : texCoord.p;\\n  float v = a_index == 2.0 || a_index == 3.0 ? texCoord.t : texCoord.q;\\n  v_texCoord = vec2(u, v);\\n  u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\\n  v = a_index == 2.0 || a_index == 3.0 ? 0.0 : 1.0;\\n  v_quadCoord = vec2(u, v);\\n\" + varyings.map(function (varying) {\n      return '  ' + varying.name + ' = ' + varying.expression + ';';\n    }).join('\\n') + \"\\n}\";\n  };\n  /**\n   * Generates a symbol fragment shader from the builder parameters,\n   * intended to be used on point geometries.\n   *\n   * Expects the following varyings to be transmitted by the vertex shader:\n   * `vec2 v_quadCoord`, `vec2 v_texCoord`\n   *\n   * @param {boolean} [forHitDetection] If true, the shader will be modified to include hit detection variables\n   * (namely, hit color with encoded feature id).\n   * @returns {string} The full shader as a string.\n   */\n  ShaderBuilder.prototype.getSymbolFragmentShader = function (forHitDetection) {\n    var hitDetectionBypass = forHitDetection ? '  if (gl_FragColor.a < 0.1) { discard; } gl_FragColor = v_hitColor;' : '';\n    var varyings = this.varyings;\n    if (forHitDetection) {\n      varyings = varyings.concat({\n        name: 'v_hitColor',\n        type: 'vec4',\n        expression: 'a_hitColor'\n      });\n    }\n    return \"precision mediump float;\\nuniform float u_time;\\nuniform float u_zoom;\\nuniform float u_resolution;\\n\" + this.uniforms.map(function (uniform) {\n      return 'uniform ' + uniform + ';';\n    }).join('\\n') + \"\\nvarying vec2 v_texCoord;\\nvarying vec2 v_quadCoord;\\n\" + varyings.map(function (varying) {\n      return 'varying ' + varying.type + ' ' + varying.name + ';';\n    }).join('\\n') + \"\\nvoid main(void) {\\n  if (\" + this.discardExpression + \") { discard; }\\n  gl_FragColor = \" + this.colorExpression + \";\\n  gl_FragColor.rgb *= gl_FragColor.a;\\n\" + hitDetectionBypass + \"\\n}\";\n  };\n  return ShaderBuilder;\n}();\nexport { ShaderBuilder };\n/**\n * @typedef {Object} StyleParseResult\n * @property {ShaderBuilder} builder Shader builder pre-configured according to a given style\n * @property {Object.<string,import(\"./Helper\").UniformValue>} uniforms Uniform definitions.\n * @property {Array<import(\"../renderer/webgl/PointsLayer\").CustomAttribute>} attributes Attribute descriptions.\n */\n/**\n * Parses a {@link import(\"../style/LiteralStyle\").LiteralStyle} object and returns a {@link ShaderBuilder}\n * object that has been configured according to the given style, as well as `attributes` and `uniforms`\n * arrays to be fed to the `WebGLPointsRenderer` class.\n *\n * Also returns `uniforms` and `attributes` properties as expected by the\n * {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.\n *\n * @param {import(\"../style/LiteralStyle\").LiteralStyle} style Literal style.\n * @returns {StyleParseResult} Result containing shader params, attributes and uniforms.\n */\nexport function parseLiteralStyle(style) {\n  var symbStyle = style.symbol;\n  var size = symbStyle.size !== undefined ? symbStyle.size : 1;\n  var color = symbStyle.color || 'white';\n  var texCoord = symbStyle.textureCoord || [0, 0, 1, 1];\n  var offset = symbStyle.offset || [0, 0];\n  var opacity = symbStyle.opacity !== undefined ? symbStyle.opacity : 1;\n  var rotation = symbStyle.rotation !== undefined ? symbStyle.rotation : 0;\n  /**\n   * @type {import(\"../style/expressions.js\").ParsingContext}\n   */\n  var vertContext = {\n    inFragmentShader: false,\n    variables: [],\n    attributes: [],\n    stringLiteralsMap: {}\n  };\n  var parsedSize = expressionToGlsl(vertContext, size, ValueTypes.NUMBER_ARRAY | ValueTypes.NUMBER);\n  var parsedOffset = expressionToGlsl(vertContext, offset, ValueTypes.NUMBER_ARRAY);\n  var parsedTexCoord = expressionToGlsl(vertContext, texCoord, ValueTypes.NUMBER_ARRAY);\n  var parsedRotation = expressionToGlsl(vertContext, rotation, ValueTypes.NUMBER);\n  /**\n   * @type {import(\"../style/expressions.js\").ParsingContext}\n   */\n  var fragContext = {\n    inFragmentShader: true,\n    variables: vertContext.variables,\n    attributes: [],\n    stringLiteralsMap: vertContext.stringLiteralsMap\n  };\n  var parsedColor = expressionToGlsl(fragContext, color, ValueTypes.COLOR);\n  var parsedOpacity = expressionToGlsl(fragContext, opacity, ValueTypes.NUMBER);\n  var opacityFilter = '1.0';\n  var visibleSize = \"vec2(\" + expressionToGlsl(fragContext, size, ValueTypes.NUMBER_ARRAY | ValueTypes.NUMBER) + \").x\";\n  switch (symbStyle.symbolType) {\n    case 'square':\n      break;\n    case 'image':\n      break;\n    // taken from https://thebookofshaders.com/07/\n    case 'circle':\n      opacityFilter = \"(1.0-smoothstep(1.-4./\" + visibleSize + \",1.,dot(v_quadCoord-.5,v_quadCoord-.5)*4.))\";\n      break;\n    case 'triangle':\n      var st = '(v_quadCoord*2.-1.)';\n      var a = \"(atan(\" + st + \".x,\" + st + \".y))\";\n      opacityFilter = \"(1.0-smoothstep(.5-3./\" + visibleSize + \",.5,cos(floor(.5+\" + a + \"/2.094395102)*2.094395102-\" + a + \")*length(\" + st + \")))\";\n      break;\n    default:\n      throw new Error('Unexpected symbol type: ' + symbStyle.symbolType);\n  }\n  var builder = new ShaderBuilder().setSizeExpression(\"vec2(\" + parsedSize + \")\").setRotationExpression(parsedRotation).setSymbolOffsetExpression(parsedOffset).setTextureCoordinateExpression(parsedTexCoord).setSymbolRotateWithView(!!symbStyle.rotateWithView).setColorExpression(\"vec4(\" + parsedColor + \".rgb, \" + parsedColor + \".a * \" + parsedOpacity + \" * \" + opacityFilter + \")\");\n  if (style.filter) {\n    var parsedFilter = expressionToGlsl(fragContext, style.filter, ValueTypes.BOOLEAN);\n    builder.setFragmentDiscardExpression(\"!\" + parsedFilter);\n  }\n  /** @type {Object.<string,import(\"../webgl/Helper\").UniformValue>} */\n  var uniforms = {};\n  // define one uniform per variable\n  fragContext.variables.forEach(function (varName) {\n    builder.addUniform(\"float u_\" + varName);\n    uniforms[\"u_\" + varName] = function () {\n      if (!style.variables || style.variables[varName] === undefined) {\n        throw new Error(\"The following variable is missing from the style: \" + varName);\n      }\n      var value = style.variables[varName];\n      if (typeof value === 'string') {\n        value = getStringNumberEquivalent(vertContext, value);\n      }\n      return value !== undefined ? value : -9999999; // to avoid matching with the first string literal\n    };\n  });\n\n  if (symbStyle.symbolType === 'image' && symbStyle.src) {\n    var texture = new Image();\n    texture.src = symbStyle.src;\n    builder.addUniform('sampler2D u_texture').setColorExpression(builder.getColorExpression() + ' * texture2D(u_texture, v_texCoord)');\n    uniforms['u_texture'] = texture;\n  }\n  // for each feature attribute used in the fragment shader, define a varying that will be used to pass data\n  // from the vertex to the fragment shader, as well as an attribute in the vertex shader (if not already present)\n  fragContext.attributes.forEach(function (attrName) {\n    if (vertContext.attributes.indexOf(attrName) === -1) {\n      vertContext.attributes.push(attrName);\n    }\n    builder.addVarying(\"v_\" + attrName, 'float', \"a_\" + attrName);\n  });\n  // for each feature attribute used in the vertex shader, define an attribute in the vertex shader.\n  vertContext.attributes.forEach(function (attrName) {\n    builder.addAttribute(\"float a_\" + attrName);\n  });\n  return {\n    builder: builder,\n    attributes: vertContext.attributes.map(function (attributeName) {\n      return {\n        name: attributeName,\n        callback: function (feature, props) {\n          var value = props[attributeName];\n          if (typeof value === 'string') {\n            value = getStringNumberEquivalent(vertContext, value);\n          }\n          return value !== undefined ? value : -9999999; // to avoid matching with the first string literal\n        }\n      };\n    }),\n\n    uniforms: uniforms\n  };\n}","map":{"version":3,"names":["ValueTypes","expressionToGlsl","getStringNumberEquivalent","ShaderBuilder","uniforms","attributes","varyings","sizeExpression","rotationExpression","offsetExpression","colorExpression","texCoordExpression","discardExpression","rotateWithView","prototype","addUniform","name","push","addAttribute","addVarying","type","expression","setSizeExpression","setRotationExpression","setSymbolOffsetExpression","setColorExpression","setTextureCoordinateExpression","setFragmentDiscardExpression","setSymbolRotateWithView","getSizeExpression","getOffsetExpression","getColorExpression","getTextureCoordinateExpression","getFragmentDiscardExpression","getSymbolVertexShader","forHitDetection","offsetMatrix","concat","map","uniform","join","attribute","varying","getSymbolFragmentShader","hitDetectionBypass","parseLiteralStyle","style","symbStyle","symbol","size","undefined","color","texCoord","textureCoord","offset","opacity","rotation","vertContext","inFragmentShader","variables","stringLiteralsMap","parsedSize","NUMBER_ARRAY","NUMBER","parsedOffset","parsedTexCoord","parsedRotation","fragContext","parsedColor","COLOR","parsedOpacity","opacityFilter","visibleSize","symbolType","st","a","Error","builder","filter","parsedFilter","BOOLEAN","forEach","varName","value","src","texture","Image","attrName","indexOf","attributeName","callback","feature","props"],"sources":["/Users/mariovicky/Skripsi_OpenLayers/node_modules/ol/src/webgl/ShaderBuilder.js"],"sourcesContent":["/**\n * Classes and utilities for generating shaders from literal style objects\n * @module ol/webgl/ShaderBuilder\n */\n\nimport {\n  ValueTypes,\n  expressionToGlsl,\n  getStringNumberEquivalent,\n} from '../style/expressions.js';\n\n/**\n * @typedef {Object} VaryingDescription\n * @property {string} name Varying name, as will be declared in the header.\n * @property {string} type Varying type, either `float`, `vec2`, `vec4`...\n * @property {string} expression Expression which will be assigned to the varying in the vertex shader, and\n * passed on to the fragment shader.\n */\n\n/**\n * @classdesc\n * This class implements a classic builder pattern for generating many different types of shaders.\n * Methods can be chained, e. g.:\n *\n * ```js\n * const shader = new ShaderBuilder()\n *   .addVarying('v_width', 'float', 'a_width')\n *   .addUniform('u_time')\n *   .setColorExpression('...')\n *   .setSizeExpression('...')\n *   .outputSymbolFragmentShader();\n * ```\n */\nexport class ShaderBuilder {\n  constructor() {\n    /**\n     * Uniforms; these will be declared in the header (should include the type).\n     * @type {Array<string>}\n     * @private\n     */\n    this.uniforms = [];\n\n    /**\n     * Attributes; these will be declared in the header (should include the type).\n     * @type {Array<string>}\n     * @private\n     */\n    this.attributes = [];\n\n    /**\n     * Varyings with a name, a type and an expression.\n     * @type {Array<VaryingDescription>}\n     * @private\n     */\n    this.varyings = [];\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.sizeExpression = 'vec2(1.0)';\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.rotationExpression = '0.0';\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.offsetExpression = 'vec2(0.0)';\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.colorExpression = 'vec4(1.0)';\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.texCoordExpression = 'vec4(0.0, 0.0, 1.0, 1.0)';\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.discardExpression = 'false';\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.rotateWithView = false;\n  }\n\n  /**\n   * Adds a uniform accessible in both fragment and vertex shaders.\n   * The given name should include a type, such as `sampler2D u_texture`.\n   * @param {string} name Uniform name\n   * @return {ShaderBuilder} the builder object\n   */\n  addUniform(name) {\n    this.uniforms.push(name);\n    return this;\n  }\n\n  /**\n   * Adds an attribute accessible in the vertex shader, read from the geometry buffer.\n   * The given name should include a type, such as `vec2 a_position`.\n   * @param {string} name Attribute name\n   * @return {ShaderBuilder} the builder object\n   */\n  addAttribute(name) {\n    this.attributes.push(name);\n    return this;\n  }\n\n  /**\n   * Adds a varying defined in the vertex shader and accessible from the fragment shader.\n   * The type and expression of the varying have to be specified separately.\n   * @param {string} name Varying name\n   * @param {'float'|'vec2'|'vec3'|'vec4'} type Type\n   * @param {string} expression Expression used to assign a value to the varying.\n   * @return {ShaderBuilder} the builder object\n   */\n  addVarying(name, type, expression) {\n    this.varyings.push({\n      name: name,\n      type: type,\n      expression: expression,\n    });\n    return this;\n  }\n\n  /**\n   * Sets an expression to compute the size of the shape.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `vec2` value.\n   * @param {string} expression Size expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setSizeExpression(expression) {\n    this.sizeExpression = expression;\n    return this;\n  }\n\n  /**\n   * Sets an expression to compute the rotation of the shape.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `float` value in radians.\n   * @param {string} expression Size expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setRotationExpression(expression) {\n    this.rotationExpression = expression;\n    return this;\n  }\n\n  /**\n   * Sets an expression to compute the offset of the symbol from the point center.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `vec2` value.\n   * Note: will only be used for point geometry shaders.\n   * @param {string} expression Offset expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setSymbolOffsetExpression(expression) {\n    this.offsetExpression = expression;\n    return this;\n  }\n\n  /**\n   * Sets an expression to compute the color of the shape.\n   * This expression can use all the uniforms, varyings and attributes available\n   * in the fragment shader, and should evaluate to a `vec4` value.\n   * @param {string} expression Color expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setColorExpression(expression) {\n    this.colorExpression = expression;\n    return this;\n  }\n\n  /**\n   * Sets an expression to compute the texture coordinates of the vertices.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `vec4` value.\n   * @param {string} expression Texture coordinate expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setTextureCoordinateExpression(expression) {\n    this.texCoordExpression = expression;\n    return this;\n  }\n\n  /**\n   * Sets an expression to determine whether a fragment (pixel) should be discarded,\n   * i.e. not drawn at all.\n   * This expression can use all the uniforms, varyings and attributes available\n   * in the fragment shader, and should evaluate to a `bool` value (it will be\n   * used in an `if` statement)\n   * @param {string} expression Fragment discard expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setFragmentDiscardExpression(expression) {\n    this.discardExpression = expression;\n    return this;\n  }\n\n  /**\n   * Sets whether the symbols should rotate with the view or stay aligned with the map.\n   * Note: will only be used for point geometry shaders.\n   * @param {boolean} rotateWithView Rotate with view\n   * @return {ShaderBuilder} the builder object\n   */\n  setSymbolRotateWithView(rotateWithView) {\n    this.rotateWithView = rotateWithView;\n    return this;\n  }\n\n  /**\n   * @returns {string} Previously set size expression\n   */\n  getSizeExpression() {\n    return this.sizeExpression;\n  }\n\n  /**\n   * @returns {string} Previously set symbol offset expression\n   */\n  getOffsetExpression() {\n    return this.offsetExpression;\n  }\n\n  /**\n   * @returns {string} Previously set color expression\n   */\n  getColorExpression() {\n    return this.colorExpression;\n  }\n\n  /**\n   * @returns {string} Previously set texture coordinate expression\n   */\n  getTextureCoordinateExpression() {\n    return this.texCoordExpression;\n  }\n\n  /**\n   * @returns {string} Previously set fragment discard expression\n   */\n  getFragmentDiscardExpression() {\n    return this.discardExpression;\n  }\n\n  /**\n   * Generates a symbol vertex shader from the builder parameters,\n   * intended to be used on point geometries.\n   *\n   * Three uniforms are hardcoded in all shaders: `u_projectionMatrix`, `u_offsetScaleMatrix`,\n   * `u_offsetRotateMatrix`, `u_time`.\n   *\n   * The following attributes are hardcoded and expected to be present in the vertex buffers:\n   * `vec2 a_position`, `float a_index` (being the index of the vertex in the quad, 0 to 3).\n   *\n   * The following varyings are hardcoded and gives the coordinate of the pixel both in the quad and on the texture:\n   * `vec2 v_quadCoord`, `vec2 v_texCoord`\n   *\n   * @param {boolean} [forHitDetection] If true, the shader will be modified to include hit detection variables\n   * (namely, hit color with encoded feature id).\n   * @returns {string} The full shader as a string.\n   */\n  getSymbolVertexShader(forHitDetection) {\n    const offsetMatrix = this.rotateWithView\n      ? 'u_offsetScaleMatrix * u_offsetRotateMatrix'\n      : 'u_offsetScaleMatrix';\n\n    let attributes = this.attributes;\n    let varyings = this.varyings;\n\n    if (forHitDetection) {\n      attributes = attributes.concat('vec4 a_hitColor');\n      varyings = varyings.concat({\n        name: 'v_hitColor',\n        type: 'vec4',\n        expression: 'a_hitColor',\n      });\n    }\n\n    return `precision mediump float;\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_offsetScaleMatrix;\nuniform mat4 u_offsetRotateMatrix;\nuniform float u_time;\nuniform float u_zoom;\nuniform float u_resolution;\n${this.uniforms\n  .map(function (uniform) {\n    return 'uniform ' + uniform + ';';\n  })\n  .join('\\n')}\nattribute vec2 a_position;\nattribute float a_index;\n${attributes\n  .map(function (attribute) {\n    return 'attribute ' + attribute + ';';\n  })\n  .join('\\n')}\nvarying vec2 v_texCoord;\nvarying vec2 v_quadCoord;\n${varyings\n  .map(function (varying) {\n    return 'varying ' + varying.type + ' ' + varying.name + ';';\n  })\n  .join('\\n')}\nvoid main(void) {\n  mat4 offsetMatrix = ${offsetMatrix};\n  vec2 halfSize = ${this.sizeExpression} * 0.5;\n  vec2 offset = ${this.offsetExpression};\n  float angle = ${this.rotationExpression};\n  float offsetX;\n  float offsetY;\n  if (a_index == 0.0) {\n    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);\n    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);\n  } else if (a_index == 1.0) {\n    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);\n    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);\n  } else if (a_index == 2.0) {\n    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);\n    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);\n  } else {\n    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);\n    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);\n  }\n  vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\n  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n  vec4 texCoord = ${this.texCoordExpression};\n  float u = a_index == 0.0 || a_index == 3.0 ? texCoord.s : texCoord.p;\n  float v = a_index == 2.0 || a_index == 3.0 ? texCoord.t : texCoord.q;\n  v_texCoord = vec2(u, v);\n  u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\n  v = a_index == 2.0 || a_index == 3.0 ? 0.0 : 1.0;\n  v_quadCoord = vec2(u, v);\n${varyings\n  .map(function (varying) {\n    return '  ' + varying.name + ' = ' + varying.expression + ';';\n  })\n  .join('\\n')}\n}`;\n  }\n\n  /**\n   * Generates a symbol fragment shader from the builder parameters,\n   * intended to be used on point geometries.\n   *\n   * Expects the following varyings to be transmitted by the vertex shader:\n   * `vec2 v_quadCoord`, `vec2 v_texCoord`\n   *\n   * @param {boolean} [forHitDetection] If true, the shader will be modified to include hit detection variables\n   * (namely, hit color with encoded feature id).\n   * @returns {string} The full shader as a string.\n   */\n  getSymbolFragmentShader(forHitDetection) {\n    const hitDetectionBypass = forHitDetection\n      ? '  if (gl_FragColor.a < 0.1) { discard; } gl_FragColor = v_hitColor;'\n      : '';\n\n    let varyings = this.varyings;\n\n    if (forHitDetection) {\n      varyings = varyings.concat({\n        name: 'v_hitColor',\n        type: 'vec4',\n        expression: 'a_hitColor',\n      });\n    }\n\n    return `precision mediump float;\nuniform float u_time;\nuniform float u_zoom;\nuniform float u_resolution;\n${this.uniforms\n  .map(function (uniform) {\n    return 'uniform ' + uniform + ';';\n  })\n  .join('\\n')}\nvarying vec2 v_texCoord;\nvarying vec2 v_quadCoord;\n${varyings\n  .map(function (varying) {\n    return 'varying ' + varying.type + ' ' + varying.name + ';';\n  })\n  .join('\\n')}\nvoid main(void) {\n  if (${this.discardExpression}) { discard; }\n  gl_FragColor = ${this.colorExpression};\n  gl_FragColor.rgb *= gl_FragColor.a;\n${hitDetectionBypass}\n}`;\n  }\n}\n\n/**\n * @typedef {Object} StyleParseResult\n * @property {ShaderBuilder} builder Shader builder pre-configured according to a given style\n * @property {Object.<string,import(\"./Helper\").UniformValue>} uniforms Uniform definitions.\n * @property {Array<import(\"../renderer/webgl/PointsLayer\").CustomAttribute>} attributes Attribute descriptions.\n */\n\n/**\n * Parses a {@link import(\"../style/LiteralStyle\").LiteralStyle} object and returns a {@link ShaderBuilder}\n * object that has been configured according to the given style, as well as `attributes` and `uniforms`\n * arrays to be fed to the `WebGLPointsRenderer` class.\n *\n * Also returns `uniforms` and `attributes` properties as expected by the\n * {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.\n *\n * @param {import(\"../style/LiteralStyle\").LiteralStyle} style Literal style.\n * @returns {StyleParseResult} Result containing shader params, attributes and uniforms.\n */\nexport function parseLiteralStyle(style) {\n  const symbStyle = style.symbol;\n  const size = symbStyle.size !== undefined ? symbStyle.size : 1;\n  const color = symbStyle.color || 'white';\n  const texCoord = symbStyle.textureCoord || [0, 0, 1, 1];\n  const offset = symbStyle.offset || [0, 0];\n  const opacity = symbStyle.opacity !== undefined ? symbStyle.opacity : 1;\n  const rotation = symbStyle.rotation !== undefined ? symbStyle.rotation : 0;\n\n  /**\n   * @type {import(\"../style/expressions.js\").ParsingContext}\n   */\n  const vertContext = {\n    inFragmentShader: false,\n    variables: [],\n    attributes: [],\n    stringLiteralsMap: {},\n  };\n  const parsedSize = expressionToGlsl(\n    vertContext,\n    size,\n    ValueTypes.NUMBER_ARRAY | ValueTypes.NUMBER\n  );\n  const parsedOffset = expressionToGlsl(\n    vertContext,\n    offset,\n    ValueTypes.NUMBER_ARRAY\n  );\n  const parsedTexCoord = expressionToGlsl(\n    vertContext,\n    texCoord,\n    ValueTypes.NUMBER_ARRAY\n  );\n  const parsedRotation = expressionToGlsl(\n    vertContext,\n    rotation,\n    ValueTypes.NUMBER\n  );\n\n  /**\n   * @type {import(\"../style/expressions.js\").ParsingContext}\n   */\n  const fragContext = {\n    inFragmentShader: true,\n    variables: vertContext.variables,\n    attributes: [],\n    stringLiteralsMap: vertContext.stringLiteralsMap,\n  };\n  const parsedColor = expressionToGlsl(fragContext, color, ValueTypes.COLOR);\n  const parsedOpacity = expressionToGlsl(\n    fragContext,\n    opacity,\n    ValueTypes.NUMBER\n  );\n\n  let opacityFilter = '1.0';\n  const visibleSize = `vec2(${expressionToGlsl(\n    fragContext,\n    size,\n    ValueTypes.NUMBER_ARRAY | ValueTypes.NUMBER\n  )}).x`;\n  switch (symbStyle.symbolType) {\n    case 'square':\n      break;\n    case 'image':\n      break;\n    // taken from https://thebookofshaders.com/07/\n    case 'circle':\n      opacityFilter = `(1.0-smoothstep(1.-4./${visibleSize},1.,dot(v_quadCoord-.5,v_quadCoord-.5)*4.))`;\n      break;\n    case 'triangle':\n      const st = '(v_quadCoord*2.-1.)';\n      const a = `(atan(${st}.x,${st}.y))`;\n      opacityFilter = `(1.0-smoothstep(.5-3./${visibleSize},.5,cos(floor(.5+${a}/2.094395102)*2.094395102-${a})*length(${st})))`;\n      break;\n\n    default:\n      throw new Error('Unexpected symbol type: ' + symbStyle.symbolType);\n  }\n\n  const builder = new ShaderBuilder()\n    .setSizeExpression(`vec2(${parsedSize})`)\n    .setRotationExpression(parsedRotation)\n    .setSymbolOffsetExpression(parsedOffset)\n    .setTextureCoordinateExpression(parsedTexCoord)\n    .setSymbolRotateWithView(!!symbStyle.rotateWithView)\n    .setColorExpression(\n      `vec4(${parsedColor}.rgb, ${parsedColor}.a * ${parsedOpacity} * ${opacityFilter})`\n    );\n\n  if (style.filter) {\n    const parsedFilter = expressionToGlsl(\n      fragContext,\n      style.filter,\n      ValueTypes.BOOLEAN\n    );\n    builder.setFragmentDiscardExpression(`!${parsedFilter}`);\n  }\n\n  /** @type {Object.<string,import(\"../webgl/Helper\").UniformValue>} */\n  const uniforms = {};\n\n  // define one uniform per variable\n  fragContext.variables.forEach(function (varName) {\n    builder.addUniform(`float u_${varName}`);\n    uniforms[`u_${varName}`] = function () {\n      if (!style.variables || style.variables[varName] === undefined) {\n        throw new Error(\n          `The following variable is missing from the style: ${varName}`\n        );\n      }\n      let value = style.variables[varName];\n      if (typeof value === 'string') {\n        value = getStringNumberEquivalent(vertContext, value);\n      }\n      return value !== undefined ? value : -9999999; // to avoid matching with the first string literal\n    };\n  });\n\n  if (symbStyle.symbolType === 'image' && symbStyle.src) {\n    const texture = new Image();\n    texture.src = symbStyle.src;\n    builder\n      .addUniform('sampler2D u_texture')\n      .setColorExpression(\n        builder.getColorExpression() + ' * texture2D(u_texture, v_texCoord)'\n      );\n    uniforms['u_texture'] = texture;\n  }\n\n  // for each feature attribute used in the fragment shader, define a varying that will be used to pass data\n  // from the vertex to the fragment shader, as well as an attribute in the vertex shader (if not already present)\n  fragContext.attributes.forEach(function (attrName) {\n    if (vertContext.attributes.indexOf(attrName) === -1) {\n      vertContext.attributes.push(attrName);\n    }\n    builder.addVarying(`v_${attrName}`, 'float', `a_${attrName}`);\n  });\n\n  // for each feature attribute used in the vertex shader, define an attribute in the vertex shader.\n  vertContext.attributes.forEach(function (attrName) {\n    builder.addAttribute(`float a_${attrName}`);\n  });\n\n  return {\n    builder: builder,\n    attributes: vertContext.attributes.map(function (attributeName) {\n      return {\n        name: attributeName,\n        callback: function (feature, props) {\n          let value = props[attributeName];\n          if (typeof value === 'string') {\n            value = getStringNumberEquivalent(vertContext, value);\n          }\n          return value !== undefined ? value : -9999999; // to avoid matching with the first string literal\n        },\n      };\n    }),\n    uniforms: uniforms,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
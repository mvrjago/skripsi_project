{"ast":null,"code":"import Feature from 'ol/Feature.js';\nimport LineString from 'ol/geom/LineString.js';\nimport Map from 'ol/Map.js';\nimport Stamen from 'ol/source/Stamen.js';\nimport VectorSource from 'ol/source/Vector.js';\nimport View from 'ol/View.js';\nimport { Stroke, Style } from 'ol/style.js';\nimport { Tile as TileLayer, Vector as VectorLayer } from 'ol/layer.js';\nimport { getVectorContext } from 'ol/render.js';\nimport { getWidth } from 'ol/extent.js';\nimport arc from 'arc';\nconst tileLayer = new TileLayer({\n  source: new Stamen({\n    layer: 'toner'\n  })\n});\nconst map = new Map({\n  layers: [tileLayer],\n  target: 'map',\n  view: new View({\n    center: [-11000000, 4600000],\n    zoom: 2\n  })\n});\nconst style = new Style({\n  stroke: new Stroke({\n    color: '#EAE911',\n    width: 2\n  })\n});\nconst flightsSource = new VectorSource({\n  attributions: 'Flight data by ' + '<a href=\"https://openflights.org/data.html\">OpenFlights</a>,',\n  loader: function () {\n    const url = 'data/openflights/flights.json';\n    fetch(url).then(function (response) {\n      return response.json();\n    }).then(function (json) {\n      const flightsData = json.flights;\n      for (let i = 0; i < flightsData.length; i++) {\n        const flight = flightsData[i];\n        const from = flight[0];\n        const to = flight[1];\n\n        // create an arc circle between the two locations\n        const arcGenerator = new arc.GreatCircle({\n          x: from[1],\n          y: from[0]\n        }, {\n          x: to[1],\n          y: to[0]\n        });\n        const arcLine = arcGenerator.Arc(100, {\n          offset: 10\n        });\n        // paths which cross the -180째/+180째 meridian are split\n        // into two sections which will be animated sequentially\n        const features = [];\n        arcLine.geometries.forEach(function (geometry) {\n          const line = new LineString(geometry.coords);\n          line.transform('EPSG:4326', 'EPSG:3857');\n          features.push(new Feature({\n            geometry: line,\n            finished: false\n          }));\n        });\n        // add the features with a delay so that the animation\n        // for all features does not start at the same time\n        addLater(features, i * 50);\n      }\n      tileLayer.on('postrender', animateFlights);\n    });\n  }\n});\nconst flightsLayer = new VectorLayer({\n  source: flightsSource,\n  style: function (feature) {\n    // if the animation is still active for a feature, do not\n    // render the feature with the layer style\n    if (feature.get('finished')) {\n      return style;\n    }\n    return null;\n  }\n});\nmap.addLayer(flightsLayer);\nconst pointsPerMs = 0.02;\nfunction animateFlights(event) {\n  const vectorContext = getVectorContext(event);\n  const frameState = event.frameState;\n  vectorContext.setStyle(style);\n  const features = flightsSource.getFeatures();\n  for (let i = 0; i < features.length; i++) {\n    const feature = features[i];\n    if (!feature.get('finished')) {\n      // only draw the lines for which the animation has not finished yet\n      const coords = feature.getGeometry().getCoordinates();\n      const elapsedTime = frameState.time - feature.get('start');\n      if (elapsedTime >= 0) {\n        const elapsedPoints = elapsedTime * pointsPerMs;\n        if (elapsedPoints >= coords.length) {\n          feature.set('finished', true);\n        }\n        const maxIndex = Math.min(elapsedPoints, coords.length);\n        const currentLine = new LineString(coords.slice(0, maxIndex));\n\n        // animation is needed in the current and nearest adjacent wrapped world\n        const worldWidth = getWidth(map.getView().getProjection().getExtent());\n        const offset = Math.floor(map.getView().getCenter()[0] / worldWidth);\n\n        // directly draw the lines with the vector context\n        currentLine.translate(offset * worldWidth, 0);\n        vectorContext.drawGeometry(currentLine);\n        currentLine.translate(worldWidth, 0);\n        vectorContext.drawGeometry(currentLine);\n      }\n    }\n  }\n  // tell OpenLayers to continue the animation\n  map.render();\n}\nfunction addLater(features, timeout) {\n  window.setTimeout(function () {\n    let start = Date.now();\n    features.forEach(function (feature) {\n      feature.set('start', start);\n      flightsSource.addFeature(feature);\n      const duration = (feature.getGeometry().getCoordinates().length - 1) / pointsPerMs;\n      start += duration;\n    });\n  }, timeout);\n}","map":{"version":3,"names":["Feature","LineString","Map","Stamen","VectorSource","View","Stroke","Style","Tile","TileLayer","Vector","VectorLayer","getVectorContext","getWidth","arc","tileLayer","source","layer","map","layers","target","view","center","zoom","style","stroke","color","width","flightsSource","attributions","loader","url","fetch","then","response","json","flightsData","flights","i","length","flight","from","to","arcGenerator","GreatCircle","x","y","arcLine","Arc","offset","features","geometries","forEach","geometry","line","coords","transform","push","finished","addLater","on","animateFlights","flightsLayer","feature","get","addLayer","pointsPerMs","event","vectorContext","frameState","setStyle","getFeatures","getGeometry","getCoordinates","elapsedTime","time","elapsedPoints","set","maxIndex","Math","min","currentLine","slice","worldWidth","getView","getProjection","getExtent","floor","getCenter","translate","drawGeometry","render","timeout","window","setTimeout","start","Date","now","addFeature","duration"],"sources":["/Users/mariovicky/Skripsi_OpenLayers/src/containers/Map/Map.js"],"sourcesContent":["import Feature from 'ol/Feature.js';\nimport LineString from 'ol/geom/LineString.js';\nimport Map from 'ol/Map.js';\nimport Stamen from 'ol/source/Stamen.js';\nimport VectorSource from 'ol/source/Vector.js';\nimport View from 'ol/View.js';\nimport { Stroke, Style } from 'ol/style.js';\nimport { Tile as TileLayer, Vector as VectorLayer } from 'ol/layer.js';\nimport { getVectorContext } from 'ol/render.js';\nimport { getWidth } from 'ol/extent.js';\nimport arc from 'arc';\n\nconst tileLayer = new TileLayer({\n  source: new Stamen({\n    layer: 'toner',\n  }),\n});\n\nconst map = new Map({\n  layers: [tileLayer],\n  target: 'map',\n  view: new View({\n    center: [-11000000, 4600000],\n    zoom: 2,\n  }),\n});\n\nconst style = new Style({\n  stroke: new Stroke({\n    color: '#EAE911',\n    width: 2,\n  }),\n});\n\nconst flightsSource = new VectorSource({\n  attributions:\n    'Flight data by ' +\n    '<a href=\"https://openflights.org/data.html\">OpenFlights</a>,',\n  loader: function () {\n    const url = 'data/openflights/flights.json';\n    fetch(url)\n      .then(function (response) {\n        return response.json();\n      })\n      .then(function (json) {\n        const flightsData = json.flights;\n        for (let i = 0; i < flightsData.length; i++) {\n          const flight = flightsData[i];\n          const from = flight[0];\n          const to = flight[1];\n\n          // create an arc circle between the two locations\n          const arcGenerator = new arc.GreatCircle(\n            { x: from[1], y: from[0] },\n            { x: to[1], y: to[0] }\n          );\n\n          const arcLine = arcGenerator.Arc(100, { offset: 10 });\n          // paths which cross the -180째/+180째 meridian are split\n          // into two sections which will be animated sequentially\n          const features = [];\n          arcLine.geometries.forEach(function (geometry) {\n            const line = new LineString(geometry.coords);\n            line.transform('EPSG:4326', 'EPSG:3857');\n\n            features.push(\n              new Feature({\n                geometry: line,\n                finished: false,\n              })\n            );\n          });\n          // add the features with a delay so that the animation\n          // for all features does not start at the same time\n          addLater(features, i * 50);\n        }\n        tileLayer.on('postrender', animateFlights);\n      });\n  },\n});\n\nconst flightsLayer = new VectorLayer({\n  source: flightsSource,\n  style: function (feature) {\n    // if the animation is still active for a feature, do not\n    // render the feature with the layer style\n    if (feature.get('finished')) {\n      return style;\n    }\n    return null;\n  },\n});\n\nmap.addLayer(flightsLayer);\n\nconst pointsPerMs = 0.02;\nfunction animateFlights(event) {\n  const vectorContext = getVectorContext(event);\n  const frameState = event.frameState;\n  vectorContext.setStyle(style);\n\n  const features = flightsSource.getFeatures();\n  for (let i = 0; i < features.length; i++) {\n    const feature = features[i];\n    if (!feature.get('finished')) {\n      // only draw the lines for which the animation has not finished yet\n      const coords = feature.getGeometry().getCoordinates();\n      const elapsedTime = frameState.time - feature.get('start');\n      if (elapsedTime >= 0) {\n        const elapsedPoints = elapsedTime * pointsPerMs;\n\n        if (elapsedPoints >= coords.length) {\n          feature.set('finished', true);\n        }\n\n        const maxIndex = Math.min(elapsedPoints, coords.length);\n        const currentLine = new LineString(coords.slice(0, maxIndex));\n\n        // animation is needed in the current and nearest adjacent wrapped world\n        const worldWidth = getWidth(map.getView().getProjection().getExtent());\n        const offset = Math.floor(map.getView().getCenter()[0] / worldWidth);\n\n        // directly draw the lines with the vector context\n        currentLine.translate(offset * worldWidth, 0);\n        vectorContext.drawGeometry(currentLine);\n        currentLine.translate(worldWidth, 0);\n        vectorContext.drawGeometry(currentLine);\n      }\n    }\n  }\n  // tell OpenLayers to continue the animation\n  map.render();\n}\n\nfunction addLater(features, timeout) {\n  window.setTimeout(function () {\n    let start = Date.now();\n    features.forEach(function (feature) {\n      feature.set('start', start);\n      flightsSource.addFeature(feature);\n      const duration =\n        (feature.getGeometry().getCoordinates().length - 1) / pointsPerMs;\n      start += duration;\n    });\n  }, timeout);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"/**\n * @module ol/render/canvas/Executor\n */\nimport CanvasInstruction from './Instruction.js';\nimport RBush from 'rbush/rbush.js';\nimport { TEXT_ALIGN } from './TextBuilder.js';\nimport { WORKER_OFFSCREEN_CANVAS } from '../../has.js';\nimport { apply as applyTransform, compose as composeTransform, create as createTransform, setFromArray as transformSetFromArray } from '../../transform.js';\nimport { createEmpty, createOrUpdate, getHeight, getWidth, intersects } from '../../extent.js';\nimport { defaultPadding, defaultTextBaseline, drawImageOrLabel } from '../canvas.js';\nimport { defaultTextAlign, measureAndCacheTextWidth, measureTextHeight, measureTextWidths } from '../canvas.js';\nimport { drawTextOnPath } from '../../geom/flat/textpath.js';\nimport { equals } from '../../array.js';\nimport { lineStringLength } from '../../geom/flat/length.js';\nimport { transform2D } from '../../geom/flat/transform.js';\n/**\n * @typedef {Object} SerializableInstructions\n * @property {Array<*>} instructions The rendering instructions.\n * @property {Array<*>} hitDetectionInstructions The rendering hit detection instructions.\n * @property {Array<number>} coordinates The array of all coordinates.\n * @property {!Object<string, import(\"../canvas.js\").TextState>} textStates The text states (decluttering).\n * @property {!Object<string, import(\"../canvas.js\").FillState>} fillStates The fill states (decluttering).\n * @property {!Object<string, import(\"../canvas.js\").StrokeState>} strokeStates The stroke states (decluttering).\n */\n/**\n * @type {import(\"../../extent.js\").Extent}\n */\nvar tmpExtent = createEmpty();\n/**\n * @type {!import(\"../../transform.js\").Transform}\n */\nvar tmpTransform = createTransform();\n/** @type {import(\"../../coordinate.js\").Coordinate} */\nvar p1 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\nvar p2 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\nvar p3 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\nvar p4 = [];\nvar Executor = /** @class */function () {\n  /**\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {boolean} overlaps The replay can have overlapping geometries.\n   * @param {SerializableInstructions} instructions The serializable instructions\n   * @param {import(\"../../size.js\").Size} renderBuffer Render buffer (width/height) in pixels.\n   */\n  function Executor(resolution, pixelRatio, overlaps, instructions, renderBuffer) {\n    /**\n     * @protected\n     * @type {boolean}\n     */\n    this.overlaps = overlaps;\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.pixelRatio = pixelRatio;\n    /**\n     * @protected\n     * @const\n     * @type {number}\n     */\n    this.resolution = resolution;\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.alignFill_;\n    /**\n     * @type {Array<*>}\n     */\n    this.declutterItems = [];\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n    this.instructions = instructions.instructions;\n    /**\n     * @protected\n     * @type {Array<number>}\n     */\n    this.coordinates = instructions.coordinates;\n    /**\n     * @private\n     * @type {!Object<number,import(\"../../coordinate.js\").Coordinate|Array<import(\"../../coordinate.js\").Coordinate>|Array<Array<import(\"../../coordinate.js\").Coordinate>>>}\n     */\n    this.coordinateCache_ = {};\n    /**\n     * @private\n     * @type {import(\"../../size.js\").Size}\n     */\n    this.renderBuffer_ = renderBuffer;\n    /**\n     * @private\n     * @type {!import(\"../../transform.js\").Transform}\n     */\n    this.renderedTransform_ = createTransform();\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n    this.hitDetectionInstructions = instructions.hitDetectionInstructions;\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.pixelCoordinates_ = null;\n    /**\n     * @private\n     * @type {number}\n     */\n    this.viewRotation_ = 0;\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").FillState>}\n     */\n    this.fillStates = instructions.fillStates || {};\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").StrokeState>}\n     */\n    this.strokeStates = instructions.strokeStates || {};\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").TextState>}\n     */\n    this.textStates = instructions.textStates || {};\n    /**\n     * @private\n     * @type {Object<string, Object<string, number>>}\n     */\n    this.widths_ = {};\n    /**\n     * @private\n     * @type {Object<string, import(\"../canvas.js\").Label>}\n     */\n    this.labels_ = {};\n  }\n  /**\n   * @param {string} text Text.\n   * @param {string} textKey Text style key.\n   * @param {string} fillKey Fill style key.\n   * @param {string} strokeKey Stroke style key.\n   * @return {import(\"../canvas.js\").Label} Label.\n   */\n  Executor.prototype.createLabel = function (text, textKey, fillKey, strokeKey) {\n    var key = text + textKey + fillKey + strokeKey;\n    if (this.labels_[key]) {\n      return this.labels_[key];\n    }\n    var strokeState = strokeKey ? this.strokeStates[strokeKey] : null;\n    var fillState = fillKey ? this.fillStates[fillKey] : null;\n    var textState = this.textStates[textKey];\n    var pixelRatio = this.pixelRatio;\n    var scale = [textState.scale[0] * pixelRatio, textState.scale[1] * pixelRatio];\n    var align = TEXT_ALIGN[textState.textAlign || defaultTextAlign];\n    var strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;\n    var lines = text.split('\\n');\n    var numLines = lines.length;\n    var widths = [];\n    var width = measureTextWidths(textState.font, lines, widths);\n    var lineHeight = measureTextHeight(textState.font);\n    var height = lineHeight * numLines;\n    var renderWidth = width + strokeWidth;\n    var contextInstructions = [];\n    // make canvas 2 pixels wider to account for italic text width measurement errors\n    var w = (renderWidth + 2) * scale[0];\n    var h = (height + strokeWidth) * scale[1];\n    /** @type {import(\"../canvas.js\").Label} */\n    var label = {\n      width: w < 0 ? Math.floor(w) : Math.ceil(w),\n      height: h < 0 ? Math.floor(h) : Math.ceil(h),\n      contextInstructions: contextInstructions\n    };\n    if (scale[0] != 1 || scale[1] != 1) {\n      contextInstructions.push('scale', scale);\n    }\n    contextInstructions.push('font', textState.font);\n    if (strokeKey) {\n      contextInstructions.push('strokeStyle', strokeState.strokeStyle);\n      contextInstructions.push('lineWidth', strokeWidth);\n      contextInstructions.push('lineCap', strokeState.lineCap);\n      contextInstructions.push('lineJoin', strokeState.lineJoin);\n      contextInstructions.push('miterLimit', strokeState.miterLimit);\n      // eslint-disable-next-line\n      var Context = WORKER_OFFSCREEN_CANVAS ? OffscreenCanvasRenderingContext2D : CanvasRenderingContext2D;\n      if (Context.prototype.setLineDash) {\n        contextInstructions.push('setLineDash', [strokeState.lineDash]);\n        contextInstructions.push('lineDashOffset', strokeState.lineDashOffset);\n      }\n    }\n    if (fillKey) {\n      contextInstructions.push('fillStyle', fillState.fillStyle);\n    }\n    contextInstructions.push('textBaseline', 'middle');\n    contextInstructions.push('textAlign', 'center');\n    var leftRight = 0.5 - align;\n    var x = align * renderWidth + leftRight * strokeWidth;\n    var i;\n    if (strokeKey) {\n      for (i = 0; i < numLines; ++i) {\n        contextInstructions.push('strokeText', [lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight]);\n      }\n    }\n    if (fillKey) {\n      for (i = 0; i < numLines; ++i) {\n        contextInstructions.push('fillText', [lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight]);\n      }\n    }\n    this.labels_[key] = label;\n    return label;\n  };\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../coordinate.js\").Coordinate} p1 1st point of the background box.\n   * @param {import(\"../../coordinate.js\").Coordinate} p2 2nd point of the background box.\n   * @param {import(\"../../coordinate.js\").Coordinate} p3 3rd point of the background box.\n   * @param {import(\"../../coordinate.js\").Coordinate} p4 4th point of the background box.\n   * @param {Array<*>} fillInstruction Fill instruction.\n   * @param {Array<*>} strokeInstruction Stroke instruction.\n   * @param {boolean} declutter Declutter.\n   */\n  Executor.prototype.replayTextBackground_ = function (context, p1, p2, p3, p4, fillInstruction, strokeInstruction, declutter) {\n    context.beginPath();\n    context.moveTo.apply(context, p1);\n    context.lineTo.apply(context, p2);\n    context.lineTo.apply(context, p3);\n    context.lineTo.apply(context, p4);\n    context.lineTo.apply(context, p1);\n    if (fillInstruction) {\n      this.alignFill_ = /** @type {boolean} */fillInstruction[2];\n      if (declutter) {\n        context.fillStyle = /** @type {import(\"../../colorlike.js\").ColorLike} */fillInstruction[1];\n      }\n      this.fill_(context);\n    }\n    if (strokeInstruction) {\n      this.setStrokeStyle_(context, /** @type {Array<*>} */strokeInstruction);\n      context.stroke();\n    }\n  };\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} contextScale Scale of the context.\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../canvas.js\").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.\n   * @param {number} anchorX Anchor X.\n   * @param {number} anchorY Anchor Y.\n   * @param {import(\"../canvas.js\").DeclutterGroup} declutterGroup Declutter group.\n   * @param {number} height Height.\n   * @param {number} opacity Opacity.\n   * @param {number} originX Origin X.\n   * @param {number} originY Origin Y.\n   * @param {number} rotation Rotation.\n   * @param {import(\"../../size.js\").Size} scale Scale.\n   * @param {boolean} snapToPixel Snap to pixel.\n   * @param {number} width Width.\n   * @param {Array<number>} padding Padding.\n   * @param {Array<*>} fillInstruction Fill instruction.\n   * @param {Array<*>} strokeInstruction Stroke instruction.\n   * @return {boolean} The image or label was rendered.\n   */\n  Executor.prototype.replayImageOrLabel_ = function (context, contextScale, x, y, imageOrLabel, anchorX, anchorY, declutterGroup, height, opacity, originX, originY, rotation, scale, snapToPixel, width, padding, fillInstruction, strokeInstruction) {\n    var fillStroke = fillInstruction || strokeInstruction;\n    anchorX *= scale[0];\n    anchorY *= scale[1];\n    x -= anchorX;\n    y -= anchorY;\n    var w = width + originX > imageOrLabel.width ? imageOrLabel.width - originX : width;\n    var h = height + originY > imageOrLabel.height ? imageOrLabel.height - originY : height;\n    var boxW = padding[3] + w * scale[0] + padding[1];\n    var boxH = padding[0] + h * scale[1] + padding[2];\n    var boxX = x - padding[3];\n    var boxY = y - padding[0];\n    if (fillStroke || rotation !== 0) {\n      p1[0] = boxX;\n      p4[0] = boxX;\n      p1[1] = boxY;\n      p2[1] = boxY;\n      p2[0] = boxX + boxW;\n      p3[0] = p2[0];\n      p3[1] = boxY + boxH;\n      p4[1] = p3[1];\n    }\n    var transform = null;\n    if (rotation !== 0) {\n      var centerX = x + anchorX;\n      var centerY = y + anchorY;\n      transform = composeTransform(tmpTransform, centerX, centerY, 1, 1, rotation, -centerX, -centerY);\n      applyTransform(tmpTransform, p1);\n      applyTransform(tmpTransform, p2);\n      applyTransform(tmpTransform, p3);\n      applyTransform(tmpTransform, p4);\n      createOrUpdate(Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1]), tmpExtent);\n    } else {\n      createOrUpdate(boxX, boxY, boxX + boxW, boxY + boxH, tmpExtent);\n    }\n    var renderBufferX = 0;\n    var renderBufferY = 0;\n    if (declutterGroup) {\n      var renderBuffer = this.renderBuffer_;\n      renderBuffer[0] = Math.max(renderBuffer[0], getWidth(tmpExtent));\n      renderBufferX = renderBuffer[0];\n      renderBuffer[1] = Math.max(renderBuffer[1], getHeight(tmpExtent));\n      renderBufferY = renderBuffer[1];\n    }\n    var canvas = context.canvas;\n    var strokePadding = strokeInstruction ? strokeInstruction[2] * scale[0] / 2 : 0;\n    var intersects = tmpExtent[0] - strokePadding <= (canvas.width + renderBufferX) / contextScale && tmpExtent[2] + strokePadding >= -renderBufferX / contextScale && tmpExtent[1] - strokePadding <= (canvas.height + renderBufferY) / contextScale && tmpExtent[3] + strokePadding >= -renderBufferY / contextScale;\n    if (snapToPixel) {\n      x = Math.round(x);\n      y = Math.round(y);\n    }\n    if (declutterGroup) {\n      if (!intersects && declutterGroup[0] == 1) {\n        return false;\n      }\n      var declutterArgs = intersects ? [context, transform ? transform.slice(0) : null, opacity, imageOrLabel, originX, originY, w, h, x, y, scale, tmpExtent.slice()] : null;\n      if (declutterArgs) {\n        if (fillStroke) {\n          declutterArgs.push(fillInstruction, strokeInstruction, p1.slice(0), p2.slice(0), p3.slice(0), p4.slice(0));\n        }\n        declutterGroup.push(declutterArgs);\n      }\n    } else if (intersects) {\n      if (fillStroke) {\n        this.replayTextBackground_(context, p1, p2, p3, p4, /** @type {Array<*>} */fillInstruction, /** @type {Array<*>} */strokeInstruction, false);\n      }\n      drawImageOrLabel(context, transform, opacity, imageOrLabel, originX, originY, w, h, x, y, scale);\n    }\n    return true;\n  };\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   */\n  Executor.prototype.fill_ = function (context) {\n    if (this.alignFill_) {\n      var origin_1 = applyTransform(this.renderedTransform_, [0, 0]);\n      var repeatSize = 512 * this.pixelRatio;\n      context.save();\n      context.translate(origin_1[0] % repeatSize, origin_1[1] % repeatSize);\n      context.rotate(this.viewRotation_);\n    }\n    context.fill();\n    if (this.alignFill_) {\n      context.restore();\n    }\n  };\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {Array<*>} instruction Instruction.\n   */\n  Executor.prototype.setStrokeStyle_ = function (context, instruction) {\n    context.strokeStyle = /** @type {import(\"../../colorlike.js\").ColorLike} */instruction[1];\n    context.lineWidth = /** @type {number} */instruction[2];\n    context.lineCap = /** @type {CanvasLineCap} */instruction[3];\n    context.lineJoin = /** @type {CanvasLineJoin} */instruction[4];\n    context.miterLimit = /** @type {number} */instruction[5];\n    if (context.setLineDash) {\n      context.lineDashOffset = /** @type {number} */instruction[7];\n      context.setLineDash( /** @type {Array<number>} */instruction[6]);\n    }\n  };\n  /**\n   * @param {import(\"../canvas.js\").DeclutterGroup} declutterGroup Declutter group.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {number} opacity Layer opacity.\n   * @param {?} declutterTree Declutter tree.\n   * @return {?} Declutter tree.\n   */\n  Executor.prototype.renderDeclutter = function (declutterGroup, feature, opacity, declutterTree) {\n    /** @type {Array<import(\"../../structs/RBush.js\").Entry>} */\n    var boxes = [];\n    for (var i = 1, ii = declutterGroup.length; i < ii; ++i) {\n      var declutterData = declutterGroup[i];\n      var box = declutterData[11];\n      boxes.push({\n        minX: box[0],\n        minY: box[1],\n        maxX: box[2],\n        maxY: box[3],\n        value: feature\n      });\n    }\n    if (!declutterTree) {\n      declutterTree = new RBush(9);\n    }\n    var collides = false;\n    for (var i = 0, ii = boxes.length; i < ii; ++i) {\n      if (declutterTree.collides(boxes[i])) {\n        collides = true;\n        break;\n      }\n    }\n    if (!collides) {\n      declutterTree.load(boxes);\n      for (var j = 1, jj = declutterGroup.length; j < jj; ++j) {\n        var declutterData = /** @type {Array} */declutterGroup[j];\n        var context = declutterData[0];\n        var currentAlpha = context.globalAlpha;\n        if (currentAlpha !== opacity) {\n          context.globalAlpha = opacity;\n        }\n        if (declutterData.length > 12) {\n          this.replayTextBackground_(declutterData[0], declutterData[14], declutterData[15], declutterData[16], declutterData[17], declutterData[12], declutterData[13], true);\n        }\n        drawImageOrLabel.apply(undefined, declutterData);\n        if (currentAlpha !== opacity) {\n          context.globalAlpha = currentAlpha;\n        }\n      }\n    }\n    declutterGroup.length = 1;\n    return declutterTree;\n  };\n  /**\n   * @private\n   * @param {string} text The text to draw.\n   * @param {string} textKey The key of the text state.\n   * @param {string} strokeKey The key for the stroke state.\n   * @param {string} fillKey The key for the fill state.\n   * @return {{label: import(\"../canvas.js\").Label, anchorX: number, anchorY: number}} The text image and its anchor.\n   */\n  Executor.prototype.drawLabelWithPointPlacement_ = function (text, textKey, strokeKey, fillKey) {\n    var textState = this.textStates[textKey];\n    var label = this.createLabel(text, textKey, fillKey, strokeKey);\n    var strokeState = this.strokeStates[strokeKey];\n    var pixelRatio = this.pixelRatio;\n    var align = TEXT_ALIGN[textState.textAlign || defaultTextAlign];\n    var baseline = TEXT_ALIGN[textState.textBaseline || defaultTextBaseline];\n    var strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;\n    // Remove the 2 pixels we added in createLabel() for the anchor\n    var width = label.width / pixelRatio - 2 * textState.scale[0];\n    var anchorX = align * width + 2 * (0.5 - align) * strokeWidth;\n    var anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;\n    return {\n      label: label,\n      anchorX: anchorX,\n      anchorY: anchorY\n    };\n  };\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} contextScale Scale of the context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {Array<*>} instructions Instructions array.\n   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n   * @param {function(import(\"../../Feature.js\").FeatureLike): T|undefined} featureCallback Feature callback.\n   * @param {import(\"../../extent.js\").Extent=} opt_hitExtent Only check features that intersect this\n   *     extent.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  Executor.prototype.execute_ = function (context, contextScale, transform, instructions, snapToPixel, featureCallback, opt_hitExtent) {\n    this.declutterItems.length = 0;\n    /** @type {Array<number>} */\n    var pixelCoordinates;\n    if (this.pixelCoordinates_ && equals(transform, this.renderedTransform_)) {\n      pixelCoordinates = this.pixelCoordinates_;\n    } else {\n      if (!this.pixelCoordinates_) {\n        this.pixelCoordinates_ = [];\n      }\n      pixelCoordinates = transform2D(this.coordinates, 0, this.coordinates.length, 2, transform, this.pixelCoordinates_);\n      transformSetFromArray(this.renderedTransform_, transform);\n    }\n    var i = 0; // instruction index\n    var ii = instructions.length; // end of instructions\n    var d = 0; // data index\n    var dd; // end of per-instruction data\n    var anchorX, anchorY, prevX, prevY, roundX, roundY, declutterGroup, declutterGroups, image, text, textKey;\n    var strokeKey, fillKey;\n    var pendingFill = 0;\n    var pendingStroke = 0;\n    var lastFillInstruction = null;\n    var lastStrokeInstruction = null;\n    var coordinateCache = this.coordinateCache_;\n    var viewRotation = this.viewRotation_;\n    var viewRotationFromTransform = Math.round(Math.atan2(-transform[1], transform[0]) * 1e12) / 1e12;\n    var state = /** @type {import(\"../../render.js\").State} */{\n      context: context,\n      pixelRatio: this.pixelRatio,\n      resolution: this.resolution,\n      rotation: viewRotation\n    };\n    // When the batch size gets too big, performance decreases. 200 is a good\n    // balance between batch size and number of fill/stroke instructions.\n    var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;\n    var /** @type {import(\"../../Feature.js\").FeatureLike} */feature;\n    var x, y;\n    while (i < ii) {\n      var instruction = instructions[i];\n      var type = /** @type {import(\"./Instruction.js\").default} */instruction[0];\n      switch (type) {\n        case CanvasInstruction.BEGIN_GEOMETRY:\n          feature = /** @type {import(\"../../Feature.js\").FeatureLike} */instruction[1];\n          if (!feature.getGeometry()) {\n            i = /** @type {number} */instruction[2];\n          } else if (opt_hitExtent !== undefined && !intersects(opt_hitExtent, instruction[3])) {\n            i = /** @type {number} */instruction[2] + 1;\n          } else {\n            ++i;\n          }\n          break;\n        case CanvasInstruction.BEGIN_PATH:\n          if (pendingFill > batchSize) {\n            this.fill_(context);\n            pendingFill = 0;\n          }\n          if (pendingStroke > batchSize) {\n            context.stroke();\n            pendingStroke = 0;\n          }\n          if (!pendingFill && !pendingStroke) {\n            context.beginPath();\n            prevX = NaN;\n            prevY = NaN;\n          }\n          ++i;\n          break;\n        case CanvasInstruction.CIRCLE:\n          d = /** @type {number} */instruction[1];\n          var x1 = pixelCoordinates[d];\n          var y1 = pixelCoordinates[d + 1];\n          var x2 = pixelCoordinates[d + 2];\n          var y2 = pixelCoordinates[d + 3];\n          var dx = x2 - x1;\n          var dy = y2 - y1;\n          var r = Math.sqrt(dx * dx + dy * dy);\n          context.moveTo(x1 + r, y1);\n          context.arc(x1, y1, r, 0, 2 * Math.PI, true);\n          ++i;\n          break;\n        case CanvasInstruction.CLOSE_PATH:\n          context.closePath();\n          ++i;\n          break;\n        case CanvasInstruction.CUSTOM:\n          d = /** @type {number} */instruction[1];\n          dd = instruction[2];\n          var geometry = /** @type {import(\"../../geom/SimpleGeometry.js\").default} */instruction[3];\n          var renderer = instruction[4];\n          var fn = instruction.length == 6 ? instruction[5] : undefined;\n          state.geometry = geometry;\n          state.feature = feature;\n          if (!(i in coordinateCache)) {\n            coordinateCache[i] = [];\n          }\n          var coords = coordinateCache[i];\n          if (fn) {\n            fn(pixelCoordinates, d, dd, 2, coords);\n          } else {\n            coords[0] = pixelCoordinates[d];\n            coords[1] = pixelCoordinates[d + 1];\n            coords.length = 2;\n          }\n          renderer(coords, state);\n          ++i;\n          break;\n        case CanvasInstruction.DRAW_IMAGE:\n          d = /** @type {number} */instruction[1];\n          dd = /** @type {number} */instruction[2];\n          image = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */instruction[3];\n          // Remaining arguments in DRAW_IMAGE are in alphabetical order\n          anchorX = /** @type {number} */instruction[4];\n          anchorY = /** @type {number} */instruction[5];\n          declutterGroups = featureCallback ? null : instruction[6];\n          var height = /** @type {number} */instruction[7];\n          var opacity = /** @type {number} */instruction[8];\n          var originX = /** @type {number} */instruction[9];\n          var originY = /** @type {number} */instruction[10];\n          var rotateWithView = /** @type {boolean} */instruction[11];\n          var rotation = /** @type {number} */instruction[12];\n          var scale = /** @type {import(\"../../size.js\").Size} */instruction[13];\n          var width = /** @type {number} */instruction[14];\n          if (!image && instruction.length >= 19) {\n            // create label images\n            text = /** @type {string} */instruction[18];\n            textKey = /** @type {string} */instruction[19];\n            strokeKey = /** @type {string} */instruction[20];\n            fillKey = /** @type {string} */instruction[21];\n            var labelWithAnchor = this.drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey);\n            image = labelWithAnchor.label;\n            instruction[3] = image;\n            var textOffsetX = /** @type {number} */instruction[22];\n            anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;\n            instruction[4] = anchorX;\n            var textOffsetY = /** @type {number} */instruction[23];\n            anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;\n            instruction[5] = anchorY;\n            height = image.height;\n            instruction[7] = height;\n            width = image.width;\n            instruction[14] = width;\n          }\n          var geometryWidths = void 0;\n          if (instruction.length > 24) {\n            geometryWidths = /** @type {number} */instruction[24];\n          }\n          var padding = void 0,\n            backgroundFill = void 0,\n            backgroundStroke = void 0;\n          if (instruction.length > 16) {\n            padding = /** @type {Array<number>} */instruction[15];\n            backgroundFill = /** @type {boolean} */instruction[16];\n            backgroundStroke = /** @type {boolean} */instruction[17];\n          } else {\n            padding = defaultPadding;\n            backgroundFill = false;\n            backgroundStroke = false;\n          }\n          if (rotateWithView && viewRotationFromTransform) {\n            // Canvas is expected to be rotated to reverse view rotation.\n            rotation += viewRotation;\n          } else if (!rotateWithView && !viewRotationFromTransform) {\n            // Canvas is not rotated, images need to be rotated back to be north-up.\n            rotation -= viewRotation;\n          }\n          var widthIndex = 0;\n          var declutterGroupIndex = 0;\n          for (; d < dd; d += 2) {\n            if (geometryWidths && geometryWidths[widthIndex++] < width / this.pixelRatio) {\n              continue;\n            }\n            if (declutterGroups) {\n              var index = Math.floor(declutterGroupIndex);\n              declutterGroup = declutterGroups.length < index + 1 ? [declutterGroups[0][0]] : declutterGroups[index];\n            }\n            var rendered = this.replayImageOrLabel_(context, contextScale, pixelCoordinates[d], pixelCoordinates[d + 1], image, anchorX, anchorY, declutterGroup, height, opacity, originX, originY, rotation, scale, snapToPixel, width, padding, backgroundFill ? /** @type {Array<*>} */lastFillInstruction : null, backgroundStroke ? /** @type {Array<*>} */lastStrokeInstruction : null);\n            if (rendered && declutterGroup && declutterGroups[declutterGroups.length - 1] !== declutterGroup) {\n              declutterGroups.push(declutterGroup);\n            }\n            if (declutterGroup) {\n              if (declutterGroup.length - 1 === declutterGroup[0]) {\n                this.declutterItems.push(this, declutterGroup, feature);\n              }\n              declutterGroupIndex += 1 / declutterGroup[0];\n            }\n          }\n          ++i;\n          break;\n        case CanvasInstruction.DRAW_CHARS:\n          var begin = /** @type {number} */instruction[1];\n          var end = /** @type {number} */instruction[2];\n          var baseline = /** @type {number} */instruction[3];\n          declutterGroup = featureCallback ? null : instruction[4];\n          var overflow = /** @type {number} */instruction[5];\n          fillKey = /** @type {string} */instruction[6];\n          var maxAngle = /** @type {number} */instruction[7];\n          var measurePixelRatio = /** @type {number} */instruction[8];\n          var offsetY = /** @type {number} */instruction[9];\n          strokeKey = /** @type {string} */instruction[10];\n          var strokeWidth = /** @type {number} */instruction[11];\n          text = /** @type {string} */instruction[12];\n          textKey = /** @type {string} */instruction[13];\n          var pixelRatioScale = [/** @type {number} */instruction[14], /** @type {number} */instruction[14]];\n          var textState = this.textStates[textKey];\n          var font = textState.font;\n          var textScale = [textState.scale[0] * measurePixelRatio, textState.scale[1] * measurePixelRatio];\n          var cachedWidths = void 0;\n          if (font in this.widths_) {\n            cachedWidths = this.widths_[font];\n          } else {\n            cachedWidths = {};\n            this.widths_[font] = cachedWidths;\n          }\n          var pathLength = lineStringLength(pixelCoordinates, begin, end, 2);\n          var textLength = Math.abs(textScale[0]) * measureAndCacheTextWidth(font, text, cachedWidths);\n          if (overflow || textLength <= pathLength) {\n            var textAlign = this.textStates[textKey].textAlign;\n            var startM = (pathLength - textLength) * TEXT_ALIGN[textAlign];\n            var parts = drawTextOnPath(pixelCoordinates, begin, end, 2, text, startM, maxAngle, Math.abs(textScale[0]), measureAndCacheTextWidth, font, cachedWidths, viewRotationFromTransform ? 0 : this.viewRotation_);\n            if (parts) {\n              var rendered = false;\n              var c = void 0,\n                cc = void 0,\n                chars = void 0,\n                label = void 0,\n                part = void 0;\n              if (strokeKey) {\n                for (c = 0, cc = parts.length; c < cc; ++c) {\n                  part = parts[c]; // x, y, anchorX, rotation, chunk\n                  chars = /** @type {string} */part[4];\n                  label = this.createLabel(chars, textKey, '', strokeKey);\n                  anchorX = /** @type {number} */part[2] + strokeWidth;\n                  anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth * textScale[1] / textScale[0] - offsetY;\n                  rendered = this.replayImageOrLabel_(context, contextScale, /** @type {number} */part[0], /** @type {number} */part[1], label, anchorX, anchorY, declutterGroup, label.height, 1, 0, 0, /** @type {number} */part[3], pixelRatioScale, false, label.width, defaultPadding, null, null) || rendered;\n                }\n              }\n              if (fillKey) {\n                for (c = 0, cc = parts.length; c < cc; ++c) {\n                  part = parts[c]; // x, y, anchorX, rotation, chunk\n                  chars = /** @type {string} */part[4];\n                  label = this.createLabel(chars, textKey, fillKey, '');\n                  anchorX = /** @type {number} */part[2];\n                  anchorY = baseline * label.height - offsetY;\n                  rendered = this.replayImageOrLabel_(context, contextScale, /** @type {number} */part[0], /** @type {number} */part[1], label, anchorX, anchorY, declutterGroup, label.height, 1, 0, 0, /** @type {number} */part[3], pixelRatioScale, false, label.width, defaultPadding, null, null) || rendered;\n                }\n              }\n              if (rendered) {\n                this.declutterItems.push(this, declutterGroup, feature);\n              }\n            }\n          }\n          ++i;\n          break;\n        case CanvasInstruction.END_GEOMETRY:\n          if (featureCallback !== undefined) {\n            feature = /** @type {import(\"../../Feature.js\").FeatureLike} */instruction[1];\n            var result = featureCallback(feature);\n            if (result) {\n              return result;\n            }\n          }\n          ++i;\n          break;\n        case CanvasInstruction.FILL:\n          if (batchSize) {\n            pendingFill++;\n          } else {\n            this.fill_(context);\n          }\n          ++i;\n          break;\n        case CanvasInstruction.MOVE_TO_LINE_TO:\n          d = /** @type {number} */instruction[1];\n          dd = /** @type {number} */instruction[2];\n          x = pixelCoordinates[d];\n          y = pixelCoordinates[d + 1];\n          roundX = x + 0.5 | 0;\n          roundY = y + 0.5 | 0;\n          if (roundX !== prevX || roundY !== prevY) {\n            context.moveTo(x, y);\n            prevX = roundX;\n            prevY = roundY;\n          }\n          for (d += 2; d < dd; d += 2) {\n            x = pixelCoordinates[d];\n            y = pixelCoordinates[d + 1];\n            roundX = x + 0.5 | 0;\n            roundY = y + 0.5 | 0;\n            if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {\n              context.lineTo(x, y);\n              prevX = roundX;\n              prevY = roundY;\n            }\n          }\n          ++i;\n          break;\n        case CanvasInstruction.SET_FILL_STYLE:\n          lastFillInstruction = instruction;\n          this.alignFill_ = instruction[2];\n          if (pendingFill) {\n            this.fill_(context);\n            pendingFill = 0;\n            if (pendingStroke) {\n              context.stroke();\n              pendingStroke = 0;\n            }\n          }\n          context.fillStyle = /** @type {import(\"../../colorlike.js\").ColorLike} */instruction[1];\n          ++i;\n          break;\n        case CanvasInstruction.SET_STROKE_STYLE:\n          lastStrokeInstruction = instruction;\n          if (pendingStroke) {\n            context.stroke();\n            pendingStroke = 0;\n          }\n          this.setStrokeStyle_(context, /** @type {Array<*>} */instruction);\n          ++i;\n          break;\n        case CanvasInstruction.STROKE:\n          if (batchSize) {\n            pendingStroke++;\n          } else {\n            context.stroke();\n          }\n          ++i;\n          break;\n        default:\n          ++i; // consume the instruction anyway, to avoid an infinite loop\n          break;\n      }\n    }\n    if (pendingFill) {\n      this.fill_(context);\n    }\n    if (pendingStroke) {\n      context.stroke();\n    }\n    return undefined;\n  };\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} contextScale Scale of the context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n   */\n  Executor.prototype.execute = function (context, contextScale, transform, viewRotation, snapToPixel) {\n    this.viewRotation_ = viewRotation;\n    this.execute_(context, contextScale, transform, this.instructions, snapToPixel, undefined, undefined);\n  };\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {function(import(\"../../Feature.js\").FeatureLike): T=} opt_featureCallback\n   *     Feature callback.\n   * @param {import(\"../../extent.js\").Extent=} opt_hitExtent Only check features that intersect this\n   *     extent.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  Executor.prototype.executeHitDetection = function (context, transform, viewRotation, opt_featureCallback, opt_hitExtent) {\n    this.viewRotation_ = viewRotation;\n    return this.execute_(context, 1, transform, this.hitDetectionInstructions, true, opt_featureCallback, opt_hitExtent);\n  };\n  return Executor;\n}();\nexport default Executor;","map":{"version":3,"names":["CanvasInstruction","RBush","TEXT_ALIGN","WORKER_OFFSCREEN_CANVAS","apply","applyTransform","compose","composeTransform","create","createTransform","setFromArray","transformSetFromArray","createEmpty","createOrUpdate","getHeight","getWidth","intersects","defaultPadding","defaultTextBaseline","drawImageOrLabel","defaultTextAlign","measureAndCacheTextWidth","measureTextHeight","measureTextWidths","drawTextOnPath","equals","lineStringLength","transform2D","tmpExtent","tmpTransform","p1","p2","p3","p4","Executor","resolution","pixelRatio","overlaps","instructions","renderBuffer","alignFill_","declutterItems","coordinates","coordinateCache_","renderBuffer_","renderedTransform_","hitDetectionInstructions","pixelCoordinates_","viewRotation_","fillStates","strokeStates","textStates","widths_","labels_","prototype","createLabel","text","textKey","fillKey","strokeKey","key","strokeState","fillState","textState","scale","align","textAlign","strokeWidth","lineWidth","lines","split","numLines","length","widths","width","font","lineHeight","height","renderWidth","contextInstructions","w","h","label","Math","floor","ceil","push","strokeStyle","lineCap","lineJoin","miterLimit","Context","OffscreenCanvasRenderingContext2D","CanvasRenderingContext2D","setLineDash","lineDash","lineDashOffset","fillStyle","leftRight","x","i","replayTextBackground_","context","fillInstruction","strokeInstruction","declutter","beginPath","moveTo","lineTo","fill_","setStrokeStyle_","stroke","replayImageOrLabel_","contextScale","y","imageOrLabel","anchorX","anchorY","declutterGroup","opacity","originX","originY","rotation","snapToPixel","padding","fillStroke","boxW","boxH","boxX","boxY","transform","centerX","centerY","min","max","renderBufferX","renderBufferY","canvas","strokePadding","round","declutterArgs","slice","origin_1","repeatSize","save","translate","rotate","fill","restore","instruction","renderDeclutter","feature","declutterTree","boxes","ii","declutterData","box","minX","minY","maxX","maxY","value","collides","load","j","jj","currentAlpha","globalAlpha","undefined","drawLabelWithPointPlacement_","baseline","textBaseline","execute_","featureCallback","opt_hitExtent","pixelCoordinates","d","dd","prevX","prevY","roundX","roundY","declutterGroups","image","pendingFill","pendingStroke","lastFillInstruction","lastStrokeInstruction","coordinateCache","viewRotation","viewRotationFromTransform","atan2","state","batchSize","type","BEGIN_GEOMETRY","getGeometry","BEGIN_PATH","NaN","CIRCLE","x1","y1","x2","y2","dx","dy","r","sqrt","arc","PI","CLOSE_PATH","closePath","CUSTOM","geometry","renderer","fn","coords","DRAW_IMAGE","rotateWithView","labelWithAnchor","textOffsetX","textOffsetY","geometryWidths","backgroundFill","backgroundStroke","widthIndex","declutterGroupIndex","index","rendered","DRAW_CHARS","begin","end","overflow","maxAngle","measurePixelRatio","offsetY","pixelRatioScale","textScale","cachedWidths","pathLength","textLength","abs","startM","parts","c","cc","chars","part","END_GEOMETRY","result","FILL","MOVE_TO_LINE_TO","SET_FILL_STYLE","SET_STROKE_STYLE","STROKE","execute","executeHitDetection","opt_featureCallback"],"sources":["/Users/mariovicky/Skripsi_OpenLayers/node_modules/ol/src/render/canvas/Executor.js"],"sourcesContent":["/**\n * @module ol/render/canvas/Executor\n */\nimport CanvasInstruction from './Instruction.js';\nimport RBush from 'rbush/rbush.js';\nimport {TEXT_ALIGN} from './TextBuilder.js';\nimport {WORKER_OFFSCREEN_CANVAS} from '../../has.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n  create as createTransform,\n  setFromArray as transformSetFromArray,\n} from '../../transform.js';\nimport {\n  createEmpty,\n  createOrUpdate,\n  getHeight,\n  getWidth,\n  intersects,\n} from '../../extent.js';\nimport {\n  defaultPadding,\n  defaultTextBaseline,\n  drawImageOrLabel,\n} from '../canvas.js';\nimport {\n  defaultTextAlign,\n  measureAndCacheTextWidth,\n  measureTextHeight,\n  measureTextWidths,\n} from '../canvas.js';\nimport {drawTextOnPath} from '../../geom/flat/textpath.js';\nimport {equals} from '../../array.js';\nimport {lineStringLength} from '../../geom/flat/length.js';\nimport {transform2D} from '../../geom/flat/transform.js';\n\n/**\n * @typedef {Object} SerializableInstructions\n * @property {Array<*>} instructions The rendering instructions.\n * @property {Array<*>} hitDetectionInstructions The rendering hit detection instructions.\n * @property {Array<number>} coordinates The array of all coordinates.\n * @property {!Object<string, import(\"../canvas.js\").TextState>} textStates The text states (decluttering).\n * @property {!Object<string, import(\"../canvas.js\").FillState>} fillStates The fill states (decluttering).\n * @property {!Object<string, import(\"../canvas.js\").StrokeState>} strokeStates The stroke states (decluttering).\n */\n\n/**\n * @type {import(\"../../extent.js\").Extent}\n */\nconst tmpExtent = createEmpty();\n\n/**\n * @type {!import(\"../../transform.js\").Transform}\n */\nconst tmpTransform = createTransform();\n\n/** @type {import(\"../../coordinate.js\").Coordinate} */\nconst p1 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\nconst p2 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\nconst p3 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\nconst p4 = [];\n\nclass Executor {\n  /**\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {boolean} overlaps The replay can have overlapping geometries.\n   * @param {SerializableInstructions} instructions The serializable instructions\n   * @param {import(\"../../size.js\").Size} renderBuffer Render buffer (width/height) in pixels.\n   */\n  constructor(resolution, pixelRatio, overlaps, instructions, renderBuffer) {\n    /**\n     * @protected\n     * @type {boolean}\n     */\n    this.overlaps = overlaps;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.pixelRatio = pixelRatio;\n\n    /**\n     * @protected\n     * @const\n     * @type {number}\n     */\n    this.resolution = resolution;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.alignFill_;\n\n    /**\n     * @type {Array<*>}\n     */\n    this.declutterItems = [];\n\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n    this.instructions = instructions.instructions;\n\n    /**\n     * @protected\n     * @type {Array<number>}\n     */\n    this.coordinates = instructions.coordinates;\n\n    /**\n     * @private\n     * @type {!Object<number,import(\"../../coordinate.js\").Coordinate|Array<import(\"../../coordinate.js\").Coordinate>|Array<Array<import(\"../../coordinate.js\").Coordinate>>>}\n     */\n    this.coordinateCache_ = {};\n\n    /**\n     * @private\n     * @type {import(\"../../size.js\").Size}\n     */\n    this.renderBuffer_ = renderBuffer;\n\n    /**\n     * @private\n     * @type {!import(\"../../transform.js\").Transform}\n     */\n    this.renderedTransform_ = createTransform();\n\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n    this.hitDetectionInstructions = instructions.hitDetectionInstructions;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.pixelCoordinates_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.viewRotation_ = 0;\n\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").FillState>}\n     */\n    this.fillStates = instructions.fillStates || {};\n\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").StrokeState>}\n     */\n    this.strokeStates = instructions.strokeStates || {};\n\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").TextState>}\n     */\n    this.textStates = instructions.textStates || {};\n\n    /**\n     * @private\n     * @type {Object<string, Object<string, number>>}\n     */\n    this.widths_ = {};\n\n    /**\n     * @private\n     * @type {Object<string, import(\"../canvas.js\").Label>}\n     */\n    this.labels_ = {};\n  }\n\n  /**\n   * @param {string} text Text.\n   * @param {string} textKey Text style key.\n   * @param {string} fillKey Fill style key.\n   * @param {string} strokeKey Stroke style key.\n   * @return {import(\"../canvas.js\").Label} Label.\n   */\n  createLabel(text, textKey, fillKey, strokeKey) {\n    const key = text + textKey + fillKey + strokeKey;\n    if (this.labels_[key]) {\n      return this.labels_[key];\n    }\n    const strokeState = strokeKey ? this.strokeStates[strokeKey] : null;\n    const fillState = fillKey ? this.fillStates[fillKey] : null;\n    const textState = this.textStates[textKey];\n    const pixelRatio = this.pixelRatio;\n    const scale = [\n      textState.scale[0] * pixelRatio,\n      textState.scale[1] * pixelRatio,\n    ];\n    const align = TEXT_ALIGN[textState.textAlign || defaultTextAlign];\n    const strokeWidth =\n      strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;\n\n    const lines = text.split('\\n');\n    const numLines = lines.length;\n    const widths = [];\n    const width = measureTextWidths(textState.font, lines, widths);\n    const lineHeight = measureTextHeight(textState.font);\n    const height = lineHeight * numLines;\n    const renderWidth = width + strokeWidth;\n    const contextInstructions = [];\n    // make canvas 2 pixels wider to account for italic text width measurement errors\n    const w = (renderWidth + 2) * scale[0];\n    const h = (height + strokeWidth) * scale[1];\n    /** @type {import(\"../canvas.js\").Label} */\n    const label = {\n      width: w < 0 ? Math.floor(w) : Math.ceil(w),\n      height: h < 0 ? Math.floor(h) : Math.ceil(h),\n      contextInstructions: contextInstructions,\n    };\n    if (scale[0] != 1 || scale[1] != 1) {\n      contextInstructions.push('scale', scale);\n    }\n    contextInstructions.push('font', textState.font);\n    if (strokeKey) {\n      contextInstructions.push('strokeStyle', strokeState.strokeStyle);\n      contextInstructions.push('lineWidth', strokeWidth);\n      contextInstructions.push('lineCap', strokeState.lineCap);\n      contextInstructions.push('lineJoin', strokeState.lineJoin);\n      contextInstructions.push('miterLimit', strokeState.miterLimit);\n      // eslint-disable-next-line\n      const Context = WORKER_OFFSCREEN_CANVAS ? OffscreenCanvasRenderingContext2D : CanvasRenderingContext2D;\n      if (Context.prototype.setLineDash) {\n        contextInstructions.push('setLineDash', [strokeState.lineDash]);\n        contextInstructions.push('lineDashOffset', strokeState.lineDashOffset);\n      }\n    }\n    if (fillKey) {\n      contextInstructions.push('fillStyle', fillState.fillStyle);\n    }\n    contextInstructions.push('textBaseline', 'middle');\n    contextInstructions.push('textAlign', 'center');\n    const leftRight = 0.5 - align;\n    const x = align * renderWidth + leftRight * strokeWidth;\n    let i;\n    if (strokeKey) {\n      for (i = 0; i < numLines; ++i) {\n        contextInstructions.push('strokeText', [\n          lines[i],\n          x + leftRight * widths[i],\n          0.5 * (strokeWidth + lineHeight) + i * lineHeight,\n        ]);\n      }\n    }\n    if (fillKey) {\n      for (i = 0; i < numLines; ++i) {\n        contextInstructions.push('fillText', [\n          lines[i],\n          x + leftRight * widths[i],\n          0.5 * (strokeWidth + lineHeight) + i * lineHeight,\n        ]);\n      }\n    }\n    this.labels_[key] = label;\n    return label;\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../coordinate.js\").Coordinate} p1 1st point of the background box.\n   * @param {import(\"../../coordinate.js\").Coordinate} p2 2nd point of the background box.\n   * @param {import(\"../../coordinate.js\").Coordinate} p3 3rd point of the background box.\n   * @param {import(\"../../coordinate.js\").Coordinate} p4 4th point of the background box.\n   * @param {Array<*>} fillInstruction Fill instruction.\n   * @param {Array<*>} strokeInstruction Stroke instruction.\n   * @param {boolean} declutter Declutter.\n   */\n  replayTextBackground_(\n    context,\n    p1,\n    p2,\n    p3,\n    p4,\n    fillInstruction,\n    strokeInstruction,\n    declutter\n  ) {\n    context.beginPath();\n    context.moveTo.apply(context, p1);\n    context.lineTo.apply(context, p2);\n    context.lineTo.apply(context, p3);\n    context.lineTo.apply(context, p4);\n    context.lineTo.apply(context, p1);\n    if (fillInstruction) {\n      this.alignFill_ = /** @type {boolean} */ (fillInstruction[2]);\n      if (declutter) {\n        context.fillStyle = /** @type {import(\"../../colorlike.js\").ColorLike} */ (fillInstruction[1]);\n      }\n      this.fill_(context);\n    }\n    if (strokeInstruction) {\n      this.setStrokeStyle_(\n        context,\n        /** @type {Array<*>} */ (strokeInstruction)\n      );\n      context.stroke();\n    }\n  }\n\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} contextScale Scale of the context.\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../canvas.js\").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.\n   * @param {number} anchorX Anchor X.\n   * @param {number} anchorY Anchor Y.\n   * @param {import(\"../canvas.js\").DeclutterGroup} declutterGroup Declutter group.\n   * @param {number} height Height.\n   * @param {number} opacity Opacity.\n   * @param {number} originX Origin X.\n   * @param {number} originY Origin Y.\n   * @param {number} rotation Rotation.\n   * @param {import(\"../../size.js\").Size} scale Scale.\n   * @param {boolean} snapToPixel Snap to pixel.\n   * @param {number} width Width.\n   * @param {Array<number>} padding Padding.\n   * @param {Array<*>} fillInstruction Fill instruction.\n   * @param {Array<*>} strokeInstruction Stroke instruction.\n   * @return {boolean} The image or label was rendered.\n   */\n  replayImageOrLabel_(\n    context,\n    contextScale,\n    x,\n    y,\n    imageOrLabel,\n    anchorX,\n    anchorY,\n    declutterGroup,\n    height,\n    opacity,\n    originX,\n    originY,\n    rotation,\n    scale,\n    snapToPixel,\n    width,\n    padding,\n    fillInstruction,\n    strokeInstruction\n  ) {\n    const fillStroke = fillInstruction || strokeInstruction;\n    anchorX *= scale[0];\n    anchorY *= scale[1];\n    x -= anchorX;\n    y -= anchorY;\n\n    const w =\n      width + originX > imageOrLabel.width\n        ? imageOrLabel.width - originX\n        : width;\n    const h =\n      height + originY > imageOrLabel.height\n        ? imageOrLabel.height - originY\n        : height;\n    const boxW = padding[3] + w * scale[0] + padding[1];\n    const boxH = padding[0] + h * scale[1] + padding[2];\n    const boxX = x - padding[3];\n    const boxY = y - padding[0];\n\n    if (fillStroke || rotation !== 0) {\n      p1[0] = boxX;\n      p4[0] = boxX;\n      p1[1] = boxY;\n      p2[1] = boxY;\n      p2[0] = boxX + boxW;\n      p3[0] = p2[0];\n      p3[1] = boxY + boxH;\n      p4[1] = p3[1];\n    }\n\n    let transform = null;\n    if (rotation !== 0) {\n      const centerX = x + anchorX;\n      const centerY = y + anchorY;\n      transform = composeTransform(\n        tmpTransform,\n        centerX,\n        centerY,\n        1,\n        1,\n        rotation,\n        -centerX,\n        -centerY\n      );\n\n      applyTransform(tmpTransform, p1);\n      applyTransform(tmpTransform, p2);\n      applyTransform(tmpTransform, p3);\n      applyTransform(tmpTransform, p4);\n      createOrUpdate(\n        Math.min(p1[0], p2[0], p3[0], p4[0]),\n        Math.min(p1[1], p2[1], p3[1], p4[1]),\n        Math.max(p1[0], p2[0], p3[0], p4[0]),\n        Math.max(p1[1], p2[1], p3[1], p4[1]),\n        tmpExtent\n      );\n    } else {\n      createOrUpdate(boxX, boxY, boxX + boxW, boxY + boxH, tmpExtent);\n    }\n    let renderBufferX = 0;\n    let renderBufferY = 0;\n    if (declutterGroup) {\n      const renderBuffer = this.renderBuffer_;\n      renderBuffer[0] = Math.max(renderBuffer[0], getWidth(tmpExtent));\n      renderBufferX = renderBuffer[0];\n      renderBuffer[1] = Math.max(renderBuffer[1], getHeight(tmpExtent));\n      renderBufferY = renderBuffer[1];\n    }\n    const canvas = context.canvas;\n    const strokePadding = strokeInstruction\n      ? (strokeInstruction[2] * scale[0]) / 2\n      : 0;\n    const intersects =\n      tmpExtent[0] - strokePadding <=\n        (canvas.width + renderBufferX) / contextScale &&\n      tmpExtent[2] + strokePadding >= -renderBufferX / contextScale &&\n      tmpExtent[1] - strokePadding <=\n        (canvas.height + renderBufferY) / contextScale &&\n      tmpExtent[3] + strokePadding >= -renderBufferY / contextScale;\n\n    if (snapToPixel) {\n      x = Math.round(x);\n      y = Math.round(y);\n    }\n\n    if (declutterGroup) {\n      if (!intersects && declutterGroup[0] == 1) {\n        return false;\n      }\n      const declutterArgs = intersects\n        ? [\n            context,\n            transform ? transform.slice(0) : null,\n            opacity,\n            imageOrLabel,\n            originX,\n            originY,\n            w,\n            h,\n            x,\n            y,\n            scale,\n            tmpExtent.slice(),\n          ]\n        : null;\n      if (declutterArgs) {\n        if (fillStroke) {\n          declutterArgs.push(\n            fillInstruction,\n            strokeInstruction,\n            p1.slice(0),\n            p2.slice(0),\n            p3.slice(0),\n            p4.slice(0)\n          );\n        }\n        declutterGroup.push(declutterArgs);\n      }\n    } else if (intersects) {\n      if (fillStroke) {\n        this.replayTextBackground_(\n          context,\n          p1,\n          p2,\n          p3,\n          p4,\n          /** @type {Array<*>} */ (fillInstruction),\n          /** @type {Array<*>} */ (strokeInstruction),\n          false\n        );\n      }\n      drawImageOrLabel(\n        context,\n        transform,\n        opacity,\n        imageOrLabel,\n        originX,\n        originY,\n        w,\n        h,\n        x,\n        y,\n        scale\n      );\n    }\n    return true;\n  }\n\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   */\n  fill_(context) {\n    if (this.alignFill_) {\n      const origin = applyTransform(this.renderedTransform_, [0, 0]);\n      const repeatSize = 512 * this.pixelRatio;\n      context.save();\n      context.translate(origin[0] % repeatSize, origin[1] % repeatSize);\n      context.rotate(this.viewRotation_);\n    }\n    context.fill();\n    if (this.alignFill_) {\n      context.restore();\n    }\n  }\n\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {Array<*>} instruction Instruction.\n   */\n  setStrokeStyle_(context, instruction) {\n    context.strokeStyle = /** @type {import(\"../../colorlike.js\").ColorLike} */ (instruction[1]);\n    context.lineWidth = /** @type {number} */ (instruction[2]);\n    context.lineCap = /** @type {CanvasLineCap} */ (instruction[3]);\n    context.lineJoin = /** @type {CanvasLineJoin} */ (instruction[4]);\n    context.miterLimit = /** @type {number} */ (instruction[5]);\n    if (context.setLineDash) {\n      context.lineDashOffset = /** @type {number} */ (instruction[7]);\n      context.setLineDash(/** @type {Array<number>} */ (instruction[6]));\n    }\n  }\n\n  /**\n   * @param {import(\"../canvas.js\").DeclutterGroup} declutterGroup Declutter group.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {number} opacity Layer opacity.\n   * @param {?} declutterTree Declutter tree.\n   * @return {?} Declutter tree.\n   */\n  renderDeclutter(declutterGroup, feature, opacity, declutterTree) {\n    /** @type {Array<import(\"../../structs/RBush.js\").Entry>} */\n    const boxes = [];\n    for (let i = 1, ii = declutterGroup.length; i < ii; ++i) {\n      const declutterData = declutterGroup[i];\n      const box = declutterData[11];\n      boxes.push({\n        minX: box[0],\n        minY: box[1],\n        maxX: box[2],\n        maxY: box[3],\n        value: feature,\n      });\n    }\n    if (!declutterTree) {\n      declutterTree = new RBush(9);\n    }\n    let collides = false;\n    for (let i = 0, ii = boxes.length; i < ii; ++i) {\n      if (declutterTree.collides(boxes[i])) {\n        collides = true;\n        break;\n      }\n    }\n    if (!collides) {\n      declutterTree.load(boxes);\n      for (let j = 1, jj = declutterGroup.length; j < jj; ++j) {\n        const declutterData = /** @type {Array} */ (declutterGroup[j]);\n        const context = declutterData[0];\n        const currentAlpha = context.globalAlpha;\n        if (currentAlpha !== opacity) {\n          context.globalAlpha = opacity;\n        }\n        if (declutterData.length > 12) {\n          this.replayTextBackground_(\n            declutterData[0],\n            declutterData[14],\n            declutterData[15],\n            declutterData[16],\n            declutterData[17],\n            declutterData[12],\n            declutterData[13],\n            true\n          );\n        }\n        drawImageOrLabel.apply(undefined, declutterData);\n        if (currentAlpha !== opacity) {\n          context.globalAlpha = currentAlpha;\n        }\n      }\n    }\n    declutterGroup.length = 1;\n    return declutterTree;\n  }\n\n  /**\n   * @private\n   * @param {string} text The text to draw.\n   * @param {string} textKey The key of the text state.\n   * @param {string} strokeKey The key for the stroke state.\n   * @param {string} fillKey The key for the fill state.\n   * @return {{label: import(\"../canvas.js\").Label, anchorX: number, anchorY: number}} The text image and its anchor.\n   */\n  drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey) {\n    const textState = this.textStates[textKey];\n\n    const label = this.createLabel(text, textKey, fillKey, strokeKey);\n\n    const strokeState = this.strokeStates[strokeKey];\n    const pixelRatio = this.pixelRatio;\n    const align = TEXT_ALIGN[textState.textAlign || defaultTextAlign];\n    const baseline = TEXT_ALIGN[textState.textBaseline || defaultTextBaseline];\n    const strokeWidth =\n      strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;\n\n    // Remove the 2 pixels we added in createLabel() for the anchor\n    const width = label.width / pixelRatio - 2 * textState.scale[0];\n    const anchorX = align * width + 2 * (0.5 - align) * strokeWidth;\n    const anchorY =\n      (baseline * label.height) / pixelRatio +\n      2 * (0.5 - baseline) * strokeWidth;\n\n    return {\n      label: label,\n      anchorX: anchorX,\n      anchorY: anchorY,\n    };\n  }\n\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} contextScale Scale of the context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {Array<*>} instructions Instructions array.\n   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n   * @param {function(import(\"../../Feature.js\").FeatureLike): T|undefined} featureCallback Feature callback.\n   * @param {import(\"../../extent.js\").Extent=} opt_hitExtent Only check features that intersect this\n   *     extent.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  execute_(\n    context,\n    contextScale,\n    transform,\n    instructions,\n    snapToPixel,\n    featureCallback,\n    opt_hitExtent\n  ) {\n    this.declutterItems.length = 0;\n    /** @type {Array<number>} */\n    let pixelCoordinates;\n    if (this.pixelCoordinates_ && equals(transform, this.renderedTransform_)) {\n      pixelCoordinates = this.pixelCoordinates_;\n    } else {\n      if (!this.pixelCoordinates_) {\n        this.pixelCoordinates_ = [];\n      }\n      pixelCoordinates = transform2D(\n        this.coordinates,\n        0,\n        this.coordinates.length,\n        2,\n        transform,\n        this.pixelCoordinates_\n      );\n      transformSetFromArray(this.renderedTransform_, transform);\n    }\n    let i = 0; // instruction index\n    const ii = instructions.length; // end of instructions\n    let d = 0; // data index\n    let dd; // end of per-instruction data\n    let anchorX,\n      anchorY,\n      prevX,\n      prevY,\n      roundX,\n      roundY,\n      declutterGroup,\n      declutterGroups,\n      image,\n      text,\n      textKey;\n    let strokeKey, fillKey;\n    let pendingFill = 0;\n    let pendingStroke = 0;\n    let lastFillInstruction = null;\n    let lastStrokeInstruction = null;\n    const coordinateCache = this.coordinateCache_;\n    const viewRotation = this.viewRotation_;\n    const viewRotationFromTransform =\n      Math.round(Math.atan2(-transform[1], transform[0]) * 1e12) / 1e12;\n\n    const state = /** @type {import(\"../../render.js\").State} */ ({\n      context: context,\n      pixelRatio: this.pixelRatio,\n      resolution: this.resolution,\n      rotation: viewRotation,\n    });\n\n    // When the batch size gets too big, performance decreases. 200 is a good\n    // balance between batch size and number of fill/stroke instructions.\n    const batchSize =\n      this.instructions != instructions || this.overlaps ? 0 : 200;\n    let /** @type {import(\"../../Feature.js\").FeatureLike} */ feature;\n    let x, y;\n    while (i < ii) {\n      const instruction = instructions[i];\n      const type = /** @type {import(\"./Instruction.js\").default} */ (instruction[0]);\n      switch (type) {\n        case CanvasInstruction.BEGIN_GEOMETRY:\n          feature = /** @type {import(\"../../Feature.js\").FeatureLike} */ (instruction[1]);\n          if (!feature.getGeometry()) {\n            i = /** @type {number} */ (instruction[2]);\n          } else if (\n            opt_hitExtent !== undefined &&\n            !intersects(opt_hitExtent, instruction[3])\n          ) {\n            i = /** @type {number} */ (instruction[2]) + 1;\n          } else {\n            ++i;\n          }\n          break;\n        case CanvasInstruction.BEGIN_PATH:\n          if (pendingFill > batchSize) {\n            this.fill_(context);\n            pendingFill = 0;\n          }\n          if (pendingStroke > batchSize) {\n            context.stroke();\n            pendingStroke = 0;\n          }\n          if (!pendingFill && !pendingStroke) {\n            context.beginPath();\n            prevX = NaN;\n            prevY = NaN;\n          }\n          ++i;\n          break;\n        case CanvasInstruction.CIRCLE:\n          d = /** @type {number} */ (instruction[1]);\n          const x1 = pixelCoordinates[d];\n          const y1 = pixelCoordinates[d + 1];\n          const x2 = pixelCoordinates[d + 2];\n          const y2 = pixelCoordinates[d + 3];\n          const dx = x2 - x1;\n          const dy = y2 - y1;\n          const r = Math.sqrt(dx * dx + dy * dy);\n          context.moveTo(x1 + r, y1);\n          context.arc(x1, y1, r, 0, 2 * Math.PI, true);\n          ++i;\n          break;\n        case CanvasInstruction.CLOSE_PATH:\n          context.closePath();\n          ++i;\n          break;\n        case CanvasInstruction.CUSTOM:\n          d = /** @type {number} */ (instruction[1]);\n          dd = instruction[2];\n          const geometry = /** @type {import(\"../../geom/SimpleGeometry.js\").default} */ (instruction[3]);\n          const renderer = instruction[4];\n          const fn = instruction.length == 6 ? instruction[5] : undefined;\n          state.geometry = geometry;\n          state.feature = feature;\n          if (!(i in coordinateCache)) {\n            coordinateCache[i] = [];\n          }\n          const coords = coordinateCache[i];\n          if (fn) {\n            fn(pixelCoordinates, d, dd, 2, coords);\n          } else {\n            coords[0] = pixelCoordinates[d];\n            coords[1] = pixelCoordinates[d + 1];\n            coords.length = 2;\n          }\n          renderer(coords, state);\n          ++i;\n          break;\n        case CanvasInstruction.DRAW_IMAGE:\n          d = /** @type {number} */ (instruction[1]);\n          dd = /** @type {number} */ (instruction[2]);\n          image = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */ (instruction[3]);\n\n          // Remaining arguments in DRAW_IMAGE are in alphabetical order\n          anchorX = /** @type {number} */ (instruction[4]);\n          anchorY = /** @type {number} */ (instruction[5]);\n          declutterGroups = featureCallback ? null : instruction[6];\n          let height = /** @type {number} */ (instruction[7]);\n          const opacity = /** @type {number} */ (instruction[8]);\n          const originX = /** @type {number} */ (instruction[9]);\n          const originY = /** @type {number} */ (instruction[10]);\n          const rotateWithView = /** @type {boolean} */ (instruction[11]);\n          let rotation = /** @type {number} */ (instruction[12]);\n          const scale = /** @type {import(\"../../size.js\").Size} */ (instruction[13]);\n          let width = /** @type {number} */ (instruction[14]);\n\n          if (!image && instruction.length >= 19) {\n            // create label images\n            text = /** @type {string} */ (instruction[18]);\n            textKey = /** @type {string} */ (instruction[19]);\n            strokeKey = /** @type {string} */ (instruction[20]);\n            fillKey = /** @type {string} */ (instruction[21]);\n            const labelWithAnchor = this.drawLabelWithPointPlacement_(\n              text,\n              textKey,\n              strokeKey,\n              fillKey\n            );\n            image = labelWithAnchor.label;\n            instruction[3] = image;\n            const textOffsetX = /** @type {number} */ (instruction[22]);\n            anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;\n            instruction[4] = anchorX;\n            const textOffsetY = /** @type {number} */ (instruction[23]);\n            anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;\n            instruction[5] = anchorY;\n            height = image.height;\n            instruction[7] = height;\n            width = image.width;\n            instruction[14] = width;\n          }\n\n          let geometryWidths;\n          if (instruction.length > 24) {\n            geometryWidths = /** @type {number} */ (instruction[24]);\n          }\n\n          let padding, backgroundFill, backgroundStroke;\n          if (instruction.length > 16) {\n            padding = /** @type {Array<number>} */ (instruction[15]);\n            backgroundFill = /** @type {boolean} */ (instruction[16]);\n            backgroundStroke = /** @type {boolean} */ (instruction[17]);\n          } else {\n            padding = defaultPadding;\n            backgroundFill = false;\n            backgroundStroke = false;\n          }\n\n          if (rotateWithView && viewRotationFromTransform) {\n            // Canvas is expected to be rotated to reverse view rotation.\n            rotation += viewRotation;\n          } else if (!rotateWithView && !viewRotationFromTransform) {\n            // Canvas is not rotated, images need to be rotated back to be north-up.\n            rotation -= viewRotation;\n          }\n          let widthIndex = 0;\n          let declutterGroupIndex = 0;\n          for (; d < dd; d += 2) {\n            if (\n              geometryWidths &&\n              geometryWidths[widthIndex++] < width / this.pixelRatio\n            ) {\n              continue;\n            }\n            if (declutterGroups) {\n              const index = Math.floor(declutterGroupIndex);\n              declutterGroup =\n                declutterGroups.length < index + 1\n                  ? [declutterGroups[0][0]]\n                  : declutterGroups[index];\n            }\n            const rendered = this.replayImageOrLabel_(\n              context,\n              contextScale,\n              pixelCoordinates[d],\n              pixelCoordinates[d + 1],\n              image,\n              anchorX,\n              anchorY,\n              declutterGroup,\n              height,\n              opacity,\n              originX,\n              originY,\n              rotation,\n              scale,\n              snapToPixel,\n              width,\n              padding,\n              backgroundFill\n                ? /** @type {Array<*>} */ (lastFillInstruction)\n                : null,\n              backgroundStroke\n                ? /** @type {Array<*>} */ (lastStrokeInstruction)\n                : null\n            );\n            if (\n              rendered &&\n              declutterGroup &&\n              declutterGroups[declutterGroups.length - 1] !== declutterGroup\n            ) {\n              declutterGroups.push(declutterGroup);\n            }\n            if (declutterGroup) {\n              if (declutterGroup.length - 1 === declutterGroup[0]) {\n                this.declutterItems.push(this, declutterGroup, feature);\n              }\n              declutterGroupIndex += 1 / declutterGroup[0];\n            }\n          }\n          ++i;\n          break;\n        case CanvasInstruction.DRAW_CHARS:\n          const begin = /** @type {number} */ (instruction[1]);\n          const end = /** @type {number} */ (instruction[2]);\n          const baseline = /** @type {number} */ (instruction[3]);\n          declutterGroup = featureCallback ? null : instruction[4];\n          const overflow = /** @type {number} */ (instruction[5]);\n          fillKey = /** @type {string} */ (instruction[6]);\n          const maxAngle = /** @type {number} */ (instruction[7]);\n          const measurePixelRatio = /** @type {number} */ (instruction[8]);\n          const offsetY = /** @type {number} */ (instruction[9]);\n          strokeKey = /** @type {string} */ (instruction[10]);\n          const strokeWidth = /** @type {number} */ (instruction[11]);\n          text = /** @type {string} */ (instruction[12]);\n          textKey = /** @type {string} */ (instruction[13]);\n          const pixelRatioScale = [\n            /** @type {number} */ (instruction[14]),\n            /** @type {number} */ (instruction[14]),\n          ];\n\n          const textState = this.textStates[textKey];\n          const font = textState.font;\n          const textScale = [\n            textState.scale[0] * measurePixelRatio,\n            textState.scale[1] * measurePixelRatio,\n          ];\n\n          let cachedWidths;\n          if (font in this.widths_) {\n            cachedWidths = this.widths_[font];\n          } else {\n            cachedWidths = {};\n            this.widths_[font] = cachedWidths;\n          }\n\n          const pathLength = lineStringLength(pixelCoordinates, begin, end, 2);\n          const textLength =\n            Math.abs(textScale[0]) *\n            measureAndCacheTextWidth(font, text, cachedWidths);\n          if (overflow || textLength <= pathLength) {\n            const textAlign = this.textStates[textKey].textAlign;\n            const startM = (pathLength - textLength) * TEXT_ALIGN[textAlign];\n            const parts = drawTextOnPath(\n              pixelCoordinates,\n              begin,\n              end,\n              2,\n              text,\n              startM,\n              maxAngle,\n              Math.abs(textScale[0]),\n              measureAndCacheTextWidth,\n              font,\n              cachedWidths,\n              viewRotationFromTransform ? 0 : this.viewRotation_\n            );\n            if (parts) {\n              let rendered = false;\n              let c, cc, chars, label, part;\n              if (strokeKey) {\n                for (c = 0, cc = parts.length; c < cc; ++c) {\n                  part = parts[c]; // x, y, anchorX, rotation, chunk\n                  chars = /** @type {string} */ (part[4]);\n                  label = this.createLabel(chars, textKey, '', strokeKey);\n                  anchorX = /** @type {number} */ (part[2]) + strokeWidth;\n                  anchorY =\n                    baseline * label.height +\n                    ((0.5 - baseline) * 2 * strokeWidth * textScale[1]) /\n                      textScale[0] -\n                    offsetY;\n                  rendered =\n                    this.replayImageOrLabel_(\n                      context,\n                      contextScale,\n                      /** @type {number} */ (part[0]),\n                      /** @type {number} */ (part[1]),\n                      label,\n                      anchorX,\n                      anchorY,\n                      declutterGroup,\n                      label.height,\n                      1,\n                      0,\n                      0,\n                      /** @type {number} */ (part[3]),\n                      pixelRatioScale,\n                      false,\n                      label.width,\n                      defaultPadding,\n                      null,\n                      null\n                    ) || rendered;\n                }\n              }\n              if (fillKey) {\n                for (c = 0, cc = parts.length; c < cc; ++c) {\n                  part = parts[c]; // x, y, anchorX, rotation, chunk\n                  chars = /** @type {string} */ (part[4]);\n                  label = this.createLabel(chars, textKey, fillKey, '');\n                  anchorX = /** @type {number} */ (part[2]);\n                  anchorY = baseline * label.height - offsetY;\n                  rendered =\n                    this.replayImageOrLabel_(\n                      context,\n                      contextScale,\n                      /** @type {number} */ (part[0]),\n                      /** @type {number} */ (part[1]),\n                      label,\n                      anchorX,\n                      anchorY,\n                      declutterGroup,\n                      label.height,\n                      1,\n                      0,\n                      0,\n                      /** @type {number} */ (part[3]),\n                      pixelRatioScale,\n                      false,\n                      label.width,\n                      defaultPadding,\n                      null,\n                      null\n                    ) || rendered;\n                }\n              }\n              if (rendered) {\n                this.declutterItems.push(this, declutterGroup, feature);\n              }\n            }\n          }\n          ++i;\n          break;\n        case CanvasInstruction.END_GEOMETRY:\n          if (featureCallback !== undefined) {\n            feature = /** @type {import(\"../../Feature.js\").FeatureLike} */ (instruction[1]);\n            const result = featureCallback(feature);\n            if (result) {\n              return result;\n            }\n          }\n          ++i;\n          break;\n        case CanvasInstruction.FILL:\n          if (batchSize) {\n            pendingFill++;\n          } else {\n            this.fill_(context);\n          }\n          ++i;\n          break;\n        case CanvasInstruction.MOVE_TO_LINE_TO:\n          d = /** @type {number} */ (instruction[1]);\n          dd = /** @type {number} */ (instruction[2]);\n          x = pixelCoordinates[d];\n          y = pixelCoordinates[d + 1];\n          roundX = (x + 0.5) | 0;\n          roundY = (y + 0.5) | 0;\n          if (roundX !== prevX || roundY !== prevY) {\n            context.moveTo(x, y);\n            prevX = roundX;\n            prevY = roundY;\n          }\n          for (d += 2; d < dd; d += 2) {\n            x = pixelCoordinates[d];\n            y = pixelCoordinates[d + 1];\n            roundX = (x + 0.5) | 0;\n            roundY = (y + 0.5) | 0;\n            if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {\n              context.lineTo(x, y);\n              prevX = roundX;\n              prevY = roundY;\n            }\n          }\n          ++i;\n          break;\n        case CanvasInstruction.SET_FILL_STYLE:\n          lastFillInstruction = instruction;\n          this.alignFill_ = instruction[2];\n\n          if (pendingFill) {\n            this.fill_(context);\n            pendingFill = 0;\n            if (pendingStroke) {\n              context.stroke();\n              pendingStroke = 0;\n            }\n          }\n\n          context.fillStyle = /** @type {import(\"../../colorlike.js\").ColorLike} */ (instruction[1]);\n          ++i;\n          break;\n        case CanvasInstruction.SET_STROKE_STYLE:\n          lastStrokeInstruction = instruction;\n          if (pendingStroke) {\n            context.stroke();\n            pendingStroke = 0;\n          }\n          this.setStrokeStyle_(context, /** @type {Array<*>} */ (instruction));\n          ++i;\n          break;\n        case CanvasInstruction.STROKE:\n          if (batchSize) {\n            pendingStroke++;\n          } else {\n            context.stroke();\n          }\n          ++i;\n          break;\n        default:\n          ++i; // consume the instruction anyway, to avoid an infinite loop\n          break;\n      }\n    }\n    if (pendingFill) {\n      this.fill_(context);\n    }\n    if (pendingStroke) {\n      context.stroke();\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} contextScale Scale of the context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n   */\n  execute(context, contextScale, transform, viewRotation, snapToPixel) {\n    this.viewRotation_ = viewRotation;\n    this.execute_(\n      context,\n      contextScale,\n      transform,\n      this.instructions,\n      snapToPixel,\n      undefined,\n      undefined\n    );\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {function(import(\"../../Feature.js\").FeatureLike): T=} opt_featureCallback\n   *     Feature callback.\n   * @param {import(\"../../extent.js\").Extent=} opt_hitExtent Only check features that intersect this\n   *     extent.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  executeHitDetection(\n    context,\n    transform,\n    viewRotation,\n    opt_featureCallback,\n    opt_hitExtent\n  ) {\n    this.viewRotation_ = viewRotation;\n    return this.execute_(\n      context,\n      1,\n      transform,\n      this.hitDetectionInstructions,\n      true,\n      opt_featureCallback,\n      opt_hitExtent\n    );\n  }\n}\n\nexport default Executor;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
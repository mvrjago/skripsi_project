{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/webgl/Helper\n */\nimport ContextEventType from '../webgl/ContextEventType.js';\nimport Disposable from '../Disposable.js';\nimport WebGLPostProcessingPass from './PostProcessingPass.js';\nimport { FLOAT, UNSIGNED_BYTE, UNSIGNED_INT, UNSIGNED_SHORT, getContext, getSupportedExtensions } from '../webgl.js';\nimport { assert } from '../asserts.js';\nimport { clear } from '../obj.js';\nimport { compose as composeTransform, create as createTransform, reset as resetTransform, rotate as rotateTransform, scale as scaleTransform } from '../transform.js';\nimport { create, fromTransform } from '../vec/mat4.js';\nimport { getUid } from '../util.js';\nimport { includes } from '../array.js';\n/**\n * @typedef {Object} BufferCacheEntry\n * @property {import(\"./Buffer.js\").default} buffer\n * @property {WebGLBuffer} webGlBuffer\n */\n/**\n * Shader types, either `FRAGMENT_SHADER` or `VERTEX_SHADER`.\n * @enum {number}\n */\nexport var ShaderType = {\n  FRAGMENT_SHADER: 0x8b30,\n  VERTEX_SHADER: 0x8b31\n};\n/**\n * Uniform names used in the default shaders: `PROJECTION_MATRIX`, `OFFSET_SCALE_MATRIX`.\n * and `OFFSET_ROTATION_MATRIX`.\n * @enum {string}\n */\nexport var DefaultUniform = {\n  PROJECTION_MATRIX: 'u_projectionMatrix',\n  OFFSET_SCALE_MATRIX: 'u_offsetScaleMatrix',\n  OFFSET_ROTATION_MATRIX: 'u_offsetRotateMatrix',\n  TIME: 'u_time',\n  ZOOM: 'u_zoom',\n  RESOLUTION: 'u_resolution'\n};\n/**\n * Attribute types, either `UNSIGNED_BYTE`, `UNSIGNED_SHORT`, `UNSIGNED_INT` or `FLOAT`\n * Note: an attribute stored in a `Float32Array` should be of type `FLOAT`.\n * @enum {number}\n */\nexport var AttributeType = {\n  UNSIGNED_BYTE: UNSIGNED_BYTE,\n  UNSIGNED_SHORT: UNSIGNED_SHORT,\n  UNSIGNED_INT: UNSIGNED_INT,\n  FLOAT: FLOAT\n};\n/**\n * Description of an attribute in a buffer\n * @typedef {Object} AttributeDescription\n * @property {string} name Attribute name to use in shaders\n * @property {number} size Number of components per attributes\n * @property {AttributeType} [type] Attribute type, i.e. number of bytes used to store the value. This is\n * determined by the class of typed array which the buffer uses (eg. `Float32Array` for a `FLOAT` attribute).\n * Default is `FLOAT`.\n */\n/**\n * @typedef {number|Array<number>|HTMLCanvasElement|HTMLImageElement|ImageData|import(\"../transform\").Transform} UniformLiteralValue\n */\n/**\n * Uniform value can be a number, array of numbers (2 to 4), canvas element or a callback returning\n * one of the previous types.\n * @typedef {UniformLiteralValue|function(import(\"../PluggableMap.js\").FrameState):UniformLiteralValue} UniformValue\n */\n/**\n * @typedef {Object} PostProcessesOptions\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\n * the main canvas which will then be sampled up (useful for saving resource on blur steps).\n * @property {string} [vertexShader] Vertex shader source\n * @property {string} [fragmentShader] Fragment shader source\n * @property {Object.<string,UniformValue>} [uniforms] Uniform definitions for the post process step\n */\n/**\n * @typedef {Object} Options\n * @property {Object.<string,UniformValue>} [uniforms] Uniform definitions; property names must match the uniform\n * names in the provided or default shaders.\n * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n/**\n * @typedef {Object} UniformInternalDescription\n * @property {string} name Name\n * @property {UniformValue=} value Value\n * @property {WebGLTexture} [texture] Texture\n * @private\n */\n/**\n * @classdesc\n * This class is intended to provide low-level functions related to WebGL rendering, so that accessing\n * directly the WebGL API should not be required anymore.\n *\n * Several operations are handled by the `WebGLHelper` class:\n *\n * ### Define custom shaders and uniforms\n *\n *   *Shaders* are low-level programs executed on the GPU and written in GLSL. There are two types of shaders:\n *\n *   Vertex shaders are used to manipulate the position and attribute of *vertices* of rendered primitives (ie. corners of a square).\n *   Outputs are:\n *\n *   * `gl_Position`: position of the vertex in screen space\n *\n *   * Varyings usually prefixed with `v_` are passed on to the fragment shader\n *\n *   Fragment shaders are used to control the actual color of the pixels drawn on screen. Their only output is `gl_FragColor`.\n *\n *   Both shaders can take *uniforms* or *attributes* as input. Attributes are explained later. Uniforms are common, read-only values that\n *   can be changed at every frame and can be of type float, arrays of float or images.\n *\n *   Shaders must be compiled and assembled into a program like so:\n *   ```js\n *   // here we simply create two shaders and assemble them in a program which is then used\n *   // for subsequent rendering calls\n *   const vertexShader = new WebGLVertex(VERTEX_SHADER);\n *   const fragmentShader = new WebGLFragment(FRAGMENT_SHADER);\n *   const program = this.context.getProgram(fragmentShader, vertexShader);\n *   helper.useProgram(this.program);\n *   ```\n *\n *   Uniforms are defined using the `uniforms` option and can either be explicit values or callbacks taking the frame state as argument.\n *   You can also change their value along the way like so:\n *   ```js\n *   helper.setUniformFloatValue('u_value', valueAsNumber);\n *   ```\n *\n * ### Defining post processing passes\n *\n *   *Post processing* describes the act of rendering primitives to a texture, and then rendering this texture to the final canvas\n *   while applying special effects in screen space.\n *   Typical uses are: blurring, color manipulation, depth of field, filtering...\n *\n *   The `WebGLHelper` class offers the possibility to define post processes at creation time using the `postProcesses` option.\n *   A post process step accepts the following options:\n *\n *   * `fragmentShader` and `vertexShader`: text literals in GLSL language that will be compiled and used in the post processing step.\n *   * `uniforms`: uniforms can be defined for the post processing steps just like for the main render.\n *   * `scaleRatio`: allows using an intermediate texture smaller or higher than the final canvas in the post processing step.\n *     This is typically used in blur steps to reduce the performance overhead by using an already downsampled texture as input.\n *\n *   The {@link module:ol/webgl/PostProcessingPass~WebGLPostProcessingPass} class is used internally, refer to its documentation for more info.\n *\n * ### Binding WebGL buffers and flushing data into them\n *\n *   Data that must be passed to the GPU has to be transferred using {@link module:ol/webgl/Buffer~WebGLArrayBuffer} objects.\n *   A buffer has to be created only once, but must be bound every time the buffer content will be used for rendering.\n *   This is done using {@link bindBuffer}.\n *   When the buffer's array content has changed, the new data has to be flushed to the GPU memory; this is done using\n *   {@link flushBufferData}. Note: this operation is expensive and should be done as infrequently as possible.\n *\n *   When binding an array buffer, a `target` parameter must be given: it should be either {@link module:ol/webgl.ARRAY_BUFFER}\n *   (if the buffer contains vertices data) or {@link module:ol/webgl.ELEMENT_ARRAY_BUFFER} (if the buffer contains indices data).\n *\n *   Examples below:\n *   ```js\n *   // at initialization phase\n *   const verticesBuffer = new WebGLArrayBuffer([], DYNAMIC_DRAW);\n *   const indicesBuffer = new WebGLArrayBuffer([], DYNAMIC_DRAW);\n *\n *   // when array values have changed\n *   helper.flushBufferData(ARRAY_BUFFER, this.verticesBuffer);\n *   helper.flushBufferData(ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\n *\n *   // at rendering phase\n *   helper.bindBuffer(ARRAY_BUFFER, this.verticesBuffer);\n *   helper.bindBuffer(ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\n *   ```\n *\n * ### Specifying attributes\n *\n *   The GPU only receives the data as arrays of numbers. These numbers must be handled differently depending on what it describes (position, texture coordinate...).\n *   Attributes are used to specify these uses. Use {@link enableAttributeArray_} and either\n *   the default attribute names in {@link module:ol/webgl/Helper.DefaultAttrib} or custom ones.\n *\n *   Please note that you will have to specify the type and offset of the attributes in the data array. You can refer to the documentation of [WebGLRenderingContext.vertexAttribPointer](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer) for more explanation.\n *   ```js\n *   // here we indicate that the data array has the following structure:\n *   // [posX, posY, offsetX, offsetY, texCoordU, texCoordV, posX, posY, ...]\n *   helper.enableAttributes([\n *     {\n *        name: 'a_position',\n *        size: 2\n *     },\n *     {\n *       name: 'a_offset',\n *       size: 2\n *     },\n *     {\n *       name: 'a_texCoord',\n *       size: 2\n *     }\n *   ])\n *   ```\n *\n * ### Rendering primitives\n *\n *   Once all the steps above have been achieved, rendering primitives to the screen is done using {@link prepareDraw}, {@link drawElements} and {@link finalizeDraw}.\n *   ```js\n *   // frame preparation step\n *   helper.prepareDraw(frameState);\n *\n *   // call this for every data array that has to be rendered on screen\n *   helper.drawElements(0, this.indicesBuffer.getArray().length);\n *\n *   // finalize the rendering by applying post processes\n *   helper.finalizeDraw(frameState);\n *   ```\n *\n * For an example usage of this class, refer to {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.\n *\n *\n * @api\n */\nvar WebGLHelper = /** @class */function (_super) {\n  __extends(WebGLHelper, _super);\n  /**\n   * @param {Options=} opt_options Options.\n   */\n  function WebGLHelper(opt_options) {\n    var _this = _super.call(this) || this;\n    var options = opt_options || {};\n    /** @private */\n    _this.boundHandleWebGLContextLost_ = _this.handleWebGLContextLost.bind(_this);\n    /** @private */\n    _this.boundHandleWebGLContextRestored_ = _this.handleWebGLContextRestored.bind(_this);\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    _this.canvas_ = document.createElement('canvas');\n    _this.canvas_.style.position = 'absolute';\n    _this.canvas_.style.left = '0';\n    /**\n     * @private\n     * @type {WebGLRenderingContext}\n     */\n    _this.gl_ = getContext(_this.canvas_);\n    var gl = _this.getGL();\n    /**\n     * @private\n     * @type {!Object<string, BufferCacheEntry>}\n     */\n    _this.bufferCache_ = {};\n    /**\n     * @private\n     * @type {WebGLProgram}\n     */\n    _this.currentProgram_ = null;\n    assert(includes(getSupportedExtensions(), 'OES_element_index_uint'), 63);\n    gl.getExtension('OES_element_index_uint');\n    _this.canvas_.addEventListener(ContextEventType.LOST, _this.boundHandleWebGLContextLost_);\n    _this.canvas_.addEventListener(ContextEventType.RESTORED, _this.boundHandleWebGLContextRestored_);\n    /**\n     * @private\n     * @type {import(\"../transform.js\").Transform}\n     */\n    _this.offsetRotateMatrix_ = createTransform();\n    /**\n     * @private\n     * @type {import(\"../transform.js\").Transform}\n     */\n    _this.offsetScaleMatrix_ = createTransform();\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    _this.tmpMat4_ = create();\n    /**\n     * @private\n     * @type {Object.<string, WebGLUniformLocation>}\n     */\n    _this.uniformLocations_ = {};\n    /**\n     * @private\n     * @type {Object.<string, number>}\n     */\n    _this.attribLocations_ = {};\n    /**\n     * Holds info about custom uniforms used in the post processing pass.\n     * If the uniform is a texture, the WebGL Texture object will be stored here.\n     * @type {Array<UniformInternalDescription>}\n     * @private\n     */\n    _this.uniforms_ = [];\n    if (options.uniforms) {\n      for (var name_1 in options.uniforms) {\n        _this.uniforms_.push({\n          name: name_1,\n          value: options.uniforms[name_1]\n        });\n      }\n    }\n    /**\n     * An array of PostProcessingPass objects is kept in this variable, built from the steps provided in the\n     * options. If no post process was given, a default one is used (so as not to have to make an exception to\n     * the frame buffer logic).\n     * @type {Array<WebGLPostProcessingPass>}\n     * @private\n     */\n    _this.postProcessPasses_ = options.postProcesses ? options.postProcesses.map(function (options) {\n      return new WebGLPostProcessingPass({\n        webGlContext: gl,\n        scaleRatio: options.scaleRatio,\n        vertexShader: options.vertexShader,\n        fragmentShader: options.fragmentShader,\n        uniforms: options.uniforms\n      });\n    }) : [new WebGLPostProcessingPass({\n      webGlContext: gl\n    })];\n    /**\n     * @type {string|null}\n     * @private\n     */\n    _this.shaderCompileErrors_ = null;\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.startTime_ = Date.now();\n    return _this;\n  }\n  /**\n   * Just bind the buffer if it's in the cache. Otherwise create\n   * the WebGL buffer, bind it, populate it, and add an entry to\n   * the cache.\n   * @param {import(\"./Buffer\").default} buffer Buffer.\n   * @api\n   */\n  WebGLHelper.prototype.bindBuffer = function (buffer) {\n    var gl = this.getGL();\n    var bufferKey = getUid(buffer);\n    var bufferCache = this.bufferCache_[bufferKey];\n    if (!bufferCache) {\n      var webGlBuffer = gl.createBuffer();\n      bufferCache = {\n        buffer: buffer,\n        webGlBuffer: webGlBuffer\n      };\n      this.bufferCache_[bufferKey] = bufferCache;\n    }\n    gl.bindBuffer(buffer.getType(), bufferCache.webGlBuffer);\n  };\n  /**\n   * Update the data contained in the buffer array; this is required for the\n   * new data to be rendered\n   * @param {import(\"./Buffer\").default} buffer Buffer.\n   * @api\n   */\n  WebGLHelper.prototype.flushBufferData = function (buffer) {\n    var gl = this.getGL();\n    this.bindBuffer(buffer);\n    gl.bufferData(buffer.getType(), buffer.getArray(), buffer.getUsage());\n  };\n  /**\n   * @param {import(\"./Buffer.js\").default} buf Buffer.\n   */\n  WebGLHelper.prototype.deleteBuffer = function (buf) {\n    var gl = this.getGL();\n    var bufferKey = getUid(buf);\n    var bufferCacheEntry = this.bufferCache_[bufferKey];\n    if (!gl.isContextLost()) {\n      gl.deleteBuffer(bufferCacheEntry.buffer);\n    }\n    delete this.bufferCache_[bufferKey];\n  };\n  /**\n   * Clean up.\n   */\n  WebGLHelper.prototype.disposeInternal = function () {\n    this.canvas_.removeEventListener(ContextEventType.LOST, this.boundHandleWebGLContextLost_);\n    this.canvas_.removeEventListener(ContextEventType.RESTORED, this.boundHandleWebGLContextRestored_);\n  };\n  /**\n   * Clear the buffer & set the viewport to draw.\n   * Post process passes will be initialized here, the first one being bound as a render target for\n   * subsequent draw calls.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState current frame state\n   * @api\n   */\n  WebGLHelper.prototype.prepareDraw = function (frameState) {\n    var gl = this.getGL();\n    var canvas = this.getCanvas();\n    var size = frameState.size;\n    var pixelRatio = frameState.pixelRatio;\n    canvas.width = size[0] * pixelRatio;\n    canvas.height = size[1] * pixelRatio;\n    canvas.style.width = size[0] + 'px';\n    canvas.style.height = size[1] + 'px';\n    gl.useProgram(this.currentProgram_);\n    // loop backwards in post processes list\n    for (var i = this.postProcessPasses_.length - 1; i >= 0; i--) {\n      this.postProcessPasses_[i].init(frameState);\n    }\n    gl.bindTexture(gl.TEXTURE_2D, null);\n    gl.clearColor(0.0, 0.0, 0.0, 0.0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n    gl.useProgram(this.currentProgram_);\n    this.applyFrameState(frameState);\n    this.applyUniforms(frameState);\n  };\n  /**\n   * Clear the render target & bind it for future draw operations.\n   * This is similar to `prepareDraw`, only post processes will not be applied.\n   * Note: the whole viewport will be drawn to the render target, regardless of its size.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState current frame state\n   * @param {import(\"./RenderTarget.js\").default} renderTarget Render target to draw to\n   * @param {boolean} [opt_disableAlphaBlend] If true, no alpha blending will happen.\n   */\n  WebGLHelper.prototype.prepareDrawToRenderTarget = function (frameState, renderTarget, opt_disableAlphaBlend) {\n    var gl = this.getGL();\n    var size = renderTarget.getSize();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget.getFramebuffer());\n    gl.viewport(0, 0, size[0], size[1]);\n    gl.bindTexture(gl.TEXTURE_2D, renderTarget.getTexture());\n    gl.clearColor(0.0, 0.0, 0.0, 0.0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.ONE, opt_disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA);\n    gl.useProgram(this.currentProgram_);\n    this.applyFrameState(frameState);\n    this.applyUniforms(frameState);\n  };\n  /**\n   * Execute a draw call based on the currently bound program, texture, buffers, attributes.\n   * @param {number} start Start index.\n   * @param {number} end End index.\n   * @api\n   */\n  WebGLHelper.prototype.drawElements = function (start, end) {\n    var gl = this.getGL();\n    var elementType = gl.UNSIGNED_INT;\n    var elementSize = 4;\n    var numItems = end - start;\n    var offsetInBytes = start * elementSize;\n    gl.drawElements(gl.TRIANGLES, numItems, elementType, offsetInBytes);\n  };\n  /**\n   * Apply the successive post process passes which will eventually render to the actual canvas.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState current frame state\n   * @api\n   */\n  WebGLHelper.prototype.finalizeDraw = function (frameState) {\n    // apply post processes using the next one as target\n    for (var i = 0; i < this.postProcessPasses_.length; i++) {\n      this.postProcessPasses_[i].apply(frameState, this.postProcessPasses_[i + 1] || null);\n    }\n  };\n  /**\n   * @return {HTMLCanvasElement} Canvas.\n   * @api\n   */\n  WebGLHelper.prototype.getCanvas = function () {\n    return this.canvas_;\n  };\n  /**\n   * Get the WebGL rendering context\n   * @return {WebGLRenderingContext} The rendering context.\n   * @api\n   */\n  WebGLHelper.prototype.getGL = function () {\n    return this.gl_;\n  };\n  /**\n   * Sets the default matrix uniforms for a given frame state. This is called internally in `prepareDraw`.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n   * @private\n   */\n  WebGLHelper.prototype.applyFrameState = function (frameState) {\n    var size = frameState.size;\n    var rotation = frameState.viewState.rotation;\n    var offsetScaleMatrix = resetTransform(this.offsetScaleMatrix_);\n    scaleTransform(offsetScaleMatrix, 2 / size[0], 2 / size[1]);\n    var offsetRotateMatrix = resetTransform(this.offsetRotateMatrix_);\n    if (rotation !== 0) {\n      rotateTransform(offsetRotateMatrix, -rotation);\n    }\n    this.setUniformMatrixValue(DefaultUniform.OFFSET_SCALE_MATRIX, fromTransform(this.tmpMat4_, offsetScaleMatrix));\n    this.setUniformMatrixValue(DefaultUniform.OFFSET_ROTATION_MATRIX, fromTransform(this.tmpMat4_, offsetRotateMatrix));\n    this.setUniformFloatValue(DefaultUniform.TIME, (Date.now() - this.startTime_) * 0.001);\n    this.setUniformFloatValue(DefaultUniform.ZOOM, frameState.viewState.zoom);\n    this.setUniformFloatValue(DefaultUniform.RESOLUTION, frameState.viewState.resolution);\n  };\n  /**\n   * Sets the custom uniforms based on what was given in the constructor. This is called internally in `prepareDraw`.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n   * @private\n   */\n  WebGLHelper.prototype.applyUniforms = function (frameState) {\n    var gl = this.getGL();\n    var value;\n    var textureSlot = 0;\n    this.uniforms_.forEach(function (uniform) {\n      value = typeof uniform.value === 'function' ? uniform.value(frameState) : uniform.value;\n      // apply value based on type\n      if (value instanceof HTMLCanvasElement || value instanceof HTMLImageElement || value instanceof ImageData) {\n        // create a texture & put data\n        if (!uniform.texture) {\n          uniform.prevValue = undefined;\n          uniform.texture = gl.createTexture();\n        }\n        gl.activeTexture(gl[\"TEXTURE\" + textureSlot]);\n        gl.bindTexture(gl.TEXTURE_2D, uniform.texture);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        var imageReady = !(value instanceof HTMLImageElement) || /** @type {HTMLImageElement} */value.complete;\n        if (imageReady && uniform.prevValue !== value) {\n          uniform.prevValue = value;\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, value);\n        }\n        // fill texture slots by increasing index\n        gl.uniform1i(this.getUniformLocation(uniform.name), textureSlot++);\n      } else if (Array.isArray(value) && value.length === 6) {\n        this.setUniformMatrixValue(uniform.name, fromTransform(this.tmpMat4_, value));\n      } else if (Array.isArray(value) && value.length <= 4) {\n        switch (value.length) {\n          case 2:\n            gl.uniform2f(this.getUniformLocation(uniform.name), value[0], value[1]);\n            return;\n          case 3:\n            gl.uniform3f(this.getUniformLocation(uniform.name), value[0], value[1], value[2]);\n            return;\n          case 4:\n            gl.uniform4f(this.getUniformLocation(uniform.name), value[0], value[1], value[2], value[3]);\n            return;\n          default:\n            return;\n        }\n      } else if (typeof value === 'number') {\n        gl.uniform1f(this.getUniformLocation(uniform.name), value);\n      }\n    }.bind(this));\n  };\n  /**\n   * Use a program.  If the program is already in use, this will return `false`.\n   * @param {WebGLProgram} program Program.\n   * @return {boolean} Changed.\n   * @api\n   */\n  WebGLHelper.prototype.useProgram = function (program) {\n    if (program == this.currentProgram_) {\n      return false;\n    } else {\n      var gl = this.getGL();\n      gl.useProgram(program);\n      this.currentProgram_ = program;\n      this.uniformLocations_ = {};\n      this.attribLocations_ = {};\n      return true;\n    }\n  };\n  /**\n   * Will attempt to compile a vertex or fragment shader based on source\n   * On error, the shader will be returned but\n   * `gl.getShaderParameter(shader, gl.COMPILE_STATUS)` will return `true`\n   * Use `gl.getShaderInfoLog(shader)` to have details\n   * @param {string} source Shader source\n   * @param {ShaderType} type VERTEX_SHADER or FRAGMENT_SHADER\n   * @return {WebGLShader} Shader object\n   */\n  WebGLHelper.prototype.compileShader = function (source, type) {\n    var gl = this.getGL();\n    var shader = gl.createShader(type);\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n    return shader;\n  };\n  /**\n   * Create a program for a vertex and fragment shader. The shaders compilation may have failed:\n   * use `WebGLHelper.getShaderCompileErrors()`to have details if any.\n   * @param {string} fragmentShaderSource Fragment shader source.\n   * @param {string} vertexShaderSource Vertex shader source.\n   * @return {WebGLProgram} Program\n   * @api\n   */\n  WebGLHelper.prototype.getProgram = function (fragmentShaderSource, vertexShaderSource) {\n    var gl = this.getGL();\n    var fragmentShader = this.compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);\n    var vertexShader = this.compileShader(vertexShaderSource, gl.VERTEX_SHADER);\n    this.shaderCompileErrors_ = null;\n    if (gl.getShaderInfoLog(fragmentShader)) {\n      this.shaderCompileErrors_ = \"Fragment shader compilation failed:\\n\" + gl.getShaderInfoLog(fragmentShader);\n    }\n    if (gl.getShaderInfoLog(vertexShader)) {\n      this.shaderCompileErrors_ = (this.shaderCompileErrors_ || '') + (\"Vertex shader compilation failed:\\n\" + gl.getShaderInfoLog(vertexShader));\n    }\n    var program = gl.createProgram();\n    gl.attachShader(program, fragmentShader);\n    gl.attachShader(program, vertexShader);\n    gl.linkProgram(program);\n    return program;\n  };\n  /**\n   * Will return the last shader compilation errors. If no error happened, will return null;\n   * @return {string|null} Errors description, or null if last compilation was successful\n   * @api\n   */\n  WebGLHelper.prototype.getShaderCompileErrors = function () {\n    return this.shaderCompileErrors_;\n  };\n  /**\n   * Will get the location from the shader or the cache\n   * @param {string} name Uniform name\n   * @return {WebGLUniformLocation} uniformLocation\n   * @api\n   */\n  WebGLHelper.prototype.getUniformLocation = function (name) {\n    if (this.uniformLocations_[name] === undefined) {\n      this.uniformLocations_[name] = this.getGL().getUniformLocation(this.currentProgram_, name);\n    }\n    return this.uniformLocations_[name];\n  };\n  /**\n   * Will get the location from the shader or the cache\n   * @param {string} name Attribute name\n   * @return {number} attribLocation\n   * @api\n   */\n  WebGLHelper.prototype.getAttributeLocation = function (name) {\n    if (this.attribLocations_[name] === undefined) {\n      this.attribLocations_[name] = this.getGL().getAttribLocation(this.currentProgram_, name);\n    }\n    return this.attribLocations_[name];\n  };\n  /**\n   * Modifies the given transform to apply the rotation/translation/scaling of the given frame state.\n   * The resulting transform can be used to convert world space coordinates to view coordinates.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {import(\"../transform\").Transform} transform Transform to update.\n   * @return {import(\"../transform\").Transform} The updated transform object.\n   * @api\n   */\n  WebGLHelper.prototype.makeProjectionTransform = function (frameState, transform) {\n    var size = frameState.size;\n    var rotation = frameState.viewState.rotation;\n    var resolution = frameState.viewState.resolution;\n    var center = frameState.viewState.center;\n    resetTransform(transform);\n    composeTransform(transform, 0, 0, 2 / (resolution * size[0]), 2 / (resolution * size[1]), -rotation, -center[0], -center[1]);\n    return transform;\n  };\n  /**\n   * Give a value for a standard float uniform\n   * @param {string} uniform Uniform name\n   * @param {number} value Value\n   * @api\n   */\n  WebGLHelper.prototype.setUniformFloatValue = function (uniform, value) {\n    this.getGL().uniform1f(this.getUniformLocation(uniform), value);\n  };\n  /**\n   * Give a value for a standard matrix4 uniform\n   * @param {string} uniform Uniform name\n   * @param {Array<number>} value Matrix value\n   * @api\n   */\n  WebGLHelper.prototype.setUniformMatrixValue = function (uniform, value) {\n    this.getGL().uniformMatrix4fv(this.getUniformLocation(uniform), false, value);\n  };\n  /**\n   * Will set the currently bound buffer to an attribute of the shader program. Used by `#enableAttributes`\n   * internally.\n   * @param {string} attribName Attribute name\n   * @param {number} size Number of components per attributes\n   * @param {number} type UNSIGNED_INT, UNSIGNED_BYTE, UNSIGNED_SHORT or FLOAT\n   * @param {number} stride Stride in bytes (0 means attribs are packed)\n   * @param {number} offset Offset in bytes\n   * @private\n   */\n  WebGLHelper.prototype.enableAttributeArray_ = function (attribName, size, type, stride, offset) {\n    var location = this.getAttributeLocation(attribName);\n    // the attribute has not been found in the shaders; do not enable it\n    if (location < 0) {\n      return;\n    }\n    this.getGL().enableVertexAttribArray(location);\n    this.getGL().vertexAttribPointer(location, size, type, false, stride, offset);\n  };\n  /**\n   * Will enable the following attributes to be read from the currently bound buffer,\n   * i.e. tell the GPU where to read the different attributes in the buffer. An error in the\n   * size/type/order of attributes will most likely break the rendering and throw a WebGL exception.\n   * @param {Array<AttributeDescription>} attributes Ordered list of attributes to read from the buffer\n   * @api\n   */\n  WebGLHelper.prototype.enableAttributes = function (attributes) {\n    var stride = computeAttributesStride(attributes);\n    var offset = 0;\n    for (var i = 0; i < attributes.length; i++) {\n      var attr = attributes[i];\n      this.enableAttributeArray_(attr.name, attr.size, attr.type || FLOAT, stride, offset);\n      offset += attr.size * getByteSizeFromType(attr.type);\n    }\n  };\n  /**\n   * WebGL context was lost\n   * @private\n   */\n  WebGLHelper.prototype.handleWebGLContextLost = function () {\n    clear(this.bufferCache_);\n    this.currentProgram_ = null;\n  };\n  /**\n   * WebGL context was restored\n   * @private\n   */\n  WebGLHelper.prototype.handleWebGLContextRestored = function () {};\n  /**\n   * Will create or reuse a given webgl texture and apply the given size. If no image data\n   * specified, the texture will be empty, otherwise image data will be used and the `size`\n   * parameter will be ignored.\n   * Note: wrap parameters are set to clamp to edge, min filter is set to linear.\n   * @param {Array<number>} size Expected size of the texture\n   * @param {ImageData|HTMLImageElement|HTMLCanvasElement} [opt_data] Image data/object to bind to the texture\n   * @param {WebGLTexture} [opt_texture] Existing texture to reuse\n   * @return {WebGLTexture} The generated texture\n   * @api\n   */\n  WebGLHelper.prototype.createTexture = function (size, opt_data, opt_texture) {\n    var gl = this.getGL();\n    var texture = opt_texture || gl.createTexture();\n    // set params & size\n    var level = 0;\n    var internalFormat = gl.RGBA;\n    var border = 0;\n    var format = gl.RGBA;\n    var type = gl.UNSIGNED_BYTE;\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    if (opt_data) {\n      gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, format, type, opt_data);\n    } else {\n      gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, size[0], size[1], border, format, type, null);\n    }\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    return texture;\n  };\n  return WebGLHelper;\n}(Disposable);\n/**\n * Compute a stride in bytes based on a list of attributes\n * @param {Array<AttributeDescription>} attributes Ordered list of attributes\n * @returns {number} Stride, ie amount of values for each vertex in the vertex buffer\n * @api\n */\nexport function computeAttributesStride(attributes) {\n  var stride = 0;\n  for (var i = 0; i < attributes.length; i++) {\n    var attr = attributes[i];\n    stride += attr.size * getByteSizeFromType(attr.type);\n  }\n  return stride;\n}\n/**\n * Computes the size in byte of an attribute type.\n * @param {AttributeType} type Attribute type\n * @returns {number} The size in bytes\n */\nfunction getByteSizeFromType(type) {\n  switch (type) {\n    case AttributeType.UNSIGNED_BYTE:\n      return Uint8Array.BYTES_PER_ELEMENT;\n    case AttributeType.UNSIGNED_SHORT:\n      return Uint16Array.BYTES_PER_ELEMENT;\n    case AttributeType.UNSIGNED_INT:\n      return Uint32Array.BYTES_PER_ELEMENT;\n    case AttributeType.FLOAT:\n    default:\n      return Float32Array.BYTES_PER_ELEMENT;\n  }\n}\nexport default WebGLHelper;","map":{"version":3,"names":["ContextEventType","Disposable","WebGLPostProcessingPass","FLOAT","UNSIGNED_BYTE","UNSIGNED_INT","UNSIGNED_SHORT","getContext","getSupportedExtensions","assert","clear","compose","composeTransform","create","createTransform","reset","resetTransform","rotate","rotateTransform","scale","scaleTransform","fromTransform","getUid","includes","ShaderType","FRAGMENT_SHADER","VERTEX_SHADER","DefaultUniform","PROJECTION_MATRIX","OFFSET_SCALE_MATRIX","OFFSET_ROTATION_MATRIX","TIME","ZOOM","RESOLUTION","AttributeType","WebGLHelper","_super","__extends","opt_options","_this","call","options","boundHandleWebGLContextLost_","handleWebGLContextLost","bind","boundHandleWebGLContextRestored_","handleWebGLContextRestored","canvas_","document","createElement","style","position","left","gl_","gl","getGL","bufferCache_","currentProgram_","getExtension","addEventListener","LOST","RESTORED","offsetRotateMatrix_","offsetScaleMatrix_","tmpMat4_","uniformLocations_","attribLocations_","uniforms_","uniforms","name_1","push","name","value","postProcessPasses_","postProcesses","map","webGlContext","scaleRatio","vertexShader","fragmentShader","shaderCompileErrors_","startTime_","Date","now","prototype","bindBuffer","buffer","bufferKey","bufferCache","webGlBuffer","createBuffer","getType","flushBufferData","bufferData","getArray","getUsage","deleteBuffer","buf","bufferCacheEntry","isContextLost","disposeInternal","removeEventListener","prepareDraw","frameState","canvas","getCanvas","size","pixelRatio","width","height","useProgram","i","length","init","bindTexture","TEXTURE_2D","clearColor","COLOR_BUFFER_BIT","enable","BLEND","blendFunc","ONE","ONE_MINUS_SRC_ALPHA","applyFrameState","applyUniforms","prepareDrawToRenderTarget","renderTarget","opt_disableAlphaBlend","getSize","bindFramebuffer","FRAMEBUFFER","getFramebuffer","viewport","getTexture","ZERO","drawElements","start","end","elementType","elementSize","numItems","offsetInBytes","TRIANGLES","finalizeDraw","apply","rotation","viewState","offsetScaleMatrix","offsetRotateMatrix","setUniformMatrixValue","setUniformFloatValue","zoom","resolution","textureSlot","forEach","uniform","HTMLCanvasElement","HTMLImageElement","ImageData","texture","prevValue","undefined","createTexture","activeTexture","texParameteri","TEXTURE_MIN_FILTER","LINEAR","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","imageReady","complete","texImage2D","RGBA","uniform1i","getUniformLocation","Array","isArray","uniform2f","uniform3f","uniform4f","uniform1f","program","compileShader","source","type","shader","createShader","shaderSource","getProgram","fragmentShaderSource","vertexShaderSource","getShaderInfoLog","createProgram","attachShader","linkProgram","getShaderCompileErrors","getAttributeLocation","getAttribLocation","makeProjectionTransform","transform","center","uniformMatrix4fv","enableAttributeArray_","attribName","stride","offset","location","enableVertexAttribArray","vertexAttribPointer","enableAttributes","attributes","computeAttributesStride","attr","getByteSizeFromType","opt_data","opt_texture","level","internalFormat","border","format","Uint8Array","BYTES_PER_ELEMENT","Uint16Array","Uint32Array","Float32Array"],"sources":["/Users/mariovicky/Skripsi_OpenLayers/node_modules/ol/src/webgl/Helper.js"],"sourcesContent":["/**\n * @module ol/webgl/Helper\n */\nimport ContextEventType from '../webgl/ContextEventType.js';\nimport Disposable from '../Disposable.js';\nimport WebGLPostProcessingPass from './PostProcessingPass.js';\nimport {\n  FLOAT,\n  UNSIGNED_BYTE,\n  UNSIGNED_INT,\n  UNSIGNED_SHORT,\n  getContext,\n  getSupportedExtensions,\n} from '../webgl.js';\nimport {assert} from '../asserts.js';\nimport {clear} from '../obj.js';\nimport {\n  compose as composeTransform,\n  create as createTransform,\n  reset as resetTransform,\n  rotate as rotateTransform,\n  scale as scaleTransform,\n} from '../transform.js';\nimport {create, fromTransform} from '../vec/mat4.js';\nimport {getUid} from '../util.js';\nimport {includes} from '../array.js';\n\n/**\n * @typedef {Object} BufferCacheEntry\n * @property {import(\"./Buffer.js\").default} buffer\n * @property {WebGLBuffer} webGlBuffer\n */\n\n/**\n * Shader types, either `FRAGMENT_SHADER` or `VERTEX_SHADER`.\n * @enum {number}\n */\nexport const ShaderType = {\n  FRAGMENT_SHADER: 0x8b30,\n  VERTEX_SHADER: 0x8b31,\n};\n\n/**\n * Uniform names used in the default shaders: `PROJECTION_MATRIX`, `OFFSET_SCALE_MATRIX`.\n * and `OFFSET_ROTATION_MATRIX`.\n * @enum {string}\n */\nexport const DefaultUniform = {\n  PROJECTION_MATRIX: 'u_projectionMatrix',\n  OFFSET_SCALE_MATRIX: 'u_offsetScaleMatrix',\n  OFFSET_ROTATION_MATRIX: 'u_offsetRotateMatrix',\n  TIME: 'u_time',\n  ZOOM: 'u_zoom',\n  RESOLUTION: 'u_resolution',\n};\n\n/**\n * Attribute types, either `UNSIGNED_BYTE`, `UNSIGNED_SHORT`, `UNSIGNED_INT` or `FLOAT`\n * Note: an attribute stored in a `Float32Array` should be of type `FLOAT`.\n * @enum {number}\n */\nexport const AttributeType = {\n  UNSIGNED_BYTE: UNSIGNED_BYTE,\n  UNSIGNED_SHORT: UNSIGNED_SHORT,\n  UNSIGNED_INT: UNSIGNED_INT,\n  FLOAT: FLOAT,\n};\n\n/**\n * Description of an attribute in a buffer\n * @typedef {Object} AttributeDescription\n * @property {string} name Attribute name to use in shaders\n * @property {number} size Number of components per attributes\n * @property {AttributeType} [type] Attribute type, i.e. number of bytes used to store the value. This is\n * determined by the class of typed array which the buffer uses (eg. `Float32Array` for a `FLOAT` attribute).\n * Default is `FLOAT`.\n */\n\n/**\n * @typedef {number|Array<number>|HTMLCanvasElement|HTMLImageElement|ImageData|import(\"../transform\").Transform} UniformLiteralValue\n */\n\n/**\n * Uniform value can be a number, array of numbers (2 to 4), canvas element or a callback returning\n * one of the previous types.\n * @typedef {UniformLiteralValue|function(import(\"../PluggableMap.js\").FrameState):UniformLiteralValue} UniformValue\n */\n\n/**\n * @typedef {Object} PostProcessesOptions\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\n * the main canvas which will then be sampled up (useful for saving resource on blur steps).\n * @property {string} [vertexShader] Vertex shader source\n * @property {string} [fragmentShader] Fragment shader source\n * @property {Object.<string,UniformValue>} [uniforms] Uniform definitions for the post process step\n */\n\n/**\n * @typedef {Object} Options\n * @property {Object.<string,UniformValue>} [uniforms] Uniform definitions; property names must match the uniform\n * names in the provided or default shaders.\n * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n\n/**\n * @typedef {Object} UniformInternalDescription\n * @property {string} name Name\n * @property {UniformValue=} value Value\n * @property {WebGLTexture} [texture] Texture\n * @private\n */\n\n/**\n * @classdesc\n * This class is intended to provide low-level functions related to WebGL rendering, so that accessing\n * directly the WebGL API should not be required anymore.\n *\n * Several operations are handled by the `WebGLHelper` class:\n *\n * ### Define custom shaders and uniforms\n *\n *   *Shaders* are low-level programs executed on the GPU and written in GLSL. There are two types of shaders:\n *\n *   Vertex shaders are used to manipulate the position and attribute of *vertices* of rendered primitives (ie. corners of a square).\n *   Outputs are:\n *\n *   * `gl_Position`: position of the vertex in screen space\n *\n *   * Varyings usually prefixed with `v_` are passed on to the fragment shader\n *\n *   Fragment shaders are used to control the actual color of the pixels drawn on screen. Their only output is `gl_FragColor`.\n *\n *   Both shaders can take *uniforms* or *attributes* as input. Attributes are explained later. Uniforms are common, read-only values that\n *   can be changed at every frame and can be of type float, arrays of float or images.\n *\n *   Shaders must be compiled and assembled into a program like so:\n *   ```js\n *   // here we simply create two shaders and assemble them in a program which is then used\n *   // for subsequent rendering calls\n *   const vertexShader = new WebGLVertex(VERTEX_SHADER);\n *   const fragmentShader = new WebGLFragment(FRAGMENT_SHADER);\n *   const program = this.context.getProgram(fragmentShader, vertexShader);\n *   helper.useProgram(this.program);\n *   ```\n *\n *   Uniforms are defined using the `uniforms` option and can either be explicit values or callbacks taking the frame state as argument.\n *   You can also change their value along the way like so:\n *   ```js\n *   helper.setUniformFloatValue('u_value', valueAsNumber);\n *   ```\n *\n * ### Defining post processing passes\n *\n *   *Post processing* describes the act of rendering primitives to a texture, and then rendering this texture to the final canvas\n *   while applying special effects in screen space.\n *   Typical uses are: blurring, color manipulation, depth of field, filtering...\n *\n *   The `WebGLHelper` class offers the possibility to define post processes at creation time using the `postProcesses` option.\n *   A post process step accepts the following options:\n *\n *   * `fragmentShader` and `vertexShader`: text literals in GLSL language that will be compiled and used in the post processing step.\n *   * `uniforms`: uniforms can be defined for the post processing steps just like for the main render.\n *   * `scaleRatio`: allows using an intermediate texture smaller or higher than the final canvas in the post processing step.\n *     This is typically used in blur steps to reduce the performance overhead by using an already downsampled texture as input.\n *\n *   The {@link module:ol/webgl/PostProcessingPass~WebGLPostProcessingPass} class is used internally, refer to its documentation for more info.\n *\n * ### Binding WebGL buffers and flushing data into them\n *\n *   Data that must be passed to the GPU has to be transferred using {@link module:ol/webgl/Buffer~WebGLArrayBuffer} objects.\n *   A buffer has to be created only once, but must be bound every time the buffer content will be used for rendering.\n *   This is done using {@link bindBuffer}.\n *   When the buffer's array content has changed, the new data has to be flushed to the GPU memory; this is done using\n *   {@link flushBufferData}. Note: this operation is expensive and should be done as infrequently as possible.\n *\n *   When binding an array buffer, a `target` parameter must be given: it should be either {@link module:ol/webgl.ARRAY_BUFFER}\n *   (if the buffer contains vertices data) or {@link module:ol/webgl.ELEMENT_ARRAY_BUFFER} (if the buffer contains indices data).\n *\n *   Examples below:\n *   ```js\n *   // at initialization phase\n *   const verticesBuffer = new WebGLArrayBuffer([], DYNAMIC_DRAW);\n *   const indicesBuffer = new WebGLArrayBuffer([], DYNAMIC_DRAW);\n *\n *   // when array values have changed\n *   helper.flushBufferData(ARRAY_BUFFER, this.verticesBuffer);\n *   helper.flushBufferData(ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\n *\n *   // at rendering phase\n *   helper.bindBuffer(ARRAY_BUFFER, this.verticesBuffer);\n *   helper.bindBuffer(ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\n *   ```\n *\n * ### Specifying attributes\n *\n *   The GPU only receives the data as arrays of numbers. These numbers must be handled differently depending on what it describes (position, texture coordinate...).\n *   Attributes are used to specify these uses. Use {@link enableAttributeArray_} and either\n *   the default attribute names in {@link module:ol/webgl/Helper.DefaultAttrib} or custom ones.\n *\n *   Please note that you will have to specify the type and offset of the attributes in the data array. You can refer to the documentation of [WebGLRenderingContext.vertexAttribPointer](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer) for more explanation.\n *   ```js\n *   // here we indicate that the data array has the following structure:\n *   // [posX, posY, offsetX, offsetY, texCoordU, texCoordV, posX, posY, ...]\n *   helper.enableAttributes([\n *     {\n *        name: 'a_position',\n *        size: 2\n *     },\n *     {\n *       name: 'a_offset',\n *       size: 2\n *     },\n *     {\n *       name: 'a_texCoord',\n *       size: 2\n *     }\n *   ])\n *   ```\n *\n * ### Rendering primitives\n *\n *   Once all the steps above have been achieved, rendering primitives to the screen is done using {@link prepareDraw}, {@link drawElements} and {@link finalizeDraw}.\n *   ```js\n *   // frame preparation step\n *   helper.prepareDraw(frameState);\n *\n *   // call this for every data array that has to be rendered on screen\n *   helper.drawElements(0, this.indicesBuffer.getArray().length);\n *\n *   // finalize the rendering by applying post processes\n *   helper.finalizeDraw(frameState);\n *   ```\n *\n * For an example usage of this class, refer to {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.\n *\n *\n * @api\n */\nclass WebGLHelper extends Disposable {\n  /**\n   * @param {Options=} opt_options Options.\n   */\n  constructor(opt_options) {\n    super();\n    const options = opt_options || {};\n\n    /** @private */\n    this.boundHandleWebGLContextLost_ = this.handleWebGLContextLost.bind(this);\n\n    /** @private */\n    this.boundHandleWebGLContextRestored_ = this.handleWebGLContextRestored.bind(\n      this\n    );\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = document.createElement('canvas');\n    this.canvas_.style.position = 'absolute';\n    this.canvas_.style.left = '0';\n\n    /**\n     * @private\n     * @type {WebGLRenderingContext}\n     */\n    this.gl_ = getContext(this.canvas_);\n    const gl = this.getGL();\n\n    /**\n     * @private\n     * @type {!Object<string, BufferCacheEntry>}\n     */\n    this.bufferCache_ = {};\n\n    /**\n     * @private\n     * @type {WebGLProgram}\n     */\n    this.currentProgram_ = null;\n\n    assert(includes(getSupportedExtensions(), 'OES_element_index_uint'), 63);\n    gl.getExtension('OES_element_index_uint');\n\n    this.canvas_.addEventListener(\n      ContextEventType.LOST,\n      this.boundHandleWebGLContextLost_\n    );\n    this.canvas_.addEventListener(\n      ContextEventType.RESTORED,\n      this.boundHandleWebGLContextRestored_\n    );\n\n    /**\n     * @private\n     * @type {import(\"../transform.js\").Transform}\n     */\n    this.offsetRotateMatrix_ = createTransform();\n\n    /**\n     * @private\n     * @type {import(\"../transform.js\").Transform}\n     */\n    this.offsetScaleMatrix_ = createTransform();\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.tmpMat4_ = create();\n\n    /**\n     * @private\n     * @type {Object.<string, WebGLUniformLocation>}\n     */\n    this.uniformLocations_ = {};\n\n    /**\n     * @private\n     * @type {Object.<string, number>}\n     */\n    this.attribLocations_ = {};\n\n    /**\n     * Holds info about custom uniforms used in the post processing pass.\n     * If the uniform is a texture, the WebGL Texture object will be stored here.\n     * @type {Array<UniformInternalDescription>}\n     * @private\n     */\n    this.uniforms_ = [];\n    if (options.uniforms) {\n      for (const name in options.uniforms) {\n        this.uniforms_.push({\n          name: name,\n          value: options.uniforms[name],\n        });\n      }\n    }\n\n    /**\n     * An array of PostProcessingPass objects is kept in this variable, built from the steps provided in the\n     * options. If no post process was given, a default one is used (so as not to have to make an exception to\n     * the frame buffer logic).\n     * @type {Array<WebGLPostProcessingPass>}\n     * @private\n     */\n    this.postProcessPasses_ = options.postProcesses\n      ? options.postProcesses.map(function (options) {\n          return new WebGLPostProcessingPass({\n            webGlContext: gl,\n            scaleRatio: options.scaleRatio,\n            vertexShader: options.vertexShader,\n            fragmentShader: options.fragmentShader,\n            uniforms: options.uniforms,\n          });\n        })\n      : [new WebGLPostProcessingPass({webGlContext: gl})];\n\n    /**\n     * @type {string|null}\n     * @private\n     */\n    this.shaderCompileErrors_ = null;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.startTime_ = Date.now();\n  }\n\n  /**\n   * Just bind the buffer if it's in the cache. Otherwise create\n   * the WebGL buffer, bind it, populate it, and add an entry to\n   * the cache.\n   * @param {import(\"./Buffer\").default} buffer Buffer.\n   * @api\n   */\n  bindBuffer(buffer) {\n    const gl = this.getGL();\n    const bufferKey = getUid(buffer);\n    let bufferCache = this.bufferCache_[bufferKey];\n    if (!bufferCache) {\n      const webGlBuffer = gl.createBuffer();\n      bufferCache = {\n        buffer: buffer,\n        webGlBuffer: webGlBuffer,\n      };\n      this.bufferCache_[bufferKey] = bufferCache;\n    }\n    gl.bindBuffer(buffer.getType(), bufferCache.webGlBuffer);\n  }\n\n  /**\n   * Update the data contained in the buffer array; this is required for the\n   * new data to be rendered\n   * @param {import(\"./Buffer\").default} buffer Buffer.\n   * @api\n   */\n  flushBufferData(buffer) {\n    const gl = this.getGL();\n    this.bindBuffer(buffer);\n    gl.bufferData(buffer.getType(), buffer.getArray(), buffer.getUsage());\n  }\n\n  /**\n   * @param {import(\"./Buffer.js\").default} buf Buffer.\n   */\n  deleteBuffer(buf) {\n    const gl = this.getGL();\n    const bufferKey = getUid(buf);\n    const bufferCacheEntry = this.bufferCache_[bufferKey];\n    if (!gl.isContextLost()) {\n      gl.deleteBuffer(bufferCacheEntry.buffer);\n    }\n    delete this.bufferCache_[bufferKey];\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    this.canvas_.removeEventListener(\n      ContextEventType.LOST,\n      this.boundHandleWebGLContextLost_\n    );\n    this.canvas_.removeEventListener(\n      ContextEventType.RESTORED,\n      this.boundHandleWebGLContextRestored_\n    );\n  }\n\n  /**\n   * Clear the buffer & set the viewport to draw.\n   * Post process passes will be initialized here, the first one being bound as a render target for\n   * subsequent draw calls.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState current frame state\n   * @api\n   */\n  prepareDraw(frameState) {\n    const gl = this.getGL();\n    const canvas = this.getCanvas();\n    const size = frameState.size;\n    const pixelRatio = frameState.pixelRatio;\n\n    canvas.width = size[0] * pixelRatio;\n    canvas.height = size[1] * pixelRatio;\n    canvas.style.width = size[0] + 'px';\n    canvas.style.height = size[1] + 'px';\n\n    gl.useProgram(this.currentProgram_);\n\n    // loop backwards in post processes list\n    for (let i = this.postProcessPasses_.length - 1; i >= 0; i--) {\n      this.postProcessPasses_[i].init(frameState);\n    }\n\n    gl.bindTexture(gl.TEXTURE_2D, null);\n\n    gl.clearColor(0.0, 0.0, 0.0, 0.0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n    gl.useProgram(this.currentProgram_);\n    this.applyFrameState(frameState);\n    this.applyUniforms(frameState);\n  }\n\n  /**\n   * Clear the render target & bind it for future draw operations.\n   * This is similar to `prepareDraw`, only post processes will not be applied.\n   * Note: the whole viewport will be drawn to the render target, regardless of its size.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState current frame state\n   * @param {import(\"./RenderTarget.js\").default} renderTarget Render target to draw to\n   * @param {boolean} [opt_disableAlphaBlend] If true, no alpha blending will happen.\n   */\n  prepareDrawToRenderTarget(frameState, renderTarget, opt_disableAlphaBlend) {\n    const gl = this.getGL();\n    const size = renderTarget.getSize();\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget.getFramebuffer());\n    gl.viewport(0, 0, size[0], size[1]);\n    gl.bindTexture(gl.TEXTURE_2D, renderTarget.getTexture());\n    gl.clearColor(0.0, 0.0, 0.0, 0.0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    gl.enable(gl.BLEND);\n    gl.blendFunc(\n      gl.ONE,\n      opt_disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA\n    );\n\n    gl.useProgram(this.currentProgram_);\n    this.applyFrameState(frameState);\n    this.applyUniforms(frameState);\n  }\n\n  /**\n   * Execute a draw call based on the currently bound program, texture, buffers, attributes.\n   * @param {number} start Start index.\n   * @param {number} end End index.\n   * @api\n   */\n  drawElements(start, end) {\n    const gl = this.getGL();\n    const elementType = gl.UNSIGNED_INT;\n    const elementSize = 4;\n\n    const numItems = end - start;\n    const offsetInBytes = start * elementSize;\n    gl.drawElements(gl.TRIANGLES, numItems, elementType, offsetInBytes);\n  }\n\n  /**\n   * Apply the successive post process passes which will eventually render to the actual canvas.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState current frame state\n   * @api\n   */\n  finalizeDraw(frameState) {\n    // apply post processes using the next one as target\n    for (let i = 0; i < this.postProcessPasses_.length; i++) {\n      this.postProcessPasses_[i].apply(\n        frameState,\n        this.postProcessPasses_[i + 1] || null\n      );\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Canvas.\n   * @api\n   */\n  getCanvas() {\n    return this.canvas_;\n  }\n\n  /**\n   * Get the WebGL rendering context\n   * @return {WebGLRenderingContext} The rendering context.\n   * @api\n   */\n  getGL() {\n    return this.gl_;\n  }\n\n  /**\n   * Sets the default matrix uniforms for a given frame state. This is called internally in `prepareDraw`.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n   * @private\n   */\n  applyFrameState(frameState) {\n    const size = frameState.size;\n    const rotation = frameState.viewState.rotation;\n\n    const offsetScaleMatrix = resetTransform(this.offsetScaleMatrix_);\n    scaleTransform(offsetScaleMatrix, 2 / size[0], 2 / size[1]);\n\n    const offsetRotateMatrix = resetTransform(this.offsetRotateMatrix_);\n    if (rotation !== 0) {\n      rotateTransform(offsetRotateMatrix, -rotation);\n    }\n\n    this.setUniformMatrixValue(\n      DefaultUniform.OFFSET_SCALE_MATRIX,\n      fromTransform(this.tmpMat4_, offsetScaleMatrix)\n    );\n    this.setUniformMatrixValue(\n      DefaultUniform.OFFSET_ROTATION_MATRIX,\n      fromTransform(this.tmpMat4_, offsetRotateMatrix)\n    );\n\n    this.setUniformFloatValue(\n      DefaultUniform.TIME,\n      (Date.now() - this.startTime_) * 0.001\n    );\n    this.setUniformFloatValue(DefaultUniform.ZOOM, frameState.viewState.zoom);\n    this.setUniformFloatValue(\n      DefaultUniform.RESOLUTION,\n      frameState.viewState.resolution\n    );\n  }\n\n  /**\n   * Sets the custom uniforms based on what was given in the constructor. This is called internally in `prepareDraw`.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n   * @private\n   */\n  applyUniforms(frameState) {\n    const gl = this.getGL();\n\n    let value;\n    let textureSlot = 0;\n    this.uniforms_.forEach(\n      function (uniform) {\n        value =\n          typeof uniform.value === 'function'\n            ? uniform.value(frameState)\n            : uniform.value;\n\n        // apply value based on type\n        if (\n          value instanceof HTMLCanvasElement ||\n          value instanceof HTMLImageElement ||\n          value instanceof ImageData\n        ) {\n          // create a texture & put data\n          if (!uniform.texture) {\n            uniform.prevValue = undefined;\n            uniform.texture = gl.createTexture();\n          }\n          gl.activeTexture(gl[`TEXTURE${textureSlot}`]);\n          gl.bindTexture(gl.TEXTURE_2D, uniform.texture);\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n          const imageReady =\n            !(value instanceof HTMLImageElement) ||\n            /** @type {HTMLImageElement} */ (value).complete;\n          if (imageReady && uniform.prevValue !== value) {\n            uniform.prevValue = value;\n            gl.texImage2D(\n              gl.TEXTURE_2D,\n              0,\n              gl.RGBA,\n              gl.RGBA,\n              gl.UNSIGNED_BYTE,\n              value\n            );\n          }\n\n          // fill texture slots by increasing index\n          gl.uniform1i(this.getUniformLocation(uniform.name), textureSlot++);\n        } else if (Array.isArray(value) && value.length === 6) {\n          this.setUniformMatrixValue(\n            uniform.name,\n            fromTransform(this.tmpMat4_, value)\n          );\n        } else if (Array.isArray(value) && value.length <= 4) {\n          switch (value.length) {\n            case 2:\n              gl.uniform2f(\n                this.getUniformLocation(uniform.name),\n                value[0],\n                value[1]\n              );\n              return;\n            case 3:\n              gl.uniform3f(\n                this.getUniformLocation(uniform.name),\n                value[0],\n                value[1],\n                value[2]\n              );\n              return;\n            case 4:\n              gl.uniform4f(\n                this.getUniformLocation(uniform.name),\n                value[0],\n                value[1],\n                value[2],\n                value[3]\n              );\n              return;\n            default:\n              return;\n          }\n        } else if (typeof value === 'number') {\n          gl.uniform1f(this.getUniformLocation(uniform.name), value);\n        }\n      }.bind(this)\n    );\n  }\n\n  /**\n   * Use a program.  If the program is already in use, this will return `false`.\n   * @param {WebGLProgram} program Program.\n   * @return {boolean} Changed.\n   * @api\n   */\n  useProgram(program) {\n    if (program == this.currentProgram_) {\n      return false;\n    } else {\n      const gl = this.getGL();\n      gl.useProgram(program);\n      this.currentProgram_ = program;\n      this.uniformLocations_ = {};\n      this.attribLocations_ = {};\n      return true;\n    }\n  }\n\n  /**\n   * Will attempt to compile a vertex or fragment shader based on source\n   * On error, the shader will be returned but\n   * `gl.getShaderParameter(shader, gl.COMPILE_STATUS)` will return `true`\n   * Use `gl.getShaderInfoLog(shader)` to have details\n   * @param {string} source Shader source\n   * @param {ShaderType} type VERTEX_SHADER or FRAGMENT_SHADER\n   * @return {WebGLShader} Shader object\n   */\n  compileShader(source, type) {\n    const gl = this.getGL();\n    const shader = gl.createShader(type);\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n    return shader;\n  }\n\n  /**\n   * Create a program for a vertex and fragment shader. The shaders compilation may have failed:\n   * use `WebGLHelper.getShaderCompileErrors()`to have details if any.\n   * @param {string} fragmentShaderSource Fragment shader source.\n   * @param {string} vertexShaderSource Vertex shader source.\n   * @return {WebGLProgram} Program\n   * @api\n   */\n  getProgram(fragmentShaderSource, vertexShaderSource) {\n    const gl = this.getGL();\n\n    const fragmentShader = this.compileShader(\n      fragmentShaderSource,\n      gl.FRAGMENT_SHADER\n    );\n    const vertexShader = this.compileShader(\n      vertexShaderSource,\n      gl.VERTEX_SHADER\n    );\n    this.shaderCompileErrors_ = null;\n\n    if (gl.getShaderInfoLog(fragmentShader)) {\n      this.shaderCompileErrors_ = `Fragment shader compilation failed:\\n${gl.getShaderInfoLog(\n        fragmentShader\n      )}`;\n    }\n    if (gl.getShaderInfoLog(vertexShader)) {\n      this.shaderCompileErrors_ =\n        (this.shaderCompileErrors_ || '') +\n        `Vertex shader compilation failed:\\n${gl.getShaderInfoLog(\n          vertexShader\n        )}`;\n    }\n\n    const program = gl.createProgram();\n    gl.attachShader(program, fragmentShader);\n    gl.attachShader(program, vertexShader);\n    gl.linkProgram(program);\n    return program;\n  }\n\n  /**\n   * Will return the last shader compilation errors. If no error happened, will return null;\n   * @return {string|null} Errors description, or null if last compilation was successful\n   * @api\n   */\n  getShaderCompileErrors() {\n    return this.shaderCompileErrors_;\n  }\n\n  /**\n   * Will get the location from the shader or the cache\n   * @param {string} name Uniform name\n   * @return {WebGLUniformLocation} uniformLocation\n   * @api\n   */\n  getUniformLocation(name) {\n    if (this.uniformLocations_[name] === undefined) {\n      this.uniformLocations_[name] = this.getGL().getUniformLocation(\n        this.currentProgram_,\n        name\n      );\n    }\n    return this.uniformLocations_[name];\n  }\n\n  /**\n   * Will get the location from the shader or the cache\n   * @param {string} name Attribute name\n   * @return {number} attribLocation\n   * @api\n   */\n  getAttributeLocation(name) {\n    if (this.attribLocations_[name] === undefined) {\n      this.attribLocations_[name] = this.getGL().getAttribLocation(\n        this.currentProgram_,\n        name\n      );\n    }\n    return this.attribLocations_[name];\n  }\n\n  /**\n   * Modifies the given transform to apply the rotation/translation/scaling of the given frame state.\n   * The resulting transform can be used to convert world space coordinates to view coordinates.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {import(\"../transform\").Transform} transform Transform to update.\n   * @return {import(\"../transform\").Transform} The updated transform object.\n   * @api\n   */\n  makeProjectionTransform(frameState, transform) {\n    const size = frameState.size;\n    const rotation = frameState.viewState.rotation;\n    const resolution = frameState.viewState.resolution;\n    const center = frameState.viewState.center;\n\n    resetTransform(transform);\n    composeTransform(\n      transform,\n      0,\n      0,\n      2 / (resolution * size[0]),\n      2 / (resolution * size[1]),\n      -rotation,\n      -center[0],\n      -center[1]\n    );\n    return transform;\n  }\n\n  /**\n   * Give a value for a standard float uniform\n   * @param {string} uniform Uniform name\n   * @param {number} value Value\n   * @api\n   */\n  setUniformFloatValue(uniform, value) {\n    this.getGL().uniform1f(this.getUniformLocation(uniform), value);\n  }\n\n  /**\n   * Give a value for a standard matrix4 uniform\n   * @param {string} uniform Uniform name\n   * @param {Array<number>} value Matrix value\n   * @api\n   */\n  setUniformMatrixValue(uniform, value) {\n    this.getGL().uniformMatrix4fv(\n      this.getUniformLocation(uniform),\n      false,\n      value\n    );\n  }\n\n  /**\n   * Will set the currently bound buffer to an attribute of the shader program. Used by `#enableAttributes`\n   * internally.\n   * @param {string} attribName Attribute name\n   * @param {number} size Number of components per attributes\n   * @param {number} type UNSIGNED_INT, UNSIGNED_BYTE, UNSIGNED_SHORT or FLOAT\n   * @param {number} stride Stride in bytes (0 means attribs are packed)\n   * @param {number} offset Offset in bytes\n   * @private\n   */\n  enableAttributeArray_(attribName, size, type, stride, offset) {\n    const location = this.getAttributeLocation(attribName);\n    // the attribute has not been found in the shaders; do not enable it\n    if (location < 0) {\n      return;\n    }\n    this.getGL().enableVertexAttribArray(location);\n    this.getGL().vertexAttribPointer(\n      location,\n      size,\n      type,\n      false,\n      stride,\n      offset\n    );\n  }\n\n  /**\n   * Will enable the following attributes to be read from the currently bound buffer,\n   * i.e. tell the GPU where to read the different attributes in the buffer. An error in the\n   * size/type/order of attributes will most likely break the rendering and throw a WebGL exception.\n   * @param {Array<AttributeDescription>} attributes Ordered list of attributes to read from the buffer\n   * @api\n   */\n  enableAttributes(attributes) {\n    const stride = computeAttributesStride(attributes);\n    let offset = 0;\n    for (let i = 0; i < attributes.length; i++) {\n      const attr = attributes[i];\n      this.enableAttributeArray_(\n        attr.name,\n        attr.size,\n        attr.type || FLOAT,\n        stride,\n        offset\n      );\n      offset += attr.size * getByteSizeFromType(attr.type);\n    }\n  }\n\n  /**\n   * WebGL context was lost\n   * @private\n   */\n  handleWebGLContextLost() {\n    clear(this.bufferCache_);\n    this.currentProgram_ = null;\n  }\n\n  /**\n   * WebGL context was restored\n   * @private\n   */\n  handleWebGLContextRestored() {}\n\n  /**\n   * Will create or reuse a given webgl texture and apply the given size. If no image data\n   * specified, the texture will be empty, otherwise image data will be used and the `size`\n   * parameter will be ignored.\n   * Note: wrap parameters are set to clamp to edge, min filter is set to linear.\n   * @param {Array<number>} size Expected size of the texture\n   * @param {ImageData|HTMLImageElement|HTMLCanvasElement} [opt_data] Image data/object to bind to the texture\n   * @param {WebGLTexture} [opt_texture] Existing texture to reuse\n   * @return {WebGLTexture} The generated texture\n   * @api\n   */\n  createTexture(size, opt_data, opt_texture) {\n    const gl = this.getGL();\n    const texture = opt_texture || gl.createTexture();\n\n    // set params & size\n    const level = 0;\n    const internalFormat = gl.RGBA;\n    const border = 0;\n    const format = gl.RGBA;\n    const type = gl.UNSIGNED_BYTE;\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    if (opt_data) {\n      gl.texImage2D(\n        gl.TEXTURE_2D,\n        level,\n        internalFormat,\n        format,\n        type,\n        opt_data\n      );\n    } else {\n      gl.texImage2D(\n        gl.TEXTURE_2D,\n        level,\n        internalFormat,\n        size[0],\n        size[1],\n        border,\n        format,\n        type,\n        null\n      );\n    }\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n    return texture;\n  }\n}\n\n/**\n * Compute a stride in bytes based on a list of attributes\n * @param {Array<AttributeDescription>} attributes Ordered list of attributes\n * @returns {number} Stride, ie amount of values for each vertex in the vertex buffer\n * @api\n */\nexport function computeAttributesStride(attributes) {\n  let stride = 0;\n  for (let i = 0; i < attributes.length; i++) {\n    const attr = attributes[i];\n    stride += attr.size * getByteSizeFromType(attr.type);\n  }\n  return stride;\n}\n\n/**\n * Computes the size in byte of an attribute type.\n * @param {AttributeType} type Attribute type\n * @returns {number} The size in bytes\n */\nfunction getByteSizeFromType(type) {\n  switch (type) {\n    case AttributeType.UNSIGNED_BYTE:\n      return Uint8Array.BYTES_PER_ELEMENT;\n    case AttributeType.UNSIGNED_SHORT:\n      return Uint16Array.BYTES_PER_ELEMENT;\n    case AttributeType.UNSIGNED_INT:\n      return Uint32Array.BYTES_PER_ELEMENT;\n    case AttributeType.FLOAT:\n    default:\n      return Float32Array.BYTES_PER_ELEMENT;\n  }\n}\n\nexport default WebGLHelper;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
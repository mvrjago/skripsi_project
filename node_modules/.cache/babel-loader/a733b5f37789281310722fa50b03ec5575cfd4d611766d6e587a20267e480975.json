{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = global || self, global.RBush = factory());\n})(this, function () {\n  'use strict';\n\n  function quickselect(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || arr.length - 1, compare || defaultCompare);\n  }\n  function quickselectStep(arr, k, left, right, compare) {\n    while (right > left) {\n      if (right - left > 600) {\n        var n = right - left + 1;\n        var m = k - left + 1;\n        var z = Math.log(n);\n        var s = 0.5 * Math.exp(2 * z / 3);\n        var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n        var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n        var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n        quickselectStep(arr, k, newLeft, newRight, compare);\n      }\n      var t = arr[k];\n      var i = left;\n      var j = right;\n      swap(arr, left, k);\n      if (compare(arr[right], t) > 0) {\n        swap(arr, left, right);\n      }\n      while (i < j) {\n        swap(arr, i, j);\n        i++;\n        j--;\n        while (compare(arr[i], t) < 0) {\n          i++;\n        }\n        while (compare(arr[j], t) > 0) {\n          j--;\n        }\n      }\n      if (compare(arr[left], t) === 0) {\n        swap(arr, left, j);\n      } else {\n        j++;\n        swap(arr, j, right);\n      }\n      if (j <= k) {\n        left = j + 1;\n      }\n      if (k <= j) {\n        right = j - 1;\n      }\n    }\n  }\n  function swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n  }\n  function defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n  }\n  var RBush = function RBush(maxEntries) {\n    if (maxEntries === void 0) maxEntries = 9;\n\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n    this.clear();\n  };\n  RBush.prototype.all = function all() {\n    return this._all(this.data, []);\n  };\n  RBush.prototype.search = function search(bbox) {\n    var node = this.data;\n    var result = [];\n    if (!intersects(bbox, node)) {\n      return result;\n    }\n    var toBBox = this.toBBox;\n    var nodesToSearch = [];\n    while (node) {\n      for (var i = 0; i < node.children.length; i++) {\n        var child = node.children[i];\n        var childBBox = node.leaf ? toBBox(child) : child;\n        if (intersects(bbox, childBBox)) {\n          if (node.leaf) {\n            result.push(child);\n          } else if (contains(bbox, childBBox)) {\n            this._all(child, result);\n          } else {\n            nodesToSearch.push(child);\n          }\n        }\n      }\n      node = nodesToSearch.pop();\n    }\n    return result;\n  };\n  RBush.prototype.collides = function collides(bbox) {\n    var node = this.data;\n    if (!intersects(bbox, node)) {\n      return false;\n    }\n    var nodesToSearch = [];\n    while (node) {\n      for (var i = 0; i < node.children.length; i++) {\n        var child = node.children[i];\n        var childBBox = node.leaf ? this.toBBox(child) : child;\n        if (intersects(bbox, childBBox)) {\n          if (node.leaf || contains(bbox, childBBox)) {\n            return true;\n          }\n          nodesToSearch.push(child);\n        }\n      }\n      node = nodesToSearch.pop();\n    }\n    return false;\n  };\n  RBush.prototype.load = function load(data) {\n    if (!(data && data.length)) {\n      return this;\n    }\n    if (data.length < this._minEntries) {\n      for (var i = 0; i < data.length; i++) {\n        this.insert(data[i]);\n      }\n      return this;\n    }\n\n    // recursively build the tree with the given data from scratch using OMT algorithm\n    var node = this._build(data.slice(), 0, data.length - 1, 0);\n    if (!this.data.children.length) {\n      // save as is if tree is empty\n      this.data = node;\n    } else if (this.data.height === node.height) {\n      // split root if trees have the same height\n      this._splitRoot(this.data, node);\n    } else {\n      if (this.data.height < node.height) {\n        // swap trees if inserted one is bigger\n        var tmpNode = this.data;\n        this.data = node;\n        node = tmpNode;\n      }\n\n      // insert the small tree into the large tree at appropriate level\n      this._insert(node, this.data.height - node.height - 1, true);\n    }\n    return this;\n  };\n  RBush.prototype.insert = function insert(item) {\n    if (item) {\n      this._insert(item, this.data.height - 1);\n    }\n    return this;\n  };\n  RBush.prototype.clear = function clear() {\n    this.data = createNode([]);\n    return this;\n  };\n  RBush.prototype.remove = function remove(item, equalsFn) {\n    if (!item) {\n      return this;\n    }\n    var node = this.data;\n    var bbox = this.toBBox(item);\n    var path = [];\n    var indexes = [];\n    var i, parent, goingUp;\n\n    // depth-first iterative tree traversal\n    while (node || path.length) {\n      if (!node) {\n        // go up\n        node = path.pop();\n        parent = path[path.length - 1];\n        i = indexes.pop();\n        goingUp = true;\n      }\n      if (node.leaf) {\n        // check current node\n        var index = findItem(item, node.children, equalsFn);\n        if (index !== -1) {\n          // item found, remove the item and condense tree upwards\n          node.children.splice(index, 1);\n          path.push(node);\n          this._condense(path);\n          return this;\n        }\n      }\n      if (!goingUp && !node.leaf && contains(node, bbox)) {\n        // go down\n        path.push(node);\n        indexes.push(i);\n        i = 0;\n        parent = node;\n        node = node.children[0];\n      } else if (parent) {\n        // go right\n        i++;\n        node = parent.children[i];\n        goingUp = false;\n      } else {\n        node = null;\n      } // nothing found\n    }\n\n    return this;\n  };\n  RBush.prototype.toBBox = function toBBox(item) {\n    return item;\n  };\n  RBush.prototype.compareMinX = function compareMinX(a, b) {\n    return a.minX - b.minX;\n  };\n  RBush.prototype.compareMinY = function compareMinY(a, b) {\n    return a.minY - b.minY;\n  };\n  RBush.prototype.toJSON = function toJSON() {\n    return this.data;\n  };\n  RBush.prototype.fromJSON = function fromJSON(data) {\n    this.data = data;\n    return this;\n  };\n  RBush.prototype._all = function _all(node, result) {\n    var nodesToSearch = [];\n    while (node) {\n      if (node.leaf) {\n        result.push.apply(result, node.children);\n      } else {\n        nodesToSearch.push.apply(nodesToSearch, node.children);\n      }\n      node = nodesToSearch.pop();\n    }\n    return result;\n  };\n  RBush.prototype._build = function _build(items, left, right, height) {\n    var N = right - left + 1;\n    var M = this._maxEntries;\n    var node;\n    if (N <= M) {\n      // reached leaf level; return leaf\n      node = createNode(items.slice(left, right + 1));\n      calcBBox(node, this.toBBox);\n      return node;\n    }\n    if (!height) {\n      // target height of the bulk-loaded tree\n      height = Math.ceil(Math.log(N) / Math.log(M));\n\n      // target number of root entries to maximize storage utilization\n      M = Math.ceil(N / Math.pow(M, height - 1));\n    }\n    node = createNode([]);\n    node.leaf = false;\n    node.height = height;\n\n    // split the items into M mostly square tiles\n\n    var N2 = Math.ceil(N / M);\n    var N1 = N2 * Math.ceil(Math.sqrt(M));\n    multiSelect(items, left, right, N1, this.compareMinX);\n    for (var i = left; i <= right; i += N1) {\n      var right2 = Math.min(i + N1 - 1, right);\n      multiSelect(items, i, right2, N2, this.compareMinY);\n      for (var j = i; j <= right2; j += N2) {\n        var right3 = Math.min(j + N2 - 1, right2);\n\n        // pack each entry recursively\n        node.children.push(this._build(items, j, right3, height - 1));\n      }\n    }\n    calcBBox(node, this.toBBox);\n    return node;\n  };\n  RBush.prototype._chooseSubtree = function _chooseSubtree(bbox, node, level, path) {\n    while (true) {\n      path.push(node);\n      if (node.leaf || path.length - 1 === level) {\n        break;\n      }\n      var minArea = Infinity;\n      var minEnlargement = Infinity;\n      var targetNode = void 0;\n      for (var i = 0; i < node.children.length; i++) {\n        var child = node.children[i];\n        var area = bboxArea(child);\n        var enlargement = enlargedArea(bbox, child) - area;\n\n        // choose entry with the least area enlargement\n        if (enlargement < minEnlargement) {\n          minEnlargement = enlargement;\n          minArea = area < minArea ? area : minArea;\n          targetNode = child;\n        } else if (enlargement === minEnlargement) {\n          // otherwise choose one with the smallest area\n          if (area < minArea) {\n            minArea = area;\n            targetNode = child;\n          }\n        }\n      }\n      node = targetNode || node.children[0];\n    }\n    return node;\n  };\n  RBush.prototype._insert = function _insert(item, level, isNode) {\n    var bbox = isNode ? item : this.toBBox(item);\n    var insertPath = [];\n\n    // find the best node for accommodating the item, saving all nodes along the path too\n    var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n    // put the item into the node\n    node.children.push(item);\n    extend(node, bbox);\n\n    // split on node overflow; propagate upwards if necessary\n    while (level >= 0) {\n      if (insertPath[level].children.length > this._maxEntries) {\n        this._split(insertPath, level);\n        level--;\n      } else {\n        break;\n      }\n    }\n\n    // adjust bboxes along the insertion path\n    this._adjustParentBBoxes(bbox, insertPath, level);\n  };\n\n  // split overflowed node into two\n  RBush.prototype._split = function _split(insertPath, level) {\n    var node = insertPath[level];\n    var M = node.children.length;\n    var m = this._minEntries;\n    this._chooseSplitAxis(node, m, M);\n    var splitIndex = this._chooseSplitIndex(node, m, M);\n    var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n    newNode.height = node.height;\n    newNode.leaf = node.leaf;\n    calcBBox(node, this.toBBox);\n    calcBBox(newNode, this.toBBox);\n    if (level) {\n      insertPath[level - 1].children.push(newNode);\n    } else {\n      this._splitRoot(node, newNode);\n    }\n  };\n  RBush.prototype._splitRoot = function _splitRoot(node, newNode) {\n    // split root node\n    this.data = createNode([node, newNode]);\n    this.data.height = node.height + 1;\n    this.data.leaf = false;\n    calcBBox(this.data, this.toBBox);\n  };\n  RBush.prototype._chooseSplitIndex = function _chooseSplitIndex(node, m, M) {\n    var index;\n    var minOverlap = Infinity;\n    var minArea = Infinity;\n    for (var i = m; i <= M - m; i++) {\n      var bbox1 = distBBox(node, 0, i, this.toBBox);\n      var bbox2 = distBBox(node, i, M, this.toBBox);\n      var overlap = intersectionArea(bbox1, bbox2);\n      var area = bboxArea(bbox1) + bboxArea(bbox2);\n\n      // choose distribution with minimum overlap\n      if (overlap < minOverlap) {\n        minOverlap = overlap;\n        index = i;\n        minArea = area < minArea ? area : minArea;\n      } else if (overlap === minOverlap) {\n        // otherwise choose distribution with minimum area\n        if (area < minArea) {\n          minArea = area;\n          index = i;\n        }\n      }\n    }\n    return index || M - m;\n  };\n\n  // sorts node children by the best axis for split\n  RBush.prototype._chooseSplitAxis = function _chooseSplitAxis(node, m, M) {\n    var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;\n    var compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;\n    var xMargin = this._allDistMargin(node, m, M, compareMinX);\n    var yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n    // if total distributions margin value is minimal for x, sort by minX,\n    // otherwise it's already sorted by minY\n    if (xMargin < yMargin) {\n      node.children.sort(compareMinX);\n    }\n  };\n\n  // total margin of all possible split distributions where each node is at least m full\n  RBush.prototype._allDistMargin = function _allDistMargin(node, m, M, compare) {\n    node.children.sort(compare);\n    var toBBox = this.toBBox;\n    var leftBBox = distBBox(node, 0, m, toBBox);\n    var rightBBox = distBBox(node, M - m, M, toBBox);\n    var margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);\n    for (var i = m; i < M - m; i++) {\n      var child = node.children[i];\n      extend(leftBBox, node.leaf ? toBBox(child) : child);\n      margin += bboxMargin(leftBBox);\n    }\n    for (var i$1 = M - m - 1; i$1 >= m; i$1--) {\n      var child$1 = node.children[i$1];\n      extend(rightBBox, node.leaf ? toBBox(child$1) : child$1);\n      margin += bboxMargin(rightBBox);\n    }\n    return margin;\n  };\n  RBush.prototype._adjustParentBBoxes = function _adjustParentBBoxes(bbox, path, level) {\n    // adjust bboxes along the given tree path\n    for (var i = level; i >= 0; i--) {\n      extend(path[i], bbox);\n    }\n  };\n  RBush.prototype._condense = function _condense(path) {\n    // go through the path, removing empty nodes and updating bboxes\n    for (var i = path.length - 1, siblings = void 0; i >= 0; i--) {\n      if (path[i].children.length === 0) {\n        if (i > 0) {\n          siblings = path[i - 1].children;\n          siblings.splice(siblings.indexOf(path[i]), 1);\n        } else {\n          this.clear();\n        }\n      } else {\n        calcBBox(path[i], this.toBBox);\n      }\n    }\n  };\n  function findItem(item, items, equalsFn) {\n    if (!equalsFn) {\n      return items.indexOf(item);\n    }\n    for (var i = 0; i < items.length; i++) {\n      if (equalsFn(item, items[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  // calculate node's bbox from bboxes of its children\n  function calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n  }\n\n  // min bounding rectangle of node children from k to p-1\n  function distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) {\n      destNode = createNode(null);\n    }\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n    for (var i = k; i < p; i++) {\n      var child = node.children[i];\n      extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n    return destNode;\n  }\n  function extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n  }\n  function compareNodeMinX(a, b) {\n    return a.minX - b.minX;\n  }\n  function compareNodeMinY(a, b) {\n    return a.minY - b.minY;\n  }\n  function bboxArea(a) {\n    return (a.maxX - a.minX) * (a.maxY - a.minY);\n  }\n  function bboxMargin(a) {\n    return a.maxX - a.minX + (a.maxY - a.minY);\n  }\n  function enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n  }\n  function intersectionArea(a, b) {\n    var minX = Math.max(a.minX, b.minX);\n    var minY = Math.max(a.minY, b.minY);\n    var maxX = Math.min(a.maxX, b.maxX);\n    var maxY = Math.min(a.maxY, b.maxY);\n    return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);\n  }\n  function contains(a, b) {\n    return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;\n  }\n  function intersects(a, b) {\n    return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;\n  }\n  function createNode(children) {\n    return {\n      children: children,\n      height: 1,\n      leaf: true,\n      minX: Infinity,\n      minY: Infinity,\n      maxX: -Infinity,\n      maxY: -Infinity\n    };\n  }\n\n  // sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n  // combines selection algorithm with binary divide & conquer approach\n\n  function multiSelect(arr, left, right, n, compare) {\n    var stack = [left, right];\n    while (stack.length) {\n      right = stack.pop();\n      left = stack.pop();\n      if (right - left <= n) {\n        continue;\n      }\n      var mid = left + Math.ceil((right - left) / n / 2) * n;\n      quickselect(arr, mid, left, right, compare);\n      stack.push(left, mid, mid, right);\n    }\n  }\n  return RBush;\n});","map":{"version":3,"names":["global","factory","exports","module","define","amd","self","RBush","quickselect","arr","k","left","right","compare","quickselectStep","length","defaultCompare","n","m","z","Math","log","s","exp","sd","sqrt","newLeft","max","floor","newRight","min","t","i","j","swap","tmp","a","b","maxEntries","_maxEntries","_minEntries","ceil","clear","prototype","all","_all","data","search","bbox","node","result","intersects","toBBox","nodesToSearch","children","child","childBBox","leaf","push","contains","pop","collides","load","insert","_build","slice","height","_splitRoot","tmpNode","_insert","item","createNode","remove","equalsFn","path","indexes","parent","goingUp","index","findItem","splice","_condense","compareMinX","minX","compareMinY","minY","toJSON","fromJSON","apply","items","N","M","calcBBox","pow","N2","N1","multiSelect","right2","right3","_chooseSubtree","level","minArea","Infinity","minEnlargement","targetNode","area","bboxArea","enlargement","enlargedArea","isNode","insertPath","extend","_split","_adjustParentBBoxes","_chooseSplitAxis","splitIndex","_chooseSplitIndex","newNode","minOverlap","bbox1","distBBox","bbox2","overlap","intersectionArea","compareNodeMinX","compareNodeMinY","xMargin","_allDistMargin","yMargin","sort","leftBBox","rightBBox","margin","bboxMargin","i$1","child$1","siblings","indexOf","p","destNode","maxX","maxY","stack","mid"],"sources":["/Users/mariovicky/Skripsi_OpenLayers/node_modules/rbush/rbush.js"],"sourcesContent":["(function (global, factory) {\ntypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\ntypeof define === 'function' && define.amd ? define(factory) :\n(global = global || self, global.RBush = factory());\n}(this, function () { 'use strict';\n\nfunction quickselect(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);\n}\n\nfunction quickselectStep(arr, k, left, right, compare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselectStep(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) { swap(arr, left, right); }\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) { i++; }\n            while (compare(arr[j], t) > 0) { j--; }\n        }\n\n        if (compare(arr[left], t) === 0) { swap(arr, left, j); }\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) { left = j + 1; }\n        if (k <= j) { right = j - 1; }\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nvar RBush = function RBush(maxEntries) {\n    if ( maxEntries === void 0 ) maxEntries = 9;\n\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n    this.clear();\n};\n\nRBush.prototype.all = function all () {\n    return this._all(this.data, []);\n};\n\nRBush.prototype.search = function search (bbox) {\n    var node = this.data;\n    var result = [];\n\n    if (!intersects(bbox, node)) { return result; }\n\n    var toBBox = this.toBBox;\n    var nodesToSearch = [];\n\n    while (node) {\n        for (var i = 0; i < node.children.length; i++) {\n            var child = node.children[i];\n            var childBBox = node.leaf ? toBBox(child) : child;\n\n            if (intersects(bbox, childBBox)) {\n                if (node.leaf) { result.push(child); }\n                else if (contains(bbox, childBBox)) { this._all(child, result); }\n                else { nodesToSearch.push(child); }\n            }\n        }\n        node = nodesToSearch.pop();\n    }\n\n    return result;\n};\n\nRBush.prototype.collides = function collides (bbox) {\n    var node = this.data;\n\n    if (!intersects(bbox, node)) { return false; }\n\n    var nodesToSearch = [];\n    while (node) {\n        for (var i = 0; i < node.children.length; i++) {\n            var child = node.children[i];\n            var childBBox = node.leaf ? this.toBBox(child) : child;\n\n            if (intersects(bbox, childBBox)) {\n                if (node.leaf || contains(bbox, childBBox)) { return true; }\n                nodesToSearch.push(child);\n            }\n        }\n        node = nodesToSearch.pop();\n    }\n\n    return false;\n};\n\nRBush.prototype.load = function load (data) {\n    if (!(data && data.length)) { return this; }\n\n    if (data.length < this._minEntries) {\n        for (var i = 0; i < data.length; i++) {\n            this.insert(data[i]);\n        }\n        return this;\n    }\n\n    // recursively build the tree with the given data from scratch using OMT algorithm\n    var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n    if (!this.data.children.length) {\n        // save as is if tree is empty\n        this.data = node;\n\n    } else if (this.data.height === node.height) {\n        // split root if trees have the same height\n        this._splitRoot(this.data, node);\n\n    } else {\n        if (this.data.height < node.height) {\n            // swap trees if inserted one is bigger\n            var tmpNode = this.data;\n            this.data = node;\n            node = tmpNode;\n        }\n\n        // insert the small tree into the large tree at appropriate level\n        this._insert(node, this.data.height - node.height - 1, true);\n    }\n\n    return this;\n};\n\nRBush.prototype.insert = function insert (item) {\n    if (item) { this._insert(item, this.data.height - 1); }\n    return this;\n};\n\nRBush.prototype.clear = function clear () {\n    this.data = createNode([]);\n    return this;\n};\n\nRBush.prototype.remove = function remove (item, equalsFn) {\n    if (!item) { return this; }\n\n    var node = this.data;\n    var bbox = this.toBBox(item);\n    var path = [];\n    var indexes = [];\n    var i, parent, goingUp;\n\n    // depth-first iterative tree traversal\n    while (node || path.length) {\n\n        if (!node) { // go up\n            node = path.pop();\n            parent = path[path.length - 1];\n            i = indexes.pop();\n            goingUp = true;\n        }\n\n        if (node.leaf) { // check current node\n            var index = findItem(item, node.children, equalsFn);\n\n            if (index !== -1) {\n                // item found, remove the item and condense tree upwards\n                node.children.splice(index, 1);\n                path.push(node);\n                this._condense(path);\n                return this;\n            }\n        }\n\n        if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n            path.push(node);\n            indexes.push(i);\n            i = 0;\n            parent = node;\n            node = node.children[0];\n\n        } else if (parent) { // go right\n            i++;\n            node = parent.children[i];\n            goingUp = false;\n\n        } else { node = null; } // nothing found\n    }\n\n    return this;\n};\n\nRBush.prototype.toBBox = function toBBox (item) { return item; };\n\nRBush.prototype.compareMinX = function compareMinX (a, b) { return a.minX - b.minX; };\nRBush.prototype.compareMinY = function compareMinY (a, b) { return a.minY - b.minY; };\n\nRBush.prototype.toJSON = function toJSON () { return this.data; };\n\nRBush.prototype.fromJSON = function fromJSON (data) {\n    this.data = data;\n    return this;\n};\n\nRBush.prototype._all = function _all (node, result) {\n    var nodesToSearch = [];\n    while (node) {\n        if (node.leaf) { result.push.apply(result, node.children); }\n        else { nodesToSearch.push.apply(nodesToSearch, node.children); }\n\n        node = nodesToSearch.pop();\n    }\n    return result;\n};\n\nRBush.prototype._build = function _build (items, left, right, height) {\n\n    var N = right - left + 1;\n    var M = this._maxEntries;\n    var node;\n\n    if (N <= M) {\n        // reached leaf level; return leaf\n        node = createNode(items.slice(left, right + 1));\n        calcBBox(node, this.toBBox);\n        return node;\n    }\n\n    if (!height) {\n        // target height of the bulk-loaded tree\n        height = Math.ceil(Math.log(N) / Math.log(M));\n\n        // target number of root entries to maximize storage utilization\n        M = Math.ceil(N / Math.pow(M, height - 1));\n    }\n\n    node = createNode([]);\n    node.leaf = false;\n    node.height = height;\n\n    // split the items into M mostly square tiles\n\n    var N2 = Math.ceil(N / M);\n    var N1 = N2 * Math.ceil(Math.sqrt(M));\n\n    multiSelect(items, left, right, N1, this.compareMinX);\n\n    for (var i = left; i <= right; i += N1) {\n\n        var right2 = Math.min(i + N1 - 1, right);\n\n        multiSelect(items, i, right2, N2, this.compareMinY);\n\n        for (var j = i; j <= right2; j += N2) {\n\n            var right3 = Math.min(j + N2 - 1, right2);\n\n            // pack each entry recursively\n            node.children.push(this._build(items, j, right3, height - 1));\n        }\n    }\n\n    calcBBox(node, this.toBBox);\n\n    return node;\n};\n\nRBush.prototype._chooseSubtree = function _chooseSubtree (bbox, node, level, path) {\n    while (true) {\n        path.push(node);\n\n        if (node.leaf || path.length - 1 === level) { break; }\n\n        var minArea = Infinity;\n        var minEnlargement = Infinity;\n        var targetNode = (void 0);\n\n        for (var i = 0; i < node.children.length; i++) {\n            var child = node.children[i];\n            var area = bboxArea(child);\n            var enlargement = enlargedArea(bbox, child) - area;\n\n            // choose entry with the least area enlargement\n            if (enlargement < minEnlargement) {\n                minEnlargement = enlargement;\n                minArea = area < minArea ? area : minArea;\n                targetNode = child;\n\n            } else if (enlargement === minEnlargement) {\n                // otherwise choose one with the smallest area\n                if (area < minArea) {\n                    minArea = area;\n                    targetNode = child;\n                }\n            }\n        }\n\n        node = targetNode || node.children[0];\n    }\n\n    return node;\n};\n\nRBush.prototype._insert = function _insert (item, level, isNode) {\n    var bbox = isNode ? item : this.toBBox(item);\n    var insertPath = [];\n\n    // find the best node for accommodating the item, saving all nodes along the path too\n    var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n    // put the item into the node\n    node.children.push(item);\n    extend(node, bbox);\n\n    // split on node overflow; propagate upwards if necessary\n    while (level >= 0) {\n        if (insertPath[level].children.length > this._maxEntries) {\n            this._split(insertPath, level);\n            level--;\n        } else { break; }\n    }\n\n    // adjust bboxes along the insertion path\n    this._adjustParentBBoxes(bbox, insertPath, level);\n};\n\n// split overflowed node into two\nRBush.prototype._split = function _split (insertPath, level) {\n    var node = insertPath[level];\n    var M = node.children.length;\n    var m = this._minEntries;\n\n    this._chooseSplitAxis(node, m, M);\n\n    var splitIndex = this._chooseSplitIndex(node, m, M);\n\n    var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n    newNode.height = node.height;\n    newNode.leaf = node.leaf;\n\n    calcBBox(node, this.toBBox);\n    calcBBox(newNode, this.toBBox);\n\n    if (level) { insertPath[level - 1].children.push(newNode); }\n    else { this._splitRoot(node, newNode); }\n};\n\nRBush.prototype._splitRoot = function _splitRoot (node, newNode) {\n    // split root node\n    this.data = createNode([node, newNode]);\n    this.data.height = node.height + 1;\n    this.data.leaf = false;\n    calcBBox(this.data, this.toBBox);\n};\n\nRBush.prototype._chooseSplitIndex = function _chooseSplitIndex (node, m, M) {\n    var index;\n    var minOverlap = Infinity;\n    var minArea = Infinity;\n\n    for (var i = m; i <= M - m; i++) {\n        var bbox1 = distBBox(node, 0, i, this.toBBox);\n        var bbox2 = distBBox(node, i, M, this.toBBox);\n\n        var overlap = intersectionArea(bbox1, bbox2);\n        var area = bboxArea(bbox1) + bboxArea(bbox2);\n\n        // choose distribution with minimum overlap\n        if (overlap < minOverlap) {\n            minOverlap = overlap;\n            index = i;\n\n            minArea = area < minArea ? area : minArea;\n\n        } else if (overlap === minOverlap) {\n            // otherwise choose distribution with minimum area\n            if (area < minArea) {\n                minArea = area;\n                index = i;\n            }\n        }\n    }\n\n    return index || M - m;\n};\n\n// sorts node children by the best axis for split\nRBush.prototype._chooseSplitAxis = function _chooseSplitAxis (node, m, M) {\n    var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;\n    var compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;\n    var xMargin = this._allDistMargin(node, m, M, compareMinX);\n    var yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n    // if total distributions margin value is minimal for x, sort by minX,\n    // otherwise it's already sorted by minY\n    if (xMargin < yMargin) { node.children.sort(compareMinX); }\n};\n\n// total margin of all possible split distributions where each node is at least m full\nRBush.prototype._allDistMargin = function _allDistMargin (node, m, M, compare) {\n    node.children.sort(compare);\n\n    var toBBox = this.toBBox;\n    var leftBBox = distBBox(node, 0, m, toBBox);\n    var rightBBox = distBBox(node, M - m, M, toBBox);\n    var margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);\n\n    for (var i = m; i < M - m; i++) {\n        var child = node.children[i];\n        extend(leftBBox, node.leaf ? toBBox(child) : child);\n        margin += bboxMargin(leftBBox);\n    }\n\n    for (var i$1 = M - m - 1; i$1 >= m; i$1--) {\n        var child$1 = node.children[i$1];\n        extend(rightBBox, node.leaf ? toBBox(child$1) : child$1);\n        margin += bboxMargin(rightBBox);\n    }\n\n    return margin;\n};\n\nRBush.prototype._adjustParentBBoxes = function _adjustParentBBoxes (bbox, path, level) {\n    // adjust bboxes along the given tree path\n    for (var i = level; i >= 0; i--) {\n        extend(path[i], bbox);\n    }\n};\n\nRBush.prototype._condense = function _condense (path) {\n    // go through the path, removing empty nodes and updating bboxes\n    for (var i = path.length - 1, siblings = (void 0); i >= 0; i--) {\n        if (path[i].children.length === 0) {\n            if (i > 0) {\n                siblings = path[i - 1].children;\n                siblings.splice(siblings.indexOf(path[i]), 1);\n\n            } else { this.clear(); }\n\n        } else { calcBBox(path[i], this.toBBox); }\n    }\n};\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) { return items.indexOf(item); }\n\n    for (var i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) { return i; }\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) { destNode = createNode(null); }\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (var i = k; i < p; i++) {\n        var child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    var minX = Math.max(a.minX, b.minX);\n    var minY = Math.max(a.minY, b.minY);\n    var maxX = Math.min(a.maxX, b.maxX);\n    var maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children: children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    var stack = [left, right];\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) { continue; }\n\n        var mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n\nreturn RBush;\n\n}));\n"],"mappings":"AAAC,WAAUA,MAAM,EAAEC,OAAO,EAAE;EAC5B,OAAOC,OAAO,KAAK,QAAQ,IAAI,OAAOC,MAAM,KAAK,WAAW,GAAGA,MAAM,CAACD,OAAO,GAAGD,OAAO,CAAC,CAAC,GACzF,OAAOG,MAAM,KAAK,UAAU,IAAIA,MAAM,CAACC,GAAG,GAAGD,MAAM,CAACH,OAAO,CAAC,IAC3DD,MAAM,GAAGA,MAAM,IAAIM,IAAI,EAAEN,MAAM,CAACO,KAAK,GAAGN,OAAO,CAAC,CAAC,CAAC;AACnD,CAAC,EAAC,IAAI,EAAE,YAAY;EAAE,YAAY;;EAElC,SAASO,WAAWA,CAACC,GAAG,EAAEC,CAAC,EAAEC,IAAI,EAAEC,KAAK,EAAEC,OAAO,EAAE;IAC/CC,eAAe,CAACL,GAAG,EAAEC,CAAC,EAAEC,IAAI,IAAI,CAAC,EAAEC,KAAK,IAAKH,GAAG,CAACM,MAAM,GAAG,CAAE,EAAEF,OAAO,IAAIG,cAAc,CAAC;EAC5F;EAEA,SAASF,eAAeA,CAACL,GAAG,EAAEC,CAAC,EAAEC,IAAI,EAAEC,KAAK,EAAEC,OAAO,EAAE;IAEnD,OAAOD,KAAK,GAAGD,IAAI,EAAE;MACjB,IAAIC,KAAK,GAAGD,IAAI,GAAG,GAAG,EAAE;QACpB,IAAIM,CAAC,GAAGL,KAAK,GAAGD,IAAI,GAAG,CAAC;QACxB,IAAIO,CAAC,GAAGR,CAAC,GAAGC,IAAI,GAAG,CAAC;QACpB,IAAIQ,CAAC,GAAGC,IAAI,CAACC,GAAG,CAACJ,CAAC,CAAC;QACnB,IAAIK,CAAC,GAAG,GAAG,GAAGF,IAAI,CAACG,GAAG,CAAC,CAAC,GAAGJ,CAAC,GAAG,CAAC,CAAC;QACjC,IAAIK,EAAE,GAAG,GAAG,GAAGJ,IAAI,CAACK,IAAI,CAACN,CAAC,GAAGG,CAAC,IAAIL,CAAC,GAAGK,CAAC,CAAC,GAAGL,CAAC,CAAC,IAAIC,CAAC,GAAGD,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;QACxE,IAAIS,OAAO,GAAGN,IAAI,CAACO,GAAG,CAAChB,IAAI,EAAES,IAAI,CAACQ,KAAK,CAAClB,CAAC,GAAGQ,CAAC,GAAGI,CAAC,GAAGL,CAAC,GAAGO,EAAE,CAAC,CAAC;QAC5D,IAAIK,QAAQ,GAAGT,IAAI,CAACU,GAAG,CAAClB,KAAK,EAAEQ,IAAI,CAACQ,KAAK,CAAClB,CAAC,GAAG,CAACO,CAAC,GAAGC,CAAC,IAAII,CAAC,GAAGL,CAAC,GAAGO,EAAE,CAAC,CAAC;QACpEV,eAAe,CAACL,GAAG,EAAEC,CAAC,EAAEgB,OAAO,EAAEG,QAAQ,EAAEhB,OAAO,CAAC;MACvD;MAEA,IAAIkB,CAAC,GAAGtB,GAAG,CAACC,CAAC,CAAC;MACd,IAAIsB,CAAC,GAAGrB,IAAI;MACZ,IAAIsB,CAAC,GAAGrB,KAAK;MAEbsB,IAAI,CAACzB,GAAG,EAAEE,IAAI,EAAED,CAAC,CAAC;MAClB,IAAIG,OAAO,CAACJ,GAAG,CAACG,KAAK,CAAC,EAAEmB,CAAC,CAAC,GAAG,CAAC,EAAE;QAAEG,IAAI,CAACzB,GAAG,EAAEE,IAAI,EAAEC,KAAK,CAAC;MAAE;MAE1D,OAAOoB,CAAC,GAAGC,CAAC,EAAE;QACVC,IAAI,CAACzB,GAAG,EAAEuB,CAAC,EAAEC,CAAC,CAAC;QACfD,CAAC,EAAE;QACHC,CAAC,EAAE;QACH,OAAOpB,OAAO,CAACJ,GAAG,CAACuB,CAAC,CAAC,EAAED,CAAC,CAAC,GAAG,CAAC,EAAE;UAAEC,CAAC,EAAE;QAAE;QACtC,OAAOnB,OAAO,CAACJ,GAAG,CAACwB,CAAC,CAAC,EAAEF,CAAC,CAAC,GAAG,CAAC,EAAE;UAAEE,CAAC,EAAE;QAAE;MAC1C;MAEA,IAAIpB,OAAO,CAACJ,GAAG,CAACE,IAAI,CAAC,EAAEoB,CAAC,CAAC,KAAK,CAAC,EAAE;QAAEG,IAAI,CAACzB,GAAG,EAAEE,IAAI,EAAEsB,CAAC,CAAC;MAAE,CAAC,MACnD;QACDA,CAAC,EAAE;QACHC,IAAI,CAACzB,GAAG,EAAEwB,CAAC,EAAErB,KAAK,CAAC;MACvB;MAEA,IAAIqB,CAAC,IAAIvB,CAAC,EAAE;QAAEC,IAAI,GAAGsB,CAAC,GAAG,CAAC;MAAE;MAC5B,IAAIvB,CAAC,IAAIuB,CAAC,EAAE;QAAErB,KAAK,GAAGqB,CAAC,GAAG,CAAC;MAAE;IACjC;EACJ;EAEA,SAASC,IAAIA,CAACzB,GAAG,EAAEuB,CAAC,EAAEC,CAAC,EAAE;IACrB,IAAIE,GAAG,GAAG1B,GAAG,CAACuB,CAAC,CAAC;IAChBvB,GAAG,CAACuB,CAAC,CAAC,GAAGvB,GAAG,CAACwB,CAAC,CAAC;IACfxB,GAAG,CAACwB,CAAC,CAAC,GAAGE,GAAG;EAChB;EAEA,SAASnB,cAAcA,CAACoB,CAAC,EAAEC,CAAC,EAAE;IAC1B,OAAOD,CAAC,GAAGC,CAAC,GAAG,CAAC,CAAC,GAAGD,CAAC,GAAGC,CAAC,GAAG,CAAC,GAAG,CAAC;EACrC;EAEA,IAAI9B,KAAK,GAAG,SAASA,KAAKA,CAAC+B,UAAU,EAAE;IACnC,IAAKA,UAAU,KAAK,KAAK,CAAC,EAAGA,UAAU,GAAG,CAAC;;IAE3C;IACA,IAAI,CAACC,WAAW,GAAGnB,IAAI,CAACO,GAAG,CAAC,CAAC,EAAEW,UAAU,CAAC;IAC1C,IAAI,CAACE,WAAW,GAAGpB,IAAI,CAACO,GAAG,CAAC,CAAC,EAAEP,IAAI,CAACqB,IAAI,CAAC,IAAI,CAACF,WAAW,GAAG,GAAG,CAAC,CAAC;IACjE,IAAI,CAACG,KAAK,CAAC,CAAC;EAChB,CAAC;EAEDnC,KAAK,CAACoC,SAAS,CAACC,GAAG,GAAG,SAASA,GAAGA,CAAA,EAAI;IAClC,OAAO,IAAI,CAACC,IAAI,CAAC,IAAI,CAACC,IAAI,EAAE,EAAE,CAAC;EACnC,CAAC;EAEDvC,KAAK,CAACoC,SAAS,CAACI,MAAM,GAAG,SAASA,MAAMA,CAAEC,IAAI,EAAE;IAC5C,IAAIC,IAAI,GAAG,IAAI,CAACH,IAAI;IACpB,IAAII,MAAM,GAAG,EAAE;IAEf,IAAI,CAACC,UAAU,CAACH,IAAI,EAAEC,IAAI,CAAC,EAAE;MAAE,OAAOC,MAAM;IAAE;IAE9C,IAAIE,MAAM,GAAG,IAAI,CAACA,MAAM;IACxB,IAAIC,aAAa,GAAG,EAAE;IAEtB,OAAOJ,IAAI,EAAE;MACT,KAAK,IAAIjB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiB,IAAI,CAACK,QAAQ,CAACvC,MAAM,EAAEiB,CAAC,EAAE,EAAE;QAC3C,IAAIuB,KAAK,GAAGN,IAAI,CAACK,QAAQ,CAACtB,CAAC,CAAC;QAC5B,IAAIwB,SAAS,GAAGP,IAAI,CAACQ,IAAI,GAAGL,MAAM,CAACG,KAAK,CAAC,GAAGA,KAAK;QAEjD,IAAIJ,UAAU,CAACH,IAAI,EAAEQ,SAAS,CAAC,EAAE;UAC7B,IAAIP,IAAI,CAACQ,IAAI,EAAE;YAAEP,MAAM,CAACQ,IAAI,CAACH,KAAK,CAAC;UAAE,CAAC,MACjC,IAAII,QAAQ,CAACX,IAAI,EAAEQ,SAAS,CAAC,EAAE;YAAE,IAAI,CAACX,IAAI,CAACU,KAAK,EAAEL,MAAM,CAAC;UAAE,CAAC,MAC5D;YAAEG,aAAa,CAACK,IAAI,CAACH,KAAK,CAAC;UAAE;QACtC;MACJ;MACAN,IAAI,GAAGI,aAAa,CAACO,GAAG,CAAC,CAAC;IAC9B;IAEA,OAAOV,MAAM;EACjB,CAAC;EAED3C,KAAK,CAACoC,SAAS,CAACkB,QAAQ,GAAG,SAASA,QAAQA,CAAEb,IAAI,EAAE;IAChD,IAAIC,IAAI,GAAG,IAAI,CAACH,IAAI;IAEpB,IAAI,CAACK,UAAU,CAACH,IAAI,EAAEC,IAAI,CAAC,EAAE;MAAE,OAAO,KAAK;IAAE;IAE7C,IAAII,aAAa,GAAG,EAAE;IACtB,OAAOJ,IAAI,EAAE;MACT,KAAK,IAAIjB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiB,IAAI,CAACK,QAAQ,CAACvC,MAAM,EAAEiB,CAAC,EAAE,EAAE;QAC3C,IAAIuB,KAAK,GAAGN,IAAI,CAACK,QAAQ,CAACtB,CAAC,CAAC;QAC5B,IAAIwB,SAAS,GAAGP,IAAI,CAACQ,IAAI,GAAG,IAAI,CAACL,MAAM,CAACG,KAAK,CAAC,GAAGA,KAAK;QAEtD,IAAIJ,UAAU,CAACH,IAAI,EAAEQ,SAAS,CAAC,EAAE;UAC7B,IAAIP,IAAI,CAACQ,IAAI,IAAIE,QAAQ,CAACX,IAAI,EAAEQ,SAAS,CAAC,EAAE;YAAE,OAAO,IAAI;UAAE;UAC3DH,aAAa,CAACK,IAAI,CAACH,KAAK,CAAC;QAC7B;MACJ;MACAN,IAAI,GAAGI,aAAa,CAACO,GAAG,CAAC,CAAC;IAC9B;IAEA,OAAO,KAAK;EAChB,CAAC;EAEDrD,KAAK,CAACoC,SAAS,CAACmB,IAAI,GAAG,SAASA,IAAIA,CAAEhB,IAAI,EAAE;IACxC,IAAI,EAAEA,IAAI,IAAIA,IAAI,CAAC/B,MAAM,CAAC,EAAE;MAAE,OAAO,IAAI;IAAE;IAE3C,IAAI+B,IAAI,CAAC/B,MAAM,GAAG,IAAI,CAACyB,WAAW,EAAE;MAChC,KAAK,IAAIR,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGc,IAAI,CAAC/B,MAAM,EAAEiB,CAAC,EAAE,EAAE;QAClC,IAAI,CAAC+B,MAAM,CAACjB,IAAI,CAACd,CAAC,CAAC,CAAC;MACxB;MACA,OAAO,IAAI;IACf;;IAEA;IACA,IAAIiB,IAAI,GAAG,IAAI,CAACe,MAAM,CAAClB,IAAI,CAACmB,KAAK,CAAC,CAAC,EAAE,CAAC,EAAEnB,IAAI,CAAC/B,MAAM,GAAG,CAAC,EAAE,CAAC,CAAC;IAE3D,IAAI,CAAC,IAAI,CAAC+B,IAAI,CAACQ,QAAQ,CAACvC,MAAM,EAAE;MAC5B;MACA,IAAI,CAAC+B,IAAI,GAAGG,IAAI;IAEpB,CAAC,MAAM,IAAI,IAAI,CAACH,IAAI,CAACoB,MAAM,KAAKjB,IAAI,CAACiB,MAAM,EAAE;MACzC;MACA,IAAI,CAACC,UAAU,CAAC,IAAI,CAACrB,IAAI,EAAEG,IAAI,CAAC;IAEpC,CAAC,MAAM;MACH,IAAI,IAAI,CAACH,IAAI,CAACoB,MAAM,GAAGjB,IAAI,CAACiB,MAAM,EAAE;QAChC;QACA,IAAIE,OAAO,GAAG,IAAI,CAACtB,IAAI;QACvB,IAAI,CAACA,IAAI,GAAGG,IAAI;QAChBA,IAAI,GAAGmB,OAAO;MAClB;;MAEA;MACA,IAAI,CAACC,OAAO,CAACpB,IAAI,EAAE,IAAI,CAACH,IAAI,CAACoB,MAAM,GAAGjB,IAAI,CAACiB,MAAM,GAAG,CAAC,EAAE,IAAI,CAAC;IAChE;IAEA,OAAO,IAAI;EACf,CAAC;EAED3D,KAAK,CAACoC,SAAS,CAACoB,MAAM,GAAG,SAASA,MAAMA,CAAEO,IAAI,EAAE;IAC5C,IAAIA,IAAI,EAAE;MAAE,IAAI,CAACD,OAAO,CAACC,IAAI,EAAE,IAAI,CAACxB,IAAI,CAACoB,MAAM,GAAG,CAAC,CAAC;IAAE;IACtD,OAAO,IAAI;EACf,CAAC;EAED3D,KAAK,CAACoC,SAAS,CAACD,KAAK,GAAG,SAASA,KAAKA,CAAA,EAAI;IACtC,IAAI,CAACI,IAAI,GAAGyB,UAAU,CAAC,EAAE,CAAC;IAC1B,OAAO,IAAI;EACf,CAAC;EAEDhE,KAAK,CAACoC,SAAS,CAAC6B,MAAM,GAAG,SAASA,MAAMA,CAAEF,IAAI,EAAEG,QAAQ,EAAE;IACtD,IAAI,CAACH,IAAI,EAAE;MAAE,OAAO,IAAI;IAAE;IAE1B,IAAIrB,IAAI,GAAG,IAAI,CAACH,IAAI;IACpB,IAAIE,IAAI,GAAG,IAAI,CAACI,MAAM,CAACkB,IAAI,CAAC;IAC5B,IAAII,IAAI,GAAG,EAAE;IACb,IAAIC,OAAO,GAAG,EAAE;IAChB,IAAI3C,CAAC,EAAE4C,MAAM,EAAEC,OAAO;;IAEtB;IACA,OAAO5B,IAAI,IAAIyB,IAAI,CAAC3D,MAAM,EAAE;MAExB,IAAI,CAACkC,IAAI,EAAE;QAAE;QACTA,IAAI,GAAGyB,IAAI,CAACd,GAAG,CAAC,CAAC;QACjBgB,MAAM,GAAGF,IAAI,CAACA,IAAI,CAAC3D,MAAM,GAAG,CAAC,CAAC;QAC9BiB,CAAC,GAAG2C,OAAO,CAACf,GAAG,CAAC,CAAC;QACjBiB,OAAO,GAAG,IAAI;MAClB;MAEA,IAAI5B,IAAI,CAACQ,IAAI,EAAE;QAAE;QACb,IAAIqB,KAAK,GAAGC,QAAQ,CAACT,IAAI,EAAErB,IAAI,CAACK,QAAQ,EAAEmB,QAAQ,CAAC;QAEnD,IAAIK,KAAK,KAAK,CAAC,CAAC,EAAE;UACd;UACA7B,IAAI,CAACK,QAAQ,CAAC0B,MAAM,CAACF,KAAK,EAAE,CAAC,CAAC;UAC9BJ,IAAI,CAAChB,IAAI,CAACT,IAAI,CAAC;UACf,IAAI,CAACgC,SAAS,CAACP,IAAI,CAAC;UACpB,OAAO,IAAI;QACf;MACJ;MAEA,IAAI,CAACG,OAAO,IAAI,CAAC5B,IAAI,CAACQ,IAAI,IAAIE,QAAQ,CAACV,IAAI,EAAED,IAAI,CAAC,EAAE;QAAE;QAClD0B,IAAI,CAAChB,IAAI,CAACT,IAAI,CAAC;QACf0B,OAAO,CAACjB,IAAI,CAAC1B,CAAC,CAAC;QACfA,CAAC,GAAG,CAAC;QACL4C,MAAM,GAAG3B,IAAI;QACbA,IAAI,GAAGA,IAAI,CAACK,QAAQ,CAAC,CAAC,CAAC;MAE3B,CAAC,MAAM,IAAIsB,MAAM,EAAE;QAAE;QACjB5C,CAAC,EAAE;QACHiB,IAAI,GAAG2B,MAAM,CAACtB,QAAQ,CAACtB,CAAC,CAAC;QACzB6C,OAAO,GAAG,KAAK;MAEnB,CAAC,MAAM;QAAE5B,IAAI,GAAG,IAAI;MAAE,CAAC,CAAC;IAC5B;;IAEA,OAAO,IAAI;EACf,CAAC;EAED1C,KAAK,CAACoC,SAAS,CAACS,MAAM,GAAG,SAASA,MAAMA,CAAEkB,IAAI,EAAE;IAAE,OAAOA,IAAI;EAAE,CAAC;EAEhE/D,KAAK,CAACoC,SAAS,CAACuC,WAAW,GAAG,SAASA,WAAWA,CAAE9C,CAAC,EAAEC,CAAC,EAAE;IAAE,OAAOD,CAAC,CAAC+C,IAAI,GAAG9C,CAAC,CAAC8C,IAAI;EAAE,CAAC;EACrF5E,KAAK,CAACoC,SAAS,CAACyC,WAAW,GAAG,SAASA,WAAWA,CAAEhD,CAAC,EAAEC,CAAC,EAAE;IAAE,OAAOD,CAAC,CAACiD,IAAI,GAAGhD,CAAC,CAACgD,IAAI;EAAE,CAAC;EAErF9E,KAAK,CAACoC,SAAS,CAAC2C,MAAM,GAAG,SAASA,MAAMA,CAAA,EAAI;IAAE,OAAO,IAAI,CAACxC,IAAI;EAAE,CAAC;EAEjEvC,KAAK,CAACoC,SAAS,CAAC4C,QAAQ,GAAG,SAASA,QAAQA,CAAEzC,IAAI,EAAE;IAChD,IAAI,CAACA,IAAI,GAAGA,IAAI;IAChB,OAAO,IAAI;EACf,CAAC;EAEDvC,KAAK,CAACoC,SAAS,CAACE,IAAI,GAAG,SAASA,IAAIA,CAAEI,IAAI,EAAEC,MAAM,EAAE;IAChD,IAAIG,aAAa,GAAG,EAAE;IACtB,OAAOJ,IAAI,EAAE;MACT,IAAIA,IAAI,CAACQ,IAAI,EAAE;QAAEP,MAAM,CAACQ,IAAI,CAAC8B,KAAK,CAACtC,MAAM,EAAED,IAAI,CAACK,QAAQ,CAAC;MAAE,CAAC,MACvD;QAAED,aAAa,CAACK,IAAI,CAAC8B,KAAK,CAACnC,aAAa,EAAEJ,IAAI,CAACK,QAAQ,CAAC;MAAE;MAE/DL,IAAI,GAAGI,aAAa,CAACO,GAAG,CAAC,CAAC;IAC9B;IACA,OAAOV,MAAM;EACjB,CAAC;EAED3C,KAAK,CAACoC,SAAS,CAACqB,MAAM,GAAG,SAASA,MAAMA,CAAEyB,KAAK,EAAE9E,IAAI,EAAEC,KAAK,EAAEsD,MAAM,EAAE;IAElE,IAAIwB,CAAC,GAAG9E,KAAK,GAAGD,IAAI,GAAG,CAAC;IACxB,IAAIgF,CAAC,GAAG,IAAI,CAACpD,WAAW;IACxB,IAAIU,IAAI;IAER,IAAIyC,CAAC,IAAIC,CAAC,EAAE;MACR;MACA1C,IAAI,GAAGsB,UAAU,CAACkB,KAAK,CAACxB,KAAK,CAACtD,IAAI,EAAEC,KAAK,GAAG,CAAC,CAAC,CAAC;MAC/CgF,QAAQ,CAAC3C,IAAI,EAAE,IAAI,CAACG,MAAM,CAAC;MAC3B,OAAOH,IAAI;IACf;IAEA,IAAI,CAACiB,MAAM,EAAE;MACT;MACAA,MAAM,GAAG9C,IAAI,CAACqB,IAAI,CAACrB,IAAI,CAACC,GAAG,CAACqE,CAAC,CAAC,GAAGtE,IAAI,CAACC,GAAG,CAACsE,CAAC,CAAC,CAAC;;MAE7C;MACAA,CAAC,GAAGvE,IAAI,CAACqB,IAAI,CAACiD,CAAC,GAAGtE,IAAI,CAACyE,GAAG,CAACF,CAAC,EAAEzB,MAAM,GAAG,CAAC,CAAC,CAAC;IAC9C;IAEAjB,IAAI,GAAGsB,UAAU,CAAC,EAAE,CAAC;IACrBtB,IAAI,CAACQ,IAAI,GAAG,KAAK;IACjBR,IAAI,CAACiB,MAAM,GAAGA,MAAM;;IAEpB;;IAEA,IAAI4B,EAAE,GAAG1E,IAAI,CAACqB,IAAI,CAACiD,CAAC,GAAGC,CAAC,CAAC;IACzB,IAAII,EAAE,GAAGD,EAAE,GAAG1E,IAAI,CAACqB,IAAI,CAACrB,IAAI,CAACK,IAAI,CAACkE,CAAC,CAAC,CAAC;IAErCK,WAAW,CAACP,KAAK,EAAE9E,IAAI,EAAEC,KAAK,EAAEmF,EAAE,EAAE,IAAI,CAACb,WAAW,CAAC;IAErD,KAAK,IAAIlD,CAAC,GAAGrB,IAAI,EAAEqB,CAAC,IAAIpB,KAAK,EAAEoB,CAAC,IAAI+D,EAAE,EAAE;MAEpC,IAAIE,MAAM,GAAG7E,IAAI,CAACU,GAAG,CAACE,CAAC,GAAG+D,EAAE,GAAG,CAAC,EAAEnF,KAAK,CAAC;MAExCoF,WAAW,CAACP,KAAK,EAAEzD,CAAC,EAAEiE,MAAM,EAAEH,EAAE,EAAE,IAAI,CAACV,WAAW,CAAC;MAEnD,KAAK,IAAInD,CAAC,GAAGD,CAAC,EAAEC,CAAC,IAAIgE,MAAM,EAAEhE,CAAC,IAAI6D,EAAE,EAAE;QAElC,IAAII,MAAM,GAAG9E,IAAI,CAACU,GAAG,CAACG,CAAC,GAAG6D,EAAE,GAAG,CAAC,EAAEG,MAAM,CAAC;;QAEzC;QACAhD,IAAI,CAACK,QAAQ,CAACI,IAAI,CAAC,IAAI,CAACM,MAAM,CAACyB,KAAK,EAAExD,CAAC,EAAEiE,MAAM,EAAEhC,MAAM,GAAG,CAAC,CAAC,CAAC;MACjE;IACJ;IAEA0B,QAAQ,CAAC3C,IAAI,EAAE,IAAI,CAACG,MAAM,CAAC;IAE3B,OAAOH,IAAI;EACf,CAAC;EAED1C,KAAK,CAACoC,SAAS,CAACwD,cAAc,GAAG,SAASA,cAAcA,CAAEnD,IAAI,EAAEC,IAAI,EAAEmD,KAAK,EAAE1B,IAAI,EAAE;IAC/E,OAAO,IAAI,EAAE;MACTA,IAAI,CAAChB,IAAI,CAACT,IAAI,CAAC;MAEf,IAAIA,IAAI,CAACQ,IAAI,IAAIiB,IAAI,CAAC3D,MAAM,GAAG,CAAC,KAAKqF,KAAK,EAAE;QAAE;MAAO;MAErD,IAAIC,OAAO,GAAGC,QAAQ;MACtB,IAAIC,cAAc,GAAGD,QAAQ;MAC7B,IAAIE,UAAU,GAAI,KAAK,CAAE;MAEzB,KAAK,IAAIxE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiB,IAAI,CAACK,QAAQ,CAACvC,MAAM,EAAEiB,CAAC,EAAE,EAAE;QAC3C,IAAIuB,KAAK,GAAGN,IAAI,CAACK,QAAQ,CAACtB,CAAC,CAAC;QAC5B,IAAIyE,IAAI,GAAGC,QAAQ,CAACnD,KAAK,CAAC;QAC1B,IAAIoD,WAAW,GAAGC,YAAY,CAAC5D,IAAI,EAAEO,KAAK,CAAC,GAAGkD,IAAI;;QAElD;QACA,IAAIE,WAAW,GAAGJ,cAAc,EAAE;UAC9BA,cAAc,GAAGI,WAAW;UAC5BN,OAAO,GAAGI,IAAI,GAAGJ,OAAO,GAAGI,IAAI,GAAGJ,OAAO;UACzCG,UAAU,GAAGjD,KAAK;QAEtB,CAAC,MAAM,IAAIoD,WAAW,KAAKJ,cAAc,EAAE;UACvC;UACA,IAAIE,IAAI,GAAGJ,OAAO,EAAE;YAChBA,OAAO,GAAGI,IAAI;YACdD,UAAU,GAAGjD,KAAK;UACtB;QACJ;MACJ;MAEAN,IAAI,GAAGuD,UAAU,IAAIvD,IAAI,CAACK,QAAQ,CAAC,CAAC,CAAC;IACzC;IAEA,OAAOL,IAAI;EACf,CAAC;EAED1C,KAAK,CAACoC,SAAS,CAAC0B,OAAO,GAAG,SAASA,OAAOA,CAAEC,IAAI,EAAE8B,KAAK,EAAES,MAAM,EAAE;IAC7D,IAAI7D,IAAI,GAAG6D,MAAM,GAAGvC,IAAI,GAAG,IAAI,CAAClB,MAAM,CAACkB,IAAI,CAAC;IAC5C,IAAIwC,UAAU,GAAG,EAAE;;IAEnB;IACA,IAAI7D,IAAI,GAAG,IAAI,CAACkD,cAAc,CAACnD,IAAI,EAAE,IAAI,CAACF,IAAI,EAAEsD,KAAK,EAAEU,UAAU,CAAC;;IAElE;IACA7D,IAAI,CAACK,QAAQ,CAACI,IAAI,CAACY,IAAI,CAAC;IACxByC,MAAM,CAAC9D,IAAI,EAAED,IAAI,CAAC;;IAElB;IACA,OAAOoD,KAAK,IAAI,CAAC,EAAE;MACf,IAAIU,UAAU,CAACV,KAAK,CAAC,CAAC9C,QAAQ,CAACvC,MAAM,GAAG,IAAI,CAACwB,WAAW,EAAE;QACtD,IAAI,CAACyE,MAAM,CAACF,UAAU,EAAEV,KAAK,CAAC;QAC9BA,KAAK,EAAE;MACX,CAAC,MAAM;QAAE;MAAO;IACpB;;IAEA;IACA,IAAI,CAACa,mBAAmB,CAACjE,IAAI,EAAE8D,UAAU,EAAEV,KAAK,CAAC;EACrD,CAAC;;EAED;EACA7F,KAAK,CAACoC,SAAS,CAACqE,MAAM,GAAG,SAASA,MAAMA,CAAEF,UAAU,EAAEV,KAAK,EAAE;IACzD,IAAInD,IAAI,GAAG6D,UAAU,CAACV,KAAK,CAAC;IAC5B,IAAIT,CAAC,GAAG1C,IAAI,CAACK,QAAQ,CAACvC,MAAM;IAC5B,IAAIG,CAAC,GAAG,IAAI,CAACsB,WAAW;IAExB,IAAI,CAAC0E,gBAAgB,CAACjE,IAAI,EAAE/B,CAAC,EAAEyE,CAAC,CAAC;IAEjC,IAAIwB,UAAU,GAAG,IAAI,CAACC,iBAAiB,CAACnE,IAAI,EAAE/B,CAAC,EAAEyE,CAAC,CAAC;IAEnD,IAAI0B,OAAO,GAAG9C,UAAU,CAACtB,IAAI,CAACK,QAAQ,CAAC0B,MAAM,CAACmC,UAAU,EAAElE,IAAI,CAACK,QAAQ,CAACvC,MAAM,GAAGoG,UAAU,CAAC,CAAC;IAC7FE,OAAO,CAACnD,MAAM,GAAGjB,IAAI,CAACiB,MAAM;IAC5BmD,OAAO,CAAC5D,IAAI,GAAGR,IAAI,CAACQ,IAAI;IAExBmC,QAAQ,CAAC3C,IAAI,EAAE,IAAI,CAACG,MAAM,CAAC;IAC3BwC,QAAQ,CAACyB,OAAO,EAAE,IAAI,CAACjE,MAAM,CAAC;IAE9B,IAAIgD,KAAK,EAAE;MAAEU,UAAU,CAACV,KAAK,GAAG,CAAC,CAAC,CAAC9C,QAAQ,CAACI,IAAI,CAAC2D,OAAO,CAAC;IAAE,CAAC,MACvD;MAAE,IAAI,CAAClD,UAAU,CAAClB,IAAI,EAAEoE,OAAO,CAAC;IAAE;EAC3C,CAAC;EAED9G,KAAK,CAACoC,SAAS,CAACwB,UAAU,GAAG,SAASA,UAAUA,CAAElB,IAAI,EAAEoE,OAAO,EAAE;IAC7D;IACA,IAAI,CAACvE,IAAI,GAAGyB,UAAU,CAAC,CAACtB,IAAI,EAAEoE,OAAO,CAAC,CAAC;IACvC,IAAI,CAACvE,IAAI,CAACoB,MAAM,GAAGjB,IAAI,CAACiB,MAAM,GAAG,CAAC;IAClC,IAAI,CAACpB,IAAI,CAACW,IAAI,GAAG,KAAK;IACtBmC,QAAQ,CAAC,IAAI,CAAC9C,IAAI,EAAE,IAAI,CAACM,MAAM,CAAC;EACpC,CAAC;EAED7C,KAAK,CAACoC,SAAS,CAACyE,iBAAiB,GAAG,SAASA,iBAAiBA,CAAEnE,IAAI,EAAE/B,CAAC,EAAEyE,CAAC,EAAE;IACxE,IAAIb,KAAK;IACT,IAAIwC,UAAU,GAAGhB,QAAQ;IACzB,IAAID,OAAO,GAAGC,QAAQ;IAEtB,KAAK,IAAItE,CAAC,GAAGd,CAAC,EAAEc,CAAC,IAAI2D,CAAC,GAAGzE,CAAC,EAAEc,CAAC,EAAE,EAAE;MAC7B,IAAIuF,KAAK,GAAGC,QAAQ,CAACvE,IAAI,EAAE,CAAC,EAAEjB,CAAC,EAAE,IAAI,CAACoB,MAAM,CAAC;MAC7C,IAAIqE,KAAK,GAAGD,QAAQ,CAACvE,IAAI,EAAEjB,CAAC,EAAE2D,CAAC,EAAE,IAAI,CAACvC,MAAM,CAAC;MAE7C,IAAIsE,OAAO,GAAGC,gBAAgB,CAACJ,KAAK,EAAEE,KAAK,CAAC;MAC5C,IAAIhB,IAAI,GAAGC,QAAQ,CAACa,KAAK,CAAC,GAAGb,QAAQ,CAACe,KAAK,CAAC;;MAE5C;MACA,IAAIC,OAAO,GAAGJ,UAAU,EAAE;QACtBA,UAAU,GAAGI,OAAO;QACpB5C,KAAK,GAAG9C,CAAC;QAETqE,OAAO,GAAGI,IAAI,GAAGJ,OAAO,GAAGI,IAAI,GAAGJ,OAAO;MAE7C,CAAC,MAAM,IAAIqB,OAAO,KAAKJ,UAAU,EAAE;QAC/B;QACA,IAAIb,IAAI,GAAGJ,OAAO,EAAE;UAChBA,OAAO,GAAGI,IAAI;UACd3B,KAAK,GAAG9C,CAAC;QACb;MACJ;IACJ;IAEA,OAAO8C,KAAK,IAAIa,CAAC,GAAGzE,CAAC;EACzB,CAAC;;EAED;EACAX,KAAK,CAACoC,SAAS,CAACuE,gBAAgB,GAAG,SAASA,gBAAgBA,CAAEjE,IAAI,EAAE/B,CAAC,EAAEyE,CAAC,EAAE;IACtE,IAAIT,WAAW,GAAGjC,IAAI,CAACQ,IAAI,GAAG,IAAI,CAACyB,WAAW,GAAG0C,eAAe;IAChE,IAAIxC,WAAW,GAAGnC,IAAI,CAACQ,IAAI,GAAG,IAAI,CAAC2B,WAAW,GAAGyC,eAAe;IAChE,IAAIC,OAAO,GAAG,IAAI,CAACC,cAAc,CAAC9E,IAAI,EAAE/B,CAAC,EAAEyE,CAAC,EAAET,WAAW,CAAC;IAC1D,IAAI8C,OAAO,GAAG,IAAI,CAACD,cAAc,CAAC9E,IAAI,EAAE/B,CAAC,EAAEyE,CAAC,EAAEP,WAAW,CAAC;;IAE1D;IACA;IACA,IAAI0C,OAAO,GAAGE,OAAO,EAAE;MAAE/E,IAAI,CAACK,QAAQ,CAAC2E,IAAI,CAAC/C,WAAW,CAAC;IAAE;EAC9D,CAAC;;EAED;EACA3E,KAAK,CAACoC,SAAS,CAACoF,cAAc,GAAG,SAASA,cAAcA,CAAE9E,IAAI,EAAE/B,CAAC,EAAEyE,CAAC,EAAE9E,OAAO,EAAE;IAC3EoC,IAAI,CAACK,QAAQ,CAAC2E,IAAI,CAACpH,OAAO,CAAC;IAE3B,IAAIuC,MAAM,GAAG,IAAI,CAACA,MAAM;IACxB,IAAI8E,QAAQ,GAAGV,QAAQ,CAACvE,IAAI,EAAE,CAAC,EAAE/B,CAAC,EAAEkC,MAAM,CAAC;IAC3C,IAAI+E,SAAS,GAAGX,QAAQ,CAACvE,IAAI,EAAE0C,CAAC,GAAGzE,CAAC,EAAEyE,CAAC,EAAEvC,MAAM,CAAC;IAChD,IAAIgF,MAAM,GAAGC,UAAU,CAACH,QAAQ,CAAC,GAAGG,UAAU,CAACF,SAAS,CAAC;IAEzD,KAAK,IAAInG,CAAC,GAAGd,CAAC,EAAEc,CAAC,GAAG2D,CAAC,GAAGzE,CAAC,EAAEc,CAAC,EAAE,EAAE;MAC5B,IAAIuB,KAAK,GAAGN,IAAI,CAACK,QAAQ,CAACtB,CAAC,CAAC;MAC5B+E,MAAM,CAACmB,QAAQ,EAAEjF,IAAI,CAACQ,IAAI,GAAGL,MAAM,CAACG,KAAK,CAAC,GAAGA,KAAK,CAAC;MACnD6E,MAAM,IAAIC,UAAU,CAACH,QAAQ,CAAC;IAClC;IAEA,KAAK,IAAII,GAAG,GAAG3C,CAAC,GAAGzE,CAAC,GAAG,CAAC,EAAEoH,GAAG,IAAIpH,CAAC,EAAEoH,GAAG,EAAE,EAAE;MACvC,IAAIC,OAAO,GAAGtF,IAAI,CAACK,QAAQ,CAACgF,GAAG,CAAC;MAChCvB,MAAM,CAACoB,SAAS,EAAElF,IAAI,CAACQ,IAAI,GAAGL,MAAM,CAACmF,OAAO,CAAC,GAAGA,OAAO,CAAC;MACxDH,MAAM,IAAIC,UAAU,CAACF,SAAS,CAAC;IACnC;IAEA,OAAOC,MAAM;EACjB,CAAC;EAED7H,KAAK,CAACoC,SAAS,CAACsE,mBAAmB,GAAG,SAASA,mBAAmBA,CAAEjE,IAAI,EAAE0B,IAAI,EAAE0B,KAAK,EAAE;IACnF;IACA,KAAK,IAAIpE,CAAC,GAAGoE,KAAK,EAAEpE,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MAC7B+E,MAAM,CAACrC,IAAI,CAAC1C,CAAC,CAAC,EAAEgB,IAAI,CAAC;IACzB;EACJ,CAAC;EAEDzC,KAAK,CAACoC,SAAS,CAACsC,SAAS,GAAG,SAASA,SAASA,CAAEP,IAAI,EAAE;IAClD;IACA,KAAK,IAAI1C,CAAC,GAAG0C,IAAI,CAAC3D,MAAM,GAAG,CAAC,EAAEyH,QAAQ,GAAI,KAAK,CAAE,EAAExG,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MAC5D,IAAI0C,IAAI,CAAC1C,CAAC,CAAC,CAACsB,QAAQ,CAACvC,MAAM,KAAK,CAAC,EAAE;QAC/B,IAAIiB,CAAC,GAAG,CAAC,EAAE;UACPwG,QAAQ,GAAG9D,IAAI,CAAC1C,CAAC,GAAG,CAAC,CAAC,CAACsB,QAAQ;UAC/BkF,QAAQ,CAACxD,MAAM,CAACwD,QAAQ,CAACC,OAAO,CAAC/D,IAAI,CAAC1C,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;QAEjD,CAAC,MAAM;UAAE,IAAI,CAACU,KAAK,CAAC,CAAC;QAAE;MAE3B,CAAC,MAAM;QAAEkD,QAAQ,CAAClB,IAAI,CAAC1C,CAAC,CAAC,EAAE,IAAI,CAACoB,MAAM,CAAC;MAAE;IAC7C;EACJ,CAAC;EAED,SAAS2B,QAAQA,CAACT,IAAI,EAAEmB,KAAK,EAAEhB,QAAQ,EAAE;IACrC,IAAI,CAACA,QAAQ,EAAE;MAAE,OAAOgB,KAAK,CAACgD,OAAO,CAACnE,IAAI,CAAC;IAAE;IAE7C,KAAK,IAAItC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyD,KAAK,CAAC1E,MAAM,EAAEiB,CAAC,EAAE,EAAE;MACnC,IAAIyC,QAAQ,CAACH,IAAI,EAAEmB,KAAK,CAACzD,CAAC,CAAC,CAAC,EAAE;QAAE,OAAOA,CAAC;MAAE;IAC9C;IACA,OAAO,CAAC,CAAC;EACb;;EAEA;EACA,SAAS4D,QAAQA,CAAC3C,IAAI,EAAEG,MAAM,EAAE;IAC5BoE,QAAQ,CAACvE,IAAI,EAAE,CAAC,EAAEA,IAAI,CAACK,QAAQ,CAACvC,MAAM,EAAEqC,MAAM,EAAEH,IAAI,CAAC;EACzD;;EAEA;EACA,SAASuE,QAAQA,CAACvE,IAAI,EAAEvC,CAAC,EAAEgI,CAAC,EAAEtF,MAAM,EAAEuF,QAAQ,EAAE;IAC5C,IAAI,CAACA,QAAQ,EAAE;MAAEA,QAAQ,GAAGpE,UAAU,CAAC,IAAI,CAAC;IAAE;IAC9CoE,QAAQ,CAACxD,IAAI,GAAGmB,QAAQ;IACxBqC,QAAQ,CAACtD,IAAI,GAAGiB,QAAQ;IACxBqC,QAAQ,CAACC,IAAI,GAAG,CAACtC,QAAQ;IACzBqC,QAAQ,CAACE,IAAI,GAAG,CAACvC,QAAQ;IAEzB,KAAK,IAAItE,CAAC,GAAGtB,CAAC,EAAEsB,CAAC,GAAG0G,CAAC,EAAE1G,CAAC,EAAE,EAAE;MACxB,IAAIuB,KAAK,GAAGN,IAAI,CAACK,QAAQ,CAACtB,CAAC,CAAC;MAC5B+E,MAAM,CAAC4B,QAAQ,EAAE1F,IAAI,CAACQ,IAAI,GAAGL,MAAM,CAACG,KAAK,CAAC,GAAGA,KAAK,CAAC;IACvD;IAEA,OAAOoF,QAAQ;EACnB;EAEA,SAAS5B,MAAMA,CAAC3E,CAAC,EAAEC,CAAC,EAAE;IAClBD,CAAC,CAAC+C,IAAI,GAAG/D,IAAI,CAACU,GAAG,CAACM,CAAC,CAAC+C,IAAI,EAAE9C,CAAC,CAAC8C,IAAI,CAAC;IACjC/C,CAAC,CAACiD,IAAI,GAAGjE,IAAI,CAACU,GAAG,CAACM,CAAC,CAACiD,IAAI,EAAEhD,CAAC,CAACgD,IAAI,CAAC;IACjCjD,CAAC,CAACwG,IAAI,GAAGxH,IAAI,CAACO,GAAG,CAACS,CAAC,CAACwG,IAAI,EAAEvG,CAAC,CAACuG,IAAI,CAAC;IACjCxG,CAAC,CAACyG,IAAI,GAAGzH,IAAI,CAACO,GAAG,CAACS,CAAC,CAACyG,IAAI,EAAExG,CAAC,CAACwG,IAAI,CAAC;IACjC,OAAOzG,CAAC;EACZ;EAEA,SAASwF,eAAeA,CAACxF,CAAC,EAAEC,CAAC,EAAE;IAAE,OAAOD,CAAC,CAAC+C,IAAI,GAAG9C,CAAC,CAAC8C,IAAI;EAAE;EACzD,SAAS0C,eAAeA,CAACzF,CAAC,EAAEC,CAAC,EAAE;IAAE,OAAOD,CAAC,CAACiD,IAAI,GAAGhD,CAAC,CAACgD,IAAI;EAAE;EAEzD,SAASqB,QAAQA,CAACtE,CAAC,EAAI;IAAE,OAAO,CAACA,CAAC,CAACwG,IAAI,GAAGxG,CAAC,CAAC+C,IAAI,KAAK/C,CAAC,CAACyG,IAAI,GAAGzG,CAAC,CAACiD,IAAI,CAAC;EAAE;EACvE,SAASgD,UAAUA,CAACjG,CAAC,EAAE;IAAE,OAAQA,CAAC,CAACwG,IAAI,GAAGxG,CAAC,CAAC+C,IAAI,IAAK/C,CAAC,CAACyG,IAAI,GAAGzG,CAAC,CAACiD,IAAI,CAAC;EAAE;EAEvE,SAASuB,YAAYA,CAACxE,CAAC,EAAEC,CAAC,EAAE;IACxB,OAAO,CAACjB,IAAI,CAACO,GAAG,CAACU,CAAC,CAACuG,IAAI,EAAExG,CAAC,CAACwG,IAAI,CAAC,GAAGxH,IAAI,CAACU,GAAG,CAACO,CAAC,CAAC8C,IAAI,EAAE/C,CAAC,CAAC+C,IAAI,CAAC,KACnD/D,IAAI,CAACO,GAAG,CAACU,CAAC,CAACwG,IAAI,EAAEzG,CAAC,CAACyG,IAAI,CAAC,GAAGzH,IAAI,CAACU,GAAG,CAACO,CAAC,CAACgD,IAAI,EAAEjD,CAAC,CAACiD,IAAI,CAAC,CAAC;EAChE;EAEA,SAASsC,gBAAgBA,CAACvF,CAAC,EAAEC,CAAC,EAAE;IAC5B,IAAI8C,IAAI,GAAG/D,IAAI,CAACO,GAAG,CAACS,CAAC,CAAC+C,IAAI,EAAE9C,CAAC,CAAC8C,IAAI,CAAC;IACnC,IAAIE,IAAI,GAAGjE,IAAI,CAACO,GAAG,CAACS,CAAC,CAACiD,IAAI,EAAEhD,CAAC,CAACgD,IAAI,CAAC;IACnC,IAAIuD,IAAI,GAAGxH,IAAI,CAACU,GAAG,CAACM,CAAC,CAACwG,IAAI,EAAEvG,CAAC,CAACuG,IAAI,CAAC;IACnC,IAAIC,IAAI,GAAGzH,IAAI,CAACU,GAAG,CAACM,CAAC,CAACyG,IAAI,EAAExG,CAAC,CAACwG,IAAI,CAAC;IAEnC,OAAOzH,IAAI,CAACO,GAAG,CAAC,CAAC,EAAEiH,IAAI,GAAGzD,IAAI,CAAC,GACxB/D,IAAI,CAACO,GAAG,CAAC,CAAC,EAAEkH,IAAI,GAAGxD,IAAI,CAAC;EACnC;EAEA,SAAS1B,QAAQA,CAACvB,CAAC,EAAEC,CAAC,EAAE;IACpB,OAAOD,CAAC,CAAC+C,IAAI,IAAI9C,CAAC,CAAC8C,IAAI,IAChB/C,CAAC,CAACiD,IAAI,IAAIhD,CAAC,CAACgD,IAAI,IAChBhD,CAAC,CAACuG,IAAI,IAAIxG,CAAC,CAACwG,IAAI,IAChBvG,CAAC,CAACwG,IAAI,IAAIzG,CAAC,CAACyG,IAAI;EAC3B;EAEA,SAAS1F,UAAUA,CAACf,CAAC,EAAEC,CAAC,EAAE;IACtB,OAAOA,CAAC,CAAC8C,IAAI,IAAI/C,CAAC,CAACwG,IAAI,IAChBvG,CAAC,CAACgD,IAAI,IAAIjD,CAAC,CAACyG,IAAI,IAChBxG,CAAC,CAACuG,IAAI,IAAIxG,CAAC,CAAC+C,IAAI,IAChB9C,CAAC,CAACwG,IAAI,IAAIzG,CAAC,CAACiD,IAAI;EAC3B;EAEA,SAASd,UAAUA,CAACjB,QAAQ,EAAE;IAC1B,OAAO;MACHA,QAAQ,EAAEA,QAAQ;MAClBY,MAAM,EAAE,CAAC;MACTT,IAAI,EAAE,IAAI;MACV0B,IAAI,EAAEmB,QAAQ;MACdjB,IAAI,EAAEiB,QAAQ;MACdsC,IAAI,EAAE,CAACtC,QAAQ;MACfuC,IAAI,EAAE,CAACvC;IACX,CAAC;EACL;;EAEA;EACA;;EAEA,SAASN,WAAWA,CAACvF,GAAG,EAAEE,IAAI,EAAEC,KAAK,EAAEK,CAAC,EAAEJ,OAAO,EAAE;IAC/C,IAAIiI,KAAK,GAAG,CAACnI,IAAI,EAAEC,KAAK,CAAC;IAEzB,OAAOkI,KAAK,CAAC/H,MAAM,EAAE;MACjBH,KAAK,GAAGkI,KAAK,CAAClF,GAAG,CAAC,CAAC;MACnBjD,IAAI,GAAGmI,KAAK,CAAClF,GAAG,CAAC,CAAC;MAElB,IAAIhD,KAAK,GAAGD,IAAI,IAAIM,CAAC,EAAE;QAAE;MAAU;MAEnC,IAAI8H,GAAG,GAAGpI,IAAI,GAAGS,IAAI,CAACqB,IAAI,CAAC,CAAC7B,KAAK,GAAGD,IAAI,IAAIM,CAAC,GAAG,CAAC,CAAC,GAAGA,CAAC;MACtDT,WAAW,CAACC,GAAG,EAAEsI,GAAG,EAAEpI,IAAI,EAAEC,KAAK,EAAEC,OAAO,CAAC;MAE3CiI,KAAK,CAACpF,IAAI,CAAC/C,IAAI,EAAEoI,GAAG,EAAEA,GAAG,EAAEnI,KAAK,CAAC;IACrC;EACJ;EAEA,OAAOL,KAAK;AAEZ,CAAC,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}
{"ast":null,"code":"/**\n * @module ol/render/canvas/ExecutorGroup\n */\nimport BuilderType from './BuilderType.js';\nimport Executor from './Executor.js';\nimport { buffer, createEmpty, extendCoordinate } from '../../extent.js';\nimport { compose as composeTransform, create as createTransform } from '../../transform.js';\nimport { createCanvasContext2D } from '../../dom.js';\nimport { isEmpty } from '../../obj.js';\nimport { numberSafeCompareFunction } from '../../array.js';\nimport { transform2D } from '../../geom/flat/transform.js';\n/**\n * @const\n * @type {Array<import(\"./BuilderType.js\").default>}\n */\nvar ORDER = [BuilderType.POLYGON, BuilderType.CIRCLE, BuilderType.LINE_STRING, BuilderType.IMAGE, BuilderType.TEXT, BuilderType.DEFAULT];\nvar ExecutorGroup = /** @class */function () {\n  /**\n   * @param {import(\"../../extent.js\").Extent} maxExtent Max extent for clipping. When a\n   * `maxExtent` was set on the Buillder for this executor group, the same `maxExtent`\n   * should be set here, unless the target context does not exceet that extent (which\n   * can be the case when rendering to tiles).\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {boolean} overlaps The executor group can have overlapping geometries.\n   * @param {!Object<string, !Object<import(\"./BuilderType.js\").default, import(\"./Builder.js\").SerializableInstructions>>} allInstructions\n   * The serializable instructions.\n   * @param {number=} opt_renderBuffer Optional rendering buffer.\n   */\n  function ExecutorGroup(maxExtent, resolution, pixelRatio, overlaps, allInstructions, opt_renderBuffer) {\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.maxExtent_ = maxExtent;\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.overlaps_ = overlaps;\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n    /**\n     * @private\n     * @type {number}\n     */\n    this.resolution_ = resolution;\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.renderBuffer_ = opt_renderBuffer;\n    /**\n     * @private\n     * @type {!Object<string, !Object<import(\"./BuilderType.js\").default, import(\"./Executor\").default>>}\n     */\n    this.executorsByZIndex_ = {};\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.hitDetectionContext_ = null;\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.hitDetectionTransform_ = createTransform();\n    this.createExecutors_(allInstructions);\n  }\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   */\n  ExecutorGroup.prototype.clip = function (context, transform) {\n    var flatClipCoords = this.getClipCoords(transform);\n    context.beginPath();\n    context.moveTo(flatClipCoords[0], flatClipCoords[1]);\n    context.lineTo(flatClipCoords[2], flatClipCoords[3]);\n    context.lineTo(flatClipCoords[4], flatClipCoords[5]);\n    context.lineTo(flatClipCoords[6], flatClipCoords[7]);\n    context.clip();\n  };\n  /**\n   * Create executors and populate them using the provided instructions.\n   * @private\n   * @param {!Object<string, !Object<import(\"./BuilderType.js\").default, import(\"./Builder.js\").SerializableInstructions>>} allInstructions The serializable instructions\n   */\n  ExecutorGroup.prototype.createExecutors_ = function (allInstructions) {\n    for (var zIndex in allInstructions) {\n      var executors = this.executorsByZIndex_[zIndex];\n      if (executors === undefined) {\n        executors = {};\n        this.executorsByZIndex_[zIndex] = executors;\n      }\n      var instructionByZindex = allInstructions[zIndex];\n      var renderBuffer = [this.renderBuffer_ || 0, this.renderBuffer_ || 0];\n      for (var builderType in instructionByZindex) {\n        var instructions = instructionByZindex[builderType];\n        executors[builderType] = new Executor(this.resolution_, this.pixelRatio_, this.overlaps_, instructions, renderBuffer);\n      }\n    }\n  };\n  /**\n   * @param {Array<import(\"./BuilderType.js\").default>} executors Executors.\n   * @return {boolean} Has executors of the provided types.\n   */\n  ExecutorGroup.prototype.hasExecutors = function (executors) {\n    for (var zIndex in this.executorsByZIndex_) {\n      var candidates = this.executorsByZIndex_[zIndex];\n      for (var i = 0, ii = executors.length; i < ii; ++i) {\n        if (executors[i] in candidates) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {number} rotation Rotation.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {function(import(\"../../Feature.js\").FeatureLike): T} callback Feature callback.\n   * @param {Array<import(\"../../Feature.js\").FeatureLike>} declutteredFeatures Decluttered features.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  ExecutorGroup.prototype.forEachFeatureAtCoordinate = function (coordinate, resolution, rotation, hitTolerance, callback, declutteredFeatures) {\n    hitTolerance = Math.round(hitTolerance);\n    var contextSize = hitTolerance * 2 + 1;\n    var transform = composeTransform(this.hitDetectionTransform_, hitTolerance + 0.5, hitTolerance + 0.5, 1 / resolution, -1 / resolution, -rotation, -coordinate[0], -coordinate[1]);\n    if (!this.hitDetectionContext_) {\n      this.hitDetectionContext_ = createCanvasContext2D(contextSize, contextSize);\n    }\n    var context = this.hitDetectionContext_;\n    if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {\n      context.canvas.width = contextSize;\n      context.canvas.height = contextSize;\n    } else {\n      context.clearRect(0, 0, contextSize, contextSize);\n    }\n    /**\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    var hitExtent;\n    if (this.renderBuffer_ !== undefined) {\n      hitExtent = createEmpty();\n      extendCoordinate(hitExtent, coordinate);\n      buffer(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);\n    }\n    var mask = getCircleArray(hitTolerance);\n    var builderType;\n    /**\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @return {?} Callback result.\n     */\n    function featureCallback(feature) {\n      var imageData = context.getImageData(0, 0, contextSize, contextSize).data;\n      for (var i_1 = 0; i_1 < contextSize; i_1++) {\n        for (var j_1 = 0; j_1 < contextSize; j_1++) {\n          if (mask[i_1][j_1]) {\n            if (imageData[(j_1 * contextSize + i_1) * 4 + 3] > 0) {\n              var result_1 = void 0;\n              if (!(declutteredFeatures && (builderType == BuilderType.IMAGE || builderType == BuilderType.TEXT)) || declutteredFeatures.indexOf(feature) !== -1) {\n                result_1 = callback(feature);\n              }\n              if (result_1) {\n                return result_1;\n              } else {\n                context.clearRect(0, 0, contextSize, contextSize);\n                return undefined;\n              }\n            }\n          }\n        }\n      }\n    }\n    /** @type {Array<number>} */\n    var zs = Object.keys(this.executorsByZIndex_).map(Number);\n    zs.sort(numberSafeCompareFunction);\n    var i, j, executors, executor, result;\n    for (i = zs.length - 1; i >= 0; --i) {\n      var zIndexKey = zs[i].toString();\n      executors = this.executorsByZIndex_[zIndexKey];\n      for (j = ORDER.length - 1; j >= 0; --j) {\n        builderType = ORDER[j];\n        executor = executors[builderType];\n        if (executor !== undefined) {\n          result = executor.executeHitDetection(context, transform, rotation, featureCallback, hitExtent);\n          if (result) {\n            return result;\n          }\n        }\n      }\n    }\n    return undefined;\n  };\n  /**\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @return {Array<number>} Clip coordinates.\n   */\n  ExecutorGroup.prototype.getClipCoords = function (transform) {\n    var maxExtent = this.maxExtent_;\n    if (!maxExtent) {\n      return null;\n    }\n    var minX = maxExtent[0];\n    var minY = maxExtent[1];\n    var maxX = maxExtent[2];\n    var maxY = maxExtent[3];\n    var flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];\n    transform2D(flatClipCoords, 0, 8, 2, transform, flatClipCoords);\n    return flatClipCoords;\n  };\n  /**\n   * @return {boolean} Is empty.\n   */\n  ExecutorGroup.prototype.isEmpty = function () {\n    return isEmpty(this.executorsByZIndex_);\n  };\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} contextScale Scale of the context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.\n   * @param {Array<import(\"./BuilderType.js\").default>=} opt_builderTypes Ordered replay types to replay.\n   *     Default is {@link module:ol/render/replay~ORDER}\n   * @param {Object<string, import(\"../canvas.js\").DeclutterGroup>=} opt_declutterReplays Declutter replays.\n   */\n  ExecutorGroup.prototype.execute = function (context, contextScale, transform, viewRotation, snapToPixel, opt_builderTypes, opt_declutterReplays) {\n    /** @type {Array<number>} */\n    var zs = Object.keys(this.executorsByZIndex_).map(Number);\n    zs.sort(numberSafeCompareFunction);\n    // setup clipping so that the parts of over-simplified geometries are not\n    // visible outside the current extent when panning\n    if (this.maxExtent_) {\n      context.save();\n      this.clip(context, transform);\n    }\n    var builderTypes = opt_builderTypes ? opt_builderTypes : ORDER;\n    var i, ii, j, jj, replays, replay;\n    for (i = 0, ii = zs.length; i < ii; ++i) {\n      var zIndexKey = zs[i].toString();\n      replays = this.executorsByZIndex_[zIndexKey];\n      for (j = 0, jj = builderTypes.length; j < jj; ++j) {\n        var builderType = builderTypes[j];\n        replay = replays[builderType];\n        if (replay !== undefined) {\n          if (opt_declutterReplays && (builderType == BuilderType.IMAGE || builderType == BuilderType.TEXT)) {\n            var declutter = opt_declutterReplays[zIndexKey];\n            if (!declutter) {\n              opt_declutterReplays[zIndexKey] = [replay, transform.slice(0)];\n            } else {\n              declutter.push(replay, transform.slice(0));\n            }\n          } else {\n            replay.execute(context, contextScale, transform, viewRotation, snapToPixel);\n          }\n        }\n      }\n    }\n    if (this.maxExtent_) {\n      context.restore();\n    }\n  };\n  return ExecutorGroup;\n}();\n/**\n * This cache is used for storing calculated pixel circles for increasing performance.\n * It is a static property to allow each Replaygroup to access it.\n * @type {Object<number, Array<Array<(boolean|undefined)>>>}\n */\nvar circleArrayCache = {\n  0: [[true]]\n};\n/**\n * This method fills a row in the array from the given coordinate to the\n * middle with `true`.\n * @param {Array<Array<(boolean|undefined)>>} array The array that will be altered.\n * @param {number} x X coordinate.\n * @param {number} y Y coordinate.\n */\nfunction fillCircleArrayRowToMiddle(array, x, y) {\n  var i;\n  var radius = Math.floor(array.length / 2);\n  if (x >= radius) {\n    for (i = radius; i < x; i++) {\n      array[i][y] = true;\n    }\n  } else if (x < radius) {\n    for (i = x + 1; i < radius; i++) {\n      array[i][y] = true;\n    }\n  }\n}\n/**\n * This methods creates a circle inside a fitting array. Points inside the\n * circle are marked by true, points on the outside are undefined.\n * It uses the midpoint circle algorithm.\n * A cache is used to increase performance.\n * @param {number} radius Radius.\n * @returns {Array<Array<(boolean|undefined)>>} An array with marked circle points.\n */\nexport function getCircleArray(radius) {\n  if (circleArrayCache[radius] !== undefined) {\n    return circleArrayCache[radius];\n  }\n  var arraySize = radius * 2 + 1;\n  var arr = new Array(arraySize);\n  for (var i = 0; i < arraySize; i++) {\n    arr[i] = new Array(arraySize);\n  }\n  var x = radius;\n  var y = 0;\n  var error = 0;\n  while (x >= y) {\n    fillCircleArrayRowToMiddle(arr, radius + x, radius + y);\n    fillCircleArrayRowToMiddle(arr, radius + y, radius + x);\n    fillCircleArrayRowToMiddle(arr, radius - y, radius + x);\n    fillCircleArrayRowToMiddle(arr, radius - x, radius + y);\n    fillCircleArrayRowToMiddle(arr, radius - x, radius - y);\n    fillCircleArrayRowToMiddle(arr, radius - y, radius - x);\n    fillCircleArrayRowToMiddle(arr, radius + y, radius - x);\n    fillCircleArrayRowToMiddle(arr, radius + x, radius - y);\n    y++;\n    error += 1 + 2 * y;\n    if (2 * (error - x) + 1 > 0) {\n      x -= 1;\n      error += 1 - 2 * x;\n    }\n  }\n  circleArrayCache[radius] = arr;\n  return arr;\n}\n/**\n * @param {!Object<string, Array<*>>} declutterReplays Declutter replays.\n * @param {CanvasRenderingContext2D} context Context.\n * @param {number} rotation Rotation.\n * @param {number} opacity Opacity.\n * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n * @param {Array<import(\"../../PluggableMap.js\").DeclutterItems>} declutterItems Declutter items.\n */\nexport function replayDeclutter(declutterReplays, context, rotation, opacity, snapToPixel, declutterItems) {\n  var zs = Object.keys(declutterReplays).map(Number).sort(numberSafeCompareFunction);\n  for (var z = 0, zz = zs.length; z < zz; ++z) {\n    var executorData = declutterReplays[zs[z].toString()];\n    var currentExecutor = void 0;\n    for (var i = 0, ii = executorData.length; i < ii;) {\n      var executor = executorData[i++];\n      var transform = executorData[i++];\n      executor.execute(context, 1, transform, rotation, snapToPixel);\n      if (executor !== currentExecutor && executor.declutterItems.length > 0) {\n        currentExecutor = executor;\n        declutterItems.push({\n          items: executor.declutterItems,\n          opacity: opacity\n        });\n      }\n    }\n  }\n}\nexport default ExecutorGroup;","map":{"version":3,"names":["BuilderType","Executor","buffer","createEmpty","extendCoordinate","compose","composeTransform","create","createTransform","createCanvasContext2D","isEmpty","numberSafeCompareFunction","transform2D","ORDER","POLYGON","CIRCLE","LINE_STRING","IMAGE","TEXT","DEFAULT","ExecutorGroup","maxExtent","resolution","pixelRatio","overlaps","allInstructions","opt_renderBuffer","maxExtent_","overlaps_","pixelRatio_","resolution_","renderBuffer_","executorsByZIndex_","hitDetectionContext_","hitDetectionTransform_","createExecutors_","prototype","clip","context","transform","flatClipCoords","getClipCoords","beginPath","moveTo","lineTo","zIndex","executors","undefined","instructionByZindex","renderBuffer","builderType","instructions","hasExecutors","candidates","i","ii","length","forEachFeatureAtCoordinate","coordinate","rotation","hitTolerance","callback","declutteredFeatures","Math","round","contextSize","canvas","width","height","clearRect","hitExtent","mask","getCircleArray","featureCallback","feature","imageData","getImageData","data","i_1","j_1","result_1","indexOf","zs","Object","keys","map","Number","sort","j","executor","result","zIndexKey","toString","executeHitDetection","minX","minY","maxX","maxY","execute","contextScale","viewRotation","snapToPixel","opt_builderTypes","opt_declutterReplays","save","builderTypes","jj","replays","replay","declutter","slice","push","restore","circleArrayCache","fillCircleArrayRowToMiddle","array","x","y","radius","floor","arraySize","arr","Array","error","replayDeclutter","declutterReplays","opacity","declutterItems","z","zz","executorData","currentExecutor","items"],"sources":["/Users/mariovicky/Skripsi_OpenLayers/node_modules/ol/src/render/canvas/ExecutorGroup.js"],"sourcesContent":["/**\n * @module ol/render/canvas/ExecutorGroup\n */\n\nimport BuilderType from './BuilderType.js';\nimport Executor from './Executor.js';\nimport {buffer, createEmpty, extendCoordinate} from '../../extent.js';\nimport {\n  compose as composeTransform,\n  create as createTransform,\n} from '../../transform.js';\nimport {createCanvasContext2D} from '../../dom.js';\nimport {isEmpty} from '../../obj.js';\nimport {numberSafeCompareFunction} from '../../array.js';\nimport {transform2D} from '../../geom/flat/transform.js';\n\n/**\n * @const\n * @type {Array<import(\"./BuilderType.js\").default>}\n */\nconst ORDER = [\n  BuilderType.POLYGON,\n  BuilderType.CIRCLE,\n  BuilderType.LINE_STRING,\n  BuilderType.IMAGE,\n  BuilderType.TEXT,\n  BuilderType.DEFAULT,\n];\n\nclass ExecutorGroup {\n  /**\n   * @param {import(\"../../extent.js\").Extent} maxExtent Max extent for clipping. When a\n   * `maxExtent` was set on the Buillder for this executor group, the same `maxExtent`\n   * should be set here, unless the target context does not exceet that extent (which\n   * can be the case when rendering to tiles).\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {boolean} overlaps The executor group can have overlapping geometries.\n   * @param {!Object<string, !Object<import(\"./BuilderType.js\").default, import(\"./Builder.js\").SerializableInstructions>>} allInstructions\n   * The serializable instructions.\n   * @param {number=} opt_renderBuffer Optional rendering buffer.\n   */\n  constructor(\n    maxExtent,\n    resolution,\n    pixelRatio,\n    overlaps,\n    allInstructions,\n    opt_renderBuffer\n  ) {\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.maxExtent_ = maxExtent;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.overlaps_ = overlaps;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.resolution_ = resolution;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.renderBuffer_ = opt_renderBuffer;\n\n    /**\n     * @private\n     * @type {!Object<string, !Object<import(\"./BuilderType.js\").default, import(\"./Executor\").default>>}\n     */\n    this.executorsByZIndex_ = {};\n\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.hitDetectionContext_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.hitDetectionTransform_ = createTransform();\n\n    this.createExecutors_(allInstructions);\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   */\n  clip(context, transform) {\n    const flatClipCoords = this.getClipCoords(transform);\n    context.beginPath();\n    context.moveTo(flatClipCoords[0], flatClipCoords[1]);\n    context.lineTo(flatClipCoords[2], flatClipCoords[3]);\n    context.lineTo(flatClipCoords[4], flatClipCoords[5]);\n    context.lineTo(flatClipCoords[6], flatClipCoords[7]);\n    context.clip();\n  }\n\n  /**\n   * Create executors and populate them using the provided instructions.\n   * @private\n   * @param {!Object<string, !Object<import(\"./BuilderType.js\").default, import(\"./Builder.js\").SerializableInstructions>>} allInstructions The serializable instructions\n   */\n  createExecutors_(allInstructions) {\n    for (const zIndex in allInstructions) {\n      let executors = this.executorsByZIndex_[zIndex];\n      if (executors === undefined) {\n        executors = {};\n        this.executorsByZIndex_[zIndex] = executors;\n      }\n      const instructionByZindex = allInstructions[zIndex];\n      const renderBuffer = [this.renderBuffer_ || 0, this.renderBuffer_ || 0];\n      for (const builderType in instructionByZindex) {\n        const instructions = instructionByZindex[builderType];\n        executors[builderType] = new Executor(\n          this.resolution_,\n          this.pixelRatio_,\n          this.overlaps_,\n          instructions,\n          renderBuffer\n        );\n      }\n    }\n  }\n\n  /**\n   * @param {Array<import(\"./BuilderType.js\").default>} executors Executors.\n   * @return {boolean} Has executors of the provided types.\n   */\n  hasExecutors(executors) {\n    for (const zIndex in this.executorsByZIndex_) {\n      const candidates = this.executorsByZIndex_[zIndex];\n      for (let i = 0, ii = executors.length; i < ii; ++i) {\n        if (executors[i] in candidates) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {number} rotation Rotation.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {function(import(\"../../Feature.js\").FeatureLike): T} callback Feature callback.\n   * @param {Array<import(\"../../Feature.js\").FeatureLike>} declutteredFeatures Decluttered features.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    resolution,\n    rotation,\n    hitTolerance,\n    callback,\n    declutteredFeatures\n  ) {\n    hitTolerance = Math.round(hitTolerance);\n    const contextSize = hitTolerance * 2 + 1;\n    const transform = composeTransform(\n      this.hitDetectionTransform_,\n      hitTolerance + 0.5,\n      hitTolerance + 0.5,\n      1 / resolution,\n      -1 / resolution,\n      -rotation,\n      -coordinate[0],\n      -coordinate[1]\n    );\n\n    if (!this.hitDetectionContext_) {\n      this.hitDetectionContext_ = createCanvasContext2D(\n        contextSize,\n        contextSize\n      );\n    }\n    const context = this.hitDetectionContext_;\n\n    if (\n      context.canvas.width !== contextSize ||\n      context.canvas.height !== contextSize\n    ) {\n      context.canvas.width = contextSize;\n      context.canvas.height = contextSize;\n    } else {\n      context.clearRect(0, 0, contextSize, contextSize);\n    }\n\n    /**\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    let hitExtent;\n    if (this.renderBuffer_ !== undefined) {\n      hitExtent = createEmpty();\n      extendCoordinate(hitExtent, coordinate);\n      buffer(\n        hitExtent,\n        resolution * (this.renderBuffer_ + hitTolerance),\n        hitExtent\n      );\n    }\n\n    const mask = getCircleArray(hitTolerance);\n\n    let builderType;\n\n    /**\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @return {?} Callback result.\n     */\n    function featureCallback(feature) {\n      const imageData = context.getImageData(0, 0, contextSize, contextSize)\n        .data;\n      for (let i = 0; i < contextSize; i++) {\n        for (let j = 0; j < contextSize; j++) {\n          if (mask[i][j]) {\n            if (imageData[(j * contextSize + i) * 4 + 3] > 0) {\n              let result;\n              if (\n                !(\n                  declutteredFeatures &&\n                  (builderType == BuilderType.IMAGE ||\n                    builderType == BuilderType.TEXT)\n                ) ||\n                declutteredFeatures.indexOf(feature) !== -1\n              ) {\n                result = callback(feature);\n              }\n              if (result) {\n                return result;\n              } else {\n                context.clearRect(0, 0, contextSize, contextSize);\n                return undefined;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    /** @type {Array<number>} */\n    const zs = Object.keys(this.executorsByZIndex_).map(Number);\n    zs.sort(numberSafeCompareFunction);\n\n    let i, j, executors, executor, result;\n    for (i = zs.length - 1; i >= 0; --i) {\n      const zIndexKey = zs[i].toString();\n      executors = this.executorsByZIndex_[zIndexKey];\n      for (j = ORDER.length - 1; j >= 0; --j) {\n        builderType = ORDER[j];\n        executor = executors[builderType];\n        if (executor !== undefined) {\n          result = executor.executeHitDetection(\n            context,\n            transform,\n            rotation,\n            featureCallback,\n            hitExtent\n          );\n          if (result) {\n            return result;\n          }\n        }\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @return {Array<number>} Clip coordinates.\n   */\n  getClipCoords(transform) {\n    const maxExtent = this.maxExtent_;\n    if (!maxExtent) {\n      return null;\n    }\n    const minX = maxExtent[0];\n    const minY = maxExtent[1];\n    const maxX = maxExtent[2];\n    const maxY = maxExtent[3];\n    const flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];\n    transform2D(flatClipCoords, 0, 8, 2, transform, flatClipCoords);\n    return flatClipCoords;\n  }\n\n  /**\n   * @return {boolean} Is empty.\n   */\n  isEmpty() {\n    return isEmpty(this.executorsByZIndex_);\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} contextScale Scale of the context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.\n   * @param {Array<import(\"./BuilderType.js\").default>=} opt_builderTypes Ordered replay types to replay.\n   *     Default is {@link module:ol/render/replay~ORDER}\n   * @param {Object<string, import(\"../canvas.js\").DeclutterGroup>=} opt_declutterReplays Declutter replays.\n   */\n  execute(\n    context,\n    contextScale,\n    transform,\n    viewRotation,\n    snapToPixel,\n    opt_builderTypes,\n    opt_declutterReplays\n  ) {\n    /** @type {Array<number>} */\n    const zs = Object.keys(this.executorsByZIndex_).map(Number);\n    zs.sort(numberSafeCompareFunction);\n\n    // setup clipping so that the parts of over-simplified geometries are not\n    // visible outside the current extent when panning\n    if (this.maxExtent_) {\n      context.save();\n      this.clip(context, transform);\n    }\n\n    const builderTypes = opt_builderTypes ? opt_builderTypes : ORDER;\n    let i, ii, j, jj, replays, replay;\n    for (i = 0, ii = zs.length; i < ii; ++i) {\n      const zIndexKey = zs[i].toString();\n      replays = this.executorsByZIndex_[zIndexKey];\n      for (j = 0, jj = builderTypes.length; j < jj; ++j) {\n        const builderType = builderTypes[j];\n        replay = replays[builderType];\n        if (replay !== undefined) {\n          if (\n            opt_declutterReplays &&\n            (builderType == BuilderType.IMAGE ||\n              builderType == BuilderType.TEXT)\n          ) {\n            const declutter = opt_declutterReplays[zIndexKey];\n            if (!declutter) {\n              opt_declutterReplays[zIndexKey] = [replay, transform.slice(0)];\n            } else {\n              declutter.push(replay, transform.slice(0));\n            }\n          } else {\n            replay.execute(\n              context,\n              contextScale,\n              transform,\n              viewRotation,\n              snapToPixel\n            );\n          }\n        }\n      }\n    }\n\n    if (this.maxExtent_) {\n      context.restore();\n    }\n  }\n}\n\n/**\n * This cache is used for storing calculated pixel circles for increasing performance.\n * It is a static property to allow each Replaygroup to access it.\n * @type {Object<number, Array<Array<(boolean|undefined)>>>}\n */\nconst circleArrayCache = {\n  0: [[true]],\n};\n\n/**\n * This method fills a row in the array from the given coordinate to the\n * middle with `true`.\n * @param {Array<Array<(boolean|undefined)>>} array The array that will be altered.\n * @param {number} x X coordinate.\n * @param {number} y Y coordinate.\n */\nfunction fillCircleArrayRowToMiddle(array, x, y) {\n  let i;\n  const radius = Math.floor(array.length / 2);\n  if (x >= radius) {\n    for (i = radius; i < x; i++) {\n      array[i][y] = true;\n    }\n  } else if (x < radius) {\n    for (i = x + 1; i < radius; i++) {\n      array[i][y] = true;\n    }\n  }\n}\n\n/**\n * This methods creates a circle inside a fitting array. Points inside the\n * circle are marked by true, points on the outside are undefined.\n * It uses the midpoint circle algorithm.\n * A cache is used to increase performance.\n * @param {number} radius Radius.\n * @returns {Array<Array<(boolean|undefined)>>} An array with marked circle points.\n */\nexport function getCircleArray(radius) {\n  if (circleArrayCache[radius] !== undefined) {\n    return circleArrayCache[radius];\n  }\n\n  const arraySize = radius * 2 + 1;\n  const arr = new Array(arraySize);\n  for (let i = 0; i < arraySize; i++) {\n    arr[i] = new Array(arraySize);\n  }\n\n  let x = radius;\n  let y = 0;\n  let error = 0;\n\n  while (x >= y) {\n    fillCircleArrayRowToMiddle(arr, radius + x, radius + y);\n    fillCircleArrayRowToMiddle(arr, radius + y, radius + x);\n    fillCircleArrayRowToMiddle(arr, radius - y, radius + x);\n    fillCircleArrayRowToMiddle(arr, radius - x, radius + y);\n    fillCircleArrayRowToMiddle(arr, radius - x, radius - y);\n    fillCircleArrayRowToMiddle(arr, radius - y, radius - x);\n    fillCircleArrayRowToMiddle(arr, radius + y, radius - x);\n    fillCircleArrayRowToMiddle(arr, radius + x, radius - y);\n\n    y++;\n    error += 1 + 2 * y;\n    if (2 * (error - x) + 1 > 0) {\n      x -= 1;\n      error += 1 - 2 * x;\n    }\n  }\n\n  circleArrayCache[radius] = arr;\n  return arr;\n}\n\n/**\n * @param {!Object<string, Array<*>>} declutterReplays Declutter replays.\n * @param {CanvasRenderingContext2D} context Context.\n * @param {number} rotation Rotation.\n * @param {number} opacity Opacity.\n * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n * @param {Array<import(\"../../PluggableMap.js\").DeclutterItems>} declutterItems Declutter items.\n */\nexport function replayDeclutter(\n  declutterReplays,\n  context,\n  rotation,\n  opacity,\n  snapToPixel,\n  declutterItems\n) {\n  const zs = Object.keys(declutterReplays)\n    .map(Number)\n    .sort(numberSafeCompareFunction);\n  for (let z = 0, zz = zs.length; z < zz; ++z) {\n    const executorData = declutterReplays[zs[z].toString()];\n    let currentExecutor;\n    for (let i = 0, ii = executorData.length; i < ii; ) {\n      const executor = executorData[i++];\n      const transform = executorData[i++];\n      executor.execute(context, 1, transform, rotation, snapToPixel);\n      if (executor !== currentExecutor && executor.declutterItems.length > 0) {\n        currentExecutor = executor;\n        declutterItems.push({\n          items: executor.declutterItems,\n          opacity: opacity,\n        });\n      }\n    }\n  }\n}\n\nexport default ExecutorGroup;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
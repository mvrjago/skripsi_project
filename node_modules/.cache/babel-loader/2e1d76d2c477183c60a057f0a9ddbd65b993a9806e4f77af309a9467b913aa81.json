{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/reproj/Tile\n */\nimport { ERROR_THRESHOLD } from './common.js';\nimport EventType from '../events/EventType.js';\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport { calculateSourceExtentResolution, render as renderReprojected } from '../reproj.js';\nimport { clamp } from '../math.js';\nimport { getArea, getIntersection } from '../extent.js';\nimport { listen, unlistenByKey } from '../events.js';\n/**\n * @typedef {function(number, number, number, number) : import(\"../Tile.js\").default} FunctionType\n */\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\nvar ReprojTile = /** @class */function (_super) {\n  __extends(ReprojTile, _super);\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n   * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} gutter Gutter of the source tiles.\n   * @param {FunctionType} getTileFunction\n   *     Function returning source tiles (z, x, y, pixelRatio).\n   * @param {number=} opt_errorThreshold Acceptable reprojection error (in px).\n   * @param {boolean=} opt_renderEdges Render reprojection edges.\n   * @param {object=} opt_contextOptions Properties to set on the canvas context.\n   */\n  function ReprojTile(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, opt_errorThreshold, opt_renderEdges, opt_contextOptions) {\n    var _this = _super.call(this, tileCoord, TileState.IDLE) || this;\n    /**\n     * @private\n     * @type {boolean}\n     */\n    _this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;\n    /**\n     * @private\n     * @type {object}\n     */\n    _this.contextOptions_ = opt_contextOptions;\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.pixelRatio_ = pixelRatio;\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.gutter_ = gutter;\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    _this.canvas_ = null;\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    _this.sourceTileGrid_ = sourceTileGrid;\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    _this.targetTileGrid_ = targetTileGrid;\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    _this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n    /**\n     * @private\n     * @type {!Array<import(\"../Tile.js\").default>}\n     */\n    _this.sourceTiles_ = [];\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    _this.sourcesListenerKeys_ = null;\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.sourceZ_ = 0;\n    var targetExtent = targetTileGrid.getTileCoordExtent(_this.wrappedTileCoord_);\n    var maxTargetExtent = _this.targetTileGrid_.getExtent();\n    var maxSourceExtent = _this.sourceTileGrid_.getExtent();\n    var limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      _this.state = TileState.EMPTY;\n      return _this;\n    }\n    var sourceProjExtent = sourceProj.getExtent();\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n    var targetResolution = targetTileGrid.getResolution(_this.wrappedTileCoord_[0]);\n    var sourceResolution = calculateSourceExtentResolution(sourceProj, targetProj, limitedTargetExtent, targetResolution);\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      _this.state = TileState.EMPTY;\n      return _this;\n    }\n    var errorThresholdInPixels = opt_errorThreshold !== undefined ? opt_errorThreshold : ERROR_THRESHOLD;\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    _this.triangulation_ = new Triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);\n    if (_this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      _this.state = TileState.EMPTY;\n      return _this;\n    }\n    _this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n    var sourceExtent = _this.triangulation_.calculateSourceExtent();\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);\n        sourceExtent[3] = clamp(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n    if (!getArea(sourceExtent)) {\n      _this.state = TileState.EMPTY;\n    } else {\n      var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, _this.sourceZ_);\n      for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n        for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n          var tile = getTileFunction(_this.sourceZ_, srcX, srcY, pixelRatio);\n          if (tile) {\n            _this.sourceTiles_.push(tile);\n          }\n        }\n      }\n      if (_this.sourceTiles_.length === 0) {\n        _this.state = TileState.EMPTY;\n      }\n    }\n    return _this;\n  }\n  /**\n   * Get the HTML Canvas element for this tile.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n  ReprojTile.prototype.getImage = function () {\n    return this.canvas_;\n  };\n  /**\n   * @private\n   */\n  ReprojTile.prototype.reproject_ = function () {\n    var sources = [];\n    this.sourceTiles_.forEach(function (tile, i, arr) {\n      if (tile && tile.getState() == TileState.LOADED) {\n        sources.push({\n          extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n          image: tile.getImage()\n        });\n      }\n    }.bind(this));\n    this.sourceTiles_.length = 0;\n    if (sources.length === 0) {\n      this.state = TileState.ERROR;\n    } else {\n      var z = this.wrappedTileCoord_[0];\n      var size = this.targetTileGrid_.getTileSize(z);\n      var width = typeof size === 'number' ? size : size[0];\n      var height = typeof size === 'number' ? size : size[1];\n      var targetResolution = this.targetTileGrid_.getResolution(z);\n      var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\n      var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);\n      this.canvas_ = renderReprojected(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_, this.contextOptions_);\n      this.state = TileState.LOADED;\n    }\n    this.changed();\n  };\n  /**\n   * Load not yet loaded URI.\n   */\n  ReprojTile.prototype.load = function () {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n      var leftToLoad_1 = 0;\n      this.sourcesListenerKeys_ = [];\n      this.sourceTiles_.forEach(function (tile, i, arr) {\n        var state = tile.getState();\n        if (state == TileState.IDLE || state == TileState.LOADING) {\n          leftToLoad_1++;\n          var sourceListenKey_1 = listen(tile, EventType.CHANGE, function (e) {\n            var state = tile.getState();\n            if (state == TileState.LOADED || state == TileState.ERROR || state == TileState.EMPTY) {\n              unlistenByKey(sourceListenKey_1);\n              leftToLoad_1--;\n              if (leftToLoad_1 === 0) {\n                this.unlistenSources_();\n                this.reproject_();\n              }\n            }\n          }, this);\n          this.sourcesListenerKeys_.push(sourceListenKey_1);\n        }\n      }.bind(this));\n      this.sourceTiles_.forEach(function (tile, i, arr) {\n        var state = tile.getState();\n        if (state == TileState.IDLE) {\n          tile.load();\n        }\n      });\n      if (leftToLoad_1 === 0) {\n        setTimeout(this.reproject_.bind(this), 0);\n      }\n    }\n  };\n  /**\n   * @private\n   */\n  ReprojTile.prototype.unlistenSources_ = function () {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  };\n  return ReprojTile;\n}(Tile);\nexport default ReprojTile;","map":{"version":3,"names":["ERROR_THRESHOLD","EventType","Tile","TileState","Triangulation","calculateSourceExtentResolution","render","renderReprojected","clamp","getArea","getIntersection","listen","unlistenByKey","ReprojTile","_super","__extends","sourceProj","sourceTileGrid","targetProj","targetTileGrid","tileCoord","wrappedTileCoord","pixelRatio","gutter","getTileFunction","opt_errorThreshold","opt_renderEdges","opt_contextOptions","_this","call","IDLE","renderEdges_","undefined","contextOptions_","pixelRatio_","gutter_","canvas_","sourceTileGrid_","targetTileGrid_","wrappedTileCoord_","sourceTiles_","sourcesListenerKeys_","sourceZ_","targetExtent","getTileCoordExtent","maxTargetExtent","getExtent","maxSourceExtent","limitedTargetExtent","state","EMPTY","sourceProjExtent","targetResolution","getResolution","sourceResolution","isFinite","errorThresholdInPixels","triangulation_","getTriangles","length","getZForResolution","sourceExtent","calculateSourceExtent","canWrapX","sourceRange","getTileRangeForExtentAndZ","srcX","minX","maxX","srcY","minY","maxY","tile","push","prototype","getImage","reproject_","sources","forEach","i","arr","getState","LOADED","extent","image","bind","ERROR","z","size","getTileSize","width","height","changed","load","LOADING","leftToLoad_1","sourceListenKey_1","CHANGE","e","unlistenSources_","setTimeout"],"sources":["/Users/mariovicky/Skripsi_OpenLayers/node_modules/ol/src/reproj/Tile.js"],"sourcesContent":["/**\n * @module ol/reproj/Tile\n */\nimport {ERROR_THRESHOLD} from './common.js';\n\nimport EventType from '../events/EventType.js';\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport {\n  calculateSourceExtentResolution,\n  render as renderReprojected,\n} from '../reproj.js';\nimport {clamp} from '../math.js';\nimport {getArea, getIntersection} from '../extent.js';\nimport {listen, unlistenByKey} from '../events.js';\n\n/**\n * @typedef {function(number, number, number, number) : import(\"../Tile.js\").default} FunctionType\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\nclass ReprojTile extends Tile {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n   * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} gutter Gutter of the source tiles.\n   * @param {FunctionType} getTileFunction\n   *     Function returning source tiles (z, x, y, pixelRatio).\n   * @param {number=} opt_errorThreshold Acceptable reprojection error (in px).\n   * @param {boolean=} opt_renderEdges Render reprojection edges.\n   * @param {object=} opt_contextOptions Properties to set on the canvas context.\n   */\n  constructor(\n    sourceProj,\n    sourceTileGrid,\n    targetProj,\n    targetTileGrid,\n    tileCoord,\n    wrappedTileCoord,\n    pixelRatio,\n    gutter,\n    getTileFunction,\n    opt_errorThreshold,\n    opt_renderEdges,\n    opt_contextOptions\n  ) {\n    super(tileCoord, TileState.IDLE);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;\n\n    /**\n     * @private\n     * @type {object}\n     */\n    this.contextOptions_ = opt_contextOptions;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = gutter;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.sourceTileGrid_ = sourceTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.targetTileGrid_ = targetTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n\n    /**\n     * @private\n     * @type {!Array<import(\"../Tile.js\").default>}\n     */\n    this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourceZ_ = 0;\n\n    const targetExtent = targetTileGrid.getTileCoordExtent(\n      this.wrappedTileCoord_\n    );\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\n\n    const limitedTargetExtent = maxTargetExtent\n      ? getIntersection(targetExtent, maxTargetExtent)\n      : targetExtent;\n\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const sourceProjExtent = sourceProj.getExtent();\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    const targetResolution = targetTileGrid.getResolution(\n      this.wrappedTileCoord_[0]\n    );\n\n    const sourceResolution = calculateSourceExtentResolution(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      targetResolution\n    );\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const errorThresholdInPixels =\n      opt_errorThreshold !== undefined ? opt_errorThreshold : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    this.triangulation_ = new Triangulation(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      maxSourceExtent,\n      sourceResolution * errorThresholdInPixels,\n      targetResolution\n    );\n\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(\n          sourceExtent[1],\n          maxSourceExtent[1],\n          maxSourceExtent[3]\n        );\n        sourceExtent[3] = clamp(\n          sourceExtent[3],\n          maxSourceExtent[1],\n          maxSourceExtent[3]\n        );\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(\n        sourceExtent,\n        this.sourceZ_\n      );\n\n      for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n        for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n          const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);\n          if (tile) {\n            this.sourceTiles_.push(tile);\n          }\n        }\n      }\n\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n\n  /**\n   * Get the HTML Canvas element for this tile.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n  getImage() {\n    return this.canvas_;\n  }\n\n  /**\n   * @private\n   */\n  reproject_() {\n    const sources = [];\n    this.sourceTiles_.forEach(\n      function (tile, i, arr) {\n        if (tile && tile.getState() == TileState.LOADED) {\n          sources.push({\n            extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n            image: tile.getImage(),\n          });\n        }\n      }.bind(this)\n    );\n    this.sourceTiles_.length = 0;\n\n    if (sources.length === 0) {\n      this.state = TileState.ERROR;\n    } else {\n      const z = this.wrappedTileCoord_[0];\n      const size = this.targetTileGrid_.getTileSize(z);\n      const width = typeof size === 'number' ? size : size[0];\n      const height = typeof size === 'number' ? size : size[1];\n      const targetResolution = this.targetTileGrid_.getResolution(z);\n      const sourceResolution = this.sourceTileGrid_.getResolution(\n        this.sourceZ_\n      );\n\n      const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n        this.wrappedTileCoord_\n      );\n      this.canvas_ = renderReprojected(\n        width,\n        height,\n        this.pixelRatio_,\n        sourceResolution,\n        this.sourceTileGrid_.getExtent(),\n        targetResolution,\n        targetExtent,\n        this.triangulation_,\n        sources,\n        this.gutter_,\n        this.renderEdges_,\n        this.contextOptions_\n      );\n\n      this.state = TileState.LOADED;\n    }\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   */\n  load() {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n\n      let leftToLoad = 0;\n\n      this.sourcesListenerKeys_ = [];\n      this.sourceTiles_.forEach(\n        function (tile, i, arr) {\n          const state = tile.getState();\n          if (state == TileState.IDLE || state == TileState.LOADING) {\n            leftToLoad++;\n\n            const sourceListenKey = listen(\n              tile,\n              EventType.CHANGE,\n              function (e) {\n                const state = tile.getState();\n                if (\n                  state == TileState.LOADED ||\n                  state == TileState.ERROR ||\n                  state == TileState.EMPTY\n                ) {\n                  unlistenByKey(sourceListenKey);\n                  leftToLoad--;\n                  if (leftToLoad === 0) {\n                    this.unlistenSources_();\n                    this.reproject_();\n                  }\n                }\n              },\n              this\n            );\n            this.sourcesListenerKeys_.push(sourceListenKey);\n          }\n        }.bind(this)\n      );\n\n      this.sourceTiles_.forEach(function (tile, i, arr) {\n        const state = tile.getState();\n        if (state == TileState.IDLE) {\n          tile.load();\n        }\n      });\n\n      if (leftToLoad === 0) {\n        setTimeout(this.reproject_.bind(this), 0);\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  unlistenSources_() {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  }\n}\n\nexport default ReprojTile;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"'use strict';\n\n// Load modules\nconst Punycode = require('punycode');\nconst Util = require('util');\n\n// Declare internals\n\nconst internals = {\n  hasOwn: Object.prototype.hasOwnProperty,\n  indexOf: Array.prototype.indexOf,\n  defaultThreshold: 16,\n  maxIPv6Groups: 8,\n  categories: {\n    valid: 1,\n    dnsWarn: 7,\n    rfc5321: 15,\n    cfws: 31,\n    deprecated: 63,\n    rfc5322: 127,\n    error: 255\n  },\n  diagnoses: {\n    // Address is valid\n\n    valid: 0,\n    // Address is valid for SMTP but has unusual elements\n\n    rfc5321TLD: 9,\n    rfc5321TLDNumeric: 10,\n    rfc5321QuotedString: 11,\n    rfc5321AddressLiteral: 12,\n    // Address is valid for message, but must be modified for envelope\n\n    cfwsComment: 17,\n    cfwsFWS: 18,\n    // Address contains non-ASCII when the allowUnicode option is false\n    // Has to be > internals.defaultThreshold so that it's rejected\n    // without an explicit errorLevel:\n    undesiredNonAscii: 25,\n    // Address contains deprecated elements, but may still be valid in some contexts\n\n    deprecatedLocalPart: 33,\n    deprecatedFWS: 34,\n    deprecatedQTEXT: 35,\n    deprecatedQP: 36,\n    deprecatedComment: 37,\n    deprecatedCTEXT: 38,\n    deprecatedIPv6: 39,\n    deprecatedCFWSNearAt: 49,\n    // Address is only valid according to broad definition in RFC 5322, but is otherwise invalid\n\n    rfc5322Domain: 65,\n    rfc5322TooLong: 66,\n    rfc5322LocalTooLong: 67,\n    rfc5322DomainTooLong: 68,\n    rfc5322LabelTooLong: 69,\n    rfc5322DomainLiteral: 70,\n    rfc5322DomainLiteralOBSDText: 71,\n    rfc5322IPv6GroupCount: 72,\n    rfc5322IPv62x2xColon: 73,\n    rfc5322IPv6BadCharacter: 74,\n    rfc5322IPv6MaxGroups: 75,\n    rfc5322IPv6ColonStart: 76,\n    rfc5322IPv6ColonEnd: 77,\n    // Address is invalid for any purpose\n\n    errExpectingDTEXT: 129,\n    errNoLocalPart: 130,\n    errNoDomain: 131,\n    errConsecutiveDots: 132,\n    errATEXTAfterCFWS: 133,\n    errATEXTAfterQS: 134,\n    errATEXTAfterDomainLiteral: 135,\n    errExpectingQPair: 136,\n    errExpectingATEXT: 137,\n    errExpectingQTEXT: 138,\n    errExpectingCTEXT: 139,\n    errBackslashEnd: 140,\n    errDotStart: 141,\n    errDotEnd: 142,\n    errDomainHyphenStart: 143,\n    errDomainHyphenEnd: 144,\n    errUnclosedQuotedString: 145,\n    errUnclosedComment: 146,\n    errUnclosedDomainLiteral: 147,\n    errFWSCRLFx2: 148,\n    errFWSCRLFEnd: 149,\n    errCRNoLF: 150,\n    errUnknownTLD: 160,\n    errDomainTooShort: 161,\n    errDotAfterDomainLiteral: 162\n  },\n  components: {\n    localpart: 0,\n    domain: 1,\n    literal: 2,\n    contextComment: 3,\n    contextFWS: 4,\n    contextQuotedString: 5,\n    contextQuotedPair: 6\n  }\n};\ninternals.specials = function () {\n  const specials = '()<>[]:;@\\\\,.\"'; // US-ASCII visible characters not valid for atext (http://tools.ietf.org/html/rfc5322#section-3.2.3)\n  const lookup = new Array(0x100);\n  lookup.fill(false);\n  for (let i = 0; i < specials.length; ++i) {\n    lookup[specials.codePointAt(i)] = true;\n  }\n  return function (code) {\n    return lookup[code];\n  };\n}();\ninternals.c0Controls = function () {\n  const lookup = new Array(0x100);\n  lookup.fill(false);\n\n  // add C0 control characters\n\n  for (let i = 0; i < 33; ++i) {\n    lookup[i] = true;\n  }\n  return function (code) {\n    return lookup[code];\n  };\n}();\ninternals.c1Controls = function () {\n  const lookup = new Array(0x100);\n  lookup.fill(false);\n\n  // add C1 control characters\n\n  for (let i = 127; i < 160; ++i) {\n    lookup[i] = true;\n  }\n  return function (code) {\n    return lookup[code];\n  };\n}();\ninternals.regex = {\n  ipV4: /\\b(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/,\n  ipV6: /^[a-fA-F\\d]{0,4}$/\n};\ninternals.normalizeSupportsNul = '\\0'.normalize('NFC') === '\\0';\n\n// $lab:coverage:off$\ninternals.nulNormalize = function (email) {\n  return email.split('\\0').map(part => part.normalize('NFC')).join('\\0');\n};\n// $lab:coverage:on$\n\ninternals.normalize = function (email) {\n  return email.normalize('NFC');\n};\n\n// $lab:coverage:off$\nif (!internals.normalizeSupportsNul) {\n  internals.normalize = function (email) {\n    if (email.indexOf('\\0') >= 0) {\n      return internals.nulNormalize(email);\n    }\n    return email.normalize('NFC');\n  };\n}\n// $lab:coverage:on$\n\ninternals.checkIpV6 = function (items) {\n  return items.every(value => internals.regex.ipV6.test(value));\n};\ninternals.isIterable = Array.isArray;\n\n/* $lab:coverage:off$ */\nif (typeof Symbol !== 'undefined') {\n  internals.isIterable = value => Array.isArray(value) || !!value && typeof value === 'object' && typeof value[Symbol.iterator] === 'function';\n}\n/* $lab:coverage:on$ */\n\n// Node 10 introduced isSet and isMap, which are useful for cross-context type\n// checking.\n// $lab:coverage:off$\ninternals._isSet = value => value instanceof Set;\ninternals._isMap = value => value instanceof Map;\ninternals.isSet = Util.types && Util.types.isSet || internals._isSet;\ninternals.isMap = Util.types && Util.types.isMap || internals._isMap;\n// $lab:coverage:on$\n\n/**\n * Normalize the given lookup \"table\" to an iterator. Outputs items in arrays\n * and sets, keys from maps (regardless of the corresponding value), and own\n * enumerable keys from all other objects (intended to be plain objects).\n *\n * @param {*} table The table to convert.\n * @returns {Iterable<*>} The converted table.\n */\ninternals.normalizeTable = function (table) {\n  if (internals.isSet(table) || Array.isArray(table)) {\n    return table;\n  }\n  if (internals.isMap(table)) {\n    return table.keys();\n  }\n  return Object.keys(table);\n};\n\n/**\n * Convert the given domain atom to its canonical form using Nameprep and string\n * lowercasing. Domain atoms that are all-ASCII will not undergo any changes via\n * Nameprep, and domain atoms that have already been canonicalized will not be\n * altered.\n *\n * @param {string} atom The atom to canonicalize.\n * @returns {string} The canonicalized atom.\n */\ninternals.canonicalizeAtom = function (atom) {\n  return Punycode.toASCII(atom).toLowerCase();\n};\n\n/**\n * Check whether any of the values in the given iterable, when passed through\n * the iteratee function, are equal to the given value.\n *\n * @param {Iterable<*>} iterable The iterable to check.\n * @param {function(*): *} iteratee The iteratee that receives each item from\n *   the iterable.\n * @param {*} value The reference value.\n * @returns {boolean} Whether the given value matches any of the items in the\n *   iterable per the iteratee.\n */\ninternals.includesMapped = function (iterable, iteratee, value) {\n  for (const item of iterable) {\n    if (value === iteratee(item)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Check whether the given top-level domain atom is valid based on the\n * configured blacklist/whitelist.\n *\n * @param {string} tldAtom The atom to check.\n * @param {Object} options\n *   {*} tldBlacklist The set of domains to consider invalid.\n *   {*} tldWhitelist The set of domains to consider valid.\n * @returns {boolean} Whether the given domain atom is valid per the blacklist/\n *   whitelist.\n */\ninternals.validDomain = function (tldAtom, options) {\n  // Nameprep handles case-sensitive unicode stuff, but doesn't touch\n  // uppercase ASCII characters.\n  const canonicalTldAtom = internals.canonicalizeAtom(tldAtom);\n  if (options.tldBlacklist) {\n    return !internals.includesMapped(internals.normalizeTable(options.tldBlacklist), internals.canonicalizeAtom, canonicalTldAtom);\n  }\n  return internals.includesMapped(internals.normalizeTable(options.tldWhitelist), internals.canonicalizeAtom, canonicalTldAtom);\n};\n\n/**\n * Check whether the domain atoms has an address literal part followed by a\n * normal domain atom part. For example, [127.0.0.1].com.\n *\n * @param {string[]} domainAtoms The parsed domain atoms.\n * @returns {boolean} Whether there exists both a normal domain atom and an\n *   address literal.\n */\ninternals.hasDomainLiteralThenAtom = function (domainAtoms) {\n  let hasDomainLiteral = false;\n  for (let i = 0; i < domainAtoms.length; ++i) {\n    if (domainAtoms[i][0] === '[') {\n      hasDomainLiteral = true;\n    } else if (hasDomainLiteral) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Check that an email address conforms to RFCs 5321, 5322, 6530 and others\n *\n * We distinguish clearly between a Mailbox as defined by RFC 5321 and an\n * addr-spec as defined by RFC 5322. Depending on the context, either can be\n * regarded as a valid email address. The RFC 5321 Mailbox specification is\n * more restrictive (comments, white space and obsolete forms are not allowed).\n *\n * @param {string} email The email address to check. See README for specifics.\n * @param {Object} options The (optional) options:\n *   {*} errorLevel Determines the boundary between valid and invalid\n *     addresses.\n *   {*} tldBlacklist The set of domains to consider invalid.\n *   {*} tldWhitelist The set of domains to consider valid.\n *   {*} allowUnicode Whether to allow non-ASCII characters, defaults to true.\n *   {*} minDomainAtoms The minimum number of domain atoms which must be present\n *     for the address to be valid.\n * @param {function(number|boolean)} callback The (optional) callback handler.\n * @return {*}\n */\n\nexports.validate = internals.validate = function (email, options, callback) {\n  options = options || {};\n  if (typeof email !== 'string') {\n    throw new TypeError('expected string email');\n  }\n  email = internals.normalize(email);\n\n  // The callback function is deprecated.\n  // $lab:coverage:off$\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  if (typeof callback !== 'function') {\n    callback = null;\n  }\n  // $lab:coverage:on$\n\n  let diagnose;\n  let threshold;\n  if (typeof options.errorLevel === 'number') {\n    diagnose = true;\n    threshold = options.errorLevel;\n  } else {\n    diagnose = !!options.errorLevel;\n    threshold = internals.diagnoses.valid;\n  }\n  if (options.tldWhitelist) {\n    if (typeof options.tldWhitelist === 'string') {\n      options.tldWhitelist = [options.tldWhitelist];\n    } else if (typeof options.tldWhitelist !== 'object') {\n      throw new TypeError('expected array or object tldWhitelist');\n    }\n  }\n  if (options.tldBlacklist) {\n    if (typeof options.tldBlacklist === 'string') {\n      options.tldBlacklist = [options.tldBlacklist];\n    } else if (typeof options.tldBlacklist !== 'object') {\n      throw new TypeError('expected array or object tldBlacklist');\n    }\n  }\n  if (options.minDomainAtoms && (options.minDomainAtoms !== (+options.minDomainAtoms | 0) || options.minDomainAtoms < 0)) {\n    throw new TypeError('expected positive integer minDomainAtoms');\n  }\n\n  // Normalize the set of excluded diagnoses.\n  if (options.excludeDiagnoses) {\n    if (!internals.isIterable(options.excludeDiagnoses)) {\n      throw new TypeError('expected iterable excludeDiagnoses');\n    }\n\n    // This won't catch cross-realm Sets pre-Node 10, but it will cast the\n    // value to an in-realm Set representation.\n    if (!internals.isSet(options.excludeDiagnoses)) {\n      options.excludeDiagnoses = new Set(options.excludeDiagnoses);\n    }\n  }\n  let maxResult = internals.diagnoses.valid;\n  const updateResult = value => {\n    if (value > maxResult && (!options.excludeDiagnoses || !options.excludeDiagnoses.has(value))) {\n      maxResult = value;\n    }\n  };\n  const allowUnicode = options.allowUnicode === undefined || !!options.allowUnicode;\n  if (!allowUnicode && /[^\\x00-\\x7f]/.test(email)) {\n    updateResult(internals.diagnoses.undesiredNonAscii);\n  }\n  const context = {\n    now: internals.components.localpart,\n    prev: internals.components.localpart,\n    stack: [internals.components.localpart]\n  };\n  let prevToken = '';\n  const parseData = {\n    local: '',\n    domain: ''\n  };\n  const atomData = {\n    locals: [''],\n    domains: ['']\n  };\n  let elementCount = 0;\n  let elementLength = 0;\n  let crlfCount = 0;\n  let charCode;\n  let hyphenFlag = false;\n  let assertEnd = false;\n  const emailLength = email.length;\n  let token; // Token is used outside the loop, must declare similarly\n  for (let i = 0; i < emailLength; i += token.length) {\n    // Utilize codepoints to account for Unicode surrogate pairs\n    token = String.fromCodePoint(email.codePointAt(i));\n    switch (context.now) {\n      // Local-part\n      case internals.components.localpart:\n        // http://tools.ietf.org/html/rfc5322#section-3.4.1\n        //   local-part      =   dot-atom / quoted-string / obs-local-part\n        //\n        //   dot-atom        =   [CFWS] dot-atom-text [CFWS]\n        //\n        //   dot-atom-text   =   1*atext *(\".\" 1*atext)\n        //\n        //   quoted-string   =   [CFWS]\n        //                       DQUOTE *([FWS] qcontent) [FWS] DQUOTE\n        //                       [CFWS]\n        //\n        //   obs-local-part  =   word *(\".\" word)\n        //\n        //   word            =   atom / quoted-string\n        //\n        //   atom            =   [CFWS] 1*atext [CFWS]\n        switch (token) {\n          // Comment\n          case '(':\n            if (elementLength === 0) {\n              // Comments are OK at the beginning of an element\n              updateResult(elementCount === 0 ? internals.diagnoses.cfwsComment : internals.diagnoses.deprecatedComment);\n            } else {\n              updateResult(internals.diagnoses.cfwsComment);\n              // Cannot start a comment in an element, should be end\n              assertEnd = true;\n            }\n            context.stack.push(context.now);\n            context.now = internals.components.contextComment;\n            break;\n\n          // Next dot-atom element\n          case '.':\n            if (elementLength === 0) {\n              // Another dot, already?\n              updateResult(elementCount === 0 ? internals.diagnoses.errDotStart : internals.diagnoses.errConsecutiveDots);\n            } else {\n              // The entire local-part can be a quoted string for RFC 5321; if one atom is quoted it's an RFC 5322 obsolete form\n              if (assertEnd) {\n                updateResult(internals.diagnoses.deprecatedLocalPart);\n              }\n\n              // CFWS & quoted strings are OK again now we're at the beginning of an element (although they are obsolete forms)\n              assertEnd = false;\n              elementLength = 0;\n              ++elementCount;\n              parseData.local += token;\n              atomData.locals[elementCount] = '';\n            }\n            break;\n\n          // Quoted string\n          case '\"':\n            if (elementLength === 0) {\n              // The entire local-part can be a quoted string for RFC 5321; if one atom is quoted it's an RFC 5322 obsolete form\n              updateResult(elementCount === 0 ? internals.diagnoses.rfc5321QuotedString : internals.diagnoses.deprecatedLocalPart);\n              parseData.local += token;\n              atomData.locals[elementCount] += token;\n              elementLength += Buffer.byteLength(token, 'utf8');\n\n              // Quoted string must be the entire element\n              assertEnd = true;\n              context.stack.push(context.now);\n              context.now = internals.components.contextQuotedString;\n            } else {\n              updateResult(internals.diagnoses.errExpectingATEXT);\n            }\n            break;\n\n          // Folding white space\n          case '\\r':\n            if (emailLength === ++i || email[i] !== '\\n') {\n              // Fatal error\n              updateResult(internals.diagnoses.errCRNoLF);\n              break;\n            }\n\n          // Fallthrough\n\n          case ' ':\n          case '\\t':\n            if (elementLength === 0) {\n              updateResult(elementCount === 0 ? internals.diagnoses.cfwsFWS : internals.diagnoses.deprecatedFWS);\n            } else {\n              // We can't start FWS in the middle of an element, better be end\n              assertEnd = true;\n            }\n            context.stack.push(context.now);\n            context.now = internals.components.contextFWS;\n            prevToken = token;\n            break;\n          case '@':\n            // At this point we should have a valid local-part\n            // $lab:coverage:off$\n            if (context.stack.length !== 1) {\n              throw new Error('unexpected item on context stack');\n            }\n            // $lab:coverage:on$\n\n            if (parseData.local.length === 0) {\n              // Fatal error\n              updateResult(internals.diagnoses.errNoLocalPart);\n            } else if (elementLength === 0) {\n              // Fatal error\n              updateResult(internals.diagnoses.errDotEnd);\n            }\n            // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.1 the maximum total length of a user name or other local-part is 64\n            //    octets\n            else if (Buffer.byteLength(parseData.local, 'utf8') > 64) {\n              updateResult(internals.diagnoses.rfc5322LocalTooLong);\n            }\n            // http://tools.ietf.org/html/rfc5322#section-3.4.1 comments and folding white space SHOULD NOT be used around \"@\" in the\n            //    addr-spec\n            //\n            // http://tools.ietf.org/html/rfc2119\n            // 4. SHOULD NOT this phrase, or the phrase \"NOT RECOMMENDED\" mean that there may exist valid reasons in particular\n            //    circumstances when the particular behavior is acceptable or even useful, but the full implications should be understood\n            //    and the case carefully weighed before implementing any behavior described with this label.\n            else if (context.prev === internals.components.contextComment || context.prev === internals.components.contextFWS) {\n              updateResult(internals.diagnoses.deprecatedCFWSNearAt);\n            }\n\n            // Clear everything down for the domain parsing\n            context.now = internals.components.domain;\n            context.stack[0] = internals.components.domain;\n            elementCount = 0;\n            elementLength = 0;\n            assertEnd = false; // CFWS can only appear at the end of the element\n            break;\n\n          // ATEXT\n          default:\n            // http://tools.ietf.org/html/rfc5322#section-3.2.3\n            //    atext = ALPHA / DIGIT / ; Printable US-ASCII\n            //            \"!\" / \"#\" /     ;  characters not including\n            //            \"$\" / \"%\" /     ;  specials.  Used for atoms.\n            //            \"&\" / \"'\" /\n            //            \"*\" / \"+\" /\n            //            \"-\" / \"/\" /\n            //            \"=\" / \"?\" /\n            //            \"^\" / \"_\" /\n            //            \"`\" / \"{\" /\n            //            \"|\" / \"}\" /\n            //            \"~\"\n            if (assertEnd) {\n              // We have encountered atext where it is no longer valid\n              switch (context.prev) {\n                case internals.components.contextComment:\n                case internals.components.contextFWS:\n                  updateResult(internals.diagnoses.errATEXTAfterCFWS);\n                  break;\n                case internals.components.contextQuotedString:\n                  updateResult(internals.diagnoses.errATEXTAfterQS);\n                  break;\n\n                // $lab:coverage:off$\n                default:\n                  throw new Error('more atext found where none is allowed, but unrecognized prev context: ' + context.prev);\n                // $lab:coverage:on$\n              }\n            } else {\n              context.prev = context.now;\n              charCode = token.codePointAt(0);\n\n              // Especially if charCode == 10\n              if (internals.specials(charCode) || internals.c0Controls(charCode) || internals.c1Controls(charCode)) {\n                // Fatal error\n                updateResult(internals.diagnoses.errExpectingATEXT);\n              }\n              parseData.local += token;\n              atomData.locals[elementCount] += token;\n              elementLength += Buffer.byteLength(token, 'utf8');\n            }\n        }\n        break;\n      case internals.components.domain:\n        // http://tools.ietf.org/html/rfc5322#section-3.4.1\n        //   domain          =   dot-atom / domain-literal / obs-domain\n        //\n        //   dot-atom        =   [CFWS] dot-atom-text [CFWS]\n        //\n        //   dot-atom-text   =   1*atext *(\".\" 1*atext)\n        //\n        //   domain-literal  =   [CFWS] \"[\" *([FWS] dtext) [FWS] \"]\" [CFWS]\n        //\n        //   dtext           =   %d33-90 /          ; Printable US-ASCII\n        //                       %d94-126 /         ;  characters not including\n        //                       obs-dtext          ;  \"[\", \"]\", or \"\\\"\n        //\n        //   obs-domain      =   atom *(\".\" atom)\n        //\n        //   atom            =   [CFWS] 1*atext [CFWS]\n\n        // http://tools.ietf.org/html/rfc5321#section-4.1.2\n        //   Mailbox        = Local-part \"@\" ( Domain / address-literal )\n        //\n        //   Domain         = sub-domain *(\".\" sub-domain)\n        //\n        //   address-literal  = \"[\" ( IPv4-address-literal /\n        //                    IPv6-address-literal /\n        //                    General-address-literal ) \"]\"\n        //                    ; See Section 4.1.3\n\n        // http://tools.ietf.org/html/rfc5322#section-3.4.1\n        //      Note: A liberal syntax for the domain portion of addr-spec is\n        //      given here.  However, the domain portion contains addressing\n        //      information specified by and used in other protocols (e.g.,\n        //      [RFC1034], [RFC1035], [RFC1123], [RFC5321]).  It is therefore\n        //      incumbent upon implementations to conform to the syntax of\n        //      addresses for the context in which they are used.\n        //\n        // is_email() author's note: it's not clear how to interpret this in\n        // he context of a general email address validator. The conclusion I\n        // have reached is this: \"addressing information\" must comply with\n        // RFC 5321 (and in turn RFC 1035), anything that is \"semantically\n        // invisible\" must comply only with RFC 5322.\n        switch (token) {\n          // Comment\n          case '(':\n            if (elementLength === 0) {\n              // Comments at the start of the domain are deprecated in the text, comments at the start of a subdomain are obs-domain\n              // http://tools.ietf.org/html/rfc5322#section-3.4.1\n              updateResult(elementCount === 0 ? internals.diagnoses.deprecatedCFWSNearAt : internals.diagnoses.deprecatedComment);\n            } else {\n              // We can't start a comment mid-element, better be at the end\n              assertEnd = true;\n              updateResult(internals.diagnoses.cfwsComment);\n            }\n            context.stack.push(context.now);\n            context.now = internals.components.contextComment;\n            break;\n\n          // Next dot-atom element\n          case '.':\n            const punycodeLength = Punycode.toASCII(atomData.domains[elementCount]).length;\n            if (elementLength === 0) {\n              // Another dot, already? Fatal error.\n              updateResult(elementCount === 0 ? internals.diagnoses.errDotStart : internals.diagnoses.errConsecutiveDots);\n            } else if (hyphenFlag) {\n              // Previous subdomain ended in a hyphen. Fatal error.\n              updateResult(internals.diagnoses.errDomainHyphenEnd);\n            } else if (punycodeLength > 63) {\n              // RFC 5890 specifies that domain labels that are encoded using the Punycode algorithm\n              // must adhere to the <= 63 octet requirement.\n              // This includes string prefixes from the Punycode algorithm.\n              //\n              // https://tools.ietf.org/html/rfc5890#section-2.3.2.1\n              // labels          63 octets or less\n\n              updateResult(internals.diagnoses.rfc5322LabelTooLong);\n            }\n\n            // CFWS is OK again now we're at the beginning of an element (although\n            // it may be obsolete CFWS)\n            assertEnd = false;\n            elementLength = 0;\n            ++elementCount;\n            atomData.domains[elementCount] = '';\n            parseData.domain += token;\n            break;\n\n          // Domain literal\n          case '[':\n            if (atomData.domains[elementCount].length === 0) {\n              if (parseData.domain.length) {\n                // Domain literal interspersed with domain refs.\n                updateResult(internals.diagnoses.errDotAfterDomainLiteral);\n              }\n              assertEnd = true;\n              elementLength += Buffer.byteLength(token, 'utf8');\n              context.stack.push(context.now);\n              context.now = internals.components.literal;\n              parseData.domain += token;\n              atomData.domains[elementCount] += token;\n              parseData.literal = '';\n            } else {\n              // Fatal error\n              updateResult(internals.diagnoses.errExpectingATEXT);\n            }\n            break;\n\n          // Folding white space\n          case '\\r':\n            if (emailLength === ++i || email[i] !== '\\n') {\n              // Fatal error\n              updateResult(internals.diagnoses.errCRNoLF);\n              break;\n            }\n\n          // Fallthrough\n\n          case ' ':\n          case '\\t':\n            if (elementLength === 0) {\n              updateResult(elementCount === 0 ? internals.diagnoses.deprecatedCFWSNearAt : internals.diagnoses.deprecatedFWS);\n            } else {\n              // We can't start FWS in the middle of an element, so this better be the end\n              updateResult(internals.diagnoses.cfwsFWS);\n              assertEnd = true;\n            }\n            context.stack.push(context.now);\n            context.now = internals.components.contextFWS;\n            prevToken = token;\n            break;\n\n          // This must be ATEXT\n          default:\n            // RFC 5322 allows any atext...\n            // http://tools.ietf.org/html/rfc5322#section-3.2.3\n            //    atext = ALPHA / DIGIT / ; Printable US-ASCII\n            //            \"!\" / \"#\" /     ;  characters not including\n            //            \"$\" / \"%\" /     ;  specials.  Used for atoms.\n            //            \"&\" / \"'\" /\n            //            \"*\" / \"+\" /\n            //            \"-\" / \"/\" /\n            //            \"=\" / \"?\" /\n            //            \"^\" / \"_\" /\n            //            \"`\" / \"{\" /\n            //            \"|\" / \"}\" /\n            //            \"~\"\n\n            // But RFC 5321 only allows letter-digit-hyphen to comply with DNS rules\n            //   (RFCs 1034 & 1123)\n            // http://tools.ietf.org/html/rfc5321#section-4.1.2\n            //   sub-domain     = Let-dig [Ldh-str]\n            //\n            //   Let-dig        = ALPHA / DIGIT\n            //\n            //   Ldh-str        = *( ALPHA / DIGIT / \"-\" ) Let-dig\n            //\n            if (assertEnd) {\n              // We have encountered ATEXT where it is no longer valid\n              switch (context.prev) {\n                case internals.components.contextComment:\n                case internals.components.contextFWS:\n                  updateResult(internals.diagnoses.errATEXTAfterCFWS);\n                  break;\n                case internals.components.literal:\n                  updateResult(internals.diagnoses.errATEXTAfterDomainLiteral);\n                  break;\n\n                // $lab:coverage:off$\n                default:\n                  throw new Error('more atext found where none is allowed, but unrecognized prev context: ' + context.prev);\n                // $lab:coverage:on$\n              }\n            }\n\n            charCode = token.codePointAt(0);\n            // Assume this token isn't a hyphen unless we discover it is\n            hyphenFlag = false;\n            if (internals.specials(charCode) || internals.c0Controls(charCode) || internals.c1Controls(charCode)) {\n              // Fatal error\n              updateResult(internals.diagnoses.errExpectingATEXT);\n            } else if (token === '-') {\n              if (elementLength === 0) {\n                // Hyphens cannot be at the beginning of a subdomain, fatal error\n                updateResult(internals.diagnoses.errDomainHyphenStart);\n              }\n              hyphenFlag = true;\n            }\n            // Check if it's a neither a number nor a latin/unicode letter\n            else if (charCode < 48 || charCode > 122 && charCode < 192 || charCode > 57 && charCode < 65 || charCode > 90 && charCode < 97) {\n              // This is not an RFC 5321 subdomain, but still OK by RFC 5322\n              updateResult(internals.diagnoses.rfc5322Domain);\n            }\n            parseData.domain += token;\n            atomData.domains[elementCount] += token;\n            elementLength += Buffer.byteLength(token, 'utf8');\n        }\n        break;\n\n      // Domain literal\n      case internals.components.literal:\n        // http://tools.ietf.org/html/rfc5322#section-3.4.1\n        //   domain-literal  =   [CFWS] \"[\" *([FWS] dtext) [FWS] \"]\" [CFWS]\n        //\n        //   dtext           =   %d33-90 /          ; Printable US-ASCII\n        //                       %d94-126 /         ;  characters not including\n        //                       obs-dtext          ;  \"[\", \"]\", or \"\\\"\n        //\n        //   obs-dtext       =   obs-NO-WS-CTL / quoted-pair\n        switch (token) {\n          // End of domain literal\n          case ']':\n            if (maxResult < internals.categories.deprecated) {\n              // Could be a valid RFC 5321 address literal, so let's check\n\n              // http://tools.ietf.org/html/rfc5321#section-4.1.2\n              //   address-literal  = \"[\" ( IPv4-address-literal /\n              //                    IPv6-address-literal /\n              //                    General-address-literal ) \"]\"\n              //                    ; See Section 4.1.3\n              //\n              // http://tools.ietf.org/html/rfc5321#section-4.1.3\n              //   IPv4-address-literal  = Snum 3(\".\"  Snum)\n              //\n              //   IPv6-address-literal  = \"IPv6:\" IPv6-addr\n              //\n              //   General-address-literal  = Standardized-tag \":\" 1*dcontent\n              //\n              //   Standardized-tag  = Ldh-str\n              //                     ; Standardized-tag MUST be specified in a\n              //                     ; Standards-Track RFC and registered with IANA\n              //\n              //   dcontent      = %d33-90 / ; Printable US-ASCII\n              //                 %d94-126 ; excl. \"[\", \"\\\", \"]\"\n              //\n              //   Snum          = 1*3DIGIT\n              //                 ; representing a decimal integer\n              //                 ; value in the range 0 through 255\n              //\n              //   IPv6-addr     = IPv6-full / IPv6-comp / IPv6v4-full / IPv6v4-comp\n              //\n              //   IPv6-hex      = 1*4HEXDIG\n              //\n              //   IPv6-full     = IPv6-hex 7(\":\" IPv6-hex)\n              //\n              //   IPv6-comp     = [IPv6-hex *5(\":\" IPv6-hex)] \"::\"\n              //                 [IPv6-hex *5(\":\" IPv6-hex)]\n              //                 ; The \"::\" represents at least 2 16-bit groups of\n              //                 ; zeros.  No more than 6 groups in addition to the\n              //                 ; \"::\" may be present.\n              //\n              //   IPv6v4-full   = IPv6-hex 5(\":\" IPv6-hex) \":\" IPv4-address-literal\n              //\n              //   IPv6v4-comp   = [IPv6-hex *3(\":\" IPv6-hex)] \"::\"\n              //                 [IPv6-hex *3(\":\" IPv6-hex) \":\"]\n              //                 IPv4-address-literal\n              //                 ; The \"::\" represents at least 2 16-bit groups of\n              //                 ; zeros.  No more than 4 groups in addition to the\n              //                 ; \"::\" and IPv4-address-literal may be present.\n\n              let index = -1;\n              let addressLiteral = parseData.literal;\n              const matchesIP = internals.regex.ipV4.exec(addressLiteral);\n\n              // Maybe extract IPv4 part from the end of the address-literal\n              if (matchesIP) {\n                index = matchesIP.index;\n                if (index !== 0) {\n                  // Convert IPv4 part to IPv6 format for futher testing\n                  addressLiteral = addressLiteral.slice(0, index) + '0:0';\n                }\n              }\n              if (index === 0) {\n                // Nothing there except a valid IPv4 address, so...\n                updateResult(internals.diagnoses.rfc5321AddressLiteral);\n              } else if (addressLiteral.slice(0, 5).toLowerCase() !== 'ipv6:') {\n                updateResult(internals.diagnoses.rfc5322DomainLiteral);\n              } else {\n                const match = addressLiteral.slice(5);\n                let maxGroups = internals.maxIPv6Groups;\n                const groups = match.split(':');\n                index = match.indexOf('::');\n                if (!~index) {\n                  // Need exactly the right number of groups\n                  if (groups.length !== maxGroups) {\n                    updateResult(internals.diagnoses.rfc5322IPv6GroupCount);\n                  }\n                } else if (index !== match.lastIndexOf('::')) {\n                  updateResult(internals.diagnoses.rfc5322IPv62x2xColon);\n                } else {\n                  if (index === 0 || index === match.length - 2) {\n                    // RFC 4291 allows :: at the start or end of an address with 7 other groups in addition\n                    ++maxGroups;\n                  }\n                  if (groups.length > maxGroups) {\n                    updateResult(internals.diagnoses.rfc5322IPv6MaxGroups);\n                  } else if (groups.length === maxGroups) {\n                    // Eliding a single \"::\"\n                    updateResult(internals.diagnoses.deprecatedIPv6);\n                  }\n                }\n\n                // IPv6 testing strategy\n                if (match[0] === ':' && match[1] !== ':') {\n                  updateResult(internals.diagnoses.rfc5322IPv6ColonStart);\n                } else if (match[match.length - 1] === ':' && match[match.length - 2] !== ':') {\n                  updateResult(internals.diagnoses.rfc5322IPv6ColonEnd);\n                } else if (internals.checkIpV6(groups)) {\n                  updateResult(internals.diagnoses.rfc5321AddressLiteral);\n                } else {\n                  updateResult(internals.diagnoses.rfc5322IPv6BadCharacter);\n                }\n              }\n            } else {\n              updateResult(internals.diagnoses.rfc5322DomainLiteral);\n            }\n            parseData.domain += token;\n            atomData.domains[elementCount] += token;\n            elementLength += Buffer.byteLength(token, 'utf8');\n            context.prev = context.now;\n            context.now = context.stack.pop();\n            break;\n          case '\\\\':\n            updateResult(internals.diagnoses.rfc5322DomainLiteralOBSDText);\n            context.stack.push(context.now);\n            context.now = internals.components.contextQuotedPair;\n            break;\n\n          // Folding white space\n          case '\\r':\n            if (emailLength === ++i || email[i] !== '\\n') {\n              updateResult(internals.diagnoses.errCRNoLF);\n              break;\n            }\n\n          // Fallthrough\n\n          case ' ':\n          case '\\t':\n            updateResult(internals.diagnoses.cfwsFWS);\n            context.stack.push(context.now);\n            context.now = internals.components.contextFWS;\n            prevToken = token;\n            break;\n\n          // DTEXT\n          default:\n            // http://tools.ietf.org/html/rfc5322#section-3.4.1\n            //   dtext         =   %d33-90 /  ; Printable US-ASCII\n            //                     %d94-126 / ;  characters not including\n            //                     obs-dtext  ;  \"[\", \"]\", or \"\\\"\n            //\n            //   obs-dtext     =   obs-NO-WS-CTL / quoted-pair\n            //\n            //   obs-NO-WS-CTL =   %d1-8 /    ; US-ASCII control\n            //                     %d11 /     ;  characters that do not\n            //                     %d12 /     ;  include the carriage\n            //                     %d14-31 /  ;  return, line feed, and\n            //                     %d127      ;  white space characters\n            charCode = token.codePointAt(0);\n\n            // '\\r', '\\n', ' ', and '\\t' have already been parsed above\n            if (charCode !== 127 && internals.c1Controls(charCode) || charCode === 0 || token === '[') {\n              // Fatal error\n              updateResult(internals.diagnoses.errExpectingDTEXT);\n              break;\n            } else if (internals.c0Controls(charCode) || charCode === 127) {\n              updateResult(internals.diagnoses.rfc5322DomainLiteralOBSDText);\n            }\n            parseData.literal += token;\n            parseData.domain += token;\n            atomData.domains[elementCount] += token;\n            elementLength += Buffer.byteLength(token, 'utf8');\n        }\n        break;\n\n      // Quoted string\n      case internals.components.contextQuotedString:\n        // http://tools.ietf.org/html/rfc5322#section-3.2.4\n        //   quoted-string = [CFWS]\n        //                   DQUOTE *([FWS] qcontent) [FWS] DQUOTE\n        //                   [CFWS]\n        //\n        //   qcontent      = qtext / quoted-pair\n        switch (token) {\n          // Quoted pair\n          case '\\\\':\n            context.stack.push(context.now);\n            context.now = internals.components.contextQuotedPair;\n            break;\n\n          // Folding white space. Spaces are allowed as regular characters inside a quoted string - it's only FWS if we include '\\t' or '\\r\\n'\n          case '\\r':\n            if (emailLength === ++i || email[i] !== '\\n') {\n              // Fatal error\n              updateResult(internals.diagnoses.errCRNoLF);\n              break;\n            }\n\n          // Fallthrough\n\n          case '\\t':\n            // http://tools.ietf.org/html/rfc5322#section-3.2.2\n            //   Runs of FWS, comment, or CFWS that occur between lexical tokens in\n            //   a structured header field are semantically interpreted as a single\n            //   space character.\n\n            // http://tools.ietf.org/html/rfc5322#section-3.2.4\n            //   the CRLF in any FWS/CFWS that appears within the quoted-string [is]\n            //   semantically \"invisible\" and therefore not part of the\n            //   quoted-string\n\n            parseData.local += ' ';\n            atomData.locals[elementCount] += ' ';\n            elementLength += Buffer.byteLength(token, 'utf8');\n            updateResult(internals.diagnoses.cfwsFWS);\n            context.stack.push(context.now);\n            context.now = internals.components.contextFWS;\n            prevToken = token;\n            break;\n\n          // End of quoted string\n          case '\"':\n            parseData.local += token;\n            atomData.locals[elementCount] += token;\n            elementLength += Buffer.byteLength(token, 'utf8');\n            context.prev = context.now;\n            context.now = context.stack.pop();\n            break;\n\n          // QTEXT\n          default:\n            // http://tools.ietf.org/html/rfc5322#section-3.2.4\n            //   qtext          =   %d33 /             ; Printable US-ASCII\n            //                      %d35-91 /          ;  characters not including\n            //                      %d93-126 /         ;  \"\\\" or the quote character\n            //                      obs-qtext\n            //\n            //   obs-qtext      =   obs-NO-WS-CTL\n            //\n            //   obs-NO-WS-CTL  =   %d1-8 /            ; US-ASCII control\n            //                      %d11 /             ;  characters that do not\n            //                      %d12 /             ;  include the carriage\n            //                      %d14-31 /          ;  return, line feed, and\n            //                      %d127              ;  white space characters\n            charCode = token.codePointAt(0);\n            if (charCode !== 127 && internals.c1Controls(charCode) || charCode === 0 || charCode === 10) {\n              updateResult(internals.diagnoses.errExpectingQTEXT);\n            } else if (internals.c0Controls(charCode) || charCode === 127) {\n              updateResult(internals.diagnoses.deprecatedQTEXT);\n            }\n            parseData.local += token;\n            atomData.locals[elementCount] += token;\n            elementLength += Buffer.byteLength(token, 'utf8');\n        }\n\n        // http://tools.ietf.org/html/rfc5322#section-3.4.1\n        //   If the string can be represented as a dot-atom (that is, it contains\n        //   no characters other than atext characters or \".\" surrounded by atext\n        //   characters), then the dot-atom form SHOULD be used and the quoted-\n        //   string form SHOULD NOT be used.\n\n        break;\n      // Quoted pair\n      case internals.components.contextQuotedPair:\n        // http://tools.ietf.org/html/rfc5322#section-3.2.1\n        //   quoted-pair     =   (\"\\\" (VCHAR / WSP)) / obs-qp\n        //\n        //   VCHAR           =  %d33-126   ; visible (printing) characters\n        //   WSP             =  SP / HTAB  ; white space\n        //\n        //   obs-qp          =   \"\\\" (%d0 / obs-NO-WS-CTL / LF / CR)\n        //\n        //   obs-NO-WS-CTL   =   %d1-8 /   ; US-ASCII control\n        //                       %d11 /    ;  characters that do not\n        //                       %d12 /    ;  include the carriage\n        //                       %d14-31 / ;  return, line feed, and\n        //                       %d127     ;  white space characters\n        //\n        // i.e. obs-qp       =  \"\\\" (%d0-8, %d10-31 / %d127)\n        charCode = token.codePointAt(0);\n        if (charCode !== 127 && internals.c1Controls(charCode)) {\n          // Fatal error\n          updateResult(internals.diagnoses.errExpectingQPair);\n        } else if (charCode < 31 && charCode !== 9 || charCode === 127) {\n          // ' ' and '\\t' are allowed\n          updateResult(internals.diagnoses.deprecatedQP);\n        }\n\n        // At this point we know where this qpair occurred so we could check to see if the character actually needed to be quoted at all.\n        // http://tools.ietf.org/html/rfc5321#section-4.1.2\n        //   the sending system SHOULD transmit the form that uses the minimum quoting possible.\n\n        context.prev = context.now;\n        // End of qpair\n        context.now = context.stack.pop();\n        const escapeToken = '\\\\' + token;\n        switch (context.now) {\n          case internals.components.contextComment:\n            break;\n          case internals.components.contextQuotedString:\n            parseData.local += escapeToken;\n            atomData.locals[elementCount] += escapeToken;\n\n            // The maximum sizes specified by RFC 5321 are octet counts, so we must include the backslash\n            elementLength += 2;\n            break;\n          case internals.components.literal:\n            parseData.domain += escapeToken;\n            atomData.domains[elementCount] += escapeToken;\n\n            // The maximum sizes specified by RFC 5321 are octet counts, so we must include the backslash\n            elementLength += 2;\n            break;\n\n          // $lab:coverage:off$\n          default:\n            throw new Error('quoted pair logic invoked in an invalid context: ' + context.now);\n          // $lab:coverage:on$\n        }\n\n        break;\n\n      // Comment\n      case internals.components.contextComment:\n        // http://tools.ietf.org/html/rfc5322#section-3.2.2\n        //   comment  = \"(\" *([FWS] ccontent) [FWS] \")\"\n        //\n        //   ccontent = ctext / quoted-pair / comment\n        switch (token) {\n          // Nested comment\n          case '(':\n            // Nested comments are ok\n            context.stack.push(context.now);\n            context.now = internals.components.contextComment;\n            break;\n\n          // End of comment\n          case ')':\n            context.prev = context.now;\n            context.now = context.stack.pop();\n            break;\n\n          // Quoted pair\n          case '\\\\':\n            context.stack.push(context.now);\n            context.now = internals.components.contextQuotedPair;\n            break;\n\n          // Folding white space\n          case '\\r':\n            if (emailLength === ++i || email[i] !== '\\n') {\n              // Fatal error\n              updateResult(internals.diagnoses.errCRNoLF);\n              break;\n            }\n\n          // Fallthrough\n\n          case ' ':\n          case '\\t':\n            updateResult(internals.diagnoses.cfwsFWS);\n            context.stack.push(context.now);\n            context.now = internals.components.contextFWS;\n            prevToken = token;\n            break;\n\n          // CTEXT\n          default:\n            // http://tools.ietf.org/html/rfc5322#section-3.2.3\n            //   ctext         = %d33-39 /  ; Printable US-ASCII\n            //                   %d42-91 /  ;  characters not including\n            //                   %d93-126 / ;  \"(\", \")\", or \"\\\"\n            //                   obs-ctext\n            //\n            //   obs-ctext     = obs-NO-WS-CTL\n            //\n            //   obs-NO-WS-CTL = %d1-8 /    ; US-ASCII control\n            //                   %d11 /     ;  characters that do not\n            //                   %d12 /     ;  include the carriage\n            //                   %d14-31 /  ;  return, line feed, and\n            //                   %d127      ;  white space characters\n            charCode = token.codePointAt(0);\n            if (charCode === 0 || charCode === 10 || charCode !== 127 && internals.c1Controls(charCode)) {\n              // Fatal error\n              updateResult(internals.diagnoses.errExpectingCTEXT);\n              break;\n            } else if (internals.c0Controls(charCode) || charCode === 127) {\n              updateResult(internals.diagnoses.deprecatedCTEXT);\n            }\n        }\n        break;\n\n      // Folding white space\n      case internals.components.contextFWS:\n        // http://tools.ietf.org/html/rfc5322#section-3.2.2\n        //   FWS     =   ([*WSP CRLF] 1*WSP) /  obs-FWS\n        //                                   ; Folding white space\n\n        // But note the erratum:\n        // http://www.rfc-editor.org/errata_search.php?rfc=5322&eid=1908:\n        //   In the obsolete syntax, any amount of folding white space MAY be\n        //   inserted where the obs-FWS rule is allowed.  This creates the\n        //   possibility of having two consecutive \"folds\" in a line, and\n        //   therefore the possibility that a line which makes up a folded header\n        //   field could be composed entirely of white space.\n        //\n        //   obs-FWS =   1*([CRLF] WSP)\n\n        if (prevToken === '\\r') {\n          if (token === '\\r') {\n            // Fatal error\n            updateResult(internals.diagnoses.errFWSCRLFx2);\n            break;\n          }\n          if (++crlfCount > 1) {\n            // Multiple folds => obsolete FWS\n            updateResult(internals.diagnoses.deprecatedFWS);\n          } else {\n            crlfCount = 1;\n          }\n        }\n        switch (token) {\n          case '\\r':\n            if (emailLength === ++i || email[i] !== '\\n') {\n              // Fatal error\n              updateResult(internals.diagnoses.errCRNoLF);\n            }\n            break;\n          case ' ':\n          case '\\t':\n            break;\n          default:\n            if (prevToken === '\\r') {\n              // Fatal error\n              updateResult(internals.diagnoses.errFWSCRLFEnd);\n            }\n            crlfCount = 0;\n\n            // End of FWS\n            context.prev = context.now;\n            context.now = context.stack.pop();\n\n            // Look at this token again in the parent context\n            --i;\n        }\n        prevToken = token;\n        break;\n\n      // Unexpected context\n      // $lab:coverage:off$\n      default:\n        throw new Error('unknown context: ' + context.now);\n      // $lab:coverage:on$\n    } // Primary state machine\n\n    if (maxResult > internals.categories.rfc5322) {\n      // Fatal error, no point continuing\n      break;\n    }\n  } // Token loop\n\n  // Check for errors\n  if (maxResult < internals.categories.rfc5322) {\n    const punycodeLength = Punycode.toASCII(parseData.domain).length;\n    // Fatal errors\n    if (context.now === internals.components.contextQuotedString) {\n      updateResult(internals.diagnoses.errUnclosedQuotedString);\n    } else if (context.now === internals.components.contextQuotedPair) {\n      updateResult(internals.diagnoses.errBackslashEnd);\n    } else if (context.now === internals.components.contextComment) {\n      updateResult(internals.diagnoses.errUnclosedComment);\n    } else if (context.now === internals.components.literal) {\n      updateResult(internals.diagnoses.errUnclosedDomainLiteral);\n    } else if (token === '\\r') {\n      updateResult(internals.diagnoses.errFWSCRLFEnd);\n    } else if (parseData.domain.length === 0) {\n      updateResult(internals.diagnoses.errNoDomain);\n    } else if (elementLength === 0) {\n      updateResult(internals.diagnoses.errDotEnd);\n    } else if (hyphenFlag) {\n      updateResult(internals.diagnoses.errDomainHyphenEnd);\n    }\n\n    // Other errors\n    else if (punycodeLength > 255) {\n      // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.2\n      //   The maximum total length of a domain name or number is 255 octets.\n      updateResult(internals.diagnoses.rfc5322DomainTooLong);\n    } else if (Buffer.byteLength(parseData.local, 'utf8') + punycodeLength + /* '@' */1 > 254) {\n      // http://tools.ietf.org/html/rfc5321#section-4.1.2\n      //   Forward-path   = Path\n      //\n      //   Path           = \"<\" [ A-d-l \":\" ] Mailbox \">\"\n      //\n      // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.3\n      //   The maximum total length of a reverse-path or forward-path is 256 octets (including the punctuation and element separators).\n      //\n      // Thus, even without (obsolete) routing information, the Mailbox can only be 254 characters long. This is confirmed by this verified\n      // erratum to RFC 3696:\n      //\n      // http://www.rfc-editor.org/errata_search.php?rfc=3696&eid=1690\n      //   However, there is a restriction in RFC 2821 on the length of an address in MAIL and RCPT commands of 254 characters.  Since\n      //   addresses that do not fit in those fields are not normally useful, the upper limit on address lengths should normally be considered\n      //   to be 254.\n      updateResult(internals.diagnoses.rfc5322TooLong);\n    } else if (elementLength > 63) {\n      // http://tools.ietf.org/html/rfc1035#section-2.3.4\n      // labels   63 octets or less\n      updateResult(internals.diagnoses.rfc5322LabelTooLong);\n    } else if (options.minDomainAtoms && atomData.domains.length < options.minDomainAtoms && (atomData.domains.length !== 1 || atomData.domains[0][0] !== '[')) {\n      updateResult(internals.diagnoses.errDomainTooShort);\n    } else if (internals.hasDomainLiteralThenAtom(atomData.domains)) {\n      updateResult(internals.diagnoses.errDotAfterDomainLiteral);\n    } else if (options.tldWhitelist || options.tldBlacklist) {\n      const tldAtom = atomData.domains[elementCount];\n      if (!internals.validDomain(tldAtom, options)) {\n        updateResult(internals.diagnoses.errUnknownTLD);\n      }\n    }\n  } // Check for errors\n\n  // Finish\n  if (maxResult < internals.categories.dnsWarn) {\n    // Per RFC 5321, domain atoms are limited to letter-digit-hyphen, so we only need to check code <= 57 to check for a digit\n    const code = atomData.domains[elementCount].codePointAt(0);\n    if (code <= 57) {\n      updateResult(internals.diagnoses.rfc5321TLDNumeric);\n    }\n  }\n  if (maxResult < threshold) {\n    maxResult = internals.diagnoses.valid;\n  }\n  const finishResult = diagnose ? maxResult : maxResult < internals.defaultThreshold;\n\n  // $lab:coverage:off$\n  if (callback) {\n    callback(finishResult);\n  }\n  // $lab:coverage:on$\n\n  return finishResult;\n};\nexports.diagnoses = internals.validate.diagnoses = function () {\n  const diag = {};\n  const keys = Object.keys(internals.diagnoses);\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    diag[key] = internals.diagnoses[key];\n  }\n  return diag;\n}();\nexports.normalize = internals.normalize;","map":{"version":3,"names":["Punycode","require","Util","internals","hasOwn","Object","prototype","hasOwnProperty","indexOf","Array","defaultThreshold","maxIPv6Groups","categories","valid","dnsWarn","rfc5321","cfws","deprecated","rfc5322","error","diagnoses","rfc5321TLD","rfc5321TLDNumeric","rfc5321QuotedString","rfc5321AddressLiteral","cfwsComment","cfwsFWS","undesiredNonAscii","deprecatedLocalPart","deprecatedFWS","deprecatedQTEXT","deprecatedQP","deprecatedComment","deprecatedCTEXT","deprecatedIPv6","deprecatedCFWSNearAt","rfc5322Domain","rfc5322TooLong","rfc5322LocalTooLong","rfc5322DomainTooLong","rfc5322LabelTooLong","rfc5322DomainLiteral","rfc5322DomainLiteralOBSDText","rfc5322IPv6GroupCount","rfc5322IPv62x2xColon","rfc5322IPv6BadCharacter","rfc5322IPv6MaxGroups","rfc5322IPv6ColonStart","rfc5322IPv6ColonEnd","errExpectingDTEXT","errNoLocalPart","errNoDomain","errConsecutiveDots","errATEXTAfterCFWS","errATEXTAfterQS","errATEXTAfterDomainLiteral","errExpectingQPair","errExpectingATEXT","errExpectingQTEXT","errExpectingCTEXT","errBackslashEnd","errDotStart","errDotEnd","errDomainHyphenStart","errDomainHyphenEnd","errUnclosedQuotedString","errUnclosedComment","errUnclosedDomainLiteral","errFWSCRLFx2","errFWSCRLFEnd","errCRNoLF","errUnknownTLD","errDomainTooShort","errDotAfterDomainLiteral","components","localpart","domain","literal","contextComment","contextFWS","contextQuotedString","contextQuotedPair","specials","lookup","fill","i","length","codePointAt","code","c0Controls","c1Controls","regex","ipV4","ipV6","normalizeSupportsNul","normalize","nulNormalize","email","split","map","part","join","checkIpV6","items","every","value","test","isIterable","isArray","Symbol","iterator","_isSet","Set","_isMap","Map","isSet","types","isMap","normalizeTable","table","keys","canonicalizeAtom","atom","toASCII","toLowerCase","includesMapped","iterable","iteratee","item","validDomain","tldAtom","options","canonicalTldAtom","tldBlacklist","tldWhitelist","hasDomainLiteralThenAtom","domainAtoms","hasDomainLiteral","exports","validate","callback","TypeError","diagnose","threshold","errorLevel","minDomainAtoms","excludeDiagnoses","maxResult","updateResult","has","allowUnicode","undefined","context","now","prev","stack","prevToken","parseData","local","atomData","locals","domains","elementCount","elementLength","crlfCount","charCode","hyphenFlag","assertEnd","emailLength","token","String","fromCodePoint","push","Buffer","byteLength","Error","punycodeLength","index","addressLiteral","matchesIP","exec","slice","match","maxGroups","groups","lastIndexOf","pop","escapeToken","finishResult","diag","key"],"sources":["/Users/mariovicky/Skripsi_OpenLayers/node_modules/isemail/lib/index.js"],"sourcesContent":["'use strict';\n\n// Load modules\n\nconst Punycode = require('punycode');\nconst Util = require('util');\n\n// Declare internals\n\nconst internals = {\n    hasOwn: Object.prototype.hasOwnProperty,\n    indexOf: Array.prototype.indexOf,\n    defaultThreshold: 16,\n    maxIPv6Groups: 8,\n\n    categories: {\n        valid: 1,\n        dnsWarn: 7,\n        rfc5321: 15,\n        cfws: 31,\n        deprecated: 63,\n        rfc5322: 127,\n        error: 255\n    },\n\n    diagnoses: {\n\n        // Address is valid\n\n        valid: 0,\n\n        // Address is valid for SMTP but has unusual elements\n\n        rfc5321TLD: 9,\n        rfc5321TLDNumeric: 10,\n        rfc5321QuotedString: 11,\n        rfc5321AddressLiteral: 12,\n\n        // Address is valid for message, but must be modified for envelope\n\n        cfwsComment: 17,\n        cfwsFWS: 18,\n\n        // Address contains non-ASCII when the allowUnicode option is false\n        // Has to be > internals.defaultThreshold so that it's rejected\n        // without an explicit errorLevel:\n        undesiredNonAscii: 25,\n\n        // Address contains deprecated elements, but may still be valid in some contexts\n\n        deprecatedLocalPart: 33,\n        deprecatedFWS: 34,\n        deprecatedQTEXT: 35,\n        deprecatedQP: 36,\n        deprecatedComment: 37,\n        deprecatedCTEXT: 38,\n        deprecatedIPv6: 39,\n        deprecatedCFWSNearAt: 49,\n\n        // Address is only valid according to broad definition in RFC 5322, but is otherwise invalid\n\n        rfc5322Domain: 65,\n        rfc5322TooLong: 66,\n        rfc5322LocalTooLong: 67,\n        rfc5322DomainTooLong: 68,\n        rfc5322LabelTooLong: 69,\n        rfc5322DomainLiteral: 70,\n        rfc5322DomainLiteralOBSDText: 71,\n        rfc5322IPv6GroupCount: 72,\n        rfc5322IPv62x2xColon: 73,\n        rfc5322IPv6BadCharacter: 74,\n        rfc5322IPv6MaxGroups: 75,\n        rfc5322IPv6ColonStart: 76,\n        rfc5322IPv6ColonEnd: 77,\n\n        // Address is invalid for any purpose\n\n        errExpectingDTEXT: 129,\n        errNoLocalPart: 130,\n        errNoDomain: 131,\n        errConsecutiveDots: 132,\n        errATEXTAfterCFWS: 133,\n        errATEXTAfterQS: 134,\n        errATEXTAfterDomainLiteral: 135,\n        errExpectingQPair: 136,\n        errExpectingATEXT: 137,\n        errExpectingQTEXT: 138,\n        errExpectingCTEXT: 139,\n        errBackslashEnd: 140,\n        errDotStart: 141,\n        errDotEnd: 142,\n        errDomainHyphenStart: 143,\n        errDomainHyphenEnd: 144,\n        errUnclosedQuotedString: 145,\n        errUnclosedComment: 146,\n        errUnclosedDomainLiteral: 147,\n        errFWSCRLFx2: 148,\n        errFWSCRLFEnd: 149,\n        errCRNoLF: 150,\n        errUnknownTLD: 160,\n        errDomainTooShort: 161,\n        errDotAfterDomainLiteral: 162\n    },\n\n    components: {\n        localpart: 0,\n        domain: 1,\n        literal: 2,\n        contextComment: 3,\n        contextFWS: 4,\n        contextQuotedString: 5,\n        contextQuotedPair: 6\n    }\n};\n\n\ninternals.specials = function () {\n\n    const specials = '()<>[]:;@\\\\,.\"';        // US-ASCII visible characters not valid for atext (http://tools.ietf.org/html/rfc5322#section-3.2.3)\n    const lookup = new Array(0x100);\n    lookup.fill(false);\n\n    for (let i = 0; i < specials.length; ++i) {\n        lookup[specials.codePointAt(i)] = true;\n    }\n\n    return function (code) {\n\n        return lookup[code];\n    };\n}();\n\ninternals.c0Controls = function () {\n\n    const lookup = new Array(0x100);\n    lookup.fill(false);\n\n    // add C0 control characters\n\n    for (let i = 0; i < 33; ++i) {\n        lookup[i] = true;\n    }\n\n    return function (code) {\n\n        return lookup[code];\n    };\n}();\n\ninternals.c1Controls = function () {\n\n    const lookup = new Array(0x100);\n    lookup.fill(false);\n\n    // add C1 control characters\n\n    for (let i = 127; i < 160; ++i) {\n        lookup[i] = true;\n    }\n\n    return function (code) {\n\n        return lookup[code];\n    };\n}();\n\ninternals.regex = {\n    ipV4: /\\b(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/,\n    ipV6: /^[a-fA-F\\d]{0,4}$/\n};\n\ninternals.normalizeSupportsNul = '\\0'.normalize('NFC') === '\\0';\n\n\n// $lab:coverage:off$\ninternals.nulNormalize = function (email) {\n\n    return email.split('\\0').map((part) => part.normalize('NFC')).join('\\0');\n};\n// $lab:coverage:on$\n\n\ninternals.normalize = function (email) {\n\n    return email.normalize('NFC');\n};\n\n\n// $lab:coverage:off$\nif (!internals.normalizeSupportsNul) {\n    internals.normalize = function (email) {\n\n        if (email.indexOf('\\0') >= 0) {\n            return internals.nulNormalize(email);\n        }\n\n        return email.normalize('NFC');\n    };\n}\n// $lab:coverage:on$\n\n\ninternals.checkIpV6 = function (items) {\n\n    return items.every((value) => internals.regex.ipV6.test(value));\n};\n\n\ninternals.isIterable = Array.isArray;\n\n\n/* $lab:coverage:off$ */\nif (typeof Symbol !== 'undefined') {\n    internals.isIterable = (value) => Array.isArray(value) || (!!value && typeof value === 'object' && typeof value[Symbol.iterator] === 'function');\n}\n/* $lab:coverage:on$ */\n\n\n// Node 10 introduced isSet and isMap, which are useful for cross-context type\n// checking.\n// $lab:coverage:off$\ninternals._isSet = (value) => value instanceof Set;\ninternals._isMap = (value) => value instanceof Map;\ninternals.isSet = Util.types && Util.types.isSet || internals._isSet;\ninternals.isMap = Util.types && Util.types.isMap || internals._isMap;\n// $lab:coverage:on$\n\n\n/**\n * Normalize the given lookup \"table\" to an iterator. Outputs items in arrays\n * and sets, keys from maps (regardless of the corresponding value), and own\n * enumerable keys from all other objects (intended to be plain objects).\n *\n * @param {*} table The table to convert.\n * @returns {Iterable<*>} The converted table.\n */\ninternals.normalizeTable = function (table) {\n\n    if (internals.isSet(table) || Array.isArray(table)) {\n        return table;\n    }\n\n    if (internals.isMap(table)) {\n        return table.keys();\n    }\n\n    return Object.keys(table);\n};\n\n\n/**\n * Convert the given domain atom to its canonical form using Nameprep and string\n * lowercasing. Domain atoms that are all-ASCII will not undergo any changes via\n * Nameprep, and domain atoms that have already been canonicalized will not be\n * altered.\n *\n * @param {string} atom The atom to canonicalize.\n * @returns {string} The canonicalized atom.\n */\ninternals.canonicalizeAtom = function (atom) {\n\n    return Punycode.toASCII(atom).toLowerCase();\n};\n\n\n/**\n * Check whether any of the values in the given iterable, when passed through\n * the iteratee function, are equal to the given value.\n *\n * @param {Iterable<*>} iterable The iterable to check.\n * @param {function(*): *} iteratee The iteratee that receives each item from\n *   the iterable.\n * @param {*} value The reference value.\n * @returns {boolean} Whether the given value matches any of the items in the\n *   iterable per the iteratee.\n */\ninternals.includesMapped = function (iterable, iteratee, value) {\n\n    for (const item of iterable) {\n        if (value === iteratee(item)) {\n            return true;\n        }\n    }\n\n    return false;\n};\n\n\n/**\n * Check whether the given top-level domain atom is valid based on the\n * configured blacklist/whitelist.\n *\n * @param {string} tldAtom The atom to check.\n * @param {Object} options\n *   {*} tldBlacklist The set of domains to consider invalid.\n *   {*} tldWhitelist The set of domains to consider valid.\n * @returns {boolean} Whether the given domain atom is valid per the blacklist/\n *   whitelist.\n */\ninternals.validDomain = function (tldAtom, options) {\n\n    // Nameprep handles case-sensitive unicode stuff, but doesn't touch\n    // uppercase ASCII characters.\n    const canonicalTldAtom = internals.canonicalizeAtom(tldAtom);\n\n    if (options.tldBlacklist) {\n        return !internals.includesMapped(\n            internals.normalizeTable(options.tldBlacklist),\n            internals.canonicalizeAtom, canonicalTldAtom);\n    }\n\n    return internals.includesMapped(\n        internals.normalizeTable(options.tldWhitelist),\n        internals.canonicalizeAtom, canonicalTldAtom);\n};\n\n\n/**\n * Check whether the domain atoms has an address literal part followed by a\n * normal domain atom part. For example, [127.0.0.1].com.\n *\n * @param {string[]} domainAtoms The parsed domain atoms.\n * @returns {boolean} Whether there exists both a normal domain atom and an\n *   address literal.\n */\ninternals.hasDomainLiteralThenAtom = function (domainAtoms) {\n\n    let hasDomainLiteral = false;\n    for (let i = 0; i < domainAtoms.length; ++i) {\n        if (domainAtoms[i][0] === '[') {\n            hasDomainLiteral = true;\n        }\n        else if (hasDomainLiteral) {\n            return true;\n        }\n    }\n\n    return false;\n};\n\n\n/**\n * Check that an email address conforms to RFCs 5321, 5322, 6530 and others\n *\n * We distinguish clearly between a Mailbox as defined by RFC 5321 and an\n * addr-spec as defined by RFC 5322. Depending on the context, either can be\n * regarded as a valid email address. The RFC 5321 Mailbox specification is\n * more restrictive (comments, white space and obsolete forms are not allowed).\n *\n * @param {string} email The email address to check. See README for specifics.\n * @param {Object} options The (optional) options:\n *   {*} errorLevel Determines the boundary between valid and invalid\n *     addresses.\n *   {*} tldBlacklist The set of domains to consider invalid.\n *   {*} tldWhitelist The set of domains to consider valid.\n *   {*} allowUnicode Whether to allow non-ASCII characters, defaults to true.\n *   {*} minDomainAtoms The minimum number of domain atoms which must be present\n *     for the address to be valid.\n * @param {function(number|boolean)} callback The (optional) callback handler.\n * @return {*}\n */\n\nexports.validate = internals.validate = function (email, options, callback) {\n\n    options = options || {};\n\n    if (typeof email !== 'string') {\n        throw new TypeError('expected string email');\n    }\n\n    email = internals.normalize(email);\n\n    // The callback function is deprecated.\n    // $lab:coverage:off$\n    if (typeof options === 'function') {\n        callback = options;\n        options = {};\n    }\n\n    if (typeof callback !== 'function') {\n        callback = null;\n    }\n    // $lab:coverage:on$\n\n    let diagnose;\n    let threshold;\n\n    if (typeof options.errorLevel === 'number') {\n        diagnose = true;\n        threshold = options.errorLevel;\n    }\n    else {\n        diagnose = !!options.errorLevel;\n        threshold = internals.diagnoses.valid;\n    }\n\n    if (options.tldWhitelist) {\n        if (typeof options.tldWhitelist === 'string') {\n            options.tldWhitelist = [options.tldWhitelist];\n        }\n        else if (typeof options.tldWhitelist !== 'object') {\n            throw new TypeError('expected array or object tldWhitelist');\n        }\n    }\n\n    if (options.tldBlacklist) {\n        if (typeof options.tldBlacklist === 'string') {\n            options.tldBlacklist = [options.tldBlacklist];\n        }\n        else if (typeof options.tldBlacklist !== 'object') {\n            throw new TypeError('expected array or object tldBlacklist');\n        }\n    }\n\n    if (options.minDomainAtoms && (options.minDomainAtoms !== ((+options.minDomainAtoms) | 0) || options.minDomainAtoms < 0)) {\n        throw new TypeError('expected positive integer minDomainAtoms');\n    }\n\n    // Normalize the set of excluded diagnoses.\n    if (options.excludeDiagnoses) {\n        if (!internals.isIterable(options.excludeDiagnoses)) {\n            throw new TypeError('expected iterable excludeDiagnoses');\n        }\n\n        // This won't catch cross-realm Sets pre-Node 10, but it will cast the\n        // value to an in-realm Set representation.\n        if (!internals.isSet(options.excludeDiagnoses)) {\n            options.excludeDiagnoses = new Set(options.excludeDiagnoses);\n        }\n    }\n\n    let maxResult = internals.diagnoses.valid;\n    const updateResult = (value) => {\n\n        if (value > maxResult && (!options.excludeDiagnoses || !options.excludeDiagnoses.has(value))) {\n            maxResult = value;\n        }\n    };\n\n    const allowUnicode = options.allowUnicode === undefined || !!options.allowUnicode;\n    if (!allowUnicode && /[^\\x00-\\x7f]/.test(email)) {\n        updateResult(internals.diagnoses.undesiredNonAscii);\n    }\n\n    const context = {\n        now: internals.components.localpart,\n        prev: internals.components.localpart,\n        stack: [internals.components.localpart]\n    };\n\n    let prevToken = '';\n\n    const parseData = {\n        local: '',\n        domain: ''\n    };\n    const atomData = {\n        locals: [''],\n        domains: ['']\n    };\n\n    let elementCount = 0;\n    let elementLength = 0;\n    let crlfCount = 0;\n    let charCode;\n\n    let hyphenFlag = false;\n    let assertEnd = false;\n\n    const emailLength = email.length;\n\n    let token;                                      // Token is used outside the loop, must declare similarly\n    for (let i = 0; i < emailLength; i += token.length) {\n        // Utilize codepoints to account for Unicode surrogate pairs\n        token = String.fromCodePoint(email.codePointAt(i));\n\n        switch (context.now) {\n            // Local-part\n            case internals.components.localpart:\n                // http://tools.ietf.org/html/rfc5322#section-3.4.1\n                //   local-part      =   dot-atom / quoted-string / obs-local-part\n                //\n                //   dot-atom        =   [CFWS] dot-atom-text [CFWS]\n                //\n                //   dot-atom-text   =   1*atext *(\".\" 1*atext)\n                //\n                //   quoted-string   =   [CFWS]\n                //                       DQUOTE *([FWS] qcontent) [FWS] DQUOTE\n                //                       [CFWS]\n                //\n                //   obs-local-part  =   word *(\".\" word)\n                //\n                //   word            =   atom / quoted-string\n                //\n                //   atom            =   [CFWS] 1*atext [CFWS]\n                switch (token) {\n                    // Comment\n                    case '(':\n                        if (elementLength === 0) {\n                            // Comments are OK at the beginning of an element\n                            updateResult(elementCount === 0 ? internals.diagnoses.cfwsComment : internals.diagnoses.deprecatedComment);\n                        }\n                        else {\n                            updateResult(internals.diagnoses.cfwsComment);\n                            // Cannot start a comment in an element, should be end\n                            assertEnd = true;\n                        }\n\n                        context.stack.push(context.now);\n                        context.now = internals.components.contextComment;\n                        break;\n\n                        // Next dot-atom element\n                    case '.':\n                        if (elementLength === 0) {\n                            // Another dot, already?\n                            updateResult(elementCount === 0 ? internals.diagnoses.errDotStart : internals.diagnoses.errConsecutiveDots);\n                        }\n                        else {\n                            // The entire local-part can be a quoted string for RFC 5321; if one atom is quoted it's an RFC 5322 obsolete form\n                            if (assertEnd) {\n                                updateResult(internals.diagnoses.deprecatedLocalPart);\n                            }\n\n                            // CFWS & quoted strings are OK again now we're at the beginning of an element (although they are obsolete forms)\n                            assertEnd = false;\n                            elementLength = 0;\n                            ++elementCount;\n                            parseData.local += token;\n                            atomData.locals[elementCount] = '';\n                        }\n\n                        break;\n\n                        // Quoted string\n                    case '\"':\n                        if (elementLength === 0) {\n                            // The entire local-part can be a quoted string for RFC 5321; if one atom is quoted it's an RFC 5322 obsolete form\n                            updateResult(elementCount === 0 ? internals.diagnoses.rfc5321QuotedString : internals.diagnoses.deprecatedLocalPart);\n\n                            parseData.local += token;\n                            atomData.locals[elementCount] += token;\n                            elementLength += Buffer.byteLength(token, 'utf8');\n\n                            // Quoted string must be the entire element\n                            assertEnd = true;\n                            context.stack.push(context.now);\n                            context.now = internals.components.contextQuotedString;\n                        }\n                        else {\n                            updateResult(internals.diagnoses.errExpectingATEXT);\n                        }\n\n                        break;\n\n                        // Folding white space\n                    case '\\r':\n                        if (emailLength === ++i || email[i] !== '\\n') {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errCRNoLF);\n                            break;\n                        }\n\n                        // Fallthrough\n\n                    case ' ':\n                    case '\\t':\n                        if (elementLength === 0) {\n                            updateResult(elementCount === 0 ? internals.diagnoses.cfwsFWS : internals.diagnoses.deprecatedFWS);\n                        }\n                        else {\n                            // We can't start FWS in the middle of an element, better be end\n                            assertEnd = true;\n                        }\n\n                        context.stack.push(context.now);\n                        context.now = internals.components.contextFWS;\n                        prevToken = token;\n                        break;\n\n                    case '@':\n                        // At this point we should have a valid local-part\n                        // $lab:coverage:off$\n                        if (context.stack.length !== 1) {\n                            throw new Error('unexpected item on context stack');\n                        }\n                        // $lab:coverage:on$\n\n                        if (parseData.local.length === 0) {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errNoLocalPart);\n                        }\n                        else if (elementLength === 0) {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errDotEnd);\n                        }\n                        // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.1 the maximum total length of a user name or other local-part is 64\n                        //    octets\n                        else if (Buffer.byteLength(parseData.local, 'utf8') > 64) {\n                            updateResult(internals.diagnoses.rfc5322LocalTooLong);\n                        }\n                        // http://tools.ietf.org/html/rfc5322#section-3.4.1 comments and folding white space SHOULD NOT be used around \"@\" in the\n                        //    addr-spec\n                        //\n                        // http://tools.ietf.org/html/rfc2119\n                        // 4. SHOULD NOT this phrase, or the phrase \"NOT RECOMMENDED\" mean that there may exist valid reasons in particular\n                        //    circumstances when the particular behavior is acceptable or even useful, but the full implications should be understood\n                        //    and the case carefully weighed before implementing any behavior described with this label.\n                        else if (context.prev === internals.components.contextComment || context.prev === internals.components.contextFWS) {\n                            updateResult(internals.diagnoses.deprecatedCFWSNearAt);\n                        }\n\n                        // Clear everything down for the domain parsing\n                        context.now = internals.components.domain;\n                        context.stack[0] = internals.components.domain;\n                        elementCount = 0;\n                        elementLength = 0;\n                        assertEnd = false; // CFWS can only appear at the end of the element\n                        break;\n\n                        // ATEXT\n                    default:\n                        // http://tools.ietf.org/html/rfc5322#section-3.2.3\n                        //    atext = ALPHA / DIGIT / ; Printable US-ASCII\n                        //            \"!\" / \"#\" /     ;  characters not including\n                        //            \"$\" / \"%\" /     ;  specials.  Used for atoms.\n                        //            \"&\" / \"'\" /\n                        //            \"*\" / \"+\" /\n                        //            \"-\" / \"/\" /\n                        //            \"=\" / \"?\" /\n                        //            \"^\" / \"_\" /\n                        //            \"`\" / \"{\" /\n                        //            \"|\" / \"}\" /\n                        //            \"~\"\n                        if (assertEnd) {\n                            // We have encountered atext where it is no longer valid\n                            switch (context.prev) {\n                                case internals.components.contextComment:\n                                case internals.components.contextFWS:\n                                    updateResult(internals.diagnoses.errATEXTAfterCFWS);\n                                    break;\n\n                                case internals.components.contextQuotedString:\n                                    updateResult(internals.diagnoses.errATEXTAfterQS);\n                                    break;\n\n                                    // $lab:coverage:off$\n                                default:\n                                    throw new Error('more atext found where none is allowed, but unrecognized prev context: ' + context.prev);\n                                    // $lab:coverage:on$\n                            }\n                        }\n                        else {\n                            context.prev = context.now;\n                            charCode = token.codePointAt(0);\n\n                            // Especially if charCode == 10\n                            if (internals.specials(charCode) || internals.c0Controls(charCode) || internals.c1Controls(charCode)) {\n\n                                // Fatal error\n                                updateResult(internals.diagnoses.errExpectingATEXT);\n                            }\n\n                            parseData.local += token;\n                            atomData.locals[elementCount] += token;\n                            elementLength += Buffer.byteLength(token, 'utf8');\n                        }\n                }\n\n                break;\n\n            case internals.components.domain:\n                // http://tools.ietf.org/html/rfc5322#section-3.4.1\n                //   domain          =   dot-atom / domain-literal / obs-domain\n                //\n                //   dot-atom        =   [CFWS] dot-atom-text [CFWS]\n                //\n                //   dot-atom-text   =   1*atext *(\".\" 1*atext)\n                //\n                //   domain-literal  =   [CFWS] \"[\" *([FWS] dtext) [FWS] \"]\" [CFWS]\n                //\n                //   dtext           =   %d33-90 /          ; Printable US-ASCII\n                //                       %d94-126 /         ;  characters not including\n                //                       obs-dtext          ;  \"[\", \"]\", or \"\\\"\n                //\n                //   obs-domain      =   atom *(\".\" atom)\n                //\n                //   atom            =   [CFWS] 1*atext [CFWS]\n\n                // http://tools.ietf.org/html/rfc5321#section-4.1.2\n                //   Mailbox        = Local-part \"@\" ( Domain / address-literal )\n                //\n                //   Domain         = sub-domain *(\".\" sub-domain)\n                //\n                //   address-literal  = \"[\" ( IPv4-address-literal /\n                //                    IPv6-address-literal /\n                //                    General-address-literal ) \"]\"\n                //                    ; See Section 4.1.3\n\n                // http://tools.ietf.org/html/rfc5322#section-3.4.1\n                //      Note: A liberal syntax for the domain portion of addr-spec is\n                //      given here.  However, the domain portion contains addressing\n                //      information specified by and used in other protocols (e.g.,\n                //      [RFC1034], [RFC1035], [RFC1123], [RFC5321]).  It is therefore\n                //      incumbent upon implementations to conform to the syntax of\n                //      addresses for the context in which they are used.\n                //\n                // is_email() author's note: it's not clear how to interpret this in\n                // he context of a general email address validator. The conclusion I\n                // have reached is this: \"addressing information\" must comply with\n                // RFC 5321 (and in turn RFC 1035), anything that is \"semantically\n                // invisible\" must comply only with RFC 5322.\n                switch (token) {\n                    // Comment\n                    case '(':\n                        if (elementLength === 0) {\n                            // Comments at the start of the domain are deprecated in the text, comments at the start of a subdomain are obs-domain\n                            // http://tools.ietf.org/html/rfc5322#section-3.4.1\n                            updateResult(elementCount === 0 ? internals.diagnoses.deprecatedCFWSNearAt : internals.diagnoses.deprecatedComment);\n                        }\n                        else {\n                            // We can't start a comment mid-element, better be at the end\n                            assertEnd = true;\n                            updateResult(internals.diagnoses.cfwsComment);\n                        }\n\n                        context.stack.push(context.now);\n                        context.now = internals.components.contextComment;\n                        break;\n\n                        // Next dot-atom element\n                    case '.':\n                        const punycodeLength = Punycode.toASCII(atomData.domains[elementCount]).length;\n                        if (elementLength === 0) {\n                            // Another dot, already? Fatal error.\n                            updateResult(elementCount === 0 ? internals.diagnoses.errDotStart : internals.diagnoses.errConsecutiveDots);\n                        }\n                        else if (hyphenFlag) {\n                            // Previous subdomain ended in a hyphen. Fatal error.\n                            updateResult(internals.diagnoses.errDomainHyphenEnd);\n                        }\n                        else if (punycodeLength > 63) {\n                            // RFC 5890 specifies that domain labels that are encoded using the Punycode algorithm\n                            // must adhere to the <= 63 octet requirement.\n                            // This includes string prefixes from the Punycode algorithm.\n                            //\n                            // https://tools.ietf.org/html/rfc5890#section-2.3.2.1\n                            // labels          63 octets or less\n\n                            updateResult(internals.diagnoses.rfc5322LabelTooLong);\n                        }\n\n                        // CFWS is OK again now we're at the beginning of an element (although\n                        // it may be obsolete CFWS)\n                        assertEnd = false;\n                        elementLength = 0;\n                        ++elementCount;\n                        atomData.domains[elementCount] = '';\n                        parseData.domain += token;\n\n                        break;\n\n                        // Domain literal\n                    case '[':\n                        if (atomData.domains[elementCount].length === 0) {\n                            if (parseData.domain.length) {\n                                // Domain literal interspersed with domain refs.\n                                updateResult(internals.diagnoses.errDotAfterDomainLiteral);\n                            }\n\n                            assertEnd = true;\n                            elementLength += Buffer.byteLength(token, 'utf8');\n                            context.stack.push(context.now);\n                            context.now = internals.components.literal;\n                            parseData.domain += token;\n                            atomData.domains[elementCount] += token;\n                            parseData.literal = '';\n                        }\n                        else {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errExpectingATEXT);\n                        }\n\n                        break;\n\n                        // Folding white space\n                    case '\\r':\n                        if (emailLength === ++i || email[i] !== '\\n') {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errCRNoLF);\n                            break;\n                        }\n\n                        // Fallthrough\n\n                    case ' ':\n                    case '\\t':\n                        if (elementLength === 0) {\n                            updateResult(elementCount === 0 ? internals.diagnoses.deprecatedCFWSNearAt : internals.diagnoses.deprecatedFWS);\n                        }\n                        else {\n                            // We can't start FWS in the middle of an element, so this better be the end\n                            updateResult(internals.diagnoses.cfwsFWS);\n                            assertEnd = true;\n                        }\n\n                        context.stack.push(context.now);\n                        context.now = internals.components.contextFWS;\n                        prevToken = token;\n                        break;\n\n                        // This must be ATEXT\n                    default:\n                        // RFC 5322 allows any atext...\n                        // http://tools.ietf.org/html/rfc5322#section-3.2.3\n                        //    atext = ALPHA / DIGIT / ; Printable US-ASCII\n                        //            \"!\" / \"#\" /     ;  characters not including\n                        //            \"$\" / \"%\" /     ;  specials.  Used for atoms.\n                        //            \"&\" / \"'\" /\n                        //            \"*\" / \"+\" /\n                        //            \"-\" / \"/\" /\n                        //            \"=\" / \"?\" /\n                        //            \"^\" / \"_\" /\n                        //            \"`\" / \"{\" /\n                        //            \"|\" / \"}\" /\n                        //            \"~\"\n\n                        // But RFC 5321 only allows letter-digit-hyphen to comply with DNS rules\n                        //   (RFCs 1034 & 1123)\n                        // http://tools.ietf.org/html/rfc5321#section-4.1.2\n                        //   sub-domain     = Let-dig [Ldh-str]\n                        //\n                        //   Let-dig        = ALPHA / DIGIT\n                        //\n                        //   Ldh-str        = *( ALPHA / DIGIT / \"-\" ) Let-dig\n                        //\n                        if (assertEnd) {\n                            // We have encountered ATEXT where it is no longer valid\n                            switch (context.prev) {\n                                case internals.components.contextComment:\n                                case internals.components.contextFWS:\n                                    updateResult(internals.diagnoses.errATEXTAfterCFWS);\n                                    break;\n\n                                case internals.components.literal:\n                                    updateResult(internals.diagnoses.errATEXTAfterDomainLiteral);\n                                    break;\n\n                                    // $lab:coverage:off$\n                                default:\n                                    throw new Error('more atext found where none is allowed, but unrecognized prev context: ' + context.prev);\n                                    // $lab:coverage:on$\n                            }\n                        }\n\n                        charCode = token.codePointAt(0);\n                        // Assume this token isn't a hyphen unless we discover it is\n                        hyphenFlag = false;\n\n                        if (internals.specials(charCode) || internals.c0Controls(charCode) || internals.c1Controls(charCode)) {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errExpectingATEXT);\n                        }\n                        else if (token === '-') {\n                            if (elementLength === 0) {\n                                // Hyphens cannot be at the beginning of a subdomain, fatal error\n                                updateResult(internals.diagnoses.errDomainHyphenStart);\n                            }\n\n                            hyphenFlag = true;\n                        }\n                        // Check if it's a neither a number nor a latin/unicode letter\n                        else if (charCode < 48 || (charCode > 122 && charCode < 192) || (charCode > 57 && charCode < 65) || (charCode > 90 && charCode < 97)) {\n                            // This is not an RFC 5321 subdomain, but still OK by RFC 5322\n                            updateResult(internals.diagnoses.rfc5322Domain);\n                        }\n\n                        parseData.domain += token;\n                        atomData.domains[elementCount] += token;\n                        elementLength += Buffer.byteLength(token, 'utf8');\n                }\n\n                break;\n\n                // Domain literal\n            case internals.components.literal:\n                // http://tools.ietf.org/html/rfc5322#section-3.4.1\n                //   domain-literal  =   [CFWS] \"[\" *([FWS] dtext) [FWS] \"]\" [CFWS]\n                //\n                //   dtext           =   %d33-90 /          ; Printable US-ASCII\n                //                       %d94-126 /         ;  characters not including\n                //                       obs-dtext          ;  \"[\", \"]\", or \"\\\"\n                //\n                //   obs-dtext       =   obs-NO-WS-CTL / quoted-pair\n                switch (token) {\n                    // End of domain literal\n                    case ']':\n                        if (maxResult < internals.categories.deprecated) {\n                            // Could be a valid RFC 5321 address literal, so let's check\n\n                            // http://tools.ietf.org/html/rfc5321#section-4.1.2\n                            //   address-literal  = \"[\" ( IPv4-address-literal /\n                            //                    IPv6-address-literal /\n                            //                    General-address-literal ) \"]\"\n                            //                    ; See Section 4.1.3\n                            //\n                            // http://tools.ietf.org/html/rfc5321#section-4.1.3\n                            //   IPv4-address-literal  = Snum 3(\".\"  Snum)\n                            //\n                            //   IPv6-address-literal  = \"IPv6:\" IPv6-addr\n                            //\n                            //   General-address-literal  = Standardized-tag \":\" 1*dcontent\n                            //\n                            //   Standardized-tag  = Ldh-str\n                            //                     ; Standardized-tag MUST be specified in a\n                            //                     ; Standards-Track RFC and registered with IANA\n                            //\n                            //   dcontent      = %d33-90 / ; Printable US-ASCII\n                            //                 %d94-126 ; excl. \"[\", \"\\\", \"]\"\n                            //\n                            //   Snum          = 1*3DIGIT\n                            //                 ; representing a decimal integer\n                            //                 ; value in the range 0 through 255\n                            //\n                            //   IPv6-addr     = IPv6-full / IPv6-comp / IPv6v4-full / IPv6v4-comp\n                            //\n                            //   IPv6-hex      = 1*4HEXDIG\n                            //\n                            //   IPv6-full     = IPv6-hex 7(\":\" IPv6-hex)\n                            //\n                            //   IPv6-comp     = [IPv6-hex *5(\":\" IPv6-hex)] \"::\"\n                            //                 [IPv6-hex *5(\":\" IPv6-hex)]\n                            //                 ; The \"::\" represents at least 2 16-bit groups of\n                            //                 ; zeros.  No more than 6 groups in addition to the\n                            //                 ; \"::\" may be present.\n                            //\n                            //   IPv6v4-full   = IPv6-hex 5(\":\" IPv6-hex) \":\" IPv4-address-literal\n                            //\n                            //   IPv6v4-comp   = [IPv6-hex *3(\":\" IPv6-hex)] \"::\"\n                            //                 [IPv6-hex *3(\":\" IPv6-hex) \":\"]\n                            //                 IPv4-address-literal\n                            //                 ; The \"::\" represents at least 2 16-bit groups of\n                            //                 ; zeros.  No more than 4 groups in addition to the\n                            //                 ; \"::\" and IPv4-address-literal may be present.\n\n                            let index = -1;\n                            let addressLiteral = parseData.literal;\n                            const matchesIP = internals.regex.ipV4.exec(addressLiteral);\n\n                            // Maybe extract IPv4 part from the end of the address-literal\n                            if (matchesIP) {\n                                index = matchesIP.index;\n                                if (index !== 0) {\n                                    // Convert IPv4 part to IPv6 format for futher testing\n                                    addressLiteral = addressLiteral.slice(0, index) + '0:0';\n                                }\n                            }\n\n                            if (index === 0) {\n                                // Nothing there except a valid IPv4 address, so...\n                                updateResult(internals.diagnoses.rfc5321AddressLiteral);\n                            }\n                            else if (addressLiteral.slice(0, 5).toLowerCase() !== 'ipv6:') {\n                                updateResult(internals.diagnoses.rfc5322DomainLiteral);\n                            }\n                            else {\n                                const match = addressLiteral.slice(5);\n                                let maxGroups = internals.maxIPv6Groups;\n                                const groups = match.split(':');\n                                index = match.indexOf('::');\n\n                                if (!~index) {\n                                    // Need exactly the right number of groups\n                                    if (groups.length !== maxGroups) {\n                                        updateResult(internals.diagnoses.rfc5322IPv6GroupCount);\n                                    }\n                                }\n                                else if (index !== match.lastIndexOf('::')) {\n                                    updateResult(internals.diagnoses.rfc5322IPv62x2xColon);\n                                }\n                                else {\n                                    if (index === 0 || index === match.length - 2) {\n                                        // RFC 4291 allows :: at the start or end of an address with 7 other groups in addition\n                                        ++maxGroups;\n                                    }\n\n                                    if (groups.length > maxGroups) {\n                                        updateResult(internals.diagnoses.rfc5322IPv6MaxGroups);\n                                    }\n                                    else if (groups.length === maxGroups) {\n                                        // Eliding a single \"::\"\n                                        updateResult(internals.diagnoses.deprecatedIPv6);\n                                    }\n                                }\n\n                                // IPv6 testing strategy\n                                if (match[0] === ':' && match[1] !== ':') {\n                                    updateResult(internals.diagnoses.rfc5322IPv6ColonStart);\n                                }\n                                else if (match[match.length - 1] === ':' && match[match.length - 2] !== ':') {\n                                    updateResult(internals.diagnoses.rfc5322IPv6ColonEnd);\n                                }\n                                else if (internals.checkIpV6(groups)) {\n                                    updateResult(internals.diagnoses.rfc5321AddressLiteral);\n                                }\n                                else {\n                                    updateResult(internals.diagnoses.rfc5322IPv6BadCharacter);\n                                }\n                            }\n                        }\n                        else {\n                            updateResult(internals.diagnoses.rfc5322DomainLiteral);\n                        }\n\n                        parseData.domain += token;\n                        atomData.domains[elementCount] += token;\n                        elementLength += Buffer.byteLength(token, 'utf8');\n                        context.prev = context.now;\n                        context.now = context.stack.pop();\n                        break;\n\n                    case '\\\\':\n                        updateResult(internals.diagnoses.rfc5322DomainLiteralOBSDText);\n                        context.stack.push(context.now);\n                        context.now = internals.components.contextQuotedPair;\n                        break;\n\n                        // Folding white space\n                    case '\\r':\n                        if (emailLength === ++i || email[i] !== '\\n') {\n                            updateResult(internals.diagnoses.errCRNoLF);\n                            break;\n                        }\n\n                        // Fallthrough\n\n                    case ' ':\n                    case '\\t':\n                        updateResult(internals.diagnoses.cfwsFWS);\n\n                        context.stack.push(context.now);\n                        context.now = internals.components.contextFWS;\n                        prevToken = token;\n                        break;\n\n                        // DTEXT\n                    default:\n                        // http://tools.ietf.org/html/rfc5322#section-3.4.1\n                        //   dtext         =   %d33-90 /  ; Printable US-ASCII\n                        //                     %d94-126 / ;  characters not including\n                        //                     obs-dtext  ;  \"[\", \"]\", or \"\\\"\n                        //\n                        //   obs-dtext     =   obs-NO-WS-CTL / quoted-pair\n                        //\n                        //   obs-NO-WS-CTL =   %d1-8 /    ; US-ASCII control\n                        //                     %d11 /     ;  characters that do not\n                        //                     %d12 /     ;  include the carriage\n                        //                     %d14-31 /  ;  return, line feed, and\n                        //                     %d127      ;  white space characters\n                        charCode = token.codePointAt(0);\n\n                        // '\\r', '\\n', ' ', and '\\t' have already been parsed above\n                        if ((charCode !== 127 && internals.c1Controls(charCode)) || charCode === 0 || token === '[') {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errExpectingDTEXT);\n                            break;\n                        }\n                        else if (internals.c0Controls(charCode) || charCode === 127) {\n                            updateResult(internals.diagnoses.rfc5322DomainLiteralOBSDText);\n                        }\n\n                        parseData.literal += token;\n                        parseData.domain += token;\n                        atomData.domains[elementCount] += token;\n                        elementLength += Buffer.byteLength(token, 'utf8');\n                }\n\n                break;\n\n                // Quoted string\n            case internals.components.contextQuotedString:\n                // http://tools.ietf.org/html/rfc5322#section-3.2.4\n                //   quoted-string = [CFWS]\n                //                   DQUOTE *([FWS] qcontent) [FWS] DQUOTE\n                //                   [CFWS]\n                //\n                //   qcontent      = qtext / quoted-pair\n                switch (token) {\n                    // Quoted pair\n                    case '\\\\':\n                        context.stack.push(context.now);\n                        context.now = internals.components.contextQuotedPair;\n                        break;\n\n                        // Folding white space. Spaces are allowed as regular characters inside a quoted string - it's only FWS if we include '\\t' or '\\r\\n'\n                    case '\\r':\n                        if (emailLength === ++i || email[i] !== '\\n') {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errCRNoLF);\n                            break;\n                        }\n\n                        // Fallthrough\n\n                    case '\\t':\n                        // http://tools.ietf.org/html/rfc5322#section-3.2.2\n                        //   Runs of FWS, comment, or CFWS that occur between lexical tokens in\n                        //   a structured header field are semantically interpreted as a single\n                        //   space character.\n\n                        // http://tools.ietf.org/html/rfc5322#section-3.2.4\n                        //   the CRLF in any FWS/CFWS that appears within the quoted-string [is]\n                        //   semantically \"invisible\" and therefore not part of the\n                        //   quoted-string\n\n                        parseData.local += ' ';\n                        atomData.locals[elementCount] += ' ';\n                        elementLength += Buffer.byteLength(token, 'utf8');\n\n                        updateResult(internals.diagnoses.cfwsFWS);\n                        context.stack.push(context.now);\n                        context.now = internals.components.contextFWS;\n                        prevToken = token;\n                        break;\n\n                        // End of quoted string\n                    case '\"':\n                        parseData.local += token;\n                        atomData.locals[elementCount] += token;\n                        elementLength += Buffer.byteLength(token, 'utf8');\n                        context.prev = context.now;\n                        context.now = context.stack.pop();\n                        break;\n\n                        // QTEXT\n                    default:\n                        // http://tools.ietf.org/html/rfc5322#section-3.2.4\n                        //   qtext          =   %d33 /             ; Printable US-ASCII\n                        //                      %d35-91 /          ;  characters not including\n                        //                      %d93-126 /         ;  \"\\\" or the quote character\n                        //                      obs-qtext\n                        //\n                        //   obs-qtext      =   obs-NO-WS-CTL\n                        //\n                        //   obs-NO-WS-CTL  =   %d1-8 /            ; US-ASCII control\n                        //                      %d11 /             ;  characters that do not\n                        //                      %d12 /             ;  include the carriage\n                        //                      %d14-31 /          ;  return, line feed, and\n                        //                      %d127              ;  white space characters\n                        charCode = token.codePointAt(0);\n\n                        if ((charCode !== 127 && internals.c1Controls(charCode)) || charCode === 0 || charCode === 10) {\n                            updateResult(internals.diagnoses.errExpectingQTEXT);\n                        }\n                        else if (internals.c0Controls(charCode) || charCode === 127) {\n                            updateResult(internals.diagnoses.deprecatedQTEXT);\n                        }\n\n                        parseData.local += token;\n                        atomData.locals[elementCount] += token;\n                        elementLength += Buffer.byteLength(token, 'utf8');\n                }\n\n                // http://tools.ietf.org/html/rfc5322#section-3.4.1\n                //   If the string can be represented as a dot-atom (that is, it contains\n                //   no characters other than atext characters or \".\" surrounded by atext\n                //   characters), then the dot-atom form SHOULD be used and the quoted-\n                //   string form SHOULD NOT be used.\n\n                break;\n                // Quoted pair\n            case internals.components.contextQuotedPair:\n                // http://tools.ietf.org/html/rfc5322#section-3.2.1\n                //   quoted-pair     =   (\"\\\" (VCHAR / WSP)) / obs-qp\n                //\n                //   VCHAR           =  %d33-126   ; visible (printing) characters\n                //   WSP             =  SP / HTAB  ; white space\n                //\n                //   obs-qp          =   \"\\\" (%d0 / obs-NO-WS-CTL / LF / CR)\n                //\n                //   obs-NO-WS-CTL   =   %d1-8 /   ; US-ASCII control\n                //                       %d11 /    ;  characters that do not\n                //                       %d12 /    ;  include the carriage\n                //                       %d14-31 / ;  return, line feed, and\n                //                       %d127     ;  white space characters\n                //\n                // i.e. obs-qp       =  \"\\\" (%d0-8, %d10-31 / %d127)\n                charCode = token.codePointAt(0);\n\n                if (charCode !== 127 &&  internals.c1Controls(charCode)) {\n                    // Fatal error\n                    updateResult(internals.diagnoses.errExpectingQPair);\n                }\n                else if ((charCode < 31 && charCode !== 9) || charCode === 127) {\n                    // ' ' and '\\t' are allowed\n                    updateResult(internals.diagnoses.deprecatedQP);\n                }\n\n                // At this point we know where this qpair occurred so we could check to see if the character actually needed to be quoted at all.\n                // http://tools.ietf.org/html/rfc5321#section-4.1.2\n                //   the sending system SHOULD transmit the form that uses the minimum quoting possible.\n\n                context.prev = context.now;\n                // End of qpair\n                context.now = context.stack.pop();\n                const escapeToken = '\\\\' + token;\n\n                switch (context.now) {\n                    case internals.components.contextComment:\n                        break;\n\n                    case internals.components.contextQuotedString:\n                        parseData.local += escapeToken;\n                        atomData.locals[elementCount] += escapeToken;\n\n                        // The maximum sizes specified by RFC 5321 are octet counts, so we must include the backslash\n                        elementLength += 2;\n                        break;\n\n                    case internals.components.literal:\n                        parseData.domain += escapeToken;\n                        atomData.domains[elementCount] += escapeToken;\n\n                        // The maximum sizes specified by RFC 5321 are octet counts, so we must include the backslash\n                        elementLength += 2;\n                        break;\n\n                        // $lab:coverage:off$\n                    default:\n                        throw new Error('quoted pair logic invoked in an invalid context: ' + context.now);\n                        // $lab:coverage:on$\n                }\n\n                break;\n\n                // Comment\n            case internals.components.contextComment:\n                // http://tools.ietf.org/html/rfc5322#section-3.2.2\n                //   comment  = \"(\" *([FWS] ccontent) [FWS] \")\"\n                //\n                //   ccontent = ctext / quoted-pair / comment\n                switch (token) {\n                    // Nested comment\n                    case '(':\n                        // Nested comments are ok\n                        context.stack.push(context.now);\n                        context.now = internals.components.contextComment;\n                        break;\n\n                        // End of comment\n                    case ')':\n                        context.prev = context.now;\n                        context.now = context.stack.pop();\n                        break;\n\n                        // Quoted pair\n                    case '\\\\':\n                        context.stack.push(context.now);\n                        context.now = internals.components.contextQuotedPair;\n                        break;\n\n                        // Folding white space\n                    case '\\r':\n                        if (emailLength === ++i || email[i] !== '\\n') {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errCRNoLF);\n                            break;\n                        }\n\n                        // Fallthrough\n\n                    case ' ':\n                    case '\\t':\n                        updateResult(internals.diagnoses.cfwsFWS);\n\n                        context.stack.push(context.now);\n                        context.now = internals.components.contextFWS;\n                        prevToken = token;\n                        break;\n\n                        // CTEXT\n                    default:\n                        // http://tools.ietf.org/html/rfc5322#section-3.2.3\n                        //   ctext         = %d33-39 /  ; Printable US-ASCII\n                        //                   %d42-91 /  ;  characters not including\n                        //                   %d93-126 / ;  \"(\", \")\", or \"\\\"\n                        //                   obs-ctext\n                        //\n                        //   obs-ctext     = obs-NO-WS-CTL\n                        //\n                        //   obs-NO-WS-CTL = %d1-8 /    ; US-ASCII control\n                        //                   %d11 /     ;  characters that do not\n                        //                   %d12 /     ;  include the carriage\n                        //                   %d14-31 /  ;  return, line feed, and\n                        //                   %d127      ;  white space characters\n                        charCode = token.codePointAt(0);\n\n                        if (charCode === 0 || charCode === 10 || (charCode !== 127 && internals.c1Controls(charCode))) {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errExpectingCTEXT);\n                            break;\n                        }\n                        else if (internals.c0Controls(charCode) || charCode === 127) {\n                            updateResult(internals.diagnoses.deprecatedCTEXT);\n                        }\n                }\n\n                break;\n\n                // Folding white space\n            case internals.components.contextFWS:\n                // http://tools.ietf.org/html/rfc5322#section-3.2.2\n                //   FWS     =   ([*WSP CRLF] 1*WSP) /  obs-FWS\n                //                                   ; Folding white space\n\n                // But note the erratum:\n                // http://www.rfc-editor.org/errata_search.php?rfc=5322&eid=1908:\n                //   In the obsolete syntax, any amount of folding white space MAY be\n                //   inserted where the obs-FWS rule is allowed.  This creates the\n                //   possibility of having two consecutive \"folds\" in a line, and\n                //   therefore the possibility that a line which makes up a folded header\n                //   field could be composed entirely of white space.\n                //\n                //   obs-FWS =   1*([CRLF] WSP)\n\n                if (prevToken === '\\r') {\n                    if (token === '\\r') {\n                        // Fatal error\n                        updateResult(internals.diagnoses.errFWSCRLFx2);\n                        break;\n                    }\n\n                    if (++crlfCount > 1) {\n                        // Multiple folds => obsolete FWS\n                        updateResult(internals.diagnoses.deprecatedFWS);\n                    }\n                    else {\n                        crlfCount = 1;\n                    }\n                }\n\n                switch (token) {\n                    case '\\r':\n                        if (emailLength === ++i || email[i] !== '\\n') {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errCRNoLF);\n                        }\n\n                        break;\n\n                    case ' ':\n                    case '\\t':\n                        break;\n\n                    default:\n                        if (prevToken === '\\r') {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errFWSCRLFEnd);\n                        }\n\n                        crlfCount = 0;\n\n                        // End of FWS\n                        context.prev = context.now;\n                        context.now = context.stack.pop();\n\n                        // Look at this token again in the parent context\n                        --i;\n                }\n\n                prevToken = token;\n                break;\n\n                // Unexpected context\n                // $lab:coverage:off$\n            default:\n                throw new Error('unknown context: ' + context.now);\n                // $lab:coverage:on$\n        } // Primary state machine\n\n        if (maxResult > internals.categories.rfc5322) {\n            // Fatal error, no point continuing\n            break;\n        }\n    } // Token loop\n\n    // Check for errors\n    if (maxResult < internals.categories.rfc5322) {\n        const punycodeLength = Punycode.toASCII(parseData.domain).length;\n        // Fatal errors\n        if (context.now === internals.components.contextQuotedString) {\n            updateResult(internals.diagnoses.errUnclosedQuotedString);\n        }\n        else if (context.now === internals.components.contextQuotedPair) {\n            updateResult(internals.diagnoses.errBackslashEnd);\n        }\n        else if (context.now === internals.components.contextComment) {\n            updateResult(internals.diagnoses.errUnclosedComment);\n        }\n        else if (context.now === internals.components.literal) {\n            updateResult(internals.diagnoses.errUnclosedDomainLiteral);\n        }\n        else if (token === '\\r') {\n            updateResult(internals.diagnoses.errFWSCRLFEnd);\n        }\n        else if (parseData.domain.length === 0) {\n            updateResult(internals.diagnoses.errNoDomain);\n        }\n        else if (elementLength === 0) {\n            updateResult(internals.diagnoses.errDotEnd);\n        }\n        else if (hyphenFlag) {\n            updateResult(internals.diagnoses.errDomainHyphenEnd);\n        }\n\n        // Other errors\n        else if (punycodeLength > 255) {\n            // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.2\n            //   The maximum total length of a domain name or number is 255 octets.\n            updateResult(internals.diagnoses.rfc5322DomainTooLong);\n        }\n        else if (Buffer.byteLength(parseData.local, 'utf8') + punycodeLength + /* '@' */ 1 > 254) {\n            // http://tools.ietf.org/html/rfc5321#section-4.1.2\n            //   Forward-path   = Path\n            //\n            //   Path           = \"<\" [ A-d-l \":\" ] Mailbox \">\"\n            //\n            // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.3\n            //   The maximum total length of a reverse-path or forward-path is 256 octets (including the punctuation and element separators).\n            //\n            // Thus, even without (obsolete) routing information, the Mailbox can only be 254 characters long. This is confirmed by this verified\n            // erratum to RFC 3696:\n            //\n            // http://www.rfc-editor.org/errata_search.php?rfc=3696&eid=1690\n            //   However, there is a restriction in RFC 2821 on the length of an address in MAIL and RCPT commands of 254 characters.  Since\n            //   addresses that do not fit in those fields are not normally useful, the upper limit on address lengths should normally be considered\n            //   to be 254.\n            updateResult(internals.diagnoses.rfc5322TooLong);\n        }\n        else if (elementLength > 63) {\n            // http://tools.ietf.org/html/rfc1035#section-2.3.4\n            // labels   63 octets or less\n            updateResult(internals.diagnoses.rfc5322LabelTooLong);\n        }\n        else if (options.minDomainAtoms && atomData.domains.length < options.minDomainAtoms && (atomData.domains.length !== 1 || atomData.domains[0][0] !== '[')) {\n            updateResult(internals.diagnoses.errDomainTooShort);\n        }\n        else if (internals.hasDomainLiteralThenAtom(atomData.domains)) {\n            updateResult(internals.diagnoses.errDotAfterDomainLiteral);\n        }\n        else if (options.tldWhitelist || options.tldBlacklist) {\n            const tldAtom = atomData.domains[elementCount];\n\n            if (!internals.validDomain(tldAtom, options)) {\n                updateResult(internals.diagnoses.errUnknownTLD);\n            }\n        }\n    } // Check for errors\n\n    // Finish\n    if (maxResult < internals.categories.dnsWarn) {\n        // Per RFC 5321, domain atoms are limited to letter-digit-hyphen, so we only need to check code <= 57 to check for a digit\n        const code = atomData.domains[elementCount].codePointAt(0);\n\n        if (code <= 57) {\n            updateResult(internals.diagnoses.rfc5321TLDNumeric);\n        }\n    }\n\n    if (maxResult < threshold) {\n        maxResult = internals.diagnoses.valid;\n    }\n\n    const finishResult = diagnose ? maxResult : maxResult < internals.defaultThreshold;\n\n    // $lab:coverage:off$\n    if (callback) {\n        callback(finishResult);\n    }\n    // $lab:coverage:on$\n\n    return finishResult;\n};\n\n\nexports.diagnoses = internals.validate.diagnoses = (function () {\n\n    const diag = {};\n    const keys = Object.keys(internals.diagnoses);\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        diag[key] = internals.diagnoses[key];\n    }\n\n    return diag;\n})();\n\n\nexports.normalize = internals.normalize;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}
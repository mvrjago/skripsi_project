{"ast":null,"code":"/**\n * @module ol/geom/flat/textpath\n */\nimport { lerp } from '../../math.js';\nimport { rotate } from './transform.js';\n/**\n * @param {Array<number>} flatCoordinates Path to put text on.\n * @param {number} offset Start offset of the `flatCoordinates`.\n * @param {number} end End offset of the `flatCoordinates`.\n * @param {number} stride Stride.\n * @param {string} text Text to place on the path.\n * @param {number} startM m along the path where the text starts.\n * @param {number} maxAngle Max angle between adjacent chars in radians.\n * @param {number} scale The product of the text scale and the device pixel ratio.\n * @param {function(string, string, Object<string, number>):number} measureAndCacheTextWidth Measure and cache text width.\n * @param {string} font The font.\n * @param {Object<string, number>} cache A cache of measured widths.\n * @param {number} rotation Rotation to apply to the flatCoordinates to determine whether text needs to be reversed.\n * @return {Array<Array<*>>} The result array (or null if `maxAngle` was\n * exceeded). Entries of the array are x, y, anchorX, angle, chunk.\n */\nexport function drawTextOnPath(flatCoordinates, offset, end, stride, text, startM, maxAngle, scale, measureAndCacheTextWidth, font, cache, rotation) {\n  var result = [];\n  // Keep text upright\n  var reverse;\n  if (rotation) {\n    var rotatedCoordinates = rotate(flatCoordinates, offset, end, stride, rotation, [flatCoordinates[offset], flatCoordinates[offset + 1]]);\n    reverse = rotatedCoordinates[0] > rotatedCoordinates[rotatedCoordinates.length - stride];\n  } else {\n    reverse = flatCoordinates[offset] > flatCoordinates[end - stride];\n  }\n  var numChars = text.length;\n  var x1 = flatCoordinates[offset];\n  var y1 = flatCoordinates[offset + 1];\n  offset += stride;\n  var x2 = flatCoordinates[offset];\n  var y2 = flatCoordinates[offset + 1];\n  var segmentM = 0;\n  var segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n  var angleChanged = false;\n  var index, previousAngle;\n  for (var i = 0; i < numChars; ++i) {\n    index = reverse ? numChars - i - 1 : i;\n    var char = text[index];\n    var charLength = scale * measureAndCacheTextWidth(font, char, cache);\n    var charM = startM + charLength / 2;\n    while (offset < end - stride && segmentM + segmentLength < charM) {\n      x1 = x2;\n      y1 = y2;\n      offset += stride;\n      x2 = flatCoordinates[offset];\n      y2 = flatCoordinates[offset + 1];\n      segmentM += segmentLength;\n      segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n    }\n    var segmentPos = charM - segmentM;\n    var angle = Math.atan2(y2 - y1, x2 - x1);\n    if (reverse) {\n      angle += angle > 0 ? -Math.PI : Math.PI;\n    }\n    if (previousAngle !== undefined) {\n      var delta = angle - previousAngle;\n      angleChanged = angleChanged || delta !== 0;\n      delta += delta > Math.PI ? -2 * Math.PI : delta < -Math.PI ? 2 * Math.PI : 0;\n      if (Math.abs(delta) > maxAngle) {\n        return null;\n      }\n    }\n    previousAngle = angle;\n    var interpolate = segmentPos / segmentLength;\n    var x = lerp(x1, x2, interpolate);\n    var y = lerp(y1, y2, interpolate);\n    result[index] = [x, y, charLength / 2, angle, char];\n    startM += charLength;\n  }\n  return angleChanged ? result : [[result[0][0], result[0][1], result[0][2], result[0][3], text]];\n}","map":{"version":3,"names":["lerp","rotate","drawTextOnPath","flatCoordinates","offset","end","stride","text","startM","maxAngle","scale","measureAndCacheTextWidth","font","cache","rotation","result","reverse","rotatedCoordinates","length","numChars","x1","y1","x2","y2","segmentM","segmentLength","Math","sqrt","pow","angleChanged","index","previousAngle","i","char","charLength","charM","segmentPos","angle","atan2","PI","undefined","delta","abs","interpolate","x","y"],"sources":["/Users/mariovicky/Skripsi_OpenLayers/node_modules/ol/src/geom/flat/textpath.js"],"sourcesContent":["/**\n * @module ol/geom/flat/textpath\n */\nimport {lerp} from '../../math.js';\nimport {rotate} from './transform.js';\n\n/**\n * @param {Array<number>} flatCoordinates Path to put text on.\n * @param {number} offset Start offset of the `flatCoordinates`.\n * @param {number} end End offset of the `flatCoordinates`.\n * @param {number} stride Stride.\n * @param {string} text Text to place on the path.\n * @param {number} startM m along the path where the text starts.\n * @param {number} maxAngle Max angle between adjacent chars in radians.\n * @param {number} scale The product of the text scale and the device pixel ratio.\n * @param {function(string, string, Object<string, number>):number} measureAndCacheTextWidth Measure and cache text width.\n * @param {string} font The font.\n * @param {Object<string, number>} cache A cache of measured widths.\n * @param {number} rotation Rotation to apply to the flatCoordinates to determine whether text needs to be reversed.\n * @return {Array<Array<*>>} The result array (or null if `maxAngle` was\n * exceeded). Entries of the array are x, y, anchorX, angle, chunk.\n */\nexport function drawTextOnPath(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  text,\n  startM,\n  maxAngle,\n  scale,\n  measureAndCacheTextWidth,\n  font,\n  cache,\n  rotation\n) {\n  const result = [];\n\n  // Keep text upright\n  let reverse;\n  if (rotation) {\n    const rotatedCoordinates = rotate(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      rotation,\n      [flatCoordinates[offset], flatCoordinates[offset + 1]]\n    );\n    reverse =\n      rotatedCoordinates[0] >\n      rotatedCoordinates[rotatedCoordinates.length - stride];\n  } else {\n    reverse = flatCoordinates[offset] > flatCoordinates[end - stride];\n  }\n\n  const numChars = text.length;\n\n  let x1 = flatCoordinates[offset];\n  let y1 = flatCoordinates[offset + 1];\n  offset += stride;\n  let x2 = flatCoordinates[offset];\n  let y2 = flatCoordinates[offset + 1];\n  let segmentM = 0;\n  let segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n  let angleChanged = false;\n\n  let index, previousAngle;\n  for (let i = 0; i < numChars; ++i) {\n    index = reverse ? numChars - i - 1 : i;\n    const char = text[index];\n    const charLength = scale * measureAndCacheTextWidth(font, char, cache);\n    const charM = startM + charLength / 2;\n    while (offset < end - stride && segmentM + segmentLength < charM) {\n      x1 = x2;\n      y1 = y2;\n      offset += stride;\n      x2 = flatCoordinates[offset];\n      y2 = flatCoordinates[offset + 1];\n      segmentM += segmentLength;\n      segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n    }\n    const segmentPos = charM - segmentM;\n    let angle = Math.atan2(y2 - y1, x2 - x1);\n    if (reverse) {\n      angle += angle > 0 ? -Math.PI : Math.PI;\n    }\n    if (previousAngle !== undefined) {\n      let delta = angle - previousAngle;\n      angleChanged = angleChanged || delta !== 0;\n      delta +=\n        delta > Math.PI ? -2 * Math.PI : delta < -Math.PI ? 2 * Math.PI : 0;\n      if (Math.abs(delta) > maxAngle) {\n        return null;\n      }\n    }\n    previousAngle = angle;\n    const interpolate = segmentPos / segmentLength;\n    const x = lerp(x1, x2, interpolate);\n    const y = lerp(y1, y2, interpolate);\n    result[index] = [x, y, charLength / 2, angle, char];\n    startM += charLength;\n  }\n  return angleChanged\n    ? result\n    : [[result[0][0], result[0][1], result[0][2], result[0][3], text]];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/renderer/webgl/PointsLayer\n */\nimport BaseVector from '../../layer/BaseVector.js';\nimport GeometryType from '../../geom/GeometryType.js';\nimport VectorEventType from '../../source/VectorEventType.js';\nimport ViewHint from '../../ViewHint.js';\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport WebGLLayerRenderer, { WebGLWorkerMessageType, colorDecodeId, colorEncodeId } from './Layer.js';\nimport WebGLRenderTarget from '../../webgl/RenderTarget.js';\nimport { ARRAY_BUFFER, DYNAMIC_DRAW, ELEMENT_ARRAY_BUFFER } from '../../webgl.js';\nimport { AttributeType, DefaultUniform } from '../../webgl/Helper.js';\nimport { apply as applyTransform, create as createTransform, makeInverse as makeInverseTransform, multiply as multiplyTransform } from '../../transform.js';\nimport { assert } from '../../asserts.js';\nimport { buffer, createEmpty, equals } from '../../extent.js';\nimport { create as createWebGLWorker } from '../../worker/webgl.js';\nimport { getUid } from '../../util.js';\nimport { listen, unlistenByKey } from '../../events.js';\n/**\n * @typedef {Object} CustomAttribute A description of a custom attribute to be passed on to the GPU, with a value different\n * for each feature.\n * @property {string} name Attribute name.\n * @property {function(import(\"../../Feature\").default, Object<string, *>):number} callback This callback computes the numerical value of the\n * attribute for a given feature (properties are available as 2nd arg for quicker access).\n */\n/**\n * @typedef {Object} FeatureCacheItem Object that holds a reference to a feature, its geometry and properties. Used to optimize\n * rebuildBuffers by accessing these objects quicker.\n * @property {import(\"../../Feature\").default} feature Feature\n * @property {Object<string, *>} properties Feature properties\n * @property {import(\"../../geom\").Geometry} geometry Feature geometry\n */\n/**\n * @typedef {Object} Options\n * @property {Array<CustomAttribute>} [attributes] These attributes will be read from the features in the source and then\n * passed to the GPU. The `name` property of each attribute will serve as its identifier:\n *  * In the vertex shader as an `attribute` by prefixing it with `a_`\n *  * In the fragment shader as a `varying` by prefixing it with `v_`\n * Please note that these can only be numerical values.\n * @property {string} vertexShader Vertex shader source, mandatory.\n * @property {string} fragmentShader Fragment shader source, mandatory.\n * @property {string} [hitVertexShader] Vertex shader source for hit detection rendering.\n * @property {string} [hitFragmentShader] Fragment shader source for hit detection rendering.\n * @property {Object.<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * Please note that `u_texture` is reserved for the main texture slot.\n * @property {Array<import(\"./Layer\").PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n/**\n * @classdesc\n * WebGL vector renderer optimized for points.\n * All features will be rendered as quads (two triangles forming a square). New data will be flushed to the GPU\n * every time the vector source changes.\n *\n * You need to provide vertex and fragment shaders for rendering. This can be done using\n * {@link module:ol/webgl/ShaderBuilder} utilities. These shaders shall expect a `a_position` attribute\n * containing the screen-space projected center of the quad, as well as a `a_index` attribute\n * whose value (0, 1, 2 or 3) indicates which quad vertex is currently getting processed (see structure below).\n *\n * To include variable attributes in the shaders, you need to declare them using the `attributes` property of\n * the options object like so:\n * ```js\n * new WebGLPointsLayerRenderer(layer, {\n *   attributes: [\n *     {\n *       name: 'size',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *     {\n *       name: 'weight',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *   ],\n *   vertexShader:\n *     // shader using attribute a_weight and a_size\n *   fragmentShader:\n *     // shader using varying v_weight and v_size\n * ```\n *\n * To enable hit detection, you must as well provide dedicated shaders using the `hitVertexShader`\n * and `hitFragmentShader` properties. These shall expect the `a_hitColor` attribute to contain\n * the final color that will have to be output for hit detection to work.\n *\n * The following uniform is used for the main texture: `u_texture`.\n *\n * Please note that the main shader output should have premultiplied alpha, otherwise visual anomalies may occur.\n *\n * Points are rendered as quads with the following structure:\n *\n * ```\n *   (u0, v1)      (u1, v1)\n *  [3]----------[2]\n *   |`           |\n *   |  `         |\n *   |    `       |\n *   |      `     |\n *   |        `   |\n *   |          ` |\n *  [0]----------[1]\n *   (u0, v0)      (u1, v0)\n *  ```\n *\n * This uses {@link module:ol/webgl/Helper~WebGLHelper} internally.\n *\n * @api\n */\nvar WebGLPointsLayerRenderer = /** @class */function (_super) {\n  __extends(WebGLPointsLayerRenderer, _super);\n  /**\n   * @param {import(\"../../layer/Layer.js\").default} layer Layer.\n   * @param {Options} options Options.\n   */\n  function WebGLPointsLayerRenderer(layer, options) {\n    var _this = this;\n    var uniforms = options.uniforms || {};\n    var projectionMatrixTransform = createTransform();\n    uniforms[DefaultUniform.PROJECTION_MATRIX] = projectionMatrixTransform;\n    _this = _super.call(this, layer, {\n      uniforms: uniforms,\n      postProcesses: options.postProcesses\n    }) || this;\n    _this.sourceRevision_ = -1;\n    _this.verticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);\n    _this.hitVerticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);\n    _this.indicesBuffer_ = new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER, DYNAMIC_DRAW);\n    _this.program_ = _this.helper.getProgram(options.fragmentShader, options.vertexShader);\n    /**\n     * @type {boolean}\n     * @private\n     */\n    _this.hitDetectionEnabled_ = options.hitFragmentShader && options.hitVertexShader ? true : false;\n    _this.hitProgram_ = _this.hitDetectionEnabled_ && _this.helper.getProgram(options.hitFragmentShader, options.hitVertexShader);\n    var customAttributes = options.attributes ? options.attributes.map(function (attribute) {\n      return {\n        name: 'a_' + attribute.name,\n        size: 1,\n        type: AttributeType.FLOAT\n      };\n    }) : [];\n    /**\n     * A list of attributes used by the renderer. By default only the position and\n     * index of the vertex (0 to 3) are required.\n     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n     */\n    _this.attributes = [{\n      name: 'a_position',\n      size: 2,\n      type: AttributeType.FLOAT\n    }, {\n      name: 'a_index',\n      size: 1,\n      type: AttributeType.FLOAT\n    }].concat(customAttributes);\n    /**\n     * A list of attributes used for hit detection.\n     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n     */\n    _this.hitDetectionAttributes = [{\n      name: 'a_position',\n      size: 2,\n      type: AttributeType.FLOAT\n    }, {\n      name: 'a_index',\n      size: 1,\n      type: AttributeType.FLOAT\n    }, {\n      name: 'a_hitColor',\n      size: 4,\n      type: AttributeType.FLOAT\n    }, {\n      name: 'a_featureUid',\n      size: 1,\n      type: AttributeType.FLOAT\n    }].concat(customAttributes);\n    _this.customAttributes = options.attributes ? options.attributes : [];\n    _this.previousExtent_ = createEmpty();\n    /**\n     * This transform is updated on every frame and is the composition of:\n     * - invert of the world->screen transform that was used when rebuilding buffers (see `this.renderTransform_`)\n     * - current world->screen transform\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    _this.currentTransform_ = projectionMatrixTransform;\n    /**\n     * This transform is updated when buffers are rebuilt and converts world space coordinates to screen space\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    _this.renderTransform_ = createTransform();\n    /**\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    _this.invertRenderTransform_ = createTransform();\n    /**\n     * @type {Float32Array}\n     * @private\n     */\n    _this.renderInstructions_ = new Float32Array(0);\n    /**\n     * These instructions are used for hit detection\n     * @type {Float32Array}\n     * @private\n     */\n    _this.hitRenderInstructions_ = new Float32Array(0);\n    /**\n     * @type {WebGLRenderTarget}\n     * @private\n     */\n    _this.hitRenderTarget_ = _this.hitDetectionEnabled_ && new WebGLRenderTarget(_this.helper);\n    _this.worker_ = createWebGLWorker();\n    _this.worker_.addEventListener('message', function (event) {\n      var received = event.data;\n      if (received.type === WebGLWorkerMessageType.GENERATE_BUFFERS) {\n        var projectionTransform = received.projectionTransform;\n        if (received.hitDetection) {\n          this.hitVerticesBuffer_.fromArrayBuffer(received.vertexBuffer);\n          this.helper.flushBufferData(this.hitVerticesBuffer_);\n        } else {\n          this.verticesBuffer_.fromArrayBuffer(received.vertexBuffer);\n          this.helper.flushBufferData(this.verticesBuffer_);\n        }\n        this.indicesBuffer_.fromArrayBuffer(received.indexBuffer);\n        this.helper.flushBufferData(this.indicesBuffer_);\n        this.renderTransform_ = projectionTransform;\n        makeInverseTransform(this.invertRenderTransform_, this.renderTransform_);\n        if (received.hitDetection) {\n          this.hitRenderInstructions_ = new Float32Array(event.data.renderInstructions);\n        } else {\n          this.renderInstructions_ = new Float32Array(event.data.renderInstructions);\n        }\n        this.getLayer().changed();\n      }\n    }.bind(_this));\n    /**\n     * This object will be updated when the source changes. Key is uid.\n     * @type {Object<string, FeatureCacheItem>}\n     * @private\n     */\n    _this.featureCache_ = {};\n    /**\n     * Amount of features in the cache.\n     * @type {number}\n     * @private\n     */\n    _this.featureCount_ = 0;\n    var source = _this.getLayer().getSource();\n    _this.sourceListenKeys_ = [listen(source, VectorEventType.ADDFEATURE, _this.handleSourceFeatureAdded_, _this), listen(source, VectorEventType.CHANGEFEATURE, _this.handleSourceFeatureChanged_, _this), listen(source, VectorEventType.REMOVEFEATURE, _this.handleSourceFeatureDelete_, _this), listen(source, VectorEventType.CLEAR, _this.handleSourceFeatureClear_, _this)];\n    source.forEachFeature(function (feature) {\n      this.featureCache_[getUid(feature)] = {\n        feature: feature,\n        properties: feature.getProperties(),\n        geometry: feature.getGeometry()\n      };\n      this.featureCount_++;\n    }.bind(_this));\n    return _this;\n  }\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  WebGLPointsLayerRenderer.prototype.handleSourceFeatureAdded_ = function (event) {\n    var feature = event.feature;\n    this.featureCache_[getUid(feature)] = {\n      feature: feature,\n      properties: feature.getProperties(),\n      geometry: feature.getGeometry()\n    };\n    this.featureCount_++;\n  };\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  WebGLPointsLayerRenderer.prototype.handleSourceFeatureChanged_ = function (event) {\n    var feature = event.feature;\n    this.featureCache_[getUid(feature)] = {\n      feature: feature,\n      properties: feature.getProperties(),\n      geometry: feature.getGeometry()\n    };\n  };\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  WebGLPointsLayerRenderer.prototype.handleSourceFeatureDelete_ = function (event) {\n    var feature = event.feature;\n    delete this.featureCache_[getUid(feature)];\n    this.featureCount_--;\n  };\n  /**\n   * @private\n   */\n  WebGLPointsLayerRenderer.prototype.handleSourceFeatureClear_ = function () {\n    this.featureCache_ = {};\n    this.featureCount_ = 0;\n  };\n  /**\n   * Render the layer.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {HTMLElement} The rendered element.\n   */\n  WebGLPointsLayerRenderer.prototype.renderFrame = function (frameState) {\n    var renderCount = this.indicesBuffer_.getSize();\n    this.helper.drawElements(0, renderCount);\n    this.helper.finalizeDraw(frameState);\n    var canvas = this.helper.getCanvas();\n    var layerState = frameState.layerStatesArray[frameState.layerIndex];\n    var opacity = layerState.opacity;\n    if (opacity !== parseFloat(canvas.style.opacity)) {\n      canvas.style.opacity = String(opacity);\n    }\n    if (this.hitDetectionEnabled_) {\n      this.renderHitDetection(frameState);\n      this.hitRenderTarget_.clearCachedData();\n    }\n    return canvas;\n  };\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  WebGLPointsLayerRenderer.prototype.prepareFrame = function (frameState) {\n    var layer = this.getLayer();\n    var vectorSource = layer.getSource();\n    var viewState = frameState.viewState;\n    var viewNotMoving = !frameState.viewHints[ViewHint.ANIMATING] && !frameState.viewHints[ViewHint.INTERACTING];\n    var extentChanged = !equals(this.previousExtent_, frameState.extent);\n    var sourceChanged = this.sourceRevision_ < vectorSource.getRevision();\n    if (sourceChanged) {\n      this.sourceRevision_ = vectorSource.getRevision();\n    }\n    if (viewNotMoving && (extentChanged || sourceChanged)) {\n      var projection = viewState.projection;\n      var resolution = viewState.resolution;\n      var renderBuffer = layer instanceof BaseVector ? layer.getRenderBuffer() : 0;\n      var extent = buffer(frameState.extent, renderBuffer * resolution);\n      vectorSource.loadFeatures(extent, resolution, projection);\n      this.rebuildBuffers_(frameState);\n      this.previousExtent_ = frameState.extent.slice();\n    }\n    // apply the current projection transform with the invert of the one used to fill buffers\n    this.helper.makeProjectionTransform(frameState, this.currentTransform_);\n    multiplyTransform(this.currentTransform_, this.invertRenderTransform_);\n    this.helper.useProgram(this.program_);\n    this.helper.prepareDraw(frameState);\n    // write new data\n    this.helper.bindBuffer(this.verticesBuffer_);\n    this.helper.bindBuffer(this.indicesBuffer_);\n    this.helper.enableAttributes(this.attributes);\n    return true;\n  };\n  /**\n   * Rebuild internal webgl buffers based on current view extent; costly, should not be called too much\n   * @param {import(\"../../PluggableMap\").FrameState} frameState Frame state.\n   * @private\n   */\n  WebGLPointsLayerRenderer.prototype.rebuildBuffers_ = function (frameState) {\n    // saves the projection transform for the current frame state\n    var projectionTransform = createTransform();\n    this.helper.makeProjectionTransform(frameState, projectionTransform);\n    // here we anticipate the amount of render instructions that we well generate\n    // this can be done since we know that for normal render we only have x, y as base instructions,\n    // and x, y, r, g, b, a and featureUid for hit render instructions\n    // and we also know the amount of custom attributes to append to these\n    var totalInstructionsCount = (2 + this.customAttributes.length) * this.featureCount_;\n    if (!this.renderInstructions_ || this.renderInstructions_.length !== totalInstructionsCount) {\n      this.renderInstructions_ = new Float32Array(totalInstructionsCount);\n    }\n    if (this.hitDetectionEnabled_) {\n      var totalHitInstructionsCount = (7 + this.customAttributes.length) * this.featureCount_;\n      if (!this.hitRenderInstructions_ || this.hitRenderInstructions_.length !== totalHitInstructionsCount) {\n        this.hitRenderInstructions_ = new Float32Array(totalHitInstructionsCount);\n      }\n    }\n    // loop on features to fill the buffer\n    var featureCache, geometry;\n    var tmpCoords = [];\n    var tmpColor = [];\n    var renderIndex = 0;\n    var hitIndex = 0;\n    var hitColor;\n    for (var featureUid in this.featureCache_) {\n      featureCache = this.featureCache_[featureUid];\n      geometry = /** @type {import(\"../../geom\").Point} */featureCache.geometry;\n      if (!geometry || geometry.getType() !== GeometryType.POINT) {\n        continue;\n      }\n      tmpCoords[0] = geometry.getFlatCoordinates()[0];\n      tmpCoords[1] = geometry.getFlatCoordinates()[1];\n      applyTransform(projectionTransform, tmpCoords);\n      hitColor = colorEncodeId(hitIndex + 6, tmpColor);\n      this.renderInstructions_[renderIndex++] = tmpCoords[0];\n      this.renderInstructions_[renderIndex++] = tmpCoords[1];\n      // for hit detection, the feature uid is saved in the opacity value\n      // and the index of the opacity value is encoded in the color values\n      if (this.hitDetectionEnabled_) {\n        this.hitRenderInstructions_[hitIndex++] = tmpCoords[0];\n        this.hitRenderInstructions_[hitIndex++] = tmpCoords[1];\n        this.hitRenderInstructions_[hitIndex++] = hitColor[0];\n        this.hitRenderInstructions_[hitIndex++] = hitColor[1];\n        this.hitRenderInstructions_[hitIndex++] = hitColor[2];\n        this.hitRenderInstructions_[hitIndex++] = hitColor[3];\n        this.hitRenderInstructions_[hitIndex++] = Number(featureUid);\n      }\n      // pushing custom attributes\n      var value = void 0;\n      for (var j = 0; j < this.customAttributes.length; j++) {\n        value = this.customAttributes[j].callback(featureCache.feature, featureCache.properties);\n        this.renderInstructions_[renderIndex++] = value;\n        if (this.hitDetectionEnabled_) {\n          this.hitRenderInstructions_[hitIndex++] = value;\n        }\n      }\n    }\n    /** @type {import('./Layer').WebGLWorkerGenerateBuffersMessage} */\n    var message = {\n      type: WebGLWorkerMessageType.GENERATE_BUFFERS,\n      renderInstructions: this.renderInstructions_.buffer,\n      customAttributesCount: this.customAttributes.length\n    };\n    // additional properties will be sent back as-is by the worker\n    message['projectionTransform'] = projectionTransform;\n    this.worker_.postMessage(message, [this.renderInstructions_.buffer]);\n    this.renderInstructions_ = null;\n    /** @type {import('./Layer').WebGLWorkerGenerateBuffersMessage} */\n    if (this.hitDetectionEnabled_) {\n      var hitMessage = {\n        type: WebGLWorkerMessageType.GENERATE_BUFFERS,\n        renderInstructions: this.hitRenderInstructions_.buffer,\n        customAttributesCount: 5 + this.customAttributes.length\n      };\n      hitMessage['projectionTransform'] = projectionTransform;\n      hitMessage['hitDetection'] = true;\n      this.worker_.postMessage(hitMessage, [this.hitRenderInstructions_.buffer]);\n      this.hitRenderInstructions_ = null;\n    }\n  };\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {function(import(\"../../Feature.js\").FeatureLike, import(\"../../layer/Layer.js\").default): T} callback Feature callback.\n   * @param {Array<import(\"../../Feature.js\").FeatureLike>} declutteredFeatures Decluttered features.\n   * @return {T|void} Callback result.\n   * @template T\n   */\n  WebGLPointsLayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, declutteredFeatures) {\n    assert(this.hitDetectionEnabled_, 66);\n    if (!this.hitRenderInstructions_) {\n      return;\n    }\n    var pixel = applyTransform(frameState.coordinateToPixelTransform, coordinate.slice());\n    var data = this.hitRenderTarget_.readPixel(pixel[0] / 2, pixel[1] / 2);\n    var color = [data[0] / 255, data[1] / 255, data[2] / 255, data[3] / 255];\n    var index = colorDecodeId(color);\n    var opacity = this.hitRenderInstructions_[index];\n    var uid = Math.floor(opacity).toString();\n    var source = this.getLayer().getSource();\n    var feature = source.getFeatureByUid(uid);\n    if (feature) {\n      return callback(feature, this.getLayer());\n    }\n  };\n  /**\n   * Render the hit detection data to the corresponding render target\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState current frame state\n   */\n  WebGLPointsLayerRenderer.prototype.renderHitDetection = function (frameState) {\n    // skip render entirely if vertex buffers not ready/generated yet\n    if (!this.hitVerticesBuffer_.getSize()) {\n      return;\n    }\n    this.hitRenderTarget_.setSize([Math.floor(frameState.size[0] / 2), Math.floor(frameState.size[1] / 2)]);\n    this.helper.useProgram(this.hitProgram_);\n    this.helper.prepareDrawToRenderTarget(frameState, this.hitRenderTarget_, true);\n    this.helper.bindBuffer(this.hitVerticesBuffer_);\n    this.helper.bindBuffer(this.indicesBuffer_);\n    this.helper.enableAttributes(this.hitDetectionAttributes);\n    var renderCount = this.indicesBuffer_.getSize();\n    this.helper.drawElements(0, renderCount);\n  };\n  /**\n   * Clean up.\n   */\n  WebGLPointsLayerRenderer.prototype.disposeInternal = function () {\n    this.worker_.terminate();\n    this.layer_ = null;\n    this.sourceListenKeys_.forEach(function (key) {\n      unlistenByKey(key);\n    });\n    this.sourceListenKeys_ = null;\n    _super.prototype.disposeInternal.call(this);\n  };\n  return WebGLPointsLayerRenderer;\n}(WebGLLayerRenderer);\nexport default WebGLPointsLayerRenderer;","map":{"version":3,"names":["BaseVector","GeometryType","VectorEventType","ViewHint","WebGLArrayBuffer","WebGLLayerRenderer","WebGLWorkerMessageType","colorDecodeId","colorEncodeId","WebGLRenderTarget","ARRAY_BUFFER","DYNAMIC_DRAW","ELEMENT_ARRAY_BUFFER","AttributeType","DefaultUniform","apply","applyTransform","create","createTransform","makeInverse","makeInverseTransform","multiply","multiplyTransform","assert","buffer","createEmpty","equals","createWebGLWorker","getUid","listen","unlistenByKey","WebGLPointsLayerRenderer","_super","__extends","layer","options","_this","uniforms","projectionMatrixTransform","PROJECTION_MATRIX","call","postProcesses","sourceRevision_","verticesBuffer_","hitVerticesBuffer_","indicesBuffer_","program_","helper","getProgram","fragmentShader","vertexShader","hitDetectionEnabled_","hitFragmentShader","hitVertexShader","hitProgram_","customAttributes","attributes","map","attribute","name","size","type","FLOAT","concat","hitDetectionAttributes","previousExtent_","currentTransform_","renderTransform_","invertRenderTransform_","renderInstructions_","Float32Array","hitRenderInstructions_","hitRenderTarget_","worker_","addEventListener","event","received","data","GENERATE_BUFFERS","projectionTransform","hitDetection","fromArrayBuffer","vertexBuffer","flushBufferData","indexBuffer","renderInstructions","getLayer","changed","bind","featureCache_","featureCount_","source","getSource","sourceListenKeys_","ADDFEATURE","handleSourceFeatureAdded_","CHANGEFEATURE","handleSourceFeatureChanged_","REMOVEFEATURE","handleSourceFeatureDelete_","CLEAR","handleSourceFeatureClear_","forEachFeature","feature","properties","getProperties","geometry","getGeometry","prototype","renderFrame","frameState","renderCount","getSize","drawElements","finalizeDraw","canvas","getCanvas","layerState","layerStatesArray","layerIndex","opacity","parseFloat","style","String","renderHitDetection","clearCachedData","prepareFrame","vectorSource","viewState","viewNotMoving","viewHints","ANIMATING","INTERACTING","extentChanged","extent","sourceChanged","getRevision","projection","resolution","renderBuffer","getRenderBuffer","loadFeatures","rebuildBuffers_","slice","makeProjectionTransform","useProgram","prepareDraw","bindBuffer","enableAttributes","totalInstructionsCount","length","totalHitInstructionsCount","featureCache","tmpCoords","tmpColor","renderIndex","hitIndex","hitColor","featureUid","getType","POINT","getFlatCoordinates","Number","value","j","callback","message","customAttributesCount","postMessage","hitMessage","forEachFeatureAtCoordinate","coordinate","hitTolerance","declutteredFeatures","pixel","coordinateToPixelTransform","readPixel","color","index","uid","Math","floor","toString","getFeatureByUid","setSize","prepareDrawToRenderTarget","disposeInternal","terminate","layer_","forEach","key"],"sources":["/Users/mariovicky/Skripsi_OpenLayers/node_modules/ol/src/renderer/webgl/PointsLayer.js"],"sourcesContent":["/**\n * @module ol/renderer/webgl/PointsLayer\n */\nimport BaseVector from '../../layer/BaseVector.js';\nimport GeometryType from '../../geom/GeometryType.js';\nimport VectorEventType from '../../source/VectorEventType.js';\nimport ViewHint from '../../ViewHint.js';\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport WebGLLayerRenderer, {\n  WebGLWorkerMessageType,\n  colorDecodeId,\n  colorEncodeId,\n} from './Layer.js';\nimport WebGLRenderTarget from '../../webgl/RenderTarget.js';\nimport {ARRAY_BUFFER, DYNAMIC_DRAW, ELEMENT_ARRAY_BUFFER} from '../../webgl.js';\nimport {AttributeType, DefaultUniform} from '../../webgl/Helper.js';\nimport {\n  apply as applyTransform,\n  create as createTransform,\n  makeInverse as makeInverseTransform,\n  multiply as multiplyTransform,\n} from '../../transform.js';\nimport {assert} from '../../asserts.js';\nimport {buffer, createEmpty, equals} from '../../extent.js';\nimport {create as createWebGLWorker} from '../../worker/webgl.js';\nimport {getUid} from '../../util.js';\nimport {listen, unlistenByKey} from '../../events.js';\n\n/**\n * @typedef {Object} CustomAttribute A description of a custom attribute to be passed on to the GPU, with a value different\n * for each feature.\n * @property {string} name Attribute name.\n * @property {function(import(\"../../Feature\").default, Object<string, *>):number} callback This callback computes the numerical value of the\n * attribute for a given feature (properties are available as 2nd arg for quicker access).\n */\n\n/**\n * @typedef {Object} FeatureCacheItem Object that holds a reference to a feature, its geometry and properties. Used to optimize\n * rebuildBuffers by accessing these objects quicker.\n * @property {import(\"../../Feature\").default} feature Feature\n * @property {Object<string, *>} properties Feature properties\n * @property {import(\"../../geom\").Geometry} geometry Feature geometry\n */\n\n/**\n * @typedef {Object} Options\n * @property {Array<CustomAttribute>} [attributes] These attributes will be read from the features in the source and then\n * passed to the GPU. The `name` property of each attribute will serve as its identifier:\n *  * In the vertex shader as an `attribute` by prefixing it with `a_`\n *  * In the fragment shader as a `varying` by prefixing it with `v_`\n * Please note that these can only be numerical values.\n * @property {string} vertexShader Vertex shader source, mandatory.\n * @property {string} fragmentShader Fragment shader source, mandatory.\n * @property {string} [hitVertexShader] Vertex shader source for hit detection rendering.\n * @property {string} [hitFragmentShader] Fragment shader source for hit detection rendering.\n * @property {Object.<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * Please note that `u_texture` is reserved for the main texture slot.\n * @property {Array<import(\"./Layer\").PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n\n/**\n * @classdesc\n * WebGL vector renderer optimized for points.\n * All features will be rendered as quads (two triangles forming a square). New data will be flushed to the GPU\n * every time the vector source changes.\n *\n * You need to provide vertex and fragment shaders for rendering. This can be done using\n * {@link module:ol/webgl/ShaderBuilder} utilities. These shaders shall expect a `a_position` attribute\n * containing the screen-space projected center of the quad, as well as a `a_index` attribute\n * whose value (0, 1, 2 or 3) indicates which quad vertex is currently getting processed (see structure below).\n *\n * To include variable attributes in the shaders, you need to declare them using the `attributes` property of\n * the options object like so:\n * ```js\n * new WebGLPointsLayerRenderer(layer, {\n *   attributes: [\n *     {\n *       name: 'size',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *     {\n *       name: 'weight',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *   ],\n *   vertexShader:\n *     // shader using attribute a_weight and a_size\n *   fragmentShader:\n *     // shader using varying v_weight and v_size\n * ```\n *\n * To enable hit detection, you must as well provide dedicated shaders using the `hitVertexShader`\n * and `hitFragmentShader` properties. These shall expect the `a_hitColor` attribute to contain\n * the final color that will have to be output for hit detection to work.\n *\n * The following uniform is used for the main texture: `u_texture`.\n *\n * Please note that the main shader output should have premultiplied alpha, otherwise visual anomalies may occur.\n *\n * Points are rendered as quads with the following structure:\n *\n * ```\n *   (u0, v1)      (u1, v1)\n *  [3]----------[2]\n *   |`           |\n *   |  `         |\n *   |    `       |\n *   |      `     |\n *   |        `   |\n *   |          ` |\n *  [0]----------[1]\n *   (u0, v0)      (u1, v0)\n *  ```\n *\n * This uses {@link module:ol/webgl/Helper~WebGLHelper} internally.\n *\n * @api\n */\nclass WebGLPointsLayerRenderer extends WebGLLayerRenderer {\n  /**\n   * @param {import(\"../../layer/Layer.js\").default} layer Layer.\n   * @param {Options} options Options.\n   */\n  constructor(layer, options) {\n    const uniforms = options.uniforms || {};\n    const projectionMatrixTransform = createTransform();\n    uniforms[DefaultUniform.PROJECTION_MATRIX] = projectionMatrixTransform;\n\n    super(layer, {\n      uniforms: uniforms,\n      postProcesses: options.postProcesses,\n    });\n\n    this.sourceRevision_ = -1;\n\n    this.verticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);\n    this.hitVerticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);\n    this.indicesBuffer_ = new WebGLArrayBuffer(\n      ELEMENT_ARRAY_BUFFER,\n      DYNAMIC_DRAW\n    );\n\n    this.program_ = this.helper.getProgram(\n      options.fragmentShader,\n      options.vertexShader\n    );\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hitDetectionEnabled_ =\n      options.hitFragmentShader && options.hitVertexShader ? true : false;\n\n    this.hitProgram_ =\n      this.hitDetectionEnabled_ &&\n      this.helper.getProgram(\n        options.hitFragmentShader,\n        options.hitVertexShader\n      );\n\n    const customAttributes = options.attributes\n      ? options.attributes.map(function (attribute) {\n          return {\n            name: 'a_' + attribute.name,\n            size: 1,\n            type: AttributeType.FLOAT,\n          };\n        })\n      : [];\n\n    /**\n     * A list of attributes used by the renderer. By default only the position and\n     * index of the vertex (0 to 3) are required.\n     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n     */\n    this.attributes = [\n      {\n        name: 'a_position',\n        size: 2,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: 'a_index',\n        size: 1,\n        type: AttributeType.FLOAT,\n      },\n    ].concat(customAttributes);\n\n    /**\n     * A list of attributes used for hit detection.\n     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n     */\n    this.hitDetectionAttributes = [\n      {\n        name: 'a_position',\n        size: 2,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: 'a_index',\n        size: 1,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: 'a_hitColor',\n        size: 4,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: 'a_featureUid',\n        size: 1,\n        type: AttributeType.FLOAT,\n      },\n    ].concat(customAttributes);\n\n    this.customAttributes = options.attributes ? options.attributes : [];\n\n    this.previousExtent_ = createEmpty();\n\n    /**\n     * This transform is updated on every frame and is the composition of:\n     * - invert of the world->screen transform that was used when rebuilding buffers (see `this.renderTransform_`)\n     * - current world->screen transform\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.currentTransform_ = projectionMatrixTransform;\n\n    /**\n     * This transform is updated when buffers are rebuilt and converts world space coordinates to screen space\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.renderTransform_ = createTransform();\n\n    /**\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.invertRenderTransform_ = createTransform();\n\n    /**\n     * @type {Float32Array}\n     * @private\n     */\n    this.renderInstructions_ = new Float32Array(0);\n\n    /**\n     * These instructions are used for hit detection\n     * @type {Float32Array}\n     * @private\n     */\n    this.hitRenderInstructions_ = new Float32Array(0);\n\n    /**\n     * @type {WebGLRenderTarget}\n     * @private\n     */\n    this.hitRenderTarget_ =\n      this.hitDetectionEnabled_ && new WebGLRenderTarget(this.helper);\n\n    this.worker_ = createWebGLWorker();\n    this.worker_.addEventListener(\n      'message',\n      function (event) {\n        const received = event.data;\n        if (received.type === WebGLWorkerMessageType.GENERATE_BUFFERS) {\n          const projectionTransform = received.projectionTransform;\n          if (received.hitDetection) {\n            this.hitVerticesBuffer_.fromArrayBuffer(received.vertexBuffer);\n            this.helper.flushBufferData(this.hitVerticesBuffer_);\n          } else {\n            this.verticesBuffer_.fromArrayBuffer(received.vertexBuffer);\n            this.helper.flushBufferData(this.verticesBuffer_);\n          }\n          this.indicesBuffer_.fromArrayBuffer(received.indexBuffer);\n          this.helper.flushBufferData(this.indicesBuffer_);\n\n          this.renderTransform_ = projectionTransform;\n          makeInverseTransform(\n            this.invertRenderTransform_,\n            this.renderTransform_\n          );\n          if (received.hitDetection) {\n            this.hitRenderInstructions_ = new Float32Array(\n              event.data.renderInstructions\n            );\n          } else {\n            this.renderInstructions_ = new Float32Array(\n              event.data.renderInstructions\n            );\n          }\n\n          this.getLayer().changed();\n        }\n      }.bind(this)\n    );\n\n    /**\n     * This object will be updated when the source changes. Key is uid.\n     * @type {Object<string, FeatureCacheItem>}\n     * @private\n     */\n    this.featureCache_ = {};\n\n    /**\n     * Amount of features in the cache.\n     * @type {number}\n     * @private\n     */\n    this.featureCount_ = 0;\n\n    const source = this.getLayer().getSource();\n    this.sourceListenKeys_ = [\n      listen(\n        source,\n        VectorEventType.ADDFEATURE,\n        this.handleSourceFeatureAdded_,\n        this\n      ),\n      listen(\n        source,\n        VectorEventType.CHANGEFEATURE,\n        this.handleSourceFeatureChanged_,\n        this\n      ),\n      listen(\n        source,\n        VectorEventType.REMOVEFEATURE,\n        this.handleSourceFeatureDelete_,\n        this\n      ),\n      listen(\n        source,\n        VectorEventType.CLEAR,\n        this.handleSourceFeatureClear_,\n        this\n      ),\n    ];\n    source.forEachFeature(\n      function (feature) {\n        this.featureCache_[getUid(feature)] = {\n          feature: feature,\n          properties: feature.getProperties(),\n          geometry: feature.getGeometry(),\n        };\n        this.featureCount_++;\n      }.bind(this)\n    );\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureAdded_(event) {\n    const feature = event.feature;\n    this.featureCache_[getUid(feature)] = {\n      feature: feature,\n      properties: feature.getProperties(),\n      geometry: feature.getGeometry(),\n    };\n    this.featureCount_++;\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureChanged_(event) {\n    const feature = event.feature;\n    this.featureCache_[getUid(feature)] = {\n      feature: feature,\n      properties: feature.getProperties(),\n      geometry: feature.getGeometry(),\n    };\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureDelete_(event) {\n    const feature = event.feature;\n    delete this.featureCache_[getUid(feature)];\n    this.featureCount_--;\n  }\n\n  /**\n   * @private\n   */\n  handleSourceFeatureClear_() {\n    this.featureCache_ = {};\n    this.featureCount_ = 0;\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState) {\n    const renderCount = this.indicesBuffer_.getSize();\n    this.helper.drawElements(0, renderCount);\n    this.helper.finalizeDraw(frameState);\n    const canvas = this.helper.getCanvas();\n\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const opacity = layerState.opacity;\n    if (opacity !== parseFloat(canvas.style.opacity)) {\n      canvas.style.opacity = String(opacity);\n    }\n\n    if (this.hitDetectionEnabled_) {\n      this.renderHitDetection(frameState);\n      this.hitRenderTarget_.clearCachedData();\n    }\n\n    return canvas;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    const layer = this.getLayer();\n    const vectorSource = layer.getSource();\n    const viewState = frameState.viewState;\n    const viewNotMoving =\n      !frameState.viewHints[ViewHint.ANIMATING] &&\n      !frameState.viewHints[ViewHint.INTERACTING];\n    const extentChanged = !equals(this.previousExtent_, frameState.extent);\n    const sourceChanged = this.sourceRevision_ < vectorSource.getRevision();\n\n    if (sourceChanged) {\n      this.sourceRevision_ = vectorSource.getRevision();\n    }\n\n    if (viewNotMoving && (extentChanged || sourceChanged)) {\n      const projection = viewState.projection;\n      const resolution = viewState.resolution;\n\n      const renderBuffer =\n        layer instanceof BaseVector ? layer.getRenderBuffer() : 0;\n      const extent = buffer(frameState.extent, renderBuffer * resolution);\n      vectorSource.loadFeatures(extent, resolution, projection);\n\n      this.rebuildBuffers_(frameState);\n      this.previousExtent_ = frameState.extent.slice();\n    }\n\n    // apply the current projection transform with the invert of the one used to fill buffers\n    this.helper.makeProjectionTransform(frameState, this.currentTransform_);\n    multiplyTransform(this.currentTransform_, this.invertRenderTransform_);\n\n    this.helper.useProgram(this.program_);\n    this.helper.prepareDraw(frameState);\n\n    // write new data\n    this.helper.bindBuffer(this.verticesBuffer_);\n    this.helper.bindBuffer(this.indicesBuffer_);\n\n    this.helper.enableAttributes(this.attributes);\n\n    return true;\n  }\n\n  /**\n   * Rebuild internal webgl buffers based on current view extent; costly, should not be called too much\n   * @param {import(\"../../PluggableMap\").FrameState} frameState Frame state.\n   * @private\n   */\n  rebuildBuffers_(frameState) {\n    // saves the projection transform for the current frame state\n    const projectionTransform = createTransform();\n    this.helper.makeProjectionTransform(frameState, projectionTransform);\n\n    // here we anticipate the amount of render instructions that we well generate\n    // this can be done since we know that for normal render we only have x, y as base instructions,\n    // and x, y, r, g, b, a and featureUid for hit render instructions\n    // and we also know the amount of custom attributes to append to these\n    const totalInstructionsCount =\n      (2 + this.customAttributes.length) * this.featureCount_;\n    if (\n      !this.renderInstructions_ ||\n      this.renderInstructions_.length !== totalInstructionsCount\n    ) {\n      this.renderInstructions_ = new Float32Array(totalInstructionsCount);\n    }\n    if (this.hitDetectionEnabled_) {\n      const totalHitInstructionsCount =\n        (7 + this.customAttributes.length) * this.featureCount_;\n      if (\n        !this.hitRenderInstructions_ ||\n        this.hitRenderInstructions_.length !== totalHitInstructionsCount\n      ) {\n        this.hitRenderInstructions_ = new Float32Array(\n          totalHitInstructionsCount\n        );\n      }\n    }\n\n    // loop on features to fill the buffer\n    let featureCache, geometry;\n    const tmpCoords = [];\n    const tmpColor = [];\n    let renderIndex = 0;\n    let hitIndex = 0;\n    let hitColor;\n    for (const featureUid in this.featureCache_) {\n      featureCache = this.featureCache_[featureUid];\n      geometry = /** @type {import(\"../../geom\").Point} */ (featureCache.geometry);\n      if (!geometry || geometry.getType() !== GeometryType.POINT) {\n        continue;\n      }\n\n      tmpCoords[0] = geometry.getFlatCoordinates()[0];\n      tmpCoords[1] = geometry.getFlatCoordinates()[1];\n      applyTransform(projectionTransform, tmpCoords);\n\n      hitColor = colorEncodeId(hitIndex + 6, tmpColor);\n\n      this.renderInstructions_[renderIndex++] = tmpCoords[0];\n      this.renderInstructions_[renderIndex++] = tmpCoords[1];\n\n      // for hit detection, the feature uid is saved in the opacity value\n      // and the index of the opacity value is encoded in the color values\n      if (this.hitDetectionEnabled_) {\n        this.hitRenderInstructions_[hitIndex++] = tmpCoords[0];\n        this.hitRenderInstructions_[hitIndex++] = tmpCoords[1];\n        this.hitRenderInstructions_[hitIndex++] = hitColor[0];\n        this.hitRenderInstructions_[hitIndex++] = hitColor[1];\n        this.hitRenderInstructions_[hitIndex++] = hitColor[2];\n        this.hitRenderInstructions_[hitIndex++] = hitColor[3];\n        this.hitRenderInstructions_[hitIndex++] = Number(featureUid);\n      }\n\n      // pushing custom attributes\n      let value;\n      for (let j = 0; j < this.customAttributes.length; j++) {\n        value = this.customAttributes[j].callback(\n          featureCache.feature,\n          featureCache.properties\n        );\n        this.renderInstructions_[renderIndex++] = value;\n        if (this.hitDetectionEnabled_) {\n          this.hitRenderInstructions_[hitIndex++] = value;\n        }\n      }\n    }\n\n    /** @type {import('./Layer').WebGLWorkerGenerateBuffersMessage} */\n    const message = {\n      type: WebGLWorkerMessageType.GENERATE_BUFFERS,\n      renderInstructions: this.renderInstructions_.buffer,\n      customAttributesCount: this.customAttributes.length,\n    };\n    // additional properties will be sent back as-is by the worker\n    message['projectionTransform'] = projectionTransform;\n    this.worker_.postMessage(message, [this.renderInstructions_.buffer]);\n    this.renderInstructions_ = null;\n\n    /** @type {import('./Layer').WebGLWorkerGenerateBuffersMessage} */\n    if (this.hitDetectionEnabled_) {\n      const hitMessage = {\n        type: WebGLWorkerMessageType.GENERATE_BUFFERS,\n        renderInstructions: this.hitRenderInstructions_.buffer,\n        customAttributesCount: 5 + this.customAttributes.length,\n      };\n      hitMessage['projectionTransform'] = projectionTransform;\n      hitMessage['hitDetection'] = true;\n      this.worker_.postMessage(hitMessage, [\n        this.hitRenderInstructions_.buffer,\n      ]);\n      this.hitRenderInstructions_ = null;\n    }\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {function(import(\"../../Feature.js\").FeatureLike, import(\"../../layer/Layer.js\").default): T} callback Feature callback.\n   * @param {Array<import(\"../../Feature.js\").FeatureLike>} declutteredFeatures Decluttered features.\n   * @return {T|void} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    declutteredFeatures\n  ) {\n    assert(this.hitDetectionEnabled_, 66);\n    if (!this.hitRenderInstructions_) {\n      return;\n    }\n\n    const pixel = applyTransform(\n      frameState.coordinateToPixelTransform,\n      coordinate.slice()\n    );\n\n    const data = this.hitRenderTarget_.readPixel(pixel[0] / 2, pixel[1] / 2);\n    const color = [data[0] / 255, data[1] / 255, data[2] / 255, data[3] / 255];\n    const index = colorDecodeId(color);\n    const opacity = this.hitRenderInstructions_[index];\n    const uid = Math.floor(opacity).toString();\n\n    const source = this.getLayer().getSource();\n    const feature = source.getFeatureByUid(uid);\n    if (feature) {\n      return callback(feature, this.getLayer());\n    }\n  }\n\n  /**\n   * Render the hit detection data to the corresponding render target\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState current frame state\n   */\n  renderHitDetection(frameState) {\n    // skip render entirely if vertex buffers not ready/generated yet\n    if (!this.hitVerticesBuffer_.getSize()) {\n      return;\n    }\n\n    this.hitRenderTarget_.setSize([\n      Math.floor(frameState.size[0] / 2),\n      Math.floor(frameState.size[1] / 2),\n    ]);\n\n    this.helper.useProgram(this.hitProgram_);\n    this.helper.prepareDrawToRenderTarget(\n      frameState,\n      this.hitRenderTarget_,\n      true\n    );\n\n    this.helper.bindBuffer(this.hitVerticesBuffer_);\n    this.helper.bindBuffer(this.indicesBuffer_);\n\n    this.helper.enableAttributes(this.hitDetectionAttributes);\n\n    const renderCount = this.indicesBuffer_.getSize();\n    this.helper.drawElements(0, renderCount);\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    this.worker_.terminate();\n    this.layer_ = null;\n    this.sourceListenKeys_.forEach(function (key) {\n      unlistenByKey(key);\n    });\n    this.sourceListenKeys_ = null;\n    super.disposeInternal();\n  }\n}\n\nexport default WebGLPointsLayerRenderer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
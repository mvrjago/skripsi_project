{"ast":null,"code":"/*\nol-mapbox-style - Use Mapbox Style objects with OpenLayers\nCopyright 2016-present ol-mapbox-style contributors\nLicense: https://raw.githubusercontent.com/openlayers/ol-mapbox-style/master/LICENSE\n*/\nimport Style from 'ol/style/Style';\nimport Fill from 'ol/style/Fill';\nimport Stroke from 'ol/style/Stroke';\nimport Icon from 'ol/style/Icon';\nimport Text from 'ol/style/Text';\nimport Circle from 'ol/style/Circle';\nimport RenderFeature from 'ol/render/Feature';\nimport { derefLayers } from '@mapbox/mapbox-gl-style-spec';\nimport { expression, Color, function as fn, latest as spec, featureFilter as createFilter } from '@mapbox/mapbox-gl-style-spec';\nimport mb2css from 'mapbox-to-css-font';\nimport { deg2rad, defaultResolutions, getZoomForResolution, wrapText, applyLetterSpacing, createCanvas } from './util';\n/**\n * @typedef {import(\"ol/layer/Vector\").default} VectorLayer\n * @typedef {import(\"ol/layer/VectorTile\").default} VectorTileLayer\n * @typedef {import(\"ol/style/Style\").StyleFunction} StyleFunction\n */\nvar isFunction = fn.isFunction;\nvar convertFunction = fn.convertFunction;\nvar isExpression = expression.isExpression;\nvar createPropertyExpression = expression.createPropertyExpression;\nvar types = {\n  'Point': 1,\n  'MultiPoint': 1,\n  'LineString': 2,\n  'MultiLineString': 2,\n  'Polygon': 3,\n  'MultiPolygon': 3\n};\nvar anchor = {\n  'center': [0.5, 0.5],\n  'left': [0, 0.5],\n  'right': [1, 0.5],\n  'top': [0.5, 0],\n  'bottom': [0.5, 1],\n  'top-left': [0, 0],\n  'top-right': [1, 0],\n  'bottom-left': [0, 1],\n  'bottom-right': [1, 1]\n};\nvar expressionData = function expressionData(rawExpression, propertySpec) {\n  var compiledExpression = createPropertyExpression(rawExpression, propertySpec);\n  if (compiledExpression.result === 'error') {\n    throw new Error(compiledExpression.value.map(function (err) {\n      return err.key + \": \" + err.message;\n    }).join(', '));\n  }\n  return compiledExpression.value;\n};\nvar emptyObj = {};\nvar zoomObj = {\n  zoom: 0\n};\n/** @private */\nvar functionCache = {};\nvar renderFeatureCoordinates, renderFeature;\n/**\n * @private\n * @param {Object} layer Gl object layer.\n * @param {string} layoutOrPaint 'layout' or 'paint'.\n * @param {string} property Feature property.\n * @param {number} zoom Zoom.\n * @param {Object} feature Gl feature.\n * @return {?} Value.\n */\nexport function getValue(layer, layoutOrPaint, property, zoom, feature) {\n  var layerId = layer.id;\n  if (!functionCache[layerId]) {\n    functionCache[layerId] = {};\n  }\n  var functions = functionCache[layerId];\n  if (!functions[property]) {\n    var value_1 = (layer[layoutOrPaint] || emptyObj)[property];\n    var propertySpec = spec[layoutOrPaint + \"_\" + layer.type][property];\n    if (value_1 === undefined) {\n      value_1 = propertySpec.default;\n    }\n    var isExpr = isExpression(value_1);\n    if (!isExpr && isFunction(value_1)) {\n      value_1 = convertFunction(value_1, propertySpec);\n      isExpr = true;\n    }\n    if (isExpr) {\n      var compiledExpression = expressionData(value_1, propertySpec);\n      functions[property] = compiledExpression.evaluate.bind(compiledExpression);\n    } else {\n      if (propertySpec.type == 'color') {\n        value_1 = Color.parse(value_1);\n      }\n      functions[property] = function () {\n        return value_1;\n      };\n    }\n  }\n  zoomObj.zoom = zoom;\n  return functions[property](zoomObj, feature);\n}\n/** @private */\nvar filterCache = {};\n/**\n * @private\n * @param {string} layerId Layer id.\n * @param {?} filter Filter.\n * @param {Object} feature Feature.\n * @param {number} zoom Zoom.\n * @return {boolean} Filter result.\n */\nfunction evaluateFilter(layerId, filter, feature, zoom) {\n  if (!(layerId in filterCache)) {\n    filterCache[layerId] = createFilter(filter).filter;\n  }\n  zoomObj.zoom = zoom;\n  return filterCache[layerId](zoomObj, feature);\n}\n/**\n * @private\n * @param {?} color Color.\n * @param {number} opacity Opacity.\n * @return {string} Color.\n */\nfunction colorWithOpacity(color, opacity) {\n  if (color) {\n    if (color.a === 0 || opacity === 0) {\n      return undefined;\n    }\n    var a = color.a;\n    opacity = opacity === undefined ? 1 : opacity;\n    return 'rgba(' + Math.round(color.r * 255 / a) + ',' + Math.round(color.g * 255 / a) + ',' + Math.round(color.b * 255 / a) + ',' + a * opacity + ')';\n  }\n  return color;\n}\nvar templateRegEx = /^([^]*)\\{(.*)\\}([^]*)$/;\n/**\n * @private\n * @param {string} text Text.\n * @param {Object} properties Properties.\n * @return {string} Text.\n */\nfunction fromTemplate(text, properties) {\n  var parts;\n  do {\n    parts = text.match(templateRegEx);\n    if (parts) {\n      var value = properties[parts[2]] || '';\n      text = parts[1] + value + parts[3];\n    }\n  } while (parts);\n  return text;\n}\n/**\n * ```js\n * import stylefunction from 'ol-mapbox-style/dist/stylefunction';\n * ```\n * Creates a style function from the `glStyle` object for all layers that use\n * the specified `source`, which needs to be a `\"type\": \"vector\"` or\n * `\"type\": \"geojson\"` source and applies it to the specified OpenLayers layer.\n *\n * Two additional properties will be set on the provided layer:\n *\n *  * `mapbox-source`: The `id` of the Mapbox Style document's source that the\n *    OpenLayers layer was created from. Usually `apply()` creates one\n *    OpenLayers layer per Mapbox Style source, unless the layer stack has\n *    layers from different sources in between.\n *  * `mapbox-layers`: The `id`s of the Mapbox Style document's layers that are\n *    included in the OpenLayers layer.\n *\n * This function also works in a web worker. In worker mode, the main thread needs\n * to listen to messages from the worker and respond with another message to make\n * sure that sprite image loading works:\n *\n * ```js\n *  worker.addEventListener('message', event => {\n *   if (event.data.action === 'loadImage') {\n *     const image = new Image();\n *     image.crossOrigin = 'anonymous';\n *     image.addEventListener('load', function() {\n *       createImageBitmap(image, 0, 0, image.width, image.height).then(imageBitmap => {\n *         worker.postMessage({\n *           action: 'imageLoaded',\n *           image: imageBitmap,\n *           src: event.data.src\n *         }, [imageBitmap]);\n *       });\n *     });\n *     image.src = event.data.src;\n *   }\n * });\n * ```\n *\n * @param {VectorLayer|VectorTileLayer} olLayer OpenLayers layer to\n * apply the style to. In addition to the style, the layer will get two\n * properties: `mapbox-source` will be the `id` of the `glStyle`'s source used\n * for the layer, and `mapbox-layers` will be an array of the `id`s of the\n * `glStyle`'s layers.\n * @param {string|Object} glStyle Mapbox Style object.\n * @param {string|Array<string>} source `source` key or an array of layer `id`s\n * from the Mapbox Style object. When a `source` key is provided, all layers for\n * the specified source will be included in the style function. When layer `id`s\n * are provided, they must be from layers that use the same source.\n * @param {Array<number>} [resolutions=[78271.51696402048, 39135.75848201024,\n   19567.87924100512, 9783.93962050256, 4891.96981025128, 2445.98490512564,\n   1222.99245256282, 611.49622628141, 305.748113140705, 152.8740565703525,\n   76.43702828517625, 38.21851414258813, 19.109257071294063, 9.554628535647032,\n   4.777314267823516, 2.388657133911758, 1.194328566955879, 0.5971642834779395,\n   0.29858214173896974, 0.14929107086948487, 0.07464553543474244]]\n * Resolutions for mapping resolution to zoom level.\n * @param {Object} [spriteData=undefined] Sprite data from the url specified in\n * the Mapbox Style object's `sprite` property. Only required if a `sprite`\n * property is specified in the Mapbox Style object.\n * @param {Object} [spriteImageUrl=undefined] Sprite image url for the sprite\n * specified in the Mapbox Style object's `sprite` property. Only required if a\n * `sprite` property is specified in the Mapbox Style object.\n * @param {function(Array<string>):Array<string>} [getFonts=undefined] Function that\n * receives a font stack as arguments, and returns a (modified) font stack that\n * is available. Font names are the names used in the Mapbox Style object. If\n * not provided, the font stack will be used as-is. This function can also be\n * used for loading web fonts.\n * @return {StyleFunction} Style function for use in\n * `ol.layer.Vector` or `ol.layer.VectorTile`.\n */\nexport default function (olLayer, glStyle, source, resolutions, spriteData, spriteImageUrl, getFonts) {\n  if (resolutions === void 0) {\n    resolutions = defaultResolutions;\n  }\n  if (typeof glStyle == 'string') {\n    glStyle = JSON.parse(glStyle);\n  }\n  if (glStyle.version != 8) {\n    throw new Error('glStyle version 8 required.');\n  }\n  var spriteImage, spriteImgSize;\n  if (spriteImageUrl) {\n    if (typeof Image !== 'undefined') {\n      var img_1 = new Image();\n      img_1.crossOrigin = 'anonymous';\n      img_1.onload = function () {\n        spriteImage = img_1;\n        spriteImgSize = [img_1.width, img_1.height];\n        olLayer.changed();\n        img_1.onload = null;\n      };\n      img_1.src = spriteImageUrl;\n    } else if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {\n      //eslint-disable-line\n      var worker = /** @type {*} */self;\n      // Main thread needs to handle 'loadImage' and dispatch 'imageLoaded'\n      worker.postMessage({\n        action: 'loadImage',\n        src: spriteImageUrl\n      });\n      worker.addEventListener('message', function handler(event) {\n        if (event.data.action === 'imageLoaded' && event.data.src === spriteImageUrl) {\n          spriteImage = event.data.image;\n          spriteImgSize = [spriteImage.width, spriteImage.height];\n        }\n      });\n    }\n  }\n  var allLayers = derefLayers(glStyle.layers);\n  var layersBySourceLayer = {};\n  var mapboxLayers = [];\n  var mapboxSource;\n  for (var i = 0, ii = allLayers.length; i < ii; ++i) {\n    var layer = allLayers[i];\n    var layerId = layer.id;\n    if (typeof source == 'string' && layer.source == source || source.indexOf(layerId) !== -1) {\n      var sourceLayer = layer['source-layer'];\n      if (!mapboxSource) {\n        mapboxSource = layer.source;\n        var source_1 = glStyle.sources[mapboxSource];\n        if (!source_1) {\n          throw new Error(\"Source \\\"\" + mapboxSource + \"\\\" is not defined\");\n        }\n        var type = source_1.type;\n        if (type !== 'vector' && type !== 'geojson') {\n          throw new Error(\"Source \\\"\" + mapboxSource + \"\\\" is not of type \\\"vector\\\" or \\\"geojson\\\", but \\\"\" + type + \"\\\"\");\n        }\n      }\n      var layers = layersBySourceLayer[sourceLayer];\n      if (!layers) {\n        layers = layersBySourceLayer[sourceLayer] = [];\n      }\n      layers.push({\n        layer: layer,\n        index: i\n      });\n      mapboxLayers.push(layerId);\n    }\n    // TODO revisit when diffing gets added\n    delete functionCache[layerId];\n    delete filterCache[layerId];\n  }\n  var textHalo = new Stroke();\n  var textColor = new Fill();\n  var iconImageCache = {};\n  var patternCache = {};\n  var styles = [];\n  var styleFunction = function styleFunction(feature, resolution) {\n    var properties = feature.getProperties();\n    var layers = layersBySourceLayer[properties.layer];\n    if (!layers) {\n      return;\n    }\n    var zoom = resolutions.indexOf(resolution);\n    if (zoom == -1) {\n      zoom = getZoomForResolution(resolution, resolutions);\n    }\n    var type = types[feature.getGeometry().getType()];\n    var f = {\n      properties: properties,\n      type: type\n    };\n    var stylesLength = -1;\n    var _loop_1 = function _loop_1(i, ii) {\n      var layerData = layers[i];\n      var layer = layerData.layer;\n      var layerId = layer.id;\n      var layout = layer.layout || emptyObj;\n      var paint = layer.paint || emptyObj;\n      if (layout.visibility === 'none' || 'minzoom' in layer && zoom < layer.minzoom || 'maxzoom' in layer && zoom >= layer.maxzoom) {\n        return \"continue\";\n      }\n      var filter = layer.filter;\n      if (!filter || evaluateFilter(layerId, filter, f, zoom)) {\n        var color = void 0,\n          opacity = void 0,\n          fill = void 0,\n          stroke = void 0,\n          strokeColor = void 0,\n          style = void 0;\n        var index = layerData.index;\n        if (type == 3 && layer.type == 'fill') {\n          opacity = getValue(layer, 'paint', 'fill-opacity', zoom, f);\n          if ('fill-pattern' in paint) {\n            var fillIcon = getValue(layer, 'paint', 'fill-pattern', zoom, f);\n            if (fillIcon) {\n              var icon_1 = typeof fillIcon === 'string' ? fromTemplate(fillIcon, properties) : fillIcon.toString();\n              if (spriteImage && spriteData && spriteData[icon_1]) {\n                ++stylesLength;\n                style = styles[stylesLength];\n                if (!style || !style.getFill() || style.getStroke() || style.getText()) {\n                  style = styles[stylesLength] = new Style({\n                    fill: new Fill()\n                  });\n                }\n                fill = style.getFill();\n                style.setZIndex(index);\n                var icon_cache_key = icon_1 + '.' + opacity;\n                var pattern = patternCache[icon_cache_key];\n                if (!pattern) {\n                  var spriteImageData = spriteData[icon_1];\n                  var canvas = createCanvas(spriteImageData.width, spriteImageData.height);\n                  var ctx = /** @type {CanvasRenderingContext2D} */canvas.getContext('2d');\n                  ctx.globalAlpha = opacity;\n                  ctx.drawImage(spriteImage, spriteImageData.x, spriteImageData.y, spriteImageData.width, spriteImageData.height, 0, 0, spriteImageData.width, spriteImageData.height);\n                  pattern = ctx.createPattern(canvas, 'repeat');\n                  patternCache[icon_cache_key] = pattern;\n                }\n                fill.setColor(pattern);\n              }\n            }\n          } else {\n            color = colorWithOpacity(getValue(layer, 'paint', 'fill-color', zoom, f), opacity);\n            if (color) {\n              if ('fill-outline-color' in paint) {\n                strokeColor = colorWithOpacity(getValue(layer, 'paint', 'fill-outline-color', zoom, f), opacity);\n              }\n              if (!strokeColor) {\n                strokeColor = color;\n              }\n              ++stylesLength;\n              style = styles[stylesLength];\n              if (!style || !(style.getFill() && style.getStroke()) || style.getText()) {\n                style = styles[stylesLength] = new Style({\n                  fill: new Fill(),\n                  stroke: new Stroke()\n                });\n              }\n              fill = style.getFill();\n              fill.setColor(color);\n              stroke = style.getStroke();\n              stroke.setColor(strokeColor);\n              stroke.setWidth(1);\n              style.setZIndex(index);\n            }\n          }\n        }\n        if (type != 1 && layer.type == 'line') {\n          color = !('line-pattern' in paint) && 'line-color' in paint ? colorWithOpacity(getValue(layer, 'paint', 'line-color', zoom, f), getValue(layer, 'paint', 'line-opacity', zoom, f)) : undefined;\n          var width_1 = getValue(layer, 'paint', 'line-width', zoom, f);\n          if (color && width_1 > 0) {\n            ++stylesLength;\n            style = styles[stylesLength];\n            if (!style || !style.getStroke() || style.getFill() || style.getText()) {\n              style = styles[stylesLength] = new Style({\n                stroke: new Stroke()\n              });\n            }\n            stroke = style.getStroke();\n            stroke.setLineCap(getValue(layer, 'layout', 'line-cap', zoom, f));\n            stroke.setLineJoin(getValue(layer, 'layout', 'line-join', zoom, f));\n            stroke.setMiterLimit(getValue(layer, 'layout', 'line-miter-limit', zoom, f));\n            stroke.setColor(color);\n            stroke.setWidth(width_1);\n            stroke.setLineDash(paint['line-dasharray'] ? getValue(layer, 'paint', 'line-dasharray', zoom, f).map(function (x) {\n              return x * width_1;\n            }) : null);\n            style.setZIndex(index);\n          }\n        }\n        var hasImage = false;\n        var text = null;\n        var placementAngle = 0;\n        var icon = void 0,\n          iconImg = void 0,\n          skipLabel = void 0;\n        if ((type == 1 || type == 2) && 'icon-image' in layout) {\n          var iconImage = getValue(layer, 'layout', 'icon-image', zoom, f);\n          if (iconImage) {\n            icon = typeof iconImage === 'string' ? fromTemplate(iconImage, properties) : iconImage.toString();\n            var styleGeom = undefined;\n            if (spriteImage && spriteData && spriteData[icon]) {\n              var iconRotationAlignment = getValue(layer, 'layout', 'icon-rotation-alignment', zoom, f);\n              if (type == 2) {\n                var geom = feature.getGeometry();\n                // ol package and ol-debug.js only\n                if (geom.getFlatMidpoint || geom.getFlatMidpoints) {\n                  var extent = geom.getExtent();\n                  var size = Math.sqrt(Math.max(Math.pow((extent[2] - extent[0]) / resolution, 2), Math.pow((extent[3] - extent[1]) / resolution, 2)));\n                  if (size > 150) {\n                    //FIXME Do not hard-code a size of 150\n                    var midpoint = geom.getType() === 'MultiLineString' ? geom.getFlatMidpoints() : geom.getFlatMidpoint();\n                    if (!renderFeature) {\n                      renderFeatureCoordinates = [NaN, NaN];\n                      renderFeature = new RenderFeature('Point', renderFeatureCoordinates, [], {}, null);\n                    }\n                    styleGeom = renderFeature;\n                    renderFeatureCoordinates[0] = midpoint[0];\n                    renderFeatureCoordinates[1] = midpoint[1];\n                    var placement = getValue(layer, 'layout', 'symbol-placement', zoom, f);\n                    if (placement === 'line' && iconRotationAlignment === 'map') {\n                      var stride = geom.getStride();\n                      var coordinates = geom.getFlatCoordinates();\n                      for (var i_1 = 0, ii_1 = coordinates.length - stride; i_1 < ii_1; i_1 += stride) {\n                        var x1 = coordinates[i_1];\n                        var y1 = coordinates[i_1 + 1];\n                        var x2 = coordinates[i_1 + stride];\n                        var y2 = coordinates[i_1 + stride + 1];\n                        var minX = Math.min(x1, x2);\n                        var minY = Math.min(y1, y2);\n                        var maxX = Math.max(x1, x2);\n                        var maxY = Math.max(y1, y2);\n                        if (midpoint[0] >= minX && midpoint[0] <= maxX && midpoint[1] >= minY && midpoint[1] <= maxY) {\n                          placementAngle = Math.atan2(y1 - y2, x2 - x1);\n                          break;\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n              if (type !== 2 || styleGeom) {\n                ++stylesLength;\n                style = styles[stylesLength];\n                if (!style || !style.getImage() || style.getFill() || style.getStroke()) {\n                  style = styles[stylesLength] = new Style();\n                }\n                style.setGeometry(styleGeom);\n                var iconSize = getValue(layer, 'layout', 'icon-size', zoom, f);\n                var iconColor = paint['icon-color'] !== undefined ? getValue(layer, 'paint', 'icon-color', zoom, f) : null;\n                var icon_cache_key = icon + '.' + iconSize;\n                if (iconColor !== null) {\n                  icon_cache_key += '.' + iconColor;\n                }\n                iconImg = iconImageCache[icon_cache_key];\n                if (!iconImg) {\n                  var spriteImageData = spriteData[icon];\n                  if (iconColor !== null) {\n                    // cut out the sprite and color it\n                    var canvas = createCanvas(spriteImageData.width, spriteImageData.height);\n                    var ctx = /** @type {CanvasRenderingContext2D} */canvas.getContext('2d');\n                    ctx.drawImage(spriteImage, spriteImageData.x, spriteImageData.y, spriteImageData.width, spriteImageData.height, 0, 0, spriteImageData.width, spriteImageData.height);\n                    var data = ctx.getImageData(0, 0, canvas.width, canvas.height);\n                    for (var c = 0, cc = data.data.length; c < cc; c += 4) {\n                      var a = iconColor.a;\n                      if (a !== 0) {\n                        data.data[c] = iconColor.r * 255 / a;\n                        data.data[c + 1] = iconColor.g * 255 / a;\n                        data.data[c + 2] = iconColor.b * 255 / a;\n                      }\n                      data.data[c + 3] = a;\n                    }\n                    ctx.putImageData(data, 0, 0);\n                    iconImg = iconImageCache[icon_cache_key] = new Icon({\n                      img: canvas,\n                      imgSize: [canvas.width, canvas.height],\n                      scale: iconSize / spriteImageData.pixelRatio\n                    });\n                  } else {\n                    iconImg = iconImageCache[icon_cache_key] = new Icon({\n                      img: spriteImage,\n                      imgSize: spriteImgSize,\n                      size: [spriteImageData.width, spriteImageData.height],\n                      offset: [spriteImageData.x, spriteImageData.y],\n                      rotateWithView: iconRotationAlignment === 'map',\n                      scale: iconSize / spriteImageData.pixelRatio\n                    });\n                  }\n                }\n                iconImg.setRotation(placementAngle + deg2rad(getValue(layer, 'layout', 'icon-rotate', zoom, f)));\n                iconImg.setOpacity(getValue(layer, 'paint', 'icon-opacity', zoom, f));\n                iconImg.setAnchor(anchor[getValue(layer, 'layout', 'icon-anchor', zoom, f)]);\n                style.setImage(iconImg);\n                text = style.getText();\n                style.setText(undefined);\n                style.setZIndex(index);\n                hasImage = true;\n                skipLabel = false;\n              } else {\n                skipLabel = true;\n              }\n            }\n          }\n        }\n        if (type == 1 && 'circle-radius' in paint) {\n          ++stylesLength;\n          style = styles[stylesLength];\n          if (!style || !style.getImage() || style.getFill() || style.getStroke()) {\n            style = styles[stylesLength] = new Style();\n          }\n          var circleRadius = getValue(layer, 'paint', 'circle-radius', zoom, f);\n          var circleStrokeColor = colorWithOpacity(getValue(layer, 'paint', 'circle-stroke-color', zoom, f), getValue(layer, 'paint', 'circle-stroke-opacity', zoom, f));\n          var circleColor = colorWithOpacity(getValue(layer, 'paint', 'circle-color', zoom, f), getValue(layer, 'paint', 'circle-opacity', zoom, f));\n          var circleStrokeWidth = getValue(layer, 'paint', 'circle-stroke-width', zoom, f);\n          var cache_key = circleRadius + '.' + circleStrokeColor + '.' + circleColor + '.' + circleStrokeWidth;\n          iconImg = iconImageCache[cache_key];\n          if (!iconImg) {\n            iconImg = iconImageCache[cache_key] = new Circle({\n              radius: circleRadius,\n              stroke: circleStrokeColor && circleStrokeWidth > 0 ? new Stroke({\n                width: circleStrokeWidth,\n                color: circleStrokeColor\n              }) : undefined,\n              fill: circleColor ? new Fill({\n                color: circleColor\n              }) : undefined\n            });\n          }\n          style.setImage(iconImg);\n          text = style.getText();\n          style.setText(undefined);\n          style.setGeometry(undefined);\n          style.setZIndex(index);\n          hasImage = true;\n        }\n        var label = void 0;\n        if ('text-field' in layout) {\n          var textField = getValue(layer, 'layout', 'text-field', zoom, f).toString();\n          label = fromTemplate(textField, properties).trim();\n          opacity = getValue(layer, 'paint', 'text-opacity', zoom, f);\n        }\n        if (label && opacity && !skipLabel) {\n          if (!hasImage) {\n            ++stylesLength;\n            style = styles[stylesLength];\n            if (!style || !style.getText() || style.getFill() || style.getStroke()) {\n              style = styles[stylesLength] = new Style();\n            }\n            style.setImage(undefined);\n            style.setGeometry(undefined);\n          }\n          if (!style.getText()) {\n            style.setText(text || new Text({\n              padding: [2, 2, 2, 2]\n            }));\n          }\n          text = style.getText();\n          var textSize = Math.round(getValue(layer, 'layout', 'text-size', zoom, f));\n          var fontArray = getValue(layer, 'layout', 'text-font', zoom, f);\n          var textLineHeight = getValue(layer, 'layout', 'text-line-height', zoom, f);\n          var font = mb2css(getFonts ? getFonts(fontArray) : fontArray, textSize, textLineHeight);\n          var textTransform = layout['text-transform'];\n          if (textTransform == 'uppercase') {\n            label = label.toUpperCase();\n          } else if (textTransform == 'lowercase') {\n            label = label.toLowerCase();\n          }\n          var maxTextWidth = getValue(layer, 'layout', 'text-max-width', zoom, f);\n          var letterSpacing = getValue(layer, 'layout', 'text-letter-spacing', zoom, f);\n          var wrappedLabel = type == 2 ? applyLetterSpacing(label, letterSpacing) : wrapText(label, font, maxTextWidth, letterSpacing);\n          text.setText(wrappedLabel);\n          text.setFont(font);\n          text.setRotation(deg2rad(getValue(layer, 'layout', 'text-rotate', zoom, f)));\n          var textAnchor = getValue(layer, 'layout', 'text-anchor', zoom, f);\n          var placement = hasImage || type == 1 ? 'point' : getValue(layer, 'layout', 'symbol-placement', zoom, f);\n          text.setPlacement(placement);\n          var textHaloWidth = getValue(layer, 'paint', 'text-halo-width', zoom, f);\n          var textOffset = getValue(layer, 'layout', 'text-offset', zoom, f);\n          var textTranslate = getValue(layer, 'paint', 'text-translate', zoom, f);\n          // Text offset has to take halo width and line height into account\n          var vOffset = 0;\n          var hOffset = 0;\n          if (placement == 'point') {\n            var textAlign = 'center';\n            if (textAnchor.indexOf('left') !== -1) {\n              textAlign = 'left';\n              hOffset = textHaloWidth;\n            } else if (textAnchor.indexOf('right') !== -1) {\n              textAlign = 'right';\n              hOffset = -textHaloWidth;\n            }\n            text.setTextAlign(textAlign);\n            var textRotationAlignment = getValue(layer, 'layout', 'text-rotation-alignment', zoom, f);\n            text.setRotateWithView(textRotationAlignment == 'map');\n          } else {\n            text.setMaxAngle(deg2rad(getValue(layer, 'layout', 'text-max-angle', zoom, f)) * label.length / wrappedLabel.length);\n            text.setTextAlign();\n            text.setRotateWithView(false);\n          }\n          var textBaseline = 'middle';\n          if (textAnchor.indexOf('bottom') == 0) {\n            textBaseline = 'bottom';\n            vOffset = -textHaloWidth - 0.5 * (textLineHeight - 1) * textSize;\n          } else if (textAnchor.indexOf('top') == 0) {\n            textBaseline = 'top';\n            vOffset = textHaloWidth + 0.5 * (textLineHeight - 1) * textSize;\n          }\n          text.setTextBaseline(textBaseline);\n          text.setOffsetX(textOffset[0] * textSize + hOffset + textTranslate[0]);\n          text.setOffsetY(textOffset[1] * textSize + vOffset + textTranslate[1]);\n          textColor.setColor(colorWithOpacity(getValue(layer, 'paint', 'text-color', zoom, f), opacity));\n          text.setFill(textColor);\n          var haloColor = colorWithOpacity(getValue(layer, 'paint', 'text-halo-color', zoom, f), opacity);\n          if (haloColor) {\n            textHalo.setColor(haloColor);\n            // spec here : https://docs.mapbox.com/mapbox-gl-js/style-spec/#paint-symbol-text-halo-width\n            // Halo width must be doubled because it is applied around the center of the text outline\n            textHaloWidth *= 2;\n            // 1/4 of text size (spec) x 2\n            var halfTextSize = 0.5 * textSize;\n            textHalo.setWidth(textHaloWidth <= halfTextSize ? textHaloWidth : halfTextSize);\n            text.setStroke(textHalo);\n          } else {\n            text.setStroke(undefined);\n          }\n          var textPadding = getValue(layer, 'layout', 'text-padding', zoom, f);\n          var padding = text.getPadding();\n          if (textPadding !== padding[0]) {\n            padding[0] = padding[1] = padding[2] = padding[3] = textPadding;\n          }\n          style.setZIndex(index);\n        }\n      }\n    };\n    for (var i = 0, ii = layers.length; i < ii; ++i) {\n      _loop_1(i, ii);\n    }\n    if (stylesLength > -1) {\n      styles.length = stylesLength + 1;\n      return styles;\n    }\n  };\n  olLayer.setStyle(styleFunction);\n  olLayer.set('mapbox-source', mapboxSource);\n  olLayer.set('mapbox-layers', mapboxLayers);\n  return styleFunction;\n}\nexport { colorWithOpacity as _colorWithOpacity, filterCache as _filterCache, evaluateFilter as _evaluateFilter, fromTemplate as _fromTemplate, getValue as _getValue, functionCache as _functionCache };","map":{"version":3,"names":["Style","Fill","Stroke","Icon","Text","Circle","RenderFeature","derefLayers","expression","Color","function","fn","latest","spec","featureFilter","createFilter","mb2css","deg2rad","defaultResolutions","getZoomForResolution","wrapText","applyLetterSpacing","createCanvas","isFunction","convertFunction","isExpression","createPropertyExpression","types","anchor","expressionData","rawExpression","propertySpec","compiledExpression","result","Error","value","map","err","key","message","join","emptyObj","zoomObj","zoom","functionCache","renderFeatureCoordinates","renderFeature","getValue","layer","layoutOrPaint","property","feature","layerId","id","functions","value_1","type","undefined","default","isExpr","evaluate","bind","parse","filterCache","evaluateFilter","filter","colorWithOpacity","color","opacity","a","Math","round","r","g","b","templateRegEx","fromTemplate","text","properties","parts","match","olLayer","glStyle","source","resolutions","spriteData","spriteImageUrl","getFonts","JSON","version","spriteImage","spriteImgSize","Image","img_1","crossOrigin","onload","width","height","changed","src","WorkerGlobalScope","self","worker","postMessage","action","addEventListener","handler","event","data","image","allLayers","layers","layersBySourceLayer","mapboxLayers","mapboxSource","i","ii","length","indexOf","sourceLayer","source_1","sources","push","index","textHalo","textColor","iconImageCache","patternCache","styles","styleFunction","resolution","getProperties","getGeometry","getType","f","stylesLength","layerData","layout","paint","visibility","minzoom","maxzoom","fill","stroke","strokeColor","style","fillIcon","icon_1","toString","getFill","getStroke","getText","setZIndex","icon_cache_key","pattern","spriteImageData","canvas","ctx","getContext","globalAlpha","drawImage","x","y","createPattern","setColor","setWidth","width_1","setLineCap","setLineJoin","setMiterLimit","setLineDash","hasImage","placementAngle","icon","iconImg","skipLabel","iconImage","styleGeom","iconRotationAlignment","geom","getFlatMidpoint","getFlatMidpoints","extent","getExtent","size","sqrt","max","pow","midpoint","NaN","placement","stride","getStride","coordinates","getFlatCoordinates","i_1","ii_1","x1","y1","x2","y2","minX","min","minY","maxX","maxY","atan2","getImage","setGeometry","iconSize","iconColor","getImageData","c","cc","putImageData","img","imgSize","scale","pixelRatio","offset","rotateWithView","setRotation","setOpacity","setAnchor","setImage","setText","circleRadius","circleStrokeColor","circleColor","circleStrokeWidth","cache_key","radius","label","textField","trim","padding","textSize","fontArray","textLineHeight","font","textTransform","toUpperCase","toLowerCase","maxTextWidth","letterSpacing","wrappedLabel","setFont","textAnchor","setPlacement","textHaloWidth","textOffset","textTranslate","vOffset","hOffset","textAlign","setTextAlign","textRotationAlignment","setRotateWithView","setMaxAngle","textBaseline","setTextBaseline","setOffsetX","setOffsetY","setFill","haloColor","halfTextSize","setStroke","textPadding","getPadding","setStyle","set","_colorWithOpacity","_filterCache","_evaluateFilter","_fromTemplate","_getValue","_functionCache"],"sources":["/Users/mariovicky/Skripsi_OpenLayers/node_modules/ol-mapbox-style/src/stylefunction.js"],"sourcesContent":["/*\nol-mapbox-style - Use Mapbox Style objects with OpenLayers\nCopyright 2016-present ol-mapbox-style contributors\nLicense: https://raw.githubusercontent.com/openlayers/ol-mapbox-style/master/LICENSE\n*/\n\nimport Style from 'ol/style/Style';\nimport Fill from 'ol/style/Fill';\nimport Stroke from 'ol/style/Stroke';\nimport Icon from 'ol/style/Icon';\nimport Text from 'ol/style/Text';\nimport Circle from 'ol/style/Circle';\nimport RenderFeature from 'ol/render/Feature';\nimport {derefLayers} from '@mapbox/mapbox-gl-style-spec';\n\nimport {\n  expression, Color,\n  function as fn,\n  latest as spec,\n  featureFilter as createFilter\n} from '@mapbox/mapbox-gl-style-spec';\nimport mb2css from 'mapbox-to-css-font';\nimport {deg2rad, defaultResolutions, getZoomForResolution, wrapText, applyLetterSpacing, createCanvas} from './util';\n\n/**\n * @typedef {import(\"ol/layer/Vector\").default} VectorLayer\n * @typedef {import(\"ol/layer/VectorTile\").default} VectorTileLayer\n * @typedef {import(\"ol/style/Style\").StyleFunction} StyleFunction\n */\n\nconst isFunction = fn.isFunction;\nconst convertFunction = fn.convertFunction;\nconst isExpression = expression.isExpression;\nconst createPropertyExpression = expression.createPropertyExpression;\n\nconst types = {\n  'Point': 1,\n  'MultiPoint': 1,\n  'LineString': 2,\n  'MultiLineString': 2,\n  'Polygon': 3,\n  'MultiPolygon': 3\n};\nconst anchor = {\n  'center': [0.5, 0.5],\n  'left': [0, 0.5],\n  'right': [1, 0.5],\n  'top': [0.5, 0],\n  'bottom': [0.5, 1],\n  'top-left': [0, 0],\n  'top-right': [1, 0],\n  'bottom-left': [0, 1],\n  'bottom-right': [1, 1]\n};\n\nconst expressionData = function(rawExpression, propertySpec) {\n  const compiledExpression = createPropertyExpression(rawExpression, propertySpec);\n  if (compiledExpression.result === 'error') {\n    throw new Error(compiledExpression.value.map(err => `${err.key}: ${err.message}`).join(', '));\n  }\n  return compiledExpression.value;\n};\n\nconst emptyObj = {};\nconst zoomObj = {zoom: 0};\n/** @private */\nconst functionCache = {};\nlet renderFeatureCoordinates, renderFeature;\n\n/**\n * @private\n * @param {Object} layer Gl object layer.\n * @param {string} layoutOrPaint 'layout' or 'paint'.\n * @param {string} property Feature property.\n * @param {number} zoom Zoom.\n * @param {Object} feature Gl feature.\n * @return {?} Value.\n */\nexport function getValue(layer, layoutOrPaint, property, zoom, feature) {\n  const layerId = layer.id;\n  if (!functionCache[layerId]) {\n    functionCache[layerId] = {};\n  }\n  const functions = functionCache[layerId];\n  if (!functions[property]) {\n    let value = (layer[layoutOrPaint] || emptyObj)[property];\n    const propertySpec = spec[`${layoutOrPaint}_${layer.type}`][property];\n    if (value === undefined) {\n      value = propertySpec.default;\n    }\n    let isExpr = isExpression((value));\n    if (!isExpr && isFunction(value)) {\n      value = convertFunction(value, propertySpec);\n      isExpr = true;\n    }\n    if (isExpr) {\n      const compiledExpression = expressionData(value, propertySpec);\n      functions[property] = compiledExpression.evaluate.bind(compiledExpression);\n    } else {\n      if (propertySpec.type == 'color') {\n        value = Color.parse(value);\n      }\n      functions[property] = function() {\n        return value;\n      };\n    }\n  }\n  zoomObj.zoom = zoom;\n  return functions[property](zoomObj, feature);\n}\n\n/** @private */\nconst filterCache = {};\n\n/**\n * @private\n * @param {string} layerId Layer id.\n * @param {?} filter Filter.\n * @param {Object} feature Feature.\n * @param {number} zoom Zoom.\n * @return {boolean} Filter result.\n */\nfunction evaluateFilter(layerId, filter, feature, zoom) {\n  if (!(layerId in filterCache)) {\n    filterCache[layerId] = createFilter(filter).filter;\n  }\n  zoomObj.zoom = zoom;\n  return filterCache[layerId](zoomObj, feature);\n}\n\n/**\n * @private\n * @param {?} color Color.\n * @param {number} opacity Opacity.\n * @return {string} Color.\n */\nfunction colorWithOpacity(color, opacity) {\n  if (color) {\n    if (color.a === 0 || opacity === 0) {\n      return undefined;\n    }\n    const a = color.a;\n    opacity = opacity === undefined ? 1 : opacity;\n    return 'rgba(' + Math.round(color.r * 255 / a) + ',' + Math.round(color.g * 255 / a) +\n      ',' + Math.round(color.b * 255 / a) + ',' + (a * opacity) + ')';\n  }\n  return color;\n}\n\nconst templateRegEx = /^([^]*)\\{(.*)\\}([^]*)$/;\n\n/**\n * @private\n * @param {string} text Text.\n * @param {Object} properties Properties.\n * @return {string} Text.\n */\nfunction fromTemplate(text, properties) {\n  let parts;\n  do {\n    parts = text.match(templateRegEx);\n    if (parts) {\n      const value = properties[parts[2]] || '';\n      text = parts[1] + value + parts[3];\n    }\n  } while (parts);\n  return text;\n}\n\n/**\n * ```js\n * import stylefunction from 'ol-mapbox-style/dist/stylefunction';\n * ```\n * Creates a style function from the `glStyle` object for all layers that use\n * the specified `source`, which needs to be a `\"type\": \"vector\"` or\n * `\"type\": \"geojson\"` source and applies it to the specified OpenLayers layer.\n *\n * Two additional properties will be set on the provided layer:\n *\n *  * `mapbox-source`: The `id` of the Mapbox Style document's source that the\n *    OpenLayers layer was created from. Usually `apply()` creates one\n *    OpenLayers layer per Mapbox Style source, unless the layer stack has\n *    layers from different sources in between.\n *  * `mapbox-layers`: The `id`s of the Mapbox Style document's layers that are\n *    included in the OpenLayers layer.\n *\n * This function also works in a web worker. In worker mode, the main thread needs\n * to listen to messages from the worker and respond with another message to make\n * sure that sprite image loading works:\n *\n * ```js\n *  worker.addEventListener('message', event => {\n *   if (event.data.action === 'loadImage') {\n *     const image = new Image();\n *     image.crossOrigin = 'anonymous';\n *     image.addEventListener('load', function() {\n *       createImageBitmap(image, 0, 0, image.width, image.height).then(imageBitmap => {\n *         worker.postMessage({\n *           action: 'imageLoaded',\n *           image: imageBitmap,\n *           src: event.data.src\n *         }, [imageBitmap]);\n *       });\n *     });\n *     image.src = event.data.src;\n *   }\n * });\n * ```\n *\n * @param {VectorLayer|VectorTileLayer} olLayer OpenLayers layer to\n * apply the style to. In addition to the style, the layer will get two\n * properties: `mapbox-source` will be the `id` of the `glStyle`'s source used\n * for the layer, and `mapbox-layers` will be an array of the `id`s of the\n * `glStyle`'s layers.\n * @param {string|Object} glStyle Mapbox Style object.\n * @param {string|Array<string>} source `source` key or an array of layer `id`s\n * from the Mapbox Style object. When a `source` key is provided, all layers for\n * the specified source will be included in the style function. When layer `id`s\n * are provided, they must be from layers that use the same source.\n * @param {Array<number>} [resolutions=[78271.51696402048, 39135.75848201024,\n   19567.87924100512, 9783.93962050256, 4891.96981025128, 2445.98490512564,\n   1222.99245256282, 611.49622628141, 305.748113140705, 152.8740565703525,\n   76.43702828517625, 38.21851414258813, 19.109257071294063, 9.554628535647032,\n   4.777314267823516, 2.388657133911758, 1.194328566955879, 0.5971642834779395,\n   0.29858214173896974, 0.14929107086948487, 0.07464553543474244]]\n * Resolutions for mapping resolution to zoom level.\n * @param {Object} [spriteData=undefined] Sprite data from the url specified in\n * the Mapbox Style object's `sprite` property. Only required if a `sprite`\n * property is specified in the Mapbox Style object.\n * @param {Object} [spriteImageUrl=undefined] Sprite image url for the sprite\n * specified in the Mapbox Style object's `sprite` property. Only required if a\n * `sprite` property is specified in the Mapbox Style object.\n * @param {function(Array<string>):Array<string>} [getFonts=undefined] Function that\n * receives a font stack as arguments, and returns a (modified) font stack that\n * is available. Font names are the names used in the Mapbox Style object. If\n * not provided, the font stack will be used as-is. This function can also be\n * used for loading web fonts.\n * @return {StyleFunction} Style function for use in\n * `ol.layer.Vector` or `ol.layer.VectorTile`.\n */\nexport default function(olLayer, glStyle, source, resolutions = defaultResolutions, spriteData, spriteImageUrl, getFonts) {\n  if (typeof glStyle == 'string') {\n    glStyle = JSON.parse(glStyle);\n  }\n  if (glStyle.version != 8) {\n    throw new Error('glStyle version 8 required.');\n  }\n\n  let spriteImage, spriteImgSize;\n  if (spriteImageUrl) {\n    if (typeof Image !== 'undefined') {\n      const img = new Image();\n      img.crossOrigin = 'anonymous';\n      img.onload = function() {\n        spriteImage = img;\n        spriteImgSize = [img.width, img.height];\n        olLayer.changed();\n        img.onload = null;\n      };\n      img.src = spriteImageUrl;\n    } else if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) { //eslint-disable-line\n      const worker = /** @type {*} */ (self);\n      // Main thread needs to handle 'loadImage' and dispatch 'imageLoaded'\n      worker.postMessage({\n        action: 'loadImage',\n        src: spriteImageUrl\n      });\n      worker.addEventListener('message', function handler(event) {\n        if (event.data.action === 'imageLoaded' && event.data.src === spriteImageUrl) {\n          spriteImage = event.data.image;\n          spriteImgSize = [spriteImage.width, spriteImage.height];\n        }\n      });\n    }\n  }\n\n\n  const allLayers = derefLayers(glStyle.layers);\n\n  const layersBySourceLayer = {};\n  const mapboxLayers = [];\n  let mapboxSource;\n  for (let i = 0, ii = allLayers.length; i < ii; ++i) {\n    const layer = allLayers[i];\n    const layerId = layer.id;\n    if (typeof source == 'string' && layer.source == source ||\n        source.indexOf(layerId) !== -1) {\n      const sourceLayer = layer['source-layer'];\n      if (!mapboxSource) {\n        mapboxSource = layer.source;\n        const source = glStyle.sources[mapboxSource];\n        if (!source) {\n          throw new Error(`Source \"${mapboxSource}\" is not defined`);\n        }\n        const type = source.type;\n        if (type !== 'vector' && type !== 'geojson') {\n          throw new Error(`Source \"${mapboxSource}\" is not of type \"vector\" or \"geojson\", but \"${type}\"`);\n        }\n      }\n      let layers = layersBySourceLayer[sourceLayer];\n      if (!layers) {\n        layers = layersBySourceLayer[sourceLayer] = [];\n      }\n      layers.push({\n        layer: layer,\n        index: i\n      });\n      mapboxLayers.push(layerId);\n    }\n    // TODO revisit when diffing gets added\n    delete functionCache[layerId];\n    delete filterCache[layerId];\n  }\n\n  const textHalo = new Stroke();\n  const textColor = new Fill();\n\n  const iconImageCache = {};\n  const patternCache = {};\n  const styles = [];\n\n  const styleFunction = function(feature, resolution) {\n    const properties = feature.getProperties();\n    const layers = layersBySourceLayer[properties.layer];\n    if (!layers) {\n      return;\n    }\n    let zoom = resolutions.indexOf(resolution);\n    if (zoom == -1) {\n      zoom = getZoomForResolution(resolution, resolutions);\n    }\n    const type = types[feature.getGeometry().getType()];\n    const f = {\n      properties: properties,\n      type: type\n    };\n    let stylesLength = -1;\n    for (let i = 0, ii = layers.length; i < ii; ++i) {\n      const layerData = layers[i];\n      const layer = layerData.layer;\n      const layerId = layer.id;\n\n      const layout = layer.layout || emptyObj;\n      const paint = layer.paint || emptyObj;\n      if (layout.visibility === 'none' || ('minzoom' in layer && zoom < layer.minzoom) ||\n          ('maxzoom' in layer && zoom >= layer.maxzoom)) {\n        continue;\n      }\n      const filter = layer.filter;\n      if (!filter || evaluateFilter(layerId, filter, f, zoom)) {\n        let color, opacity, fill, stroke, strokeColor, style;\n        const index = layerData.index;\n        if (type == 3 && layer.type == 'fill') {\n          opacity = getValue(layer, 'paint', 'fill-opacity', zoom, f);\n          if ('fill-pattern' in paint) {\n            const fillIcon = getValue(layer, 'paint', 'fill-pattern', zoom, f);\n            if (fillIcon) {\n              const icon = typeof fillIcon === 'string'\n                ? fromTemplate(fillIcon, properties)\n                : fillIcon.toString();\n              if (spriteImage && spriteData && spriteData[icon]) {\n                ++stylesLength;\n                style = styles[stylesLength];\n                if (!style || !style.getFill() || style.getStroke() || style.getText()) {\n                  style = styles[stylesLength] = new Style({\n                    fill: new Fill()\n                  });\n                }\n                fill = style.getFill();\n                style.setZIndex(index);\n                const icon_cache_key = icon + '.' + opacity;\n                let pattern = patternCache[icon_cache_key];\n                if (!pattern) {\n                  const spriteImageData = spriteData[icon];\n                  const canvas = createCanvas(spriteImageData.width, spriteImageData.height);\n                  const ctx = /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));\n                  ctx.globalAlpha = opacity;\n                  ctx.drawImage(\n                    spriteImage,\n                    spriteImageData.x,\n                    spriteImageData.y,\n                    spriteImageData.width,\n                    spriteImageData.height,\n                    0,\n                    0,\n                    spriteImageData.width,\n                    spriteImageData.height\n                  );\n                  pattern = ctx.createPattern(canvas, 'repeat');\n                  patternCache[icon_cache_key] = pattern;\n                }\n                fill.setColor(pattern);\n              }\n            }\n          } else {\n            color = colorWithOpacity(getValue(layer, 'paint', 'fill-color', zoom, f), opacity);\n            if (color) {\n              if ('fill-outline-color' in paint) {\n                strokeColor = colorWithOpacity(getValue(layer, 'paint', 'fill-outline-color', zoom, f), opacity);\n              }\n              if (!strokeColor) {\n                strokeColor = color;\n              }\n              ++stylesLength;\n              style = styles[stylesLength];\n              if (!style || !(style.getFill() && style.getStroke()) || style.getText()) {\n                style = styles[stylesLength] = new Style({\n                  fill: new Fill(),\n                  stroke: new Stroke()\n                });\n              }\n              fill = style.getFill();\n              fill.setColor(color);\n              stroke = style.getStroke();\n              stroke.setColor(strokeColor);\n              stroke.setWidth(1);\n              style.setZIndex(index);\n            }\n          }\n        }\n        if (type != 1 && layer.type == 'line') {\n          color = !('line-pattern' in paint) && 'line-color' in paint ?\n            colorWithOpacity(getValue(layer, 'paint', 'line-color', zoom, f), getValue(layer, 'paint', 'line-opacity', zoom, f)) :\n            undefined;\n          const width = getValue(layer, 'paint', 'line-width', zoom, f);\n          if (color && width > 0) {\n            ++stylesLength;\n            style = styles[stylesLength];\n            if (!style || !style.getStroke() || style.getFill() || style.getText()) {\n              style = styles[stylesLength] = new Style({\n                stroke: new Stroke()\n              });\n            }\n            stroke = style.getStroke();\n            stroke.setLineCap(getValue(layer, 'layout', 'line-cap', zoom, f));\n            stroke.setLineJoin(getValue(layer, 'layout', 'line-join', zoom, f));\n            stroke.setMiterLimit(getValue(layer, 'layout', 'line-miter-limit', zoom, f));\n            stroke.setColor(color);\n            stroke.setWidth(width);\n            stroke.setLineDash(paint['line-dasharray'] ?\n              getValue(layer, 'paint', 'line-dasharray', zoom, f).map(function(x) {\n                return x * width;\n              }) : null);\n            style.setZIndex(index);\n          }\n        }\n\n        let hasImage = false;\n        let text = null;\n        let placementAngle = 0;\n        let icon, iconImg, skipLabel;\n        if ((type == 1 || type == 2) && 'icon-image' in layout) {\n          const iconImage = getValue(layer, 'layout', 'icon-image', zoom, f);\n          if (iconImage) {\n            icon = typeof iconImage === 'string'\n              ? fromTemplate(iconImage, properties)\n              : iconImage.toString();\n            let styleGeom = undefined;\n            if (spriteImage && spriteData && spriteData[icon]) {\n              const iconRotationAlignment = getValue(layer, 'layout', 'icon-rotation-alignment', zoom, f);\n              if (type == 2) {\n                const geom = feature.getGeometry();\n                // ol package and ol-debug.js only\n                if (geom.getFlatMidpoint || geom.getFlatMidpoints) {\n                  const extent = geom.getExtent();\n                  const size = Math.sqrt(Math.max(\n                    Math.pow((extent[2] - extent[0]) / resolution, 2),\n                    Math.pow((extent[3] - extent[1]) / resolution, 2))\n                  );\n                  if (size > 150) {\n                    //FIXME Do not hard-code a size of 150\n                    const midpoint = geom.getType() === 'MultiLineString' ? geom.getFlatMidpoints() : geom.getFlatMidpoint();\n                    if (!renderFeature) {\n                      renderFeatureCoordinates = [NaN, NaN];\n                      renderFeature = new RenderFeature('Point', renderFeatureCoordinates, [], {}, null);\n                    }\n                    styleGeom = renderFeature;\n                    renderFeatureCoordinates[0] = midpoint[0];\n                    renderFeatureCoordinates[1] = midpoint[1];\n                    const placement = getValue(layer, 'layout', 'symbol-placement', zoom, f);\n                    if (placement === 'line' && iconRotationAlignment === 'map') {\n                      const stride = geom.getStride();\n                      const coordinates = geom.getFlatCoordinates();\n                      for (let i = 0, ii = coordinates.length - stride; i < ii; i += stride) {\n                        const x1 = coordinates[i];\n                        const y1 = coordinates[i + 1];\n                        const x2 = coordinates[i + stride];\n                        const y2 = coordinates[i + stride + 1];\n                        const minX = Math.min(x1, x2);\n                        const minY = Math.min(y1, y2);\n                        const maxX = Math.max(x1, x2);\n                        const maxY = Math.max(y1, y2);\n                        if (midpoint[0] >= minX && midpoint[0] <= maxX &&\n                            midpoint[1] >= minY && midpoint[1] <= maxY) {\n                          placementAngle = Math.atan2(y1 - y2, x2 - x1);\n                          break;\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n              if (type !== 2 || styleGeom) {\n                ++stylesLength;\n                style = styles[stylesLength];\n                if (!style || !style.getImage() || style.getFill() || style.getStroke()) {\n                  style = styles[stylesLength] = new Style();\n                }\n                style.setGeometry(styleGeom);\n                const iconSize = getValue(layer, 'layout', 'icon-size', zoom, f);\n                const iconColor = paint['icon-color'] !== undefined ? getValue(layer, 'paint', 'icon-color', zoom, f) : null;\n                let icon_cache_key = icon + '.' + iconSize;\n                if (iconColor !== null) {\n                  icon_cache_key += '.' + iconColor;\n                }\n                iconImg = iconImageCache[icon_cache_key];\n                if (!iconImg) {\n                  const spriteImageData = spriteData[icon];\n                  if (iconColor !== null) {\n                    // cut out the sprite and color it\n                    const canvas = createCanvas(spriteImageData.width, spriteImageData.height);\n                    const ctx = /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));\n                    ctx.drawImage(\n                      spriteImage,\n                      spriteImageData.x,\n                      spriteImageData.y,\n                      spriteImageData.width,\n                      spriteImageData.height,\n                      0,\n                      0,\n                      spriteImageData.width,\n                      spriteImageData.height\n                    );\n                    const data = ctx.getImageData(0, 0, canvas.width, canvas.height);\n                    for (let c = 0, cc = data.data.length; c < cc; c += 4) {\n                      const a = iconColor.a;\n                      if (a !== 0) {\n                        data.data[c] = iconColor.r * 255 / a;\n                        data.data[c + 1] = iconColor.g * 255 / a;\n                        data.data[c + 2] = iconColor.b * 255 / a;\n                      }\n                      data.data[c + 3] = a;\n                    }\n                    ctx.putImageData(data, 0, 0);\n                    iconImg = iconImageCache[icon_cache_key] = new Icon({\n                      img: canvas,\n                      imgSize: [canvas.width, canvas.height],\n                      scale: iconSize / spriteImageData.pixelRatio\n                    });\n                  } else {\n                    iconImg = iconImageCache[icon_cache_key] = new Icon({\n                      img: spriteImage,\n                      imgSize: spriteImgSize,\n                      size: [spriteImageData.width, spriteImageData.height],\n                      offset: [spriteImageData.x, spriteImageData.y],\n                      rotateWithView: iconRotationAlignment === 'map',\n                      scale: iconSize / spriteImageData.pixelRatio\n                    });\n                  }\n                }\n                iconImg.setRotation(placementAngle + deg2rad(getValue(layer, 'layout', 'icon-rotate', zoom, f)));\n                iconImg.setOpacity(getValue(layer, 'paint', 'icon-opacity', zoom, f));\n                iconImg.setAnchor(anchor[getValue(layer, 'layout', 'icon-anchor', zoom, f)]);\n                style.setImage(iconImg);\n                text = style.getText();\n                style.setText(undefined);\n                style.setZIndex(index);\n                hasImage = true;\n                skipLabel = false;\n              } else {\n                skipLabel = true;\n              }\n            }\n          }\n        }\n\n        if (type == 1 && 'circle-radius' in paint) {\n          ++stylesLength;\n          style = styles[stylesLength];\n          if (!style || !style.getImage() || style.getFill() || style.getStroke()) {\n            style = styles[stylesLength] = new Style();\n          }\n          const circleRadius = getValue(layer, 'paint', 'circle-radius', zoom, f);\n          const circleStrokeColor = colorWithOpacity(getValue(layer, 'paint', 'circle-stroke-color', zoom, f), getValue(layer, 'paint', 'circle-stroke-opacity', zoom, f));\n          const circleColor = colorWithOpacity(getValue(layer, 'paint', 'circle-color', zoom, f), getValue(layer, 'paint', 'circle-opacity', zoom, f));\n          const circleStrokeWidth = getValue(layer, 'paint', 'circle-stroke-width', zoom, f);\n          const cache_key = circleRadius + '.' + circleStrokeColor + '.' +\n            circleColor + '.' + circleStrokeWidth;\n          iconImg = iconImageCache[cache_key];\n          if (!iconImg) {\n            iconImg = iconImageCache[cache_key] = new Circle({\n              radius: circleRadius,\n              stroke: circleStrokeColor && circleStrokeWidth > 0 ? new Stroke({\n                width: circleStrokeWidth,\n                color: circleStrokeColor\n              }) : undefined,\n              fill: circleColor ? new Fill({\n                color: circleColor\n              }) : undefined\n            });\n          }\n          style.setImage(iconImg);\n          text = style.getText();\n          style.setText(undefined);\n          style.setGeometry(undefined);\n          style.setZIndex(index);\n          hasImage = true;\n        }\n\n        let label;\n        if ('text-field' in layout) {\n          const textField = getValue(layer, 'layout', 'text-field', zoom, f).toString();\n          label = fromTemplate(textField, properties).trim();\n          opacity = getValue(layer, 'paint', 'text-opacity', zoom, f);\n        }\n        if (label && opacity && !skipLabel) {\n          if (!hasImage) {\n            ++stylesLength;\n            style = styles[stylesLength];\n            if (!style || !style.getText() || style.getFill() || style.getStroke()) {\n              style = styles[stylesLength] = new Style();\n            }\n            style.setImage(undefined);\n            style.setGeometry(undefined);\n          }\n          if (!style.getText()) {\n            style.setText(text || new Text({\n              padding: [2, 2, 2, 2]\n            }));\n          }\n          text = style.getText();\n          const textSize = Math.round(getValue(layer, 'layout', 'text-size', zoom, f));\n          const fontArray = getValue(layer, 'layout', 'text-font', zoom, f);\n          const textLineHeight = getValue(layer, 'layout', 'text-line-height', zoom, f);\n          const font = mb2css(getFonts ? getFonts(fontArray) : fontArray, textSize, textLineHeight);\n          const textTransform = layout['text-transform'];\n          if (textTransform == 'uppercase') {\n            label = label.toUpperCase();\n          } else if (textTransform == 'lowercase') {\n            label = label.toLowerCase();\n          }\n          const maxTextWidth = getValue(layer, 'layout', 'text-max-width', zoom, f);\n          const letterSpacing = getValue(layer, 'layout', 'text-letter-spacing', zoom, f);\n          const wrappedLabel = type == 2 ? applyLetterSpacing(label, letterSpacing) : wrapText(label, font, maxTextWidth, letterSpacing);\n          text.setText(wrappedLabel);\n          text.setFont(font);\n          text.setRotation(deg2rad(getValue(layer, 'layout', 'text-rotate', zoom, f)));\n          const textAnchor = getValue(layer, 'layout', 'text-anchor', zoom, f);\n          const placement = (hasImage || type == 1) ? 'point' : getValue(layer, 'layout', 'symbol-placement', zoom, f);\n          text.setPlacement(placement);\n          let textHaloWidth = getValue(layer, 'paint', 'text-halo-width', zoom, f);\n          const textOffset = getValue(layer, 'layout', 'text-offset', zoom, f);\n          const textTranslate = getValue(layer, 'paint', 'text-translate', zoom, f);\n          // Text offset has to take halo width and line height into account\n          let vOffset = 0;\n          let hOffset = 0;\n          if (placement == 'point') {\n            let textAlign = 'center';\n            if (textAnchor.indexOf('left') !== -1) {\n              textAlign = 'left';\n              hOffset = textHaloWidth;\n            } else if (textAnchor.indexOf('right') !== -1) {\n              textAlign = 'right';\n              hOffset = -textHaloWidth;\n            }\n            text.setTextAlign(textAlign);\n            const textRotationAlignment = getValue(layer, 'layout', 'text-rotation-alignment', zoom, f);\n            text.setRotateWithView(textRotationAlignment == 'map');\n          } else {\n            text.setMaxAngle(deg2rad(getValue(layer, 'layout', 'text-max-angle', zoom, f)) * label.length / wrappedLabel.length);\n            text.setTextAlign();\n            text.setRotateWithView(false);\n          }\n          let textBaseline = 'middle';\n          if (textAnchor.indexOf('bottom') == 0) {\n            textBaseline = 'bottom';\n            vOffset = -textHaloWidth - (0.5 * (textLineHeight - 1)) * textSize;\n          } else if (textAnchor.indexOf('top') == 0) {\n            textBaseline = 'top';\n            vOffset = textHaloWidth + (0.5 * (textLineHeight - 1)) * textSize;\n          }\n          text.setTextBaseline(textBaseline);\n          text.setOffsetX(textOffset[0] * textSize + hOffset + textTranslate[0]);\n          text.setOffsetY(textOffset[1] * textSize + vOffset + textTranslate[1]);\n          textColor.setColor(colorWithOpacity(getValue(layer, 'paint', 'text-color', zoom, f), opacity));\n          text.setFill(textColor);\n          const haloColor = colorWithOpacity(getValue(layer, 'paint', 'text-halo-color', zoom, f), opacity);\n          if (haloColor) {\n            textHalo.setColor(haloColor);\n            // spec here : https://docs.mapbox.com/mapbox-gl-js/style-spec/#paint-symbol-text-halo-width\n            // Halo width must be doubled because it is applied around the center of the text outline\n            textHaloWidth *= 2;\n            // 1/4 of text size (spec) x 2\n            const halfTextSize = 0.5 * textSize;\n            textHalo.setWidth(textHaloWidth <= halfTextSize ? textHaloWidth : halfTextSize);\n            text.setStroke(textHalo);\n          } else {\n            text.setStroke(undefined);\n          }\n          const textPadding = getValue(layer, 'layout', 'text-padding', zoom, f);\n          const padding = text.getPadding();\n          if (textPadding !== padding[0]) {\n            padding[0] = padding[1] = padding[2] = padding[3] = textPadding;\n          }\n          style.setZIndex(index);\n        }\n      }\n    }\n\n    if (stylesLength > -1) {\n      styles.length = stylesLength + 1;\n      return styles;\n    }\n  };\n\n  olLayer.setStyle(styleFunction);\n  olLayer.set('mapbox-source', mapboxSource);\n  olLayer.set('mapbox-layers', mapboxLayers);\n  return styleFunction;\n}\n\nexport {\n  colorWithOpacity as _colorWithOpacity,\n  filterCache as _filterCache,\n  evaluateFilter as _evaluateFilter,\n  fromTemplate as _fromTemplate,\n  getValue as _getValue,\n  functionCache as _functionCache\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
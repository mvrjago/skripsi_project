{"ast":null,"code":"/**\n * @module ol/MapBrowserEventHandler\n */\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport EventTarget from './events/Target.js';\nimport EventType from './events/EventType.js';\nimport MapBrowserEvent from './MapBrowserEvent.js';\nimport MapBrowserEventType from './MapBrowserEventType.js';\nimport PointerEventType from './pointer/EventType.js';\nimport { DEVICE_PIXEL_RATIO, PASSIVE_EVENT_LISTENERS } from './has.js';\nimport { listen, unlistenByKey } from './events.js';\nvar MapBrowserEventHandler = /** @class */function (_super) {\n  __extends(MapBrowserEventHandler, _super);\n  /**\n   * @param {import(\"./PluggableMap.js\").default} map The map with the viewport to listen to events on.\n   * @param {number=} moveTolerance The minimal distance the pointer must travel to trigger a move.\n   */\n  function MapBrowserEventHandler(map, moveTolerance) {\n    var _this = _super.call(this, map) || this;\n    /**\n     * This is the element that we will listen to the real events on.\n     * @type {import(\"./PluggableMap.js\").default}\n     * @private\n     */\n    _this.map_ = map;\n    /**\n     * @type {any}\n     * @private\n     */\n    _this.clickTimeoutId_;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    _this.dragging_ = false;\n    /**\n     * @type {!Array<import(\"./events.js\").EventsKey>}\n     * @private\n     */\n    _this.dragListenerKeys_ = [];\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.moveTolerance_ = moveTolerance ? moveTolerance * DEVICE_PIXEL_RATIO : DEVICE_PIXEL_RATIO;\n    /**\n     * The most recent \"down\" type event (or null if none have occurred).\n     * Set on pointerdown.\n     * @type {PointerEvent}\n     * @private\n     */\n    _this.down_ = null;\n    var element = _this.map_.getViewport();\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.activePointers_ = 0;\n    /**\n     * @type {!Object<number, boolean>}\n     * @private\n     */\n    _this.trackedTouches_ = {};\n    _this.element_ = element;\n    /**\n     * @type {?import(\"./events.js\").EventsKey}\n     * @private\n     */\n    _this.pointerdownListenerKey_ = listen(element, PointerEventType.POINTERDOWN, _this.handlePointerDown_, _this);\n    /**\n     * @type {PointerEvent}\n     * @private\n     */\n    _this.originalPointerMoveEvent_;\n    /**\n     * @type {?import(\"./events.js\").EventsKey}\n     * @private\n     */\n    _this.relayedListenerKey_ = listen(element, PointerEventType.POINTERMOVE, _this.relayEvent_, _this);\n    /**\n     * @private\n     */\n    _this.boundHandleTouchMove_ = _this.handleTouchMove_.bind(_this);\n    _this.element_.addEventListener(EventType.TOUCHMOVE, _this.boundHandleTouchMove_, PASSIVE_EVENT_LISTENERS ? {\n      passive: false\n    } : false);\n    return _this;\n  }\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  MapBrowserEventHandler.prototype.emulateClick_ = function (pointerEvent) {\n    var newEvent = new MapBrowserEvent(MapBrowserEventType.CLICK, this.map_, pointerEvent);\n    this.dispatchEvent(newEvent);\n    if (this.clickTimeoutId_ !== undefined) {\n      // double-click\n      clearTimeout(this.clickTimeoutId_);\n      this.clickTimeoutId_ = undefined;\n      newEvent = new MapBrowserEvent(MapBrowserEventType.DBLCLICK, this.map_, pointerEvent);\n      this.dispatchEvent(newEvent);\n    } else {\n      // click\n      this.clickTimeoutId_ = setTimeout(function () {\n        this.clickTimeoutId_ = undefined;\n        var newEvent = new MapBrowserEvent(MapBrowserEventType.SINGLECLICK, this.map_, pointerEvent);\n        this.dispatchEvent(newEvent);\n      }.bind(this), 250);\n    }\n  };\n  /**\n   * Keeps track on how many pointers are currently active.\n   *\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  MapBrowserEventHandler.prototype.updateActivePointers_ = function (pointerEvent) {\n    var event = pointerEvent;\n    if (event.type == MapBrowserEventType.POINTERUP || event.type == MapBrowserEventType.POINTERCANCEL) {\n      delete this.trackedTouches_[event.pointerId];\n    } else if (event.type == MapBrowserEventType.POINTERDOWN) {\n      this.trackedTouches_[event.pointerId] = true;\n    }\n    this.activePointers_ = Object.keys(this.trackedTouches_).length;\n  };\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  MapBrowserEventHandler.prototype.handlePointerUp_ = function (pointerEvent) {\n    this.updateActivePointers_(pointerEvent);\n    var newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERUP, this.map_, pointerEvent);\n    this.dispatchEvent(newEvent);\n    // We emulate click events on left mouse button click, touch contact, and pen\n    // contact. isMouseActionButton returns true in these cases (evt.button is set\n    // to 0).\n    // See http://www.w3.org/TR/pointerevents/#button-states\n    // We only fire click, singleclick, and doubleclick if nobody has called\n    // event.stopPropagation() or event.preventDefault().\n    if (!newEvent.propagationStopped && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {\n      this.emulateClick_(this.down_);\n    }\n    if (this.activePointers_ === 0) {\n      this.dragListenerKeys_.forEach(unlistenByKey);\n      this.dragListenerKeys_.length = 0;\n      this.dragging_ = false;\n      this.down_ = null;\n    }\n  };\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @return {boolean} If the left mouse button was pressed.\n   * @private\n   */\n  MapBrowserEventHandler.prototype.isMouseActionButton_ = function (pointerEvent) {\n    return pointerEvent.button === 0;\n  };\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  MapBrowserEventHandler.prototype.handlePointerDown_ = function (pointerEvent) {\n    this.updateActivePointers_(pointerEvent);\n    var newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERDOWN, this.map_, pointerEvent);\n    this.dispatchEvent(newEvent);\n    this.down_ = pointerEvent;\n    if (this.dragListenerKeys_.length === 0) {\n      this.dragListenerKeys_.push(listen(document, MapBrowserEventType.POINTERMOVE, this.handlePointerMove_, this), listen(document, MapBrowserEventType.POINTERUP, this.handlePointerUp_, this),\n      /* Note that the listener for `pointercancel is set up on\n       * `pointerEventHandler_` and not `documentPointerEventHandler_` like\n       * the `pointerup` and `pointermove` listeners.\n       *\n       * The reason for this is the following: `TouchSource.vacuumTouches_()`\n       * issues `pointercancel` events, when there was no `touchend` for a\n       * `touchstart`. Now, let's say a first `touchstart` is registered on\n       * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.\n       * But `documentPointerEventHandler_` doesn't know about the first\n       * `touchstart`. If there is no `touchend` for the `touchstart`, we can\n       * only receive a `touchcancel` from `pointerEventHandler_`, because it is\n       * only registered there.\n       */\n      listen(this.element_, MapBrowserEventType.POINTERCANCEL, this.handlePointerUp_, this));\n      if (this.element_.getRootNode && this.element_.getRootNode() !== document) {\n        this.dragListenerKeys_.push(listen(this.element_.getRootNode(), MapBrowserEventType.POINTERUP, this.handlePointerUp_, this));\n      }\n    }\n  };\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  MapBrowserEventHandler.prototype.handlePointerMove_ = function (pointerEvent) {\n    // Between pointerdown and pointerup, pointermove events are triggered.\n    // To avoid a 'false' touchmove event to be dispatched, we test if the pointer\n    // moved a significant distance.\n    if (this.isMoving_(pointerEvent)) {\n      this.dragging_ = true;\n      var newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERDRAG, this.map_, pointerEvent, this.dragging_);\n      this.dispatchEvent(newEvent);\n    }\n  };\n  /**\n   * Wrap and relay a pointer event.  Note that this requires that the type\n   * string for the MapBrowserEvent matches the PointerEvent type.\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  MapBrowserEventHandler.prototype.relayEvent_ = function (pointerEvent) {\n    this.originalPointerMoveEvent_ = pointerEvent;\n    var dragging = !!(this.down_ && this.isMoving_(pointerEvent));\n    this.dispatchEvent(new MapBrowserEvent(pointerEvent.type, this.map_, pointerEvent, dragging));\n  };\n  /**\n   * Flexible handling of a `touch-action: none` css equivalent: because calling\n   * `preventDefault()` on a `pointermove` event does not stop native page scrolling\n   * and zooming, we also listen for `touchmove` and call `preventDefault()` on it\n   * when an interaction (currently `DragPan` handles the event.\n   * @param {TouchEvent} event Event.\n   * @private\n   */\n  MapBrowserEventHandler.prototype.handleTouchMove_ = function (event) {\n    // Due to https://github.com/mpizenberg/elm-pep/issues/2, `this.originalPointerMoveEvent_`\n    // may not be initialized yet when we get here on a platform without native pointer events.\n    if (!this.originalPointerMoveEvent_ || this.originalPointerMoveEvent_.defaultPrevented) {\n      event.preventDefault();\n    }\n  };\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @return {boolean} Is moving.\n   * @private\n   */\n  MapBrowserEventHandler.prototype.isMoving_ = function (pointerEvent) {\n    return this.dragging_ || Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;\n  };\n  /**\n   * Clean up.\n   */\n  MapBrowserEventHandler.prototype.disposeInternal = function () {\n    if (this.relayedListenerKey_) {\n      unlistenByKey(this.relayedListenerKey_);\n      this.relayedListenerKey_ = null;\n    }\n    this.element_.removeEventListener(EventType.TOUCHMOVE, this.boundHandleTouchMove_);\n    if (this.pointerdownListenerKey_) {\n      unlistenByKey(this.pointerdownListenerKey_);\n      this.pointerdownListenerKey_ = null;\n    }\n    this.dragListenerKeys_.forEach(unlistenByKey);\n    this.dragListenerKeys_.length = 0;\n    this.element_ = null;\n    _super.prototype.disposeInternal.call(this);\n  };\n  return MapBrowserEventHandler;\n}(EventTarget);\nexport default MapBrowserEventHandler;","map":{"version":3,"names":["EventTarget","EventType","MapBrowserEvent","MapBrowserEventType","PointerEventType","DEVICE_PIXEL_RATIO","PASSIVE_EVENT_LISTENERS","listen","unlistenByKey","MapBrowserEventHandler","_super","__extends","map","moveTolerance","_this","call","map_","clickTimeoutId_","dragging_","dragListenerKeys_","moveTolerance_","down_","element","getViewport","activePointers_","trackedTouches_","element_","pointerdownListenerKey_","POINTERDOWN","handlePointerDown_","originalPointerMoveEvent_","relayedListenerKey_","POINTERMOVE","relayEvent_","boundHandleTouchMove_","handleTouchMove_","bind","addEventListener","TOUCHMOVE","passive","prototype","emulateClick_","pointerEvent","newEvent","CLICK","dispatchEvent","undefined","clearTimeout","DBLCLICK","setTimeout","SINGLECLICK","updateActivePointers_","event","type","POINTERUP","POINTERCANCEL","pointerId","Object","keys","length","handlePointerUp_","propagationStopped","isMouseActionButton_","forEach","button","push","document","handlePointerMove_","getRootNode","isMoving_","POINTERDRAG","dragging","defaultPrevented","preventDefault","Math","abs","clientX","clientY","disposeInternal","removeEventListener"],"sources":["/Users/mariovicky/Skripsi_OpenLayers/node_modules/ol/src/MapBrowserEventHandler.js"],"sourcesContent":["/**\n * @module ol/MapBrowserEventHandler\n */\n\nimport EventTarget from './events/Target.js';\nimport EventType from './events/EventType.js';\nimport MapBrowserEvent from './MapBrowserEvent.js';\nimport MapBrowserEventType from './MapBrowserEventType.js';\nimport PointerEventType from './pointer/EventType.js';\nimport {DEVICE_PIXEL_RATIO, PASSIVE_EVENT_LISTENERS} from './has.js';\nimport {listen, unlistenByKey} from './events.js';\n\nclass MapBrowserEventHandler extends EventTarget {\n  /**\n   * @param {import(\"./PluggableMap.js\").default} map The map with the viewport to listen to events on.\n   * @param {number=} moveTolerance The minimal distance the pointer must travel to trigger a move.\n   */\n  constructor(map, moveTolerance) {\n    super(map);\n\n    /**\n     * This is the element that we will listen to the real events on.\n     * @type {import(\"./PluggableMap.js\").default}\n     * @private\n     */\n    this.map_ = map;\n\n    /**\n     * @type {any}\n     * @private\n     */\n    this.clickTimeoutId_;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.dragging_ = false;\n\n    /**\n     * @type {!Array<import(\"./events.js\").EventsKey>}\n     * @private\n     */\n    this.dragListenerKeys_ = [];\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.moveTolerance_ = moveTolerance\n      ? moveTolerance * DEVICE_PIXEL_RATIO\n      : DEVICE_PIXEL_RATIO;\n\n    /**\n     * The most recent \"down\" type event (or null if none have occurred).\n     * Set on pointerdown.\n     * @type {PointerEvent}\n     * @private\n     */\n    this.down_ = null;\n\n    const element = this.map_.getViewport();\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.activePointers_ = 0;\n\n    /**\n     * @type {!Object<number, boolean>}\n     * @private\n     */\n    this.trackedTouches_ = {};\n\n    this.element_ = element;\n\n    /**\n     * @type {?import(\"./events.js\").EventsKey}\n     * @private\n     */\n    this.pointerdownListenerKey_ = listen(\n      element,\n      PointerEventType.POINTERDOWN,\n      this.handlePointerDown_,\n      this\n    );\n\n    /**\n     * @type {PointerEvent}\n     * @private\n     */\n    this.originalPointerMoveEvent_;\n\n    /**\n     * @type {?import(\"./events.js\").EventsKey}\n     * @private\n     */\n    this.relayedListenerKey_ = listen(\n      element,\n      PointerEventType.POINTERMOVE,\n      this.relayEvent_,\n      this\n    );\n\n    /**\n     * @private\n     */\n    this.boundHandleTouchMove_ = this.handleTouchMove_.bind(this);\n\n    this.element_.addEventListener(\n      EventType.TOUCHMOVE,\n      this.boundHandleTouchMove_,\n      PASSIVE_EVENT_LISTENERS ? {passive: false} : false\n    );\n  }\n\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  emulateClick_(pointerEvent) {\n    let newEvent = new MapBrowserEvent(\n      MapBrowserEventType.CLICK,\n      this.map_,\n      pointerEvent\n    );\n    this.dispatchEvent(newEvent);\n    if (this.clickTimeoutId_ !== undefined) {\n      // double-click\n      clearTimeout(this.clickTimeoutId_);\n      this.clickTimeoutId_ = undefined;\n      newEvent = new MapBrowserEvent(\n        MapBrowserEventType.DBLCLICK,\n        this.map_,\n        pointerEvent\n      );\n      this.dispatchEvent(newEvent);\n    } else {\n      // click\n      this.clickTimeoutId_ = setTimeout(\n        function () {\n          this.clickTimeoutId_ = undefined;\n          const newEvent = new MapBrowserEvent(\n            MapBrowserEventType.SINGLECLICK,\n            this.map_,\n            pointerEvent\n          );\n          this.dispatchEvent(newEvent);\n        }.bind(this),\n        250\n      );\n    }\n  }\n\n  /**\n   * Keeps track on how many pointers are currently active.\n   *\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  updateActivePointers_(pointerEvent) {\n    const event = pointerEvent;\n\n    if (\n      event.type == MapBrowserEventType.POINTERUP ||\n      event.type == MapBrowserEventType.POINTERCANCEL\n    ) {\n      delete this.trackedTouches_[event.pointerId];\n    } else if (event.type == MapBrowserEventType.POINTERDOWN) {\n      this.trackedTouches_[event.pointerId] = true;\n    }\n    this.activePointers_ = Object.keys(this.trackedTouches_).length;\n  }\n\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  handlePointerUp_(pointerEvent) {\n    this.updateActivePointers_(pointerEvent);\n    const newEvent = new MapBrowserEvent(\n      MapBrowserEventType.POINTERUP,\n      this.map_,\n      pointerEvent\n    );\n    this.dispatchEvent(newEvent);\n\n    // We emulate click events on left mouse button click, touch contact, and pen\n    // contact. isMouseActionButton returns true in these cases (evt.button is set\n    // to 0).\n    // See http://www.w3.org/TR/pointerevents/#button-states\n    // We only fire click, singleclick, and doubleclick if nobody has called\n    // event.stopPropagation() or event.preventDefault().\n    if (\n      !newEvent.propagationStopped &&\n      !this.dragging_ &&\n      this.isMouseActionButton_(pointerEvent)\n    ) {\n      this.emulateClick_(this.down_);\n    }\n\n    if (this.activePointers_ === 0) {\n      this.dragListenerKeys_.forEach(unlistenByKey);\n      this.dragListenerKeys_.length = 0;\n      this.dragging_ = false;\n      this.down_ = null;\n    }\n  }\n\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @return {boolean} If the left mouse button was pressed.\n   * @private\n   */\n  isMouseActionButton_(pointerEvent) {\n    return pointerEvent.button === 0;\n  }\n\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  handlePointerDown_(pointerEvent) {\n    this.updateActivePointers_(pointerEvent);\n    const newEvent = new MapBrowserEvent(\n      MapBrowserEventType.POINTERDOWN,\n      this.map_,\n      pointerEvent\n    );\n    this.dispatchEvent(newEvent);\n\n    this.down_ = pointerEvent;\n\n    if (this.dragListenerKeys_.length === 0) {\n      this.dragListenerKeys_.push(\n        listen(\n          document,\n          MapBrowserEventType.POINTERMOVE,\n          this.handlePointerMove_,\n          this\n        ),\n        listen(\n          document,\n          MapBrowserEventType.POINTERUP,\n          this.handlePointerUp_,\n          this\n        ),\n        /* Note that the listener for `pointercancel is set up on\n         * `pointerEventHandler_` and not `documentPointerEventHandler_` like\n         * the `pointerup` and `pointermove` listeners.\n         *\n         * The reason for this is the following: `TouchSource.vacuumTouches_()`\n         * issues `pointercancel` events, when there was no `touchend` for a\n         * `touchstart`. Now, let's say a first `touchstart` is registered on\n         * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.\n         * But `documentPointerEventHandler_` doesn't know about the first\n         * `touchstart`. If there is no `touchend` for the `touchstart`, we can\n         * only receive a `touchcancel` from `pointerEventHandler_`, because it is\n         * only registered there.\n         */\n        listen(\n          this.element_,\n          MapBrowserEventType.POINTERCANCEL,\n          this.handlePointerUp_,\n          this\n        )\n      );\n      if (\n        this.element_.getRootNode &&\n        this.element_.getRootNode() !== document\n      ) {\n        this.dragListenerKeys_.push(\n          listen(\n            this.element_.getRootNode(),\n            MapBrowserEventType.POINTERUP,\n            this.handlePointerUp_,\n            this\n          )\n        );\n      }\n    }\n  }\n\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  handlePointerMove_(pointerEvent) {\n    // Between pointerdown and pointerup, pointermove events are triggered.\n    // To avoid a 'false' touchmove event to be dispatched, we test if the pointer\n    // moved a significant distance.\n    if (this.isMoving_(pointerEvent)) {\n      this.dragging_ = true;\n      const newEvent = new MapBrowserEvent(\n        MapBrowserEventType.POINTERDRAG,\n        this.map_,\n        pointerEvent,\n        this.dragging_\n      );\n      this.dispatchEvent(newEvent);\n    }\n  }\n\n  /**\n   * Wrap and relay a pointer event.  Note that this requires that the type\n   * string for the MapBrowserEvent matches the PointerEvent type.\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  relayEvent_(pointerEvent) {\n    this.originalPointerMoveEvent_ = pointerEvent;\n    const dragging = !!(this.down_ && this.isMoving_(pointerEvent));\n    this.dispatchEvent(\n      new MapBrowserEvent(pointerEvent.type, this.map_, pointerEvent, dragging)\n    );\n  }\n\n  /**\n   * Flexible handling of a `touch-action: none` css equivalent: because calling\n   * `preventDefault()` on a `pointermove` event does not stop native page scrolling\n   * and zooming, we also listen for `touchmove` and call `preventDefault()` on it\n   * when an interaction (currently `DragPan` handles the event.\n   * @param {TouchEvent} event Event.\n   * @private\n   */\n  handleTouchMove_(event) {\n    // Due to https://github.com/mpizenberg/elm-pep/issues/2, `this.originalPointerMoveEvent_`\n    // may not be initialized yet when we get here on a platform without native pointer events.\n    if (\n      !this.originalPointerMoveEvent_ ||\n      this.originalPointerMoveEvent_.defaultPrevented\n    ) {\n      event.preventDefault();\n    }\n  }\n\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @return {boolean} Is moving.\n   * @private\n   */\n  isMoving_(pointerEvent) {\n    return (\n      this.dragging_ ||\n      Math.abs(pointerEvent.clientX - this.down_.clientX) >\n        this.moveTolerance_ ||\n      Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_\n    );\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    if (this.relayedListenerKey_) {\n      unlistenByKey(this.relayedListenerKey_);\n      this.relayedListenerKey_ = null;\n    }\n    this.element_.removeEventListener(\n      EventType.TOUCHMOVE,\n      this.boundHandleTouchMove_\n    );\n\n    if (this.pointerdownListenerKey_) {\n      unlistenByKey(this.pointerdownListenerKey_);\n      this.pointerdownListenerKey_ = null;\n    }\n\n    this.dragListenerKeys_.forEach(unlistenByKey);\n    this.dragListenerKeys_.length = 0;\n\n    this.element_ = null;\n    super.disposeInternal();\n  }\n}\n\nexport default MapBrowserEventHandler;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
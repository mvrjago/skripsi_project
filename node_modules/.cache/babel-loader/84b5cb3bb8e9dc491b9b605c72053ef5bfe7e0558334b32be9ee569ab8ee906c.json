{"ast":null,"code":"'use strict';\n\n// Load modules\nconst Any = require('../any');\nconst Hoek = require('hoek');\n\n// Declare internals\n\nconst internals = {};\ninternals.Binary = class extends Any {\n  constructor() {\n    super();\n    this._type = 'binary';\n  }\n  _base(value, state, options) {\n    const result = {\n      value\n    };\n    if (typeof value === 'string' && options.convert) {\n      try {\n        result.value = Buffer.from(value, this._flags.encoding);\n      } catch (e) {}\n    }\n    result.errors = Buffer.isBuffer(result.value) ? null : this.createError('binary.base', null, state, options);\n    return result;\n  }\n  encoding(encoding) {\n    Hoek.assert(Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);\n    if (this._flags.encoding === encoding) {\n      return this;\n    }\n    const obj = this.clone();\n    obj._flags.encoding = encoding;\n    return obj;\n  }\n  min(limit) {\n    Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n    return this._test('min', limit, function (value, state, options) {\n      if (value.length >= limit) {\n        return value;\n      }\n      return this.createError('binary.min', {\n        limit,\n        value\n      }, state, options);\n    });\n  }\n  max(limit) {\n    Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n    return this._test('max', limit, function (value, state, options) {\n      if (value.length <= limit) {\n        return value;\n      }\n      return this.createError('binary.max', {\n        limit,\n        value\n      }, state, options);\n    });\n  }\n  length(limit) {\n    Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n    return this._test('length', limit, function (value, state, options) {\n      if (value.length === limit) {\n        return value;\n      }\n      return this.createError('binary.length', {\n        limit,\n        value\n      }, state, options);\n    });\n  }\n};\nmodule.exports = new internals.Binary();","map":{"version":3,"names":["Any","require","Hoek","internals","Binary","constructor","_type","_base","value","state","options","result","convert","Buffer","from","_flags","encoding","e","errors","isBuffer","createError","assert","isEncoding","obj","clone","min","limit","Number","isSafeInteger","_test","length","max","module","exports"],"sources":["/Users/mariovicky/Skripsi_OpenLayers/node_modules/joi/lib/types/binary/index.js"],"sourcesContent":["'use strict';\n\n// Load modules\n\nconst Any = require('../any');\nconst Hoek = require('hoek');\n\n\n// Declare internals\n\nconst internals = {};\n\n\ninternals.Binary = class extends Any {\n\n    constructor() {\n\n        super();\n        this._type = 'binary';\n    }\n\n    _base(value, state, options) {\n\n        const result = {\n            value\n        };\n\n        if (typeof value === 'string' &&\n            options.convert) {\n\n            try {\n                result.value = Buffer.from(value, this._flags.encoding);\n            }\n            catch (e) {\n            }\n        }\n\n        result.errors = Buffer.isBuffer(result.value) ? null : this.createError('binary.base', null, state, options);\n        return result;\n    }\n\n    encoding(encoding) {\n\n        Hoek.assert(Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);\n\n        if (this._flags.encoding === encoding) {\n            return this;\n        }\n\n        const obj = this.clone();\n        obj._flags.encoding = encoding;\n        return obj;\n    }\n\n    min(limit) {\n\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\n        return this._test('min', limit, function (value, state, options) {\n\n            if (value.length >= limit) {\n                return value;\n            }\n\n            return this.createError('binary.min', { limit, value }, state, options);\n        });\n    }\n\n    max(limit) {\n\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\n        return this._test('max', limit, function (value, state, options) {\n\n            if (value.length <= limit) {\n                return value;\n            }\n\n            return this.createError('binary.max', { limit, value }, state, options);\n        });\n    }\n\n    length(limit) {\n\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\n        return this._test('length', limit, function (value, state, options) {\n\n            if (value.length === limit) {\n                return value;\n            }\n\n            return this.createError('binary.length', { limit, value }, state, options);\n        });\n    }\n\n};\n\n\nmodule.exports = new internals.Binary();\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}
{"ast":null,"code":"'use strict';\n\n// Load modules\nconst Hoek = require('hoek');\nconst Any = require('../any');\nconst Cast = require('../../cast');\nconst Ref = require('../../ref');\n\n// Declare internals\n\nconst internals = {};\ninternals.Alternatives = class extends Any {\n  constructor() {\n    super();\n    this._type = 'alternatives';\n    this._invalids.remove(null);\n    this._inner.matches = [];\n  }\n  _init() {\n    return arguments.length ? this.try(...arguments) : this;\n  }\n  _base(value, state, options) {\n    let errors = [];\n    const il = this._inner.matches.length;\n    const baseType = this._baseType;\n    for (let i = 0; i < il; ++i) {\n      const item = this._inner.matches[i];\n      if (!item.schema) {\n        const schema = item.peek || item.is;\n        const input = item.is ? item.ref(state.reference || state.parent, options) : value;\n        const failed = schema._validate(input, null, options, state.parent).errors;\n        if (failed) {\n          if (item.otherwise) {\n            return item.otherwise._validate(value, state, options);\n          }\n        } else if (item.then) {\n          return item.then._validate(value, state, options);\n        }\n        if (i === il - 1 && baseType) {\n          return baseType._validate(value, state, options);\n        }\n        continue;\n      }\n      const result = item.schema._validate(value, state, options);\n      if (!result.errors) {\n        // Found a valid match\n        return result;\n      }\n      errors = errors.concat(result.errors);\n    }\n    if (errors.length) {\n      return {\n        errors: this.createError('alternatives.child', {\n          reason: errors\n        }, state, options)\n      };\n    }\n    return {\n      errors: this.createError('alternatives.base', null, state, options)\n    };\n  }\n  try() {\n    for (var _len = arguments.length, schemas = new Array(_len), _key = 0; _key < _len; _key++) {\n      schemas[_key] = arguments[_key];\n    }\n    schemas = Hoek.flatten(schemas);\n    Hoek.assert(schemas.length, 'Cannot add other alternatives without at least one schema');\n    const obj = this.clone();\n    for (let i = 0; i < schemas.length; ++i) {\n      const cast = Cast.schema(this._currentJoi, schemas[i]);\n      if (cast._refs.length) {\n        obj._refs = obj._refs.concat(cast._refs);\n      }\n      obj._inner.matches.push({\n        schema: cast\n      });\n    }\n    return obj;\n  }\n  when(condition, options) {\n    let schemaCondition = false;\n    Hoek.assert(Ref.isRef(condition) || typeof condition === 'string' || (schemaCondition = condition instanceof Any), 'Invalid condition:', condition);\n    Hoek.assert(options, 'Missing options');\n    Hoek.assert(typeof options === 'object', 'Invalid options');\n    if (schemaCondition) {\n      Hoek.assert(!options.hasOwnProperty('is'), '\"is\" can not be used with a schema condition');\n    } else {\n      Hoek.assert(options.hasOwnProperty('is'), 'Missing \"is\" directive');\n    }\n    Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \"then\" or \"otherwise\"');\n    const obj = this.clone();\n    let is;\n    if (!schemaCondition) {\n      is = Cast.schema(this._currentJoi, options.is);\n      if (options.is === null || !(Ref.isRef(options.is) || options.is instanceof Any)) {\n        // Only apply required if this wasn't already a schema or a ref, we'll suppose people know what they're doing\n        is = is.required();\n      }\n    }\n    const item = {\n      ref: schemaCondition ? null : Cast.ref(condition),\n      peek: schemaCondition ? condition : null,\n      is,\n      then: options.then !== undefined ? Cast.schema(this._currentJoi, options.then) : undefined,\n      otherwise: options.otherwise !== undefined ? Cast.schema(this._currentJoi, options.otherwise) : undefined\n    };\n    if (obj._baseType) {\n      item.then = item.then && obj._baseType.concat(item.then);\n      item.otherwise = item.otherwise && obj._baseType.concat(item.otherwise);\n    }\n    if (!schemaCondition) {\n      Ref.push(obj._refs, item.ref);\n      obj._refs = obj._refs.concat(item.is._refs);\n    }\n    if (item.then && item.then._refs) {\n      obj._refs = obj._refs.concat(item.then._refs);\n    }\n    if (item.otherwise && item.otherwise._refs) {\n      obj._refs = obj._refs.concat(item.otherwise._refs);\n    }\n    obj._inner.matches.push(item);\n    return obj;\n  }\n  describe() {\n    const description = super.describe();\n    const alternatives = [];\n    for (let i = 0; i < this._inner.matches.length; ++i) {\n      const item = this._inner.matches[i];\n      if (item.schema) {\n        // try()\n\n        alternatives.push(item.schema.describe());\n      } else {\n        // when()\n\n        const when = item.is ? {\n          ref: item.ref.toString(),\n          is: item.is.describe()\n        } : {\n          peek: item.peek.describe()\n        };\n        if (item.then) {\n          when.then = item.then.describe();\n        }\n        if (item.otherwise) {\n          when.otherwise = item.otherwise.describe();\n        }\n        alternatives.push(when);\n      }\n    }\n    description.alternatives = alternatives;\n    return description;\n  }\n};\nmodule.exports = new internals.Alternatives();","map":{"version":3,"names":["Hoek","require","Any","Cast","Ref","internals","Alternatives","constructor","_type","_invalids","remove","_inner","matches","_init","arguments","length","try","_base","value","state","options","errors","il","baseType","_baseType","i","item","schema","peek","is","input","ref","reference","parent","failed","_validate","otherwise","then","result","concat","createError","reason","_len","schemas","Array","_key","flatten","assert","obj","clone","cast","_currentJoi","_refs","push","when","condition","schemaCondition","isRef","hasOwnProperty","undefined","required","describe","description","alternatives","toString","module","exports"],"sources":["/Users/mariovicky/Skripsi_OpenLayers/node_modules/joi/lib/types/alternatives/index.js"],"sourcesContent":["'use strict';\n\n// Load modules\n\nconst Hoek = require('hoek');\nconst Any = require('../any');\nconst Cast = require('../../cast');\nconst Ref = require('../../ref');\n\n\n// Declare internals\n\nconst internals = {};\n\n\ninternals.Alternatives = class extends Any {\n\n    constructor() {\n\n        super();\n        this._type = 'alternatives';\n        this._invalids.remove(null);\n        this._inner.matches = [];\n    }\n\n    _init(...args) {\n\n        return args.length ? this.try(...args) : this;\n    }\n\n    _base(value, state, options) {\n\n        let errors = [];\n        const il = this._inner.matches.length;\n        const baseType = this._baseType;\n\n        for (let i = 0; i < il; ++i) {\n            const item = this._inner.matches[i];\n            if (!item.schema) {\n                const schema = item.peek || item.is;\n                const input = item.is ? item.ref(state.reference || state.parent, options) : value;\n                const failed = schema._validate(input, null, options, state.parent).errors;\n\n                if (failed) {\n                    if (item.otherwise) {\n                        return item.otherwise._validate(value, state, options);\n                    }\n                }\n                else if (item.then) {\n                    return item.then._validate(value, state, options);\n                }\n\n                if (i === (il - 1) && baseType) {\n                    return baseType._validate(value, state, options);\n                }\n\n                continue;\n            }\n\n            const result = item.schema._validate(value, state, options);\n            if (!result.errors) {     // Found a valid match\n                return result;\n            }\n\n            errors = errors.concat(result.errors);\n        }\n\n        if (errors.length) {\n            return { errors: this.createError('alternatives.child', { reason: errors }, state, options) };\n        }\n\n        return { errors: this.createError('alternatives.base', null, state, options) };\n    }\n\n    try(...schemas) {\n\n        schemas = Hoek.flatten(schemas);\n        Hoek.assert(schemas.length, 'Cannot add other alternatives without at least one schema');\n\n        const obj = this.clone();\n\n        for (let i = 0; i < schemas.length; ++i) {\n            const cast = Cast.schema(this._currentJoi, schemas[i]);\n            if (cast._refs.length) {\n                obj._refs = obj._refs.concat(cast._refs);\n            }\n            obj._inner.matches.push({ schema: cast });\n        }\n\n        return obj;\n    }\n\n    when(condition, options) {\n\n        let schemaCondition = false;\n        Hoek.assert(Ref.isRef(condition) || typeof condition === 'string' || (schemaCondition = condition instanceof Any), 'Invalid condition:', condition);\n        Hoek.assert(options, 'Missing options');\n        Hoek.assert(typeof options === 'object', 'Invalid options');\n        if (schemaCondition) {\n            Hoek.assert(!options.hasOwnProperty('is'), '\"is\" can not be used with a schema condition');\n        }\n        else {\n            Hoek.assert(options.hasOwnProperty('is'), 'Missing \"is\" directive');\n        }\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \"then\" or \"otherwise\"');\n\n        const obj = this.clone();\n        let is;\n        if (!schemaCondition) {\n            is = Cast.schema(this._currentJoi, options.is);\n\n            if (options.is === null || !(Ref.isRef(options.is) || options.is instanceof Any)) {\n\n                // Only apply required if this wasn't already a schema or a ref, we'll suppose people know what they're doing\n                is = is.required();\n            }\n        }\n\n        const item = {\n            ref: schemaCondition ? null : Cast.ref(condition),\n            peek: schemaCondition ? condition : null,\n            is,\n            then: options.then !== undefined ? Cast.schema(this._currentJoi, options.then) : undefined,\n            otherwise: options.otherwise !== undefined ? Cast.schema(this._currentJoi, options.otherwise) : undefined\n        };\n\n        if (obj._baseType) {\n\n            item.then = item.then && obj._baseType.concat(item.then);\n            item.otherwise = item.otherwise && obj._baseType.concat(item.otherwise);\n        }\n\n        if (!schemaCondition) {\n            Ref.push(obj._refs, item.ref);\n            obj._refs = obj._refs.concat(item.is._refs);\n        }\n\n        if (item.then && item.then._refs) {\n            obj._refs = obj._refs.concat(item.then._refs);\n        }\n\n        if (item.otherwise && item.otherwise._refs) {\n            obj._refs = obj._refs.concat(item.otherwise._refs);\n        }\n\n        obj._inner.matches.push(item);\n\n        return obj;\n    }\n\n    describe() {\n\n        const description = super.describe();\n        const alternatives = [];\n        for (let i = 0; i < this._inner.matches.length; ++i) {\n            const item = this._inner.matches[i];\n            if (item.schema) {\n\n                // try()\n\n                alternatives.push(item.schema.describe());\n            }\n            else {\n\n                // when()\n\n                const when = item.is ? {\n                    ref: item.ref.toString(),\n                    is: item.is.describe()\n                } : {\n                    peek: item.peek.describe()\n                };\n\n                if (item.then) {\n                    when.then = item.then.describe();\n                }\n\n                if (item.otherwise) {\n                    when.otherwise = item.otherwise.describe();\n                }\n\n                alternatives.push(when);\n            }\n        }\n\n        description.alternatives = alternatives;\n        return description;\n    }\n\n};\n\n\nmodule.exports = new internals.Alternatives();\n"],"mappings":"AAAA,YAAY;;AAEZ;AAEA,MAAMA,IAAI,GAAGC,OAAO,CAAC,MAAM,CAAC;AAC5B,MAAMC,GAAG,GAAGD,OAAO,CAAC,QAAQ,CAAC;AAC7B,MAAME,IAAI,GAAGF,OAAO,CAAC,YAAY,CAAC;AAClC,MAAMG,GAAG,GAAGH,OAAO,CAAC,WAAW,CAAC;;AAGhC;;AAEA,MAAMI,SAAS,GAAG,CAAC,CAAC;AAGpBA,SAAS,CAACC,YAAY,GAAG,cAAcJ,GAAG,CAAC;EAEvCK,WAAWA,CAAA,EAAG;IAEV,KAAK,CAAC,CAAC;IACP,IAAI,CAACC,KAAK,GAAG,cAAc;IAC3B,IAAI,CAACC,SAAS,CAACC,MAAM,CAAC,IAAI,CAAC;IAC3B,IAAI,CAACC,MAAM,CAACC,OAAO,GAAG,EAAE;EAC5B;EAEAC,KAAKA,CAAA,EAAU;IAEX,OAAOC,SAAA,CAAKC,MAAM,GAAG,IAAI,CAACC,GAAG,CAAC,GAAAF,SAAO,CAAC,GAAG,IAAI;EACjD;EAEAG,KAAKA,CAACC,KAAK,EAAEC,KAAK,EAAEC,OAAO,EAAE;IAEzB,IAAIC,MAAM,GAAG,EAAE;IACf,MAAMC,EAAE,GAAG,IAAI,CAACX,MAAM,CAACC,OAAO,CAACG,MAAM;IACrC,MAAMQ,QAAQ,GAAG,IAAI,CAACC,SAAS;IAE/B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,EAAE,EAAE,EAAEG,CAAC,EAAE;MACzB,MAAMC,IAAI,GAAG,IAAI,CAACf,MAAM,CAACC,OAAO,CAACa,CAAC,CAAC;MACnC,IAAI,CAACC,IAAI,CAACC,MAAM,EAAE;QACd,MAAMA,MAAM,GAAGD,IAAI,CAACE,IAAI,IAAIF,IAAI,CAACG,EAAE;QACnC,MAAMC,KAAK,GAAGJ,IAAI,CAACG,EAAE,GAAGH,IAAI,CAACK,GAAG,CAACZ,KAAK,CAACa,SAAS,IAAIb,KAAK,CAACc,MAAM,EAAEb,OAAO,CAAC,GAAGF,KAAK;QAClF,MAAMgB,MAAM,GAAGP,MAAM,CAACQ,SAAS,CAACL,KAAK,EAAE,IAAI,EAAEV,OAAO,EAAED,KAAK,CAACc,MAAM,CAAC,CAACZ,MAAM;QAE1E,IAAIa,MAAM,EAAE;UACR,IAAIR,IAAI,CAACU,SAAS,EAAE;YAChB,OAAOV,IAAI,CAACU,SAAS,CAACD,SAAS,CAACjB,KAAK,EAAEC,KAAK,EAAEC,OAAO,CAAC;UAC1D;QACJ,CAAC,MACI,IAAIM,IAAI,CAACW,IAAI,EAAE;UAChB,OAAOX,IAAI,CAACW,IAAI,CAACF,SAAS,CAACjB,KAAK,EAAEC,KAAK,EAAEC,OAAO,CAAC;QACrD;QAEA,IAAIK,CAAC,KAAMH,EAAE,GAAG,CAAE,IAAIC,QAAQ,EAAE;UAC5B,OAAOA,QAAQ,CAACY,SAAS,CAACjB,KAAK,EAAEC,KAAK,EAAEC,OAAO,CAAC;QACpD;QAEA;MACJ;MAEA,MAAMkB,MAAM,GAAGZ,IAAI,CAACC,MAAM,CAACQ,SAAS,CAACjB,KAAK,EAAEC,KAAK,EAAEC,OAAO,CAAC;MAC3D,IAAI,CAACkB,MAAM,CAACjB,MAAM,EAAE;QAAM;QACtB,OAAOiB,MAAM;MACjB;MAEAjB,MAAM,GAAGA,MAAM,CAACkB,MAAM,CAACD,MAAM,CAACjB,MAAM,CAAC;IACzC;IAEA,IAAIA,MAAM,CAACN,MAAM,EAAE;MACf,OAAO;QAAEM,MAAM,EAAE,IAAI,CAACmB,WAAW,CAAC,oBAAoB,EAAE;UAAEC,MAAM,EAAEpB;QAAO,CAAC,EAAEF,KAAK,EAAEC,OAAO;MAAE,CAAC;IACjG;IAEA,OAAO;MAAEC,MAAM,EAAE,IAAI,CAACmB,WAAW,CAAC,mBAAmB,EAAE,IAAI,EAAErB,KAAK,EAAEC,OAAO;IAAE,CAAC;EAClF;EAEAJ,GAAGA,CAAA,EAAa;IAAA,SAAA0B,IAAA,GAAA5B,SAAA,CAAAC,MAAA,EAAT4B,OAAO,OAAAC,KAAA,CAAAF,IAAA,GAAAG,IAAA,MAAAA,IAAA,GAAAH,IAAA,EAAAG,IAAA;MAAPF,OAAO,CAAAE,IAAA,IAAA/B,SAAA,CAAA+B,IAAA;IAAA;IAEVF,OAAO,GAAG3C,IAAI,CAAC8C,OAAO,CAACH,OAAO,CAAC;IAC/B3C,IAAI,CAAC+C,MAAM,CAACJ,OAAO,CAAC5B,MAAM,EAAE,2DAA2D,CAAC;IAExF,MAAMiC,GAAG,GAAG,IAAI,CAACC,KAAK,CAAC,CAAC;IAExB,KAAK,IAAIxB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkB,OAAO,CAAC5B,MAAM,EAAE,EAAEU,CAAC,EAAE;MACrC,MAAMyB,IAAI,GAAG/C,IAAI,CAACwB,MAAM,CAAC,IAAI,CAACwB,WAAW,EAAER,OAAO,CAAClB,CAAC,CAAC,CAAC;MACtD,IAAIyB,IAAI,CAACE,KAAK,CAACrC,MAAM,EAAE;QACnBiC,GAAG,CAACI,KAAK,GAAGJ,GAAG,CAACI,KAAK,CAACb,MAAM,CAACW,IAAI,CAACE,KAAK,CAAC;MAC5C;MACAJ,GAAG,CAACrC,MAAM,CAACC,OAAO,CAACyC,IAAI,CAAC;QAAE1B,MAAM,EAAEuB;MAAK,CAAC,CAAC;IAC7C;IAEA,OAAOF,GAAG;EACd;EAEAM,IAAIA,CAACC,SAAS,EAAEnC,OAAO,EAAE;IAErB,IAAIoC,eAAe,GAAG,KAAK;IAC3BxD,IAAI,CAAC+C,MAAM,CAAC3C,GAAG,CAACqD,KAAK,CAACF,SAAS,CAAC,IAAI,OAAOA,SAAS,KAAK,QAAQ,KAAKC,eAAe,GAAGD,SAAS,YAAYrD,GAAG,CAAC,EAAE,oBAAoB,EAAEqD,SAAS,CAAC;IACnJvD,IAAI,CAAC+C,MAAM,CAAC3B,OAAO,EAAE,iBAAiB,CAAC;IACvCpB,IAAI,CAAC+C,MAAM,CAAC,OAAO3B,OAAO,KAAK,QAAQ,EAAE,iBAAiB,CAAC;IAC3D,IAAIoC,eAAe,EAAE;MACjBxD,IAAI,CAAC+C,MAAM,CAAC,CAAC3B,OAAO,CAACsC,cAAc,CAAC,IAAI,CAAC,EAAE,8CAA8C,CAAC;IAC9F,CAAC,MACI;MACD1D,IAAI,CAAC+C,MAAM,CAAC3B,OAAO,CAACsC,cAAc,CAAC,IAAI,CAAC,EAAE,wBAAwB,CAAC;IACvE;IACA1D,IAAI,CAAC+C,MAAM,CAAC3B,OAAO,CAACiB,IAAI,KAAKsB,SAAS,IAAIvC,OAAO,CAACgB,SAAS,KAAKuB,SAAS,EAAE,yDAAyD,CAAC;IAErI,MAAMX,GAAG,GAAG,IAAI,CAACC,KAAK,CAAC,CAAC;IACxB,IAAIpB,EAAE;IACN,IAAI,CAAC2B,eAAe,EAAE;MAClB3B,EAAE,GAAG1B,IAAI,CAACwB,MAAM,CAAC,IAAI,CAACwB,WAAW,EAAE/B,OAAO,CAACS,EAAE,CAAC;MAE9C,IAAIT,OAAO,CAACS,EAAE,KAAK,IAAI,IAAI,EAAEzB,GAAG,CAACqD,KAAK,CAACrC,OAAO,CAACS,EAAE,CAAC,IAAIT,OAAO,CAACS,EAAE,YAAY3B,GAAG,CAAC,EAAE;QAE9E;QACA2B,EAAE,GAAGA,EAAE,CAAC+B,QAAQ,CAAC,CAAC;MACtB;IACJ;IAEA,MAAMlC,IAAI,GAAG;MACTK,GAAG,EAAEyB,eAAe,GAAG,IAAI,GAAGrD,IAAI,CAAC4B,GAAG,CAACwB,SAAS,CAAC;MACjD3B,IAAI,EAAE4B,eAAe,GAAGD,SAAS,GAAG,IAAI;MACxC1B,EAAE;MACFQ,IAAI,EAAEjB,OAAO,CAACiB,IAAI,KAAKsB,SAAS,GAAGxD,IAAI,CAACwB,MAAM,CAAC,IAAI,CAACwB,WAAW,EAAE/B,OAAO,CAACiB,IAAI,CAAC,GAAGsB,SAAS;MAC1FvB,SAAS,EAAEhB,OAAO,CAACgB,SAAS,KAAKuB,SAAS,GAAGxD,IAAI,CAACwB,MAAM,CAAC,IAAI,CAACwB,WAAW,EAAE/B,OAAO,CAACgB,SAAS,CAAC,GAAGuB;IACpG,CAAC;IAED,IAAIX,GAAG,CAACxB,SAAS,EAAE;MAEfE,IAAI,CAACW,IAAI,GAAGX,IAAI,CAACW,IAAI,IAAIW,GAAG,CAACxB,SAAS,CAACe,MAAM,CAACb,IAAI,CAACW,IAAI,CAAC;MACxDX,IAAI,CAACU,SAAS,GAAGV,IAAI,CAACU,SAAS,IAAIY,GAAG,CAACxB,SAAS,CAACe,MAAM,CAACb,IAAI,CAACU,SAAS,CAAC;IAC3E;IAEA,IAAI,CAACoB,eAAe,EAAE;MAClBpD,GAAG,CAACiD,IAAI,CAACL,GAAG,CAACI,KAAK,EAAE1B,IAAI,CAACK,GAAG,CAAC;MAC7BiB,GAAG,CAACI,KAAK,GAAGJ,GAAG,CAACI,KAAK,CAACb,MAAM,CAACb,IAAI,CAACG,EAAE,CAACuB,KAAK,CAAC;IAC/C;IAEA,IAAI1B,IAAI,CAACW,IAAI,IAAIX,IAAI,CAACW,IAAI,CAACe,KAAK,EAAE;MAC9BJ,GAAG,CAACI,KAAK,GAAGJ,GAAG,CAACI,KAAK,CAACb,MAAM,CAACb,IAAI,CAACW,IAAI,CAACe,KAAK,CAAC;IACjD;IAEA,IAAI1B,IAAI,CAACU,SAAS,IAAIV,IAAI,CAACU,SAAS,CAACgB,KAAK,EAAE;MACxCJ,GAAG,CAACI,KAAK,GAAGJ,GAAG,CAACI,KAAK,CAACb,MAAM,CAACb,IAAI,CAACU,SAAS,CAACgB,KAAK,CAAC;IACtD;IAEAJ,GAAG,CAACrC,MAAM,CAACC,OAAO,CAACyC,IAAI,CAAC3B,IAAI,CAAC;IAE7B,OAAOsB,GAAG;EACd;EAEAa,QAAQA,CAAA,EAAG;IAEP,MAAMC,WAAW,GAAG,KAAK,CAACD,QAAQ,CAAC,CAAC;IACpC,MAAME,YAAY,GAAG,EAAE;IACvB,KAAK,IAAItC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACd,MAAM,CAACC,OAAO,CAACG,MAAM,EAAE,EAAEU,CAAC,EAAE;MACjD,MAAMC,IAAI,GAAG,IAAI,CAACf,MAAM,CAACC,OAAO,CAACa,CAAC,CAAC;MACnC,IAAIC,IAAI,CAACC,MAAM,EAAE;QAEb;;QAEAoC,YAAY,CAACV,IAAI,CAAC3B,IAAI,CAACC,MAAM,CAACkC,QAAQ,CAAC,CAAC,CAAC;MAC7C,CAAC,MACI;QAED;;QAEA,MAAMP,IAAI,GAAG5B,IAAI,CAACG,EAAE,GAAG;UACnBE,GAAG,EAAEL,IAAI,CAACK,GAAG,CAACiC,QAAQ,CAAC,CAAC;UACxBnC,EAAE,EAAEH,IAAI,CAACG,EAAE,CAACgC,QAAQ,CAAC;QACzB,CAAC,GAAG;UACAjC,IAAI,EAAEF,IAAI,CAACE,IAAI,CAACiC,QAAQ,CAAC;QAC7B,CAAC;QAED,IAAInC,IAAI,CAACW,IAAI,EAAE;UACXiB,IAAI,CAACjB,IAAI,GAAGX,IAAI,CAACW,IAAI,CAACwB,QAAQ,CAAC,CAAC;QACpC;QAEA,IAAInC,IAAI,CAACU,SAAS,EAAE;UAChBkB,IAAI,CAAClB,SAAS,GAAGV,IAAI,CAACU,SAAS,CAACyB,QAAQ,CAAC,CAAC;QAC9C;QAEAE,YAAY,CAACV,IAAI,CAACC,IAAI,CAAC;MAC3B;IACJ;IAEAQ,WAAW,CAACC,YAAY,GAAGA,YAAY;IACvC,OAAOD,WAAW;EACtB;AAEJ,CAAC;AAGDG,MAAM,CAACC,OAAO,GAAG,IAAI7D,SAAS,CAACC,YAAY,CAAC,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}
{"ast":null,"code":"'use strict';\n\n// Load modules\nconst Hoek = require('hoek');\nconst Settings = require('./settings');\nconst Ref = require('../../ref');\nconst Errors = require('../../errors');\nlet Alternatives = null; // Delay-loaded to prevent circular dependencies\nlet Cast = null;\n\n// Declare internals\n\nconst internals = {\n  Set: require('../../set')\n};\ninternals.defaults = {\n  abortEarly: true,\n  convert: true,\n  allowUnknown: false,\n  skipFunctions: false,\n  stripUnknown: false,\n  language: {},\n  presence: 'optional',\n  strip: false,\n  noDefaults: false,\n  escapeHtml: false\n\n  // context: null\n};\n\nmodule.exports = internals.Any = class {\n  constructor() {\n    Cast = Cast || require('../../cast');\n    this.isJoi = true;\n    this._type = 'any';\n    this._settings = null;\n    this._valids = new internals.Set();\n    this._invalids = new internals.Set();\n    this._tests = [];\n    this._refs = [];\n    this._flags = {\n      /*\n       presence: 'optional',                   // optional, required, forbidden, ignore\n       allowOnly: false,\n       allowUnknown: undefined,\n       default: undefined,\n       forbidden: false,\n       encoding: undefined,\n       insensitive: false,\n       trim: false,\n       normalize: undefined,                   // NFC, NFD, NFKC, NFKD\n       case: undefined,                        // upper, lower\n       empty: undefined,\n       func: false,\n       raw: false\n       */\n    };\n    this._description = null;\n    this._unit = null;\n    this._notes = [];\n    this._tags = [];\n    this._examples = [];\n    this._meta = [];\n    this._inner = {}; // Hash of arrays of immutable objects\n  }\n\n  _init() {\n    return this;\n  }\n  get schemaType() {\n    return this._type;\n  }\n  createError(type, context, state, options) {\n    let flags = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this._flags;\n    return Errors.create(type, context, state, options, flags);\n  }\n  createOverrideError(type, context, state, options, message, template) {\n    return Errors.create(type, context, state, options, this._flags, message, template);\n  }\n  checkOptions(options) {\n    const Schemas = require('../../schemas');\n    const result = Schemas.options.validate(options);\n    if (result.error) {\n      throw new Error(result.error.details[0].message);\n    }\n  }\n  clone() {\n    const obj = Object.create(Object.getPrototypeOf(this));\n    obj.isJoi = true;\n    obj._currentJoi = this._currentJoi;\n    obj._type = this._type;\n    obj._settings = this._settings;\n    obj._baseType = this._baseType;\n    obj._valids = this._valids.slice();\n    obj._invalids = this._invalids.slice();\n    obj._tests = this._tests.slice();\n    obj._refs = this._refs.slice();\n    obj._flags = Hoek.clone(this._flags);\n    obj._description = this._description;\n    obj._unit = this._unit;\n    obj._notes = this._notes.slice();\n    obj._tags = this._tags.slice();\n    obj._examples = this._examples.slice();\n    obj._meta = this._meta.slice();\n    obj._inner = {};\n    const inners = Object.keys(this._inner);\n    for (let i = 0; i < inners.length; ++i) {\n      const key = inners[i];\n      obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\n    }\n    return obj;\n  }\n  concat(schema) {\n    Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\n    Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\n    let obj = this.clone();\n    if (this._type === 'any' && schema._type !== 'any') {\n      // Reset values as if we were \"this\"\n      const tmpObj = schema.clone();\n      const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit', '_notes', '_tags', '_examples', '_meta', '_inner'];\n      for (let i = 0; i < keysToRestore.length; ++i) {\n        tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\n      }\n      obj = tmpObj;\n    }\n    obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\n    obj._valids.merge(schema._valids, schema._invalids);\n    obj._invalids.merge(schema._invalids, schema._valids);\n    obj._tests = obj._tests.concat(schema._tests);\n    obj._refs = obj._refs.concat(schema._refs);\n    Hoek.merge(obj._flags, schema._flags);\n    obj._description = schema._description || obj._description;\n    obj._unit = schema._unit || obj._unit;\n    obj._notes = obj._notes.concat(schema._notes);\n    obj._tags = obj._tags.concat(schema._tags);\n    obj._examples = obj._examples.concat(schema._examples);\n    obj._meta = obj._meta.concat(schema._meta);\n    const inners = Object.keys(schema._inner);\n    const isObject = obj._type === 'object';\n    for (let i = 0; i < inners.length; ++i) {\n      const key = inners[i];\n      const source = schema._inner[key];\n      if (source) {\n        const target = obj._inner[key];\n        if (target) {\n          if (isObject && key === 'children') {\n            const keys = {};\n            for (let j = 0; j < target.length; ++j) {\n              keys[target[j].key] = j;\n            }\n            for (let j = 0; j < source.length; ++j) {\n              const sourceKey = source[j].key;\n              if (keys[sourceKey] >= 0) {\n                target[keys[sourceKey]] = {\n                  key: sourceKey,\n                  schema: target[keys[sourceKey]].schema.concat(source[j].schema)\n                };\n              } else {\n                target.push(source[j]);\n              }\n            }\n          } else {\n            obj._inner[key] = obj._inner[key].concat(source);\n          }\n        } else {\n          obj._inner[key] = source.slice();\n        }\n      }\n    }\n    return obj;\n  }\n  _test(name, arg, func, options) {\n    const obj = this.clone();\n    obj._tests.push({\n      func,\n      name,\n      arg,\n      options\n    });\n    return obj;\n  }\n  options(options) {\n    Hoek.assert(!options.context, 'Cannot override context');\n    this.checkOptions(options);\n    const obj = this.clone();\n    obj._settings = Settings.concat(obj._settings, options);\n    return obj;\n  }\n  strict(isStrict) {\n    const obj = this.clone();\n    const convert = isStrict === undefined ? false : !isStrict;\n    obj._settings = Settings.concat(obj._settings, {\n      convert\n    });\n    return obj;\n  }\n  raw(isRaw) {\n    const value = isRaw === undefined ? true : isRaw;\n    if (this._flags.raw === value) {\n      return this;\n    }\n    const obj = this.clone();\n    obj._flags.raw = value;\n    return obj;\n  }\n  error(err) {\n    Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\n    const obj = this.clone();\n    obj._flags.error = err;\n    return obj;\n  }\n  allow() {\n    for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n      values[_key] = arguments[_key];\n    }\n    const obj = this.clone();\n    values = Hoek.flatten(values);\n    for (let i = 0; i < values.length; ++i) {\n      const value = values[i];\n      Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\n      obj._invalids.remove(value);\n      obj._valids.add(value, obj._refs);\n    }\n    return obj;\n  }\n  valid() {\n    const obj = this.allow(...arguments);\n    obj._flags.allowOnly = true;\n    return obj;\n  }\n  invalid() {\n    for (var _len2 = arguments.length, values = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      values[_key2] = arguments[_key2];\n    }\n    const obj = this.clone();\n    values = Hoek.flatten(values);\n    for (let i = 0; i < values.length; ++i) {\n      const value = values[i];\n      Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\n      obj._valids.remove(value);\n      obj._invalids.add(value, obj._refs);\n    }\n    return obj;\n  }\n  required() {\n    if (this._flags.presence === 'required') {\n      return this;\n    }\n    const obj = this.clone();\n    obj._flags.presence = 'required';\n    return obj;\n  }\n  optional() {\n    if (this._flags.presence === 'optional') {\n      return this;\n    }\n    const obj = this.clone();\n    obj._flags.presence = 'optional';\n    return obj;\n  }\n  forbidden() {\n    if (this._flags.presence === 'forbidden') {\n      return this;\n    }\n    const obj = this.clone();\n    obj._flags.presence = 'forbidden';\n    return obj;\n  }\n  strip() {\n    if (this._flags.strip) {\n      return this;\n    }\n    const obj = this.clone();\n    obj._flags.strip = true;\n    return obj;\n  }\n  applyFunctionToChildren(children, fn, args, root) {\n    children = [].concat(children);\n    if (children.length !== 1 || children[0] !== '') {\n      root = root ? root + '.' : '';\n      const extraChildren = (children[0] === '' ? children.slice(1) : children).map(child => {\n        return root + child;\n      });\n      throw new Error('unknown key(s) ' + extraChildren.join(', '));\n    }\n    return this[fn].apply(this, args);\n  }\n  default(value, description) {\n    if (typeof value === 'function' && !Ref.isRef(value)) {\n      if (!value.description && description) {\n        value.description = description;\n      }\n      if (!this._flags.func) {\n        Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\n      }\n    }\n    const obj = this.clone();\n    obj._flags.default = value;\n    Ref.push(obj._refs, value);\n    return obj;\n  }\n  empty(schema) {\n    const obj = this.clone();\n    if (schema === undefined) {\n      delete obj._flags.empty;\n    } else {\n      obj._flags.empty = Cast.schema(this._currentJoi, schema);\n    }\n    return obj;\n  }\n  when(condition, options) {\n    Hoek.assert(options && typeof options === 'object', 'Invalid options');\n    Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \"then\" or \"otherwise\"');\n    const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\n    const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\n    Alternatives = Alternatives || require('../alternatives');\n    const alternativeOptions = {\n      then,\n      otherwise\n    };\n    if (Object.prototype.hasOwnProperty.call(options, 'is')) {\n      alternativeOptions.is = options.is;\n    }\n    const obj = Alternatives.when(condition, alternativeOptions);\n    obj._flags.presence = 'ignore';\n    obj._baseType = this;\n    return obj;\n  }\n  description(desc) {\n    Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\n    const obj = this.clone();\n    obj._description = desc;\n    return obj;\n  }\n  notes(notes) {\n    Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\n    const obj = this.clone();\n    obj._notes = obj._notes.concat(notes);\n    return obj;\n  }\n  tags(tags) {\n    Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\n    const obj = this.clone();\n    obj._tags = obj._tags.concat(tags);\n    return obj;\n  }\n  meta(meta) {\n    Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\n    const obj = this.clone();\n    obj._meta = obj._meta.concat(meta);\n    return obj;\n  }\n  example() {\n    Hoek.assert(arguments.length === 1, 'Missing example');\n    const value = arguments.length <= 0 ? undefined : arguments[0];\n    const obj = this.clone();\n    obj._examples.push(value);\n    return obj;\n  }\n  unit(name) {\n    Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\n    const obj = this.clone();\n    obj._unit = name;\n    return obj;\n  }\n  _prepareEmptyValue(value) {\n    if (typeof value === 'string' && this._flags.trim) {\n      return value.trim();\n    }\n    return value;\n  }\n  _validate(value, state, options, reference) {\n    const originalValue = value;\n\n    // Setup state and settings\n\n    state = state || {\n      key: '',\n      path: [],\n      parent: null,\n      reference\n    };\n    if (this._settings) {\n      options = Settings.concat(options, this._settings);\n    }\n    let errors = [];\n    const finish = () => {\n      let finalValue;\n      if (value !== undefined) {\n        finalValue = this._flags.raw ? originalValue : value;\n      } else if (options.noDefaults) {\n        finalValue = value;\n      } else if (Ref.isRef(this._flags.default)) {\n        finalValue = this._flags.default(state.parent, options);\n      } else if (typeof this._flags.default === 'function' && !(this._flags.func && !this._flags.default.description)) {\n        let args;\n        if (state.parent !== null && this._flags.default.length > 0) {\n          args = [Hoek.clone(state.parent), options];\n        }\n        const defaultValue = internals._try(this._flags.default, args);\n        finalValue = defaultValue.value;\n        if (defaultValue.error) {\n          errors.push(this.createError('any.default', {\n            error: defaultValue.error\n          }, state, options));\n        }\n      } else {\n        finalValue = Hoek.clone(this._flags.default);\n      }\n      if (errors.length && typeof this._flags.error === 'function') {\n        const change = this._flags.error.call(this, errors);\n        if (typeof change === 'string') {\n          errors = [this.createOverrideError('override', {\n            reason: errors\n          }, state, options, change)];\n        } else {\n          errors = [].concat(change).map(err => {\n            return err instanceof Error ? err : this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\n          });\n        }\n      }\n      return {\n        value: this._flags.strip ? undefined : finalValue,\n        finalValue,\n        errors: errors.length ? errors : null\n      };\n    };\n    if (this._coerce) {\n      const coerced = this._coerce.call(this, value, state, options);\n      if (coerced.errors) {\n        value = coerced.value;\n        errors = errors.concat(coerced.errors);\n        return finish(); // Coerced error always aborts early\n      }\n\n      value = coerced.value;\n    }\n    if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\n      value = undefined;\n    }\n\n    // Check presence requirements\n\n    const presence = this._flags.presence || options.presence;\n    if (presence === 'optional') {\n      if (value === undefined) {\n        const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\n        if (isDeepDefault && this._type === 'object') {\n          value = {};\n        } else {\n          return finish();\n        }\n      }\n    } else if (presence === 'required' && value === undefined) {\n      errors.push(this.createError('any.required', null, state, options));\n      return finish();\n    } else if (presence === 'forbidden') {\n      if (value === undefined) {\n        return finish();\n      }\n      errors.push(this.createError('any.unknown', null, state, options));\n      return finish();\n    }\n\n    // Check allowed and denied values using the original value\n\n    if (this._valids.has(value, state, options, this._flags.insensitive)) {\n      return finish();\n    }\n    if (this._invalids.has(value, state, options, this._flags.insensitive)) {\n      errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', {\n        value,\n        invalids: this._invalids.values({\n          stripUndefined: true\n        })\n      }, state, options));\n      if (options.abortEarly || value === undefined) {\n        // No reason to keep validating missing value\n\n        return finish();\n      }\n    }\n\n    // Convert value and validate type\n\n    if (this._base) {\n      const base = this._base.call(this, value, state, options);\n      if (base.errors) {\n        value = base.value;\n        errors = errors.concat(base.errors);\n        return finish(); // Base error always aborts early\n      }\n\n      if (base.value !== value) {\n        value = base.value;\n\n        // Check allowed and denied values using the converted value\n\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\n          return finish();\n        }\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\n          errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', {\n            value,\n            invalids: this._invalids.values({\n              stripUndefined: true\n            })\n          }, state, options));\n          if (options.abortEarly) {\n            return finish();\n          }\n        }\n      }\n    }\n\n    // Required values did not match\n\n    if (this._flags.allowOnly) {\n      errors.push(this.createError('any.allowOnly', {\n        value,\n        valids: this._valids.values({\n          stripUndefined: true\n        })\n      }, state, options));\n      if (options.abortEarly) {\n        return finish();\n      }\n    }\n\n    // Validate tests\n\n    for (let i = 0; i < this._tests.length; ++i) {\n      const test = this._tests[i];\n      const ret = test.func.call(this, value, state, options);\n      if (ret instanceof Errors.Err) {\n        errors.push(ret);\n        if (options.abortEarly) {\n          return finish();\n        }\n      } else {\n        value = ret;\n      }\n    }\n    return finish();\n  }\n  _validateWithOptions(value, options, callback) {\n    if (options) {\n      this.checkOptions(options);\n    }\n    const settings = Settings.concat(internals.defaults, options);\n    const result = this._validate(value, null, settings);\n    const errors = Errors.process(result.errors, value);\n    if (callback) {\n      return callback(errors, result.value);\n    }\n    return {\n      error: errors,\n      value: result.value,\n      then(resolve, reject) {\n        if (errors) {\n          return Promise.reject(errors).catch(reject);\n        }\n        return Promise.resolve(result.value).then(resolve);\n      },\n      catch(reject) {\n        if (errors) {\n          return Promise.reject(errors).catch(reject);\n        }\n        return Promise.resolve(result.value);\n      }\n    };\n  }\n  validate(value, options, callback) {\n    if (typeof options === 'function') {\n      return this._validateWithOptions(value, null, options);\n    }\n    return this._validateWithOptions(value, options, callback);\n  }\n  describe() {\n    const description = {\n      type: this._type\n    };\n    const flags = Object.keys(this._flags);\n    if (flags.length) {\n      if (['empty', 'default', 'lazy', 'label'].some(flag => this._flags.hasOwnProperty(flag))) {\n        description.flags = {};\n        for (let i = 0; i < flags.length; ++i) {\n          const flag = flags[i];\n          if (flag === 'empty') {\n            description.flags[flag] = this._flags[flag].describe();\n          } else if (flag === 'default') {\n            if (Ref.isRef(this._flags[flag])) {\n              description.flags[flag] = this._flags[flag].toString();\n            } else if (typeof this._flags[flag] === 'function') {\n              description.flags[flag] = {\n                description: this._flags[flag].description,\n                function: this._flags[flag]\n              };\n            } else {\n              description.flags[flag] = this._flags[flag];\n            }\n          } else if (flag === 'lazy' || flag === 'label') {\n            // We don't want it in the description\n          } else {\n            description.flags[flag] = this._flags[flag];\n          }\n        }\n      } else {\n        description.flags = this._flags;\n      }\n    }\n    if (this._settings) {\n      description.options = Hoek.clone(this._settings);\n    }\n    if (this._baseType) {\n      description.base = this._baseType.describe();\n    }\n    if (this._description) {\n      description.description = this._description;\n    }\n    if (this._notes.length) {\n      description.notes = this._notes;\n    }\n    if (this._tags.length) {\n      description.tags = this._tags;\n    }\n    if (this._meta.length) {\n      description.meta = this._meta;\n    }\n    if (this._examples.length) {\n      description.examples = this._examples;\n    }\n    if (this._unit) {\n      description.unit = this._unit;\n    }\n    const valids = this._valids.values();\n    if (valids.length) {\n      description.valids = valids.map(v => {\n        return Ref.isRef(v) ? v.toString() : v;\n      });\n    }\n    const invalids = this._invalids.values();\n    if (invalids.length) {\n      description.invalids = invalids.map(v => {\n        return Ref.isRef(v) ? v.toString() : v;\n      });\n    }\n    description.rules = [];\n    for (let i = 0; i < this._tests.length; ++i) {\n      const validator = this._tests[i];\n      const item = {\n        name: validator.name\n      };\n      if (validator.arg !== void 0) {\n        item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\n      }\n      const options = validator.options;\n      if (options) {\n        if (options.hasRef) {\n          item.arg = {};\n          const keys = Object.keys(validator.arg);\n          for (let j = 0; j < keys.length; ++j) {\n            const key = keys[j];\n            const value = validator.arg[key];\n            item.arg[key] = Ref.isRef(value) ? value.toString() : value;\n          }\n        }\n        if (typeof options.description === 'string') {\n          item.description = options.description;\n        } else if (typeof options.description === 'function') {\n          item.description = options.description(item.arg);\n        }\n      }\n      description.rules.push(item);\n    }\n    if (!description.rules.length) {\n      delete description.rules;\n    }\n    const label = this._getLabel();\n    if (label) {\n      description.label = label;\n    }\n    return description;\n  }\n  label(name) {\n    Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\n    const obj = this.clone();\n    obj._flags.label = name;\n    return obj;\n  }\n  _getLabel(def) {\n    return this._flags.label || def;\n  }\n};\ninternals.Any.prototype.isImmutable = true; // Prevents Hoek from deep cloning schema objects\n\n// Aliases\n\ninternals.Any.prototype.only = internals.Any.prototype.equal = internals.Any.prototype.valid;\ninternals.Any.prototype.disallow = internals.Any.prototype.not = internals.Any.prototype.invalid;\ninternals.Any.prototype.exist = internals.Any.prototype.required;\ninternals._try = function (fn, args) {\n  let err;\n  let result;\n  try {\n    result = fn.apply(null, args);\n  } catch (e) {\n    err = e;\n  }\n  return {\n    value: result,\n    error: err\n  };\n};","map":{"version":3,"names":["Hoek","require","Settings","Ref","Errors","Alternatives","Cast","internals","Set","defaults","abortEarly","convert","allowUnknown","skipFunctions","stripUnknown","language","presence","strip","noDefaults","escapeHtml","module","exports","Any","constructor","isJoi","_type","_settings","_valids","_invalids","_tests","_refs","_flags","_description","_unit","_notes","_tags","_examples","_meta","_inner","_init","schemaType","createError","type","context","state","options","flags","arguments","length","undefined","create","createOverrideError","message","template","checkOptions","Schemas","result","validate","error","Error","details","clone","obj","Object","getPrototypeOf","_currentJoi","_baseType","slice","inners","keys","i","key","concat","schema","assert","tmpObj","keysToRestore","merge","isObject","source","target","j","sourceKey","push","_test","name","arg","func","strict","isStrict","raw","isRaw","value","err","allow","_len","values","Array","_key","flatten","remove","add","valid","allowOnly","invalid","_len2","_key2","required","optional","forbidden","applyFunctionToChildren","children","fn","args","root","extraChildren","map","child","join","apply","default","description","isRef","empty","when","condition","then","otherwise","hasOwnProperty","alternativeOptions","prototype","call","is","desc","notes","isArray","tags","meta","example","unit","_prepareEmptyValue","trim","_validate","reference","originalValue","path","parent","errors","finish","finalValue","defaultValue","_try","change","reason","_coerce","coerced","isDeepDefault","has","insensitive","invalids","stripUndefined","_base","base","valids","test","ret","Err","_validateWithOptions","callback","settings","process","resolve","reject","Promise","catch","describe","some","flag","toString","function","examples","v","rules","validator","item","hasRef","label","_getLabel","def","isImmutable","only","equal","disallow","not","exist","e"],"sources":["/Users/mariovicky/Skripsi_OpenLayers/node_modules/joi/lib/types/any/index.js"],"sourcesContent":["'use strict';\n\n// Load modules\n\nconst Hoek = require('hoek');\nconst Settings = require('./settings');\nconst Ref = require('../../ref');\nconst Errors = require('../../errors');\nlet Alternatives = null;                // Delay-loaded to prevent circular dependencies\nlet Cast = null;\n\n\n// Declare internals\n\nconst internals = {\n    Set: require('../../set')\n};\n\n\ninternals.defaults = {\n    abortEarly: true,\n    convert: true,\n    allowUnknown: false,\n    skipFunctions: false,\n    stripUnknown: false,\n    language: {},\n    presence: 'optional',\n    strip: false,\n    noDefaults: false,\n    escapeHtml: false\n\n    // context: null\n};\n\n\nmodule.exports = internals.Any = class {\n\n    constructor() {\n\n        Cast = Cast || require('../../cast');\n\n        this.isJoi = true;\n        this._type = 'any';\n        this._settings = null;\n        this._valids = new internals.Set();\n        this._invalids = new internals.Set();\n        this._tests = [];\n        this._refs = [];\n        this._flags = {\n            /*\n             presence: 'optional',                   // optional, required, forbidden, ignore\n             allowOnly: false,\n             allowUnknown: undefined,\n             default: undefined,\n             forbidden: false,\n             encoding: undefined,\n             insensitive: false,\n             trim: false,\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\n             case: undefined,                        // upper, lower\n             empty: undefined,\n             func: false,\n             raw: false\n             */\n        };\n\n        this._description = null;\n        this._unit = null;\n        this._notes = [];\n        this._tags = [];\n        this._examples = [];\n        this._meta = [];\n\n        this._inner = {};                           // Hash of arrays of immutable objects\n    }\n\n    _init() {\n\n        return this;\n    }\n\n    get schemaType() {\n\n        return this._type;\n    }\n\n    createError(type, context, state, options, flags = this._flags) {\n\n        return Errors.create(type, context, state, options, flags);\n    }\n\n    createOverrideError(type, context, state, options, message, template) {\n\n        return Errors.create(type, context, state, options, this._flags, message, template);\n    }\n\n    checkOptions(options) {\n\n        const Schemas = require('../../schemas');\n        const result = Schemas.options.validate(options);\n        if (result.error) {\n            throw new Error(result.error.details[0].message);\n        }\n    }\n\n    clone() {\n\n        const obj = Object.create(Object.getPrototypeOf(this));\n\n        obj.isJoi = true;\n        obj._currentJoi = this._currentJoi;\n        obj._type = this._type;\n        obj._settings = this._settings;\n        obj._baseType = this._baseType;\n        obj._valids = this._valids.slice();\n        obj._invalids = this._invalids.slice();\n        obj._tests = this._tests.slice();\n        obj._refs = this._refs.slice();\n        obj._flags = Hoek.clone(this._flags);\n\n        obj._description = this._description;\n        obj._unit = this._unit;\n        obj._notes = this._notes.slice();\n        obj._tags = this._tags.slice();\n        obj._examples = this._examples.slice();\n        obj._meta = this._meta.slice();\n\n        obj._inner = {};\n        const inners = Object.keys(this._inner);\n        for (let i = 0; i < inners.length; ++i) {\n            const key = inners[i];\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\n        }\n\n        return obj;\n    }\n\n    concat(schema) {\n\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\n\n        let obj = this.clone();\n\n        if (this._type === 'any' && schema._type !== 'any') {\n\n            // Reset values as if we were \"this\"\n            const tmpObj = schema.clone();\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\n\n            for (let i = 0; i < keysToRestore.length; ++i) {\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\n            }\n\n            obj = tmpObj;\n        }\n\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\n        obj._valids.merge(schema._valids, schema._invalids);\n        obj._invalids.merge(schema._invalids, schema._valids);\n        obj._tests = obj._tests.concat(schema._tests);\n        obj._refs = obj._refs.concat(schema._refs);\n        Hoek.merge(obj._flags, schema._flags);\n\n        obj._description = schema._description || obj._description;\n        obj._unit = schema._unit || obj._unit;\n        obj._notes = obj._notes.concat(schema._notes);\n        obj._tags = obj._tags.concat(schema._tags);\n        obj._examples = obj._examples.concat(schema._examples);\n        obj._meta = obj._meta.concat(schema._meta);\n\n        const inners = Object.keys(schema._inner);\n        const isObject = obj._type === 'object';\n        for (let i = 0; i < inners.length; ++i) {\n            const key = inners[i];\n            const source = schema._inner[key];\n            if (source) {\n                const target = obj._inner[key];\n                if (target) {\n                    if (isObject && key === 'children') {\n                        const keys = {};\n\n                        for (let j = 0; j < target.length; ++j) {\n                            keys[target[j].key] = j;\n                        }\n\n                        for (let j = 0; j < source.length; ++j) {\n                            const sourceKey = source[j].key;\n                            if (keys[sourceKey] >= 0) {\n                                target[keys[sourceKey]] = {\n                                    key: sourceKey,\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\n                                };\n                            }\n                            else {\n                                target.push(source[j]);\n                            }\n                        }\n                    }\n                    else {\n                        obj._inner[key] = obj._inner[key].concat(source);\n                    }\n                }\n                else {\n                    obj._inner[key] = source.slice();\n                }\n            }\n        }\n\n        return obj;\n    }\n\n    _test(name, arg, func, options) {\n\n        const obj = this.clone();\n        obj._tests.push({ func, name, arg, options });\n        return obj;\n    }\n\n    options(options) {\n\n        Hoek.assert(!options.context, 'Cannot override context');\n        this.checkOptions(options);\n\n        const obj = this.clone();\n        obj._settings = Settings.concat(obj._settings, options);\n        return obj;\n    }\n\n    strict(isStrict) {\n\n        const obj = this.clone();\n\n        const convert = isStrict === undefined ? false : !isStrict;\n        obj._settings = Settings.concat(obj._settings, { convert });\n        return obj;\n    }\n\n    raw(isRaw) {\n\n        const value = isRaw === undefined ? true : isRaw;\n\n        if (this._flags.raw === value) {\n            return this;\n        }\n\n        const obj = this.clone();\n        obj._flags.raw = value;\n        return obj;\n    }\n\n    error(err) {\n\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\n\n        const obj = this.clone();\n        obj._flags.error = err;\n        return obj;\n    }\n\n    allow(...values) {\n\n        const obj = this.clone();\n        values = Hoek.flatten(values);\n        for (let i = 0; i < values.length; ++i) {\n            const value = values[i];\n\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\n            obj._invalids.remove(value);\n            obj._valids.add(value, obj._refs);\n        }\n        return obj;\n    }\n\n    valid(...values) {\n\n        const obj = this.allow(...values);\n        obj._flags.allowOnly = true;\n        return obj;\n    }\n\n    invalid(...values) {\n\n        const obj = this.clone();\n        values = Hoek.flatten(values);\n        for (let i = 0; i < values.length; ++i) {\n            const value = values[i];\n\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\n            obj._valids.remove(value);\n            obj._invalids.add(value, obj._refs);\n        }\n\n        return obj;\n    }\n\n    required() {\n\n        if (this._flags.presence === 'required') {\n            return this;\n        }\n\n        const obj = this.clone();\n        obj._flags.presence = 'required';\n        return obj;\n    }\n\n    optional() {\n\n        if (this._flags.presence === 'optional') {\n            return this;\n        }\n\n        const obj = this.clone();\n        obj._flags.presence = 'optional';\n        return obj;\n    }\n\n\n    forbidden() {\n\n        if (this._flags.presence === 'forbidden') {\n            return this;\n        }\n\n        const obj = this.clone();\n        obj._flags.presence = 'forbidden';\n        return obj;\n    }\n\n\n    strip() {\n\n        if (this._flags.strip) {\n            return this;\n        }\n\n        const obj = this.clone();\n        obj._flags.strip = true;\n        return obj;\n    }\n\n    applyFunctionToChildren(children, fn, args, root) {\n\n        children = [].concat(children);\n\n        if (children.length !== 1 || children[0] !== '') {\n            root = root ? (root + '.') : '';\n\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\n\n                return root + child;\n            });\n\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\n        }\n\n        return this[fn].apply(this, args);\n    }\n\n    default(value, description) {\n\n        if (typeof value === 'function' &&\n            !Ref.isRef(value)) {\n\n            if (!value.description &&\n                description) {\n\n                value.description = description;\n            }\n\n            if (!this._flags.func) {\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\n            }\n        }\n\n        const obj = this.clone();\n        obj._flags.default = value;\n        Ref.push(obj._refs, value);\n        return obj;\n    }\n\n    empty(schema) {\n\n        const obj = this.clone();\n        if (schema === undefined) {\n            delete obj._flags.empty;\n        }\n        else {\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\n        }\n        return obj;\n    }\n\n    when(condition, options) {\n\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \"then\" or \"otherwise\"');\n\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\n\n        Alternatives = Alternatives || require('../alternatives');\n\n        const alternativeOptions = { then, otherwise };\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\n            alternativeOptions.is = options.is;\n        }\n        const obj = Alternatives.when(condition, alternativeOptions);\n        obj._flags.presence = 'ignore';\n        obj._baseType = this;\n\n        return obj;\n    }\n\n    description(desc) {\n\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\n\n        const obj = this.clone();\n        obj._description = desc;\n        return obj;\n    }\n\n    notes(notes) {\n\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\n\n        const obj = this.clone();\n        obj._notes = obj._notes.concat(notes);\n        return obj;\n    }\n\n    tags(tags) {\n\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\n\n        const obj = this.clone();\n        obj._tags = obj._tags.concat(tags);\n        return obj;\n    }\n\n    meta(meta) {\n\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\n\n        const obj = this.clone();\n        obj._meta = obj._meta.concat(meta);\n        return obj;\n    }\n\n    example(...args) {\n\n        Hoek.assert(args.length === 1, 'Missing example');\n        const value = args[0];\n\n        const obj = this.clone();\n        obj._examples.push(value);\n        return obj;\n    }\n\n    unit(name) {\n\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\n\n        const obj = this.clone();\n        obj._unit = name;\n        return obj;\n    }\n\n    _prepareEmptyValue(value) {\n\n        if (typeof value === 'string' && this._flags.trim) {\n            return value.trim();\n        }\n\n        return value;\n    }\n\n    _validate(value, state, options, reference) {\n\n        const originalValue = value;\n\n        // Setup state and settings\n\n        state = state || { key: '', path: [], parent: null, reference };\n\n        if (this._settings) {\n            options = Settings.concat(options, this._settings);\n        }\n\n        let errors = [];\n        const finish = () => {\n\n            let finalValue;\n\n            if (value !== undefined) {\n                finalValue = this._flags.raw ? originalValue : value;\n            }\n            else if (options.noDefaults) {\n                finalValue = value;\n            }\n            else if (Ref.isRef(this._flags.default)) {\n                finalValue = this._flags.default(state.parent, options);\n            }\n            else if (typeof this._flags.default === 'function' &&\n                !(this._flags.func && !this._flags.default.description)) {\n\n                let args;\n\n                if (state.parent !== null &&\n                    this._flags.default.length > 0) {\n\n                    args = [Hoek.clone(state.parent), options];\n                }\n\n                const defaultValue = internals._try(this._flags.default, args);\n                finalValue = defaultValue.value;\n                if (defaultValue.error) {\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\n                }\n            }\n            else {\n                finalValue = Hoek.clone(this._flags.default);\n            }\n\n            if (errors.length && typeof this._flags.error === 'function') {\n                const change = this._flags.error.call(this, errors);\n\n                if (typeof change === 'string') {\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\n                }\n                else {\n                    errors = [].concat(change)\n                        .map((err) => {\n\n                            return err instanceof Error ?\n                                err :\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\n                        });\n                }\n            }\n\n            return {\n                value: this._flags.strip ? undefined : finalValue,\n                finalValue,\n                errors: errors.length ? errors : null\n            };\n        };\n\n        if (this._coerce) {\n            const coerced = this._coerce.call(this, value, state, options);\n            if (coerced.errors) {\n                value = coerced.value;\n                errors = errors.concat(coerced.errors);\n                return finish();                            // Coerced error always aborts early\n            }\n\n            value = coerced.value;\n        }\n\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\n            value = undefined;\n        }\n\n        // Check presence requirements\n\n        const presence = this._flags.presence || options.presence;\n        if (presence === 'optional') {\n            if (value === undefined) {\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\n                if (isDeepDefault && this._type === 'object') {\n                    value = {};\n                }\n                else {\n                    return finish();\n                }\n            }\n        }\n        else if (presence === 'required' &&\n            value === undefined) {\n\n            errors.push(this.createError('any.required', null, state, options));\n            return finish();\n        }\n        else if (presence === 'forbidden') {\n            if (value === undefined) {\n                return finish();\n            }\n\n            errors.push(this.createError('any.unknown', null, state, options));\n            return finish();\n        }\n\n        // Check allowed and denied values using the original value\n\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\n            return finish();\n        }\n\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\n            if (options.abortEarly ||\n                value === undefined) {          // No reason to keep validating missing value\n\n                return finish();\n            }\n        }\n\n        // Convert value and validate type\n\n        if (this._base) {\n            const base = this._base.call(this, value, state, options);\n            if (base.errors) {\n                value = base.value;\n                errors = errors.concat(base.errors);\n                return finish();                            // Base error always aborts early\n            }\n\n            if (base.value !== value) {\n                value = base.value;\n\n                // Check allowed and denied values using the converted value\n\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\n                    return finish();\n                }\n\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\n                    if (options.abortEarly) {\n                        return finish();\n                    }\n                }\n            }\n        }\n\n        // Required values did not match\n\n        if (this._flags.allowOnly) {\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\n            if (options.abortEarly) {\n                return finish();\n            }\n        }\n\n        // Validate tests\n\n        for (let i = 0; i < this._tests.length; ++i) {\n            const test = this._tests[i];\n            const ret = test.func.call(this, value, state, options);\n            if (ret instanceof Errors.Err) {\n                errors.push(ret);\n                if (options.abortEarly) {\n                    return finish();\n                }\n            }\n            else {\n                value = ret;\n            }\n        }\n\n        return finish();\n    }\n\n    _validateWithOptions(value, options, callback) {\n\n        if (options) {\n            this.checkOptions(options);\n        }\n\n        const settings = Settings.concat(internals.defaults, options);\n        const result = this._validate(value, null, settings);\n        const errors = Errors.process(result.errors, value);\n\n        if (callback) {\n            return callback(errors, result.value);\n        }\n\n        return {\n            error: errors,\n            value: result.value,\n            then(resolve, reject) {\n\n                if (errors) {\n                    return Promise.reject(errors).catch(reject);\n                }\n\n                return Promise.resolve(result.value).then(resolve);\n            },\n            catch(reject) {\n\n                if (errors) {\n                    return Promise.reject(errors).catch(reject);\n                }\n\n                return Promise.resolve(result.value);\n            }\n        };\n    }\n\n    validate(value, options, callback) {\n\n        if (typeof options === 'function') {\n            return this._validateWithOptions(value, null, options);\n        }\n\n        return this._validateWithOptions(value, options, callback);\n    }\n\n    describe() {\n\n        const description = {\n            type: this._type\n        };\n\n        const flags = Object.keys(this._flags);\n        if (flags.length) {\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\n                description.flags = {};\n                for (let i = 0; i < flags.length; ++i) {\n                    const flag = flags[i];\n                    if (flag === 'empty') {\n                        description.flags[flag] = this._flags[flag].describe();\n                    }\n                    else if (flag === 'default') {\n                        if (Ref.isRef(this._flags[flag])) {\n                            description.flags[flag] = this._flags[flag].toString();\n                        }\n                        else if (typeof this._flags[flag] === 'function') {\n                            description.flags[flag] = {\n                                description: this._flags[flag].description,\n                                function   : this._flags[flag]\n                            };\n                        }\n                        else {\n                            description.flags[flag] = this._flags[flag];\n                        }\n                    }\n                    else if (flag === 'lazy' || flag === 'label') {\n                        // We don't want it in the description\n                    }\n                    else {\n                        description.flags[flag] = this._flags[flag];\n                    }\n                }\n            }\n            else {\n                description.flags = this._flags;\n            }\n        }\n\n        if (this._settings) {\n            description.options = Hoek.clone(this._settings);\n        }\n\n        if (this._baseType) {\n            description.base = this._baseType.describe();\n        }\n\n        if (this._description) {\n            description.description = this._description;\n        }\n\n        if (this._notes.length) {\n            description.notes = this._notes;\n        }\n\n        if (this._tags.length) {\n            description.tags = this._tags;\n        }\n\n        if (this._meta.length) {\n            description.meta = this._meta;\n        }\n\n        if (this._examples.length) {\n            description.examples = this._examples;\n        }\n\n        if (this._unit) {\n            description.unit = this._unit;\n        }\n\n        const valids = this._valids.values();\n        if (valids.length) {\n            description.valids = valids.map((v) => {\n\n                return Ref.isRef(v) ? v.toString() : v;\n            });\n        }\n\n        const invalids = this._invalids.values();\n        if (invalids.length) {\n            description.invalids = invalids.map((v) => {\n\n                return Ref.isRef(v) ? v.toString() : v;\n            });\n        }\n\n        description.rules = [];\n\n        for (let i = 0; i < this._tests.length; ++i) {\n            const validator = this._tests[i];\n            const item = { name: validator.name };\n\n            if (validator.arg !== void 0) {\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\n            }\n\n            const options = validator.options;\n            if (options) {\n                if (options.hasRef) {\n                    item.arg = {};\n                    const keys = Object.keys(validator.arg);\n                    for (let j = 0; j < keys.length; ++j) {\n                        const key = keys[j];\n                        const value = validator.arg[key];\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\n                    }\n                }\n\n                if (typeof options.description === 'string') {\n                    item.description = options.description;\n                }\n                else if (typeof options.description === 'function') {\n                    item.description = options.description(item.arg);\n                }\n            }\n\n            description.rules.push(item);\n        }\n\n        if (!description.rules.length) {\n            delete description.rules;\n        }\n\n        const label = this._getLabel();\n        if (label) {\n            description.label = label;\n        }\n\n        return description;\n    }\n\n    label(name) {\n\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\n\n        const obj = this.clone();\n        obj._flags.label = name;\n        return obj;\n    }\n\n    _getLabel(def) {\n\n        return this._flags.label || def;\n    }\n\n};\n\n\ninternals.Any.prototype.isImmutable = true;     // Prevents Hoek from deep cloning schema objects\n\n// Aliases\n\ninternals.Any.prototype.only = internals.Any.prototype.equal = internals.Any.prototype.valid;\ninternals.Any.prototype.disallow = internals.Any.prototype.not = internals.Any.prototype.invalid;\ninternals.Any.prototype.exist = internals.Any.prototype.required;\n\n\ninternals._try = function (fn, args) {\n\n    let err;\n    let result;\n\n    try {\n        result = fn.apply(null, args);\n    }\n    catch (e) {\n        err = e;\n    }\n\n    return {\n        value: result,\n        error: err\n    };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}
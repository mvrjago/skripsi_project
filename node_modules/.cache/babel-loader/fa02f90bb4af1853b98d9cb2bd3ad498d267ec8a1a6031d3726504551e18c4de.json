{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport CanvasLayerRenderer from './Layer.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport { apply as applyTransform, compose as composeTransform, makeInverse } from '../../transform.js';\nimport { assign } from '../../obj.js';\nimport { createEmpty, equals, getIntersection, getTopLeft } from '../../extent.js';\nimport { createTransformString } from '../../render/canvas.js';\nimport { fromUserExtent } from '../../proj.js';\nimport { getUid } from '../../util.js';\nimport { numberSafeCompareFunction } from '../../array.js';\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n */\nvar CanvasTileLayerRenderer = /** @class */function (_super) {\n  __extends(CanvasTileLayerRenderer, _super);\n  /**\n   * @param {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default} tileLayer Tile layer.\n   */\n  function CanvasTileLayerRenderer(tileLayer) {\n    var _this = _super.call(this, tileLayer) || this;\n    /**\n     * Rendered extent has changed since the previous `renderFrame()` call\n     * @type {boolean}\n     */\n    _this.extentChanged = true;\n    /**\n     * @private\n     * @type {?import(\"../../extent.js\").Extent}\n     */\n    _this.renderedExtent_ = null;\n    /**\n     * @protected\n     * @type {number}\n     */\n    _this.renderedPixelRatio;\n    /**\n     * @protected\n     * @type {import(\"../../proj/Projection.js\").default}\n     */\n    _this.renderedProjection = null;\n    /**\n     * @protected\n     * @type {number}\n     */\n    _this.renderedRevision;\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    _this.renderedTiles = [];\n    /**\n     * @private\n     * @type {boolean}\n     */\n    _this.newTiles_ = false;\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    _this.tmpExtent = createEmpty();\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    _this.tmpTileRange_ = new TileRange(0, 0, 0, 0);\n    return _this;\n  }\n  /**\n   * @protected\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n  CanvasTileLayerRenderer.prototype.isDrawableTile = function (tile) {\n    var tileLayer = this.getLayer();\n    var tileState = tile.getState();\n    var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n    return tileState == TileState.LOADED || tileState == TileState.EMPTY || tileState == TileState.ERROR && !useInterimTilesOnError;\n  };\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {!import(\"../../Tile.js\").default} Tile.\n   */\n  CanvasTileLayerRenderer.prototype.getTile = function (z, x, y, frameState) {\n    var pixelRatio = frameState.pixelRatio;\n    var projection = frameState.viewState.projection;\n    var tileLayer = this.getLayer();\n    var tileSource = tileLayer.getSource();\n    var tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n    if (tile.getState() == TileState.ERROR) {\n      if (!tileLayer.getUseInterimTilesOnError()) {\n        // When useInterimTilesOnError is false, we consider the error tile as loaded.\n        tile.setState(TileState.LOADED);\n      } else if (tileLayer.getPreload() > 0) {\n        // Preloaded tiles for lower resolutions might have finished loading.\n        this.newTiles_ = true;\n      }\n    }\n    if (!this.isDrawableTile(tile)) {\n      tile = tile.getInterimTile();\n    }\n    return tile;\n  };\n  /**\n   * @param {Object<number, Object<string, import(\"../../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @param {number} zoom Zoom level.\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean|void} If `false`, the tile will not be considered loaded.\n   */\n  CanvasTileLayerRenderer.prototype.loadedTileCallback = function (tiles, zoom, tile) {\n    if (this.isDrawableTile(tile)) {\n      return _super.prototype.loadedTileCallback.call(this, tiles, zoom, tile);\n    }\n    return false;\n  };\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  CanvasTileLayerRenderer.prototype.prepareFrame = function (frameState) {\n    return !!this.getLayer().getSource();\n  };\n  /**\n   * Render the layer.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n  CanvasTileLayerRenderer.prototype.renderFrame = function (frameState, target) {\n    var layerState = frameState.layerStatesArray[frameState.layerIndex];\n    var viewState = frameState.viewState;\n    var projection = viewState.projection;\n    var viewResolution = viewState.resolution;\n    var viewCenter = viewState.center;\n    var rotation = viewState.rotation;\n    var pixelRatio = frameState.pixelRatio;\n    var tileLayer = this.getLayer();\n    var tileSource = tileLayer.getSource();\n    var sourceRevision = tileSource.getRevision();\n    var tileGrid = tileSource.getTileGridForProjection(projection);\n    var z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n    var tileResolution = tileGrid.getResolution(z);\n    var extent = frameState.extent;\n    var layerExtent = layerState.extent && fromUserExtent(layerState.extent, projection);\n    if (layerExtent) {\n      extent = getIntersection(extent, fromUserExtent(layerState.extent, projection));\n    }\n    var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n    // desired dimensions of the canvas in pixels\n    var width = Math.round(frameState.size[0] * tilePixelRatio);\n    var height = Math.round(frameState.size[1] * tilePixelRatio);\n    if (rotation) {\n      var size = Math.round(Math.sqrt(width * width + height * height));\n      width = size;\n      height = size;\n    }\n    var dx = tileResolution * width / 2 / tilePixelRatio;\n    var dy = tileResolution * height / 2 / tilePixelRatio;\n    var canvasExtent = [viewCenter[0] - dx, viewCenter[1] - dy, viewCenter[0] + dx, viewCenter[1] + dy];\n    var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n    /**\n     * @type {Object<number, Object<string, import(\"../../Tile.js\").default>>}\n     */\n    var tilesToDrawByZ = {};\n    tilesToDrawByZ[z] = {};\n    var findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);\n    var tmpExtent = this.tmpExtent;\n    var tmpTileRange = this.tmpTileRange_;\n    this.newTiles_ = false;\n    for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        var tile = this.getTile(z, x, y, frameState);\n        if (this.isDrawableTile(tile)) {\n          var uid = getUid(this);\n          if (tile.getState() == TileState.LOADED) {\n            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\n            var inTransition = tile.inTransition(uid);\n            if (!this.newTiles_ && (inTransition || this.renderedTiles.indexOf(tile) === -1)) {\n              this.newTiles_ = true;\n            }\n          }\n          if (tile.getAlpha(uid, frameState.time) === 1) {\n            // don't look for alt tiles if alpha is 1\n            continue;\n          }\n        }\n        var childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);\n        var covered = false;\n        if (childTileRange) {\n          covered = findLoadedTiles(z + 1, childTileRange);\n        }\n        if (!covered) {\n          tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, tmpTileRange, tmpExtent);\n        }\n      }\n    }\n    var canvasScale = tileResolution / viewResolution;\n    // set forward and inverse pixel transforms\n    composeTransform(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / tilePixelRatio, 1 / tilePixelRatio, rotation, -width / 2, -height / 2);\n    var canvasTransform = createTransformString(this.pixelTransform);\n    this.useContainer(target, canvasTransform, layerState.opacity);\n    var context = this.context;\n    var canvas = context.canvas;\n    makeInverse(this.inversePixelTransform, this.pixelTransform);\n    // set scale transform for calculating tile positions on the canvas\n    composeTransform(this.tempTransform, width / 2, height / 2, canvasScale, canvasScale, 0, -width / 2, -height / 2);\n    if (canvas.width != width || canvas.height != height) {\n      canvas.width = width;\n      canvas.height = height;\n    } else if (!this.containerReused) {\n      context.clearRect(0, 0, width, height);\n    }\n    if (layerExtent) {\n      this.clipUnrotated(context, frameState, layerExtent);\n    }\n    assign(context, tileSource.getContextOptions());\n    this.preRender(context, frameState);\n    this.renderedTiles.length = 0;\n    /** @type {Array<number>} */\n    var zs = Object.keys(tilesToDrawByZ).map(Number);\n    zs.sort(numberSafeCompareFunction);\n    var clips, clipZs, currentClip;\n    if (layerState.opacity === 1 && (!this.containerReused || tileSource.getOpaque(frameState.viewState.projection))) {\n      zs = zs.reverse();\n    } else {\n      clips = [];\n      clipZs = [];\n    }\n    for (var i = zs.length - 1; i >= 0; --i) {\n      var currentZ = zs[i];\n      var currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);\n      var currentResolution = tileGrid.getResolution(currentZ);\n      var currentScale = currentResolution / tileResolution;\n      var dx_1 = currentTilePixelSize[0] * currentScale * canvasScale;\n      var dy_1 = currentTilePixelSize[1] * currentScale * canvasScale;\n      var originTileCoord = tileGrid.getTileCoordForCoordAndZ(getTopLeft(canvasExtent), currentZ);\n      var originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n      var origin_1 = applyTransform(this.tempTransform, [tilePixelRatio * (originTileExtent[0] - canvasExtent[0]) / tileResolution, tilePixelRatio * (canvasExtent[3] - originTileExtent[3]) / tileResolution]);\n      var tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);\n      var tilesToDraw = tilesToDrawByZ[currentZ];\n      for (var tileCoordKey in tilesToDraw) {\n        var tile = /** @type {import(\"../../ImageTile.js\").default} */tilesToDraw[tileCoordKey];\n        var tileCoord = tile.tileCoord;\n        // Calculate integer positions and sizes so that tiles align\n        var floatX = origin_1[0] - (originTileCoord[1] - tileCoord[1]) * dx_1;\n        var nextX = Math.round(floatX + dx_1);\n        var floatY = origin_1[1] - (originTileCoord[2] - tileCoord[2]) * dy_1;\n        var nextY = Math.round(floatY + dy_1);\n        var x = Math.round(floatX);\n        var y = Math.round(floatY);\n        var w = nextX - x;\n        var h = nextY - y;\n        var transition = z === currentZ;\n        var inTransition = transition && tile.getAlpha(getUid(this), frameState.time) !== 1;\n        if (!inTransition) {\n          if (clips) {\n            // Clip mask for regions in this tile that already filled by a higher z tile\n            context.save();\n            currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n            for (var i_1 = 0, ii = clips.length; i_1 < ii; ++i_1) {\n              if (z !== currentZ && currentZ < clipZs[i_1]) {\n                var clip = clips[i_1];\n                context.beginPath();\n                // counter-clockwise (outer ring) for current tile\n                context.moveTo(currentClip[0], currentClip[1]);\n                context.lineTo(currentClip[2], currentClip[3]);\n                context.lineTo(currentClip[4], currentClip[5]);\n                context.lineTo(currentClip[6], currentClip[7]);\n                // clockwise (inner ring) for higher z tile\n                context.moveTo(clip[6], clip[7]);\n                context.lineTo(clip[4], clip[5]);\n                context.lineTo(clip[2], clip[3]);\n                context.lineTo(clip[0], clip[1]);\n                context.clip();\n              }\n            }\n            clips.push(currentClip);\n            clipZs.push(currentZ);\n          } else {\n            context.clearRect(x, y, w, h);\n          }\n        }\n        this.drawTileImage(tile, frameState, x, y, w, h, tileGutter, transition, layerState.opacity);\n        if (clips && !inTransition) {\n          context.restore();\n        }\n        this.renderedTiles.push(tile);\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n      }\n    }\n    this.renderedRevision = sourceRevision;\n    this.renderedResolution = tileResolution;\n    this.extentChanged = !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n    this.renderedExtent_ = canvasExtent;\n    this.renderedPixelRatio = pixelRatio;\n    this.renderedProjection = projection;\n    this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload());\n    this.scheduleExpireCache(frameState, tileSource);\n    this.postRender(context, frameState);\n    if (layerState.extent) {\n      context.restore();\n    }\n    if (canvasTransform !== canvas.style.transform) {\n      canvas.style.transform = canvasTransform;\n    }\n    return this.container;\n  };\n  /**\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   * @param {number} opacity Opacity.\n   */\n  CanvasTileLayerRenderer.prototype.drawTileImage = function (tile, frameState, x, y, w, h, gutter, transition, opacity) {\n    var image = this.getTileImage(tile);\n    if (!image) {\n      return;\n    }\n    var uid = getUid(this);\n    var tileAlpha = transition ? tile.getAlpha(uid, frameState.time) : 1;\n    var alpha = opacity * tileAlpha;\n    var alphaChanged = alpha !== this.context.globalAlpha;\n    if (alphaChanged) {\n      this.context.save();\n      this.context.globalAlpha = alpha;\n    }\n    this.context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);\n    if (alphaChanged) {\n      this.context.restore();\n    }\n    if (tileAlpha !== 1) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  };\n  /**\n   * @return {HTMLCanvasElement} Image\n   */\n  CanvasTileLayerRenderer.prototype.getImage = function () {\n    var context = this.context;\n    return context ? context.canvas : null;\n  };\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n  CanvasTileLayerRenderer.prototype.getTileImage = function (tile) {\n    return tile.getImage();\n  };\n  /**\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @protected\n   */\n  CanvasTileLayerRenderer.prototype.scheduleExpireCache = function (frameState, tileSource) {\n    if (tileSource.canExpireCache()) {\n      /**\n       * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n       * @param {import(\"../../PluggableMap.js\").default} map Map.\n       * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n       */\n      var postRenderFunction = function (tileSource, map, frameState) {\n        var tileSourceKey = getUid(tileSource);\n        if (tileSourceKey in frameState.usedTiles) {\n          tileSource.expireCache(frameState.viewState.projection, frameState.usedTiles[tileSourceKey]);\n        }\n      }.bind(null, tileSource);\n      frameState.postRenderFunctions.push( /** @type {import(\"../../PluggableMap.js\").PostRenderFunction} */postRenderFunction);\n    }\n  };\n  /**\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import('../../Tile.js').default} tile Tile.\n   * @protected\n   */\n  CanvasTileLayerRenderer.prototype.updateUsedTiles = function (usedTiles, tileSource, tile) {\n    // FIXME should we use tilesToDrawByZ instead?\n    var tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in usedTiles)) {\n      usedTiles[tileSourceKey] = {};\n    }\n    usedTiles[tileSourceKey][tile.getKey()] = true;\n  };\n  /**\n   * Manage tile pyramid.\n   * This function performs a number of functions related to the tiles at the\n   * current zoom and lower zoom levels:\n   * - registers idle tiles in frameState.wantedTiles so that they are not\n   *   discarded by the tile queue\n   * - enqueues missing tiles\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @param {import(\"../../extent.js\").Extent} extent Extent.\n   * @param {number} currentZ Current Z.\n   * @param {number} preload Load low resolution tiles up to 'preload' levels.\n   * @param {function(import(\"../../Tile.js\").default)=} opt_tileCallback Tile callback.\n   * @protected\n   */\n  CanvasTileLayerRenderer.prototype.manageTilePyramid = function (frameState, tileSource, tileGrid, pixelRatio, projection, extent, currentZ, preload, opt_tileCallback) {\n    var tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n    var wantedTiles = frameState.wantedTiles[tileSourceKey];\n    var tileQueue = frameState.tileQueue;\n    var minZoom = tileGrid.getMinZoom();\n    var tileCount = 0;\n    var tile, tileRange, tileResolution, x, y, z;\n    for (z = minZoom; z <= currentZ; ++z) {\n      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);\n      tileResolution = tileGrid.getResolution(z);\n      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          if (currentZ - z <= preload) {\n            ++tileCount;\n            tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n            if (tile.getState() == TileState.IDLE) {\n              wantedTiles[tile.getKey()] = true;\n              if (!tileQueue.isKeyQueued(tile.getKey())) {\n                tileQueue.enqueue([tile, tileSourceKey, tileGrid.getTileCoordCenter(tile.tileCoord), tileResolution]);\n              }\n            }\n            if (opt_tileCallback !== undefined) {\n              opt_tileCallback(tile);\n            }\n          } else {\n            tileSource.useTile(z, x, y, projection);\n          }\n        }\n      }\n    }\n    tileSource.updateCacheSize(tileCount, projection);\n  };\n  return CanvasTileLayerRenderer;\n}(CanvasLayerRenderer);\n/**\n * @function\n * @return {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default}\n */\nCanvasTileLayerRenderer.prototype.getLayer;\nexport default CanvasTileLayerRenderer;","map":{"version":3,"names":["CanvasLayerRenderer","TileRange","TileState","apply","applyTransform","compose","composeTransform","makeInverse","assign","createEmpty","equals","getIntersection","getTopLeft","createTransformString","fromUserExtent","getUid","numberSafeCompareFunction","CanvasTileLayerRenderer","_super","__extends","tileLayer","_this","call","extentChanged","renderedExtent_","renderedPixelRatio","renderedProjection","renderedRevision","renderedTiles","newTiles_","tmpExtent","tmpTileRange_","prototype","isDrawableTile","tile","getLayer","tileState","getState","useInterimTilesOnError","getUseInterimTilesOnError","LOADED","EMPTY","ERROR","getTile","z","x","y","frameState","pixelRatio","projection","viewState","tileSource","getSource","setState","getPreload","getInterimTile","loadedTileCallback","tiles","zoom","prepareFrame","renderFrame","target","layerState","layerStatesArray","layerIndex","viewResolution","resolution","viewCenter","center","rotation","sourceRevision","getRevision","tileGrid","getTileGridForProjection","getZForResolution","zDirection","tileResolution","getResolution","extent","layerExtent","tilePixelRatio","getTilePixelRatio","width","Math","round","size","height","sqrt","dx","dy","canvasExtent","tileRange","getTileRangeForExtentAndZ","tilesToDrawByZ","findLoadedTiles","createLoadedTileFinder","tmpTileRange","minX","maxX","minY","maxY","uid","tileCoord","toString","inTransition","indexOf","getAlpha","time","childTileRange","getTileCoordChildTileRange","covered","forEachTileCoordParentTileRange","canvasScale","pixelTransform","canvasTransform","useContainer","opacity","context","canvas","inversePixelTransform","tempTransform","containerReused","clearRect","clipUnrotated","getContextOptions","preRender","length","zs","Object","keys","map","Number","sort","clips","clipZs","currentClip","getOpaque","reverse","i","currentZ","currentTilePixelSize","getTilePixelSize","currentResolution","currentScale","dx_1","dy_1","originTileCoord","getTileCoordForCoordAndZ","originTileExtent","getTileCoordExtent","origin_1","tileGutter","getGutterForProjection","tilesToDraw","tileCoordKey","floatX","nextX","floatY","nextY","w","h","transition","save","i_1","ii","clip","beginPath","moveTo","lineTo","push","drawTileImage","restore","updateUsedTiles","usedTiles","renderedResolution","manageTilePyramid","scheduleExpireCache","postRender","style","transform","container","gutter","image","getTileImage","tileAlpha","alpha","alphaChanged","globalAlpha","drawImage","animate","endTransition","getImage","canExpireCache","postRenderFunction","tileSourceKey","expireCache","bind","postRenderFunctions","getKey","preload","opt_tileCallback","wantedTiles","tileQueue","minZoom","getMinZoom","tileCount","IDLE","isKeyQueued","enqueue","getTileCoordCenter","undefined","useTile","updateCacheSize"],"sources":["/Users/mariovicky/Skripsi_OpenLayers/node_modules/ol/src/renderer/canvas/TileLayer.js"],"sourcesContent":["/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport CanvasLayerRenderer from './Layer.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n  makeInverse,\n} from '../../transform.js';\nimport {assign} from '../../obj.js';\nimport {\n  createEmpty,\n  equals,\n  getIntersection,\n  getTopLeft,\n} from '../../extent.js';\nimport {createTransformString} from '../../render/canvas.js';\nimport {fromUserExtent} from '../../proj.js';\nimport {getUid} from '../../util.js';\nimport {numberSafeCompareFunction} from '../../array.js';\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n */\nclass CanvasTileLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default} tileLayer Tile layer.\n   */\n  constructor(tileLayer) {\n    super(tileLayer);\n\n    /**\n     * Rendered extent has changed since the previous `renderFrame()` call\n     * @type {boolean}\n     */\n    this.extentChanged = true;\n\n    /**\n     * @private\n     * @type {?import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedPixelRatio;\n\n    /**\n     * @protected\n     * @type {import(\"../../proj/Projection.js\").default}\n     */\n    this.renderedProjection = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedRevision;\n\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    this.renderedTiles = [];\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.newTiles_ = false;\n\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.tmpExtent = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    this.tmpTileRange_ = new TileRange(0, 0, 0, 0);\n  }\n\n  /**\n   * @protected\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n  isDrawableTile(tile) {\n    const tileLayer = this.getLayer();\n    const tileState = tile.getState();\n    const useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n    return (\n      tileState == TileState.LOADED ||\n      tileState == TileState.EMPTY ||\n      (tileState == TileState.ERROR && !useInterimTilesOnError)\n    );\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {!import(\"../../Tile.js\").default} Tile.\n   */\n  getTile(z, x, y, frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const projection = frameState.viewState.projection;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    let tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n    if (tile.getState() == TileState.ERROR) {\n      if (!tileLayer.getUseInterimTilesOnError()) {\n        // When useInterimTilesOnError is false, we consider the error tile as loaded.\n        tile.setState(TileState.LOADED);\n      } else if (tileLayer.getPreload() > 0) {\n        // Preloaded tiles for lower resolutions might have finished loading.\n        this.newTiles_ = true;\n      }\n    }\n    if (!this.isDrawableTile(tile)) {\n      tile = tile.getInterimTile();\n    }\n    return tile;\n  }\n\n  /**\n   * @param {Object<number, Object<string, import(\"../../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @param {number} zoom Zoom level.\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean|void} If `false`, the tile will not be considered loaded.\n   */\n  loadedTileCallback(tiles, zoom, tile) {\n    if (this.isDrawableTile(tile)) {\n      return super.loadedTileCallback(tiles, zoom, tile);\n    }\n    return false;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    return !!this.getLayer().getSource();\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const viewResolution = viewState.resolution;\n    const viewCenter = viewState.center;\n    const rotation = viewState.rotation;\n    const pixelRatio = frameState.pixelRatio;\n\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const sourceRevision = tileSource.getRevision();\n    const tileGrid = tileSource.getTileGridForProjection(projection);\n    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n    const tileResolution = tileGrid.getResolution(z);\n\n    let extent = frameState.extent;\n    const layerExtent =\n      layerState.extent && fromUserExtent(layerState.extent, projection);\n    if (layerExtent) {\n      extent = getIntersection(\n        extent,\n        fromUserExtent(layerState.extent, projection)\n      );\n    }\n\n    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n\n    // desired dimensions of the canvas in pixels\n    let width = Math.round(frameState.size[0] * tilePixelRatio);\n    let height = Math.round(frameState.size[1] * tilePixelRatio);\n\n    if (rotation) {\n      const size = Math.round(Math.sqrt(width * width + height * height));\n      width = size;\n      height = size;\n    }\n\n    const dx = (tileResolution * width) / 2 / tilePixelRatio;\n    const dy = (tileResolution * height) / 2 / tilePixelRatio;\n    const canvasExtent = [\n      viewCenter[0] - dx,\n      viewCenter[1] - dy,\n      viewCenter[0] + dx,\n      viewCenter[1] + dy,\n    ];\n\n    const tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n\n    /**\n     * @type {Object<number, Object<string, import(\"../../Tile.js\").default>>}\n     */\n    const tilesToDrawByZ = {};\n    tilesToDrawByZ[z] = {};\n\n    const findLoadedTiles = this.createLoadedTileFinder(\n      tileSource,\n      projection,\n      tilesToDrawByZ\n    );\n\n    const tmpExtent = this.tmpExtent;\n    const tmpTileRange = this.tmpTileRange_;\n    this.newTiles_ = false;\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        const tile = this.getTile(z, x, y, frameState);\n        if (this.isDrawableTile(tile)) {\n          const uid = getUid(this);\n          if (tile.getState() == TileState.LOADED) {\n            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\n            const inTransition = tile.inTransition(uid);\n            if (\n              !this.newTiles_ &&\n              (inTransition || this.renderedTiles.indexOf(tile) === -1)\n            ) {\n              this.newTiles_ = true;\n            }\n          }\n          if (tile.getAlpha(uid, frameState.time) === 1) {\n            // don't look for alt tiles if alpha is 1\n            continue;\n          }\n        }\n\n        const childTileRange = tileGrid.getTileCoordChildTileRange(\n          tile.tileCoord,\n          tmpTileRange,\n          tmpExtent\n        );\n\n        let covered = false;\n        if (childTileRange) {\n          covered = findLoadedTiles(z + 1, childTileRange);\n        }\n        if (!covered) {\n          tileGrid.forEachTileCoordParentTileRange(\n            tile.tileCoord,\n            findLoadedTiles,\n            tmpTileRange,\n            tmpExtent\n          );\n        }\n      }\n    }\n\n    const canvasScale = tileResolution / viewResolution;\n\n    // set forward and inverse pixel transforms\n    composeTransform(\n      this.pixelTransform,\n      frameState.size[0] / 2,\n      frameState.size[1] / 2,\n      1 / tilePixelRatio,\n      1 / tilePixelRatio,\n      rotation,\n      -width / 2,\n      -height / 2\n    );\n\n    const canvasTransform = createTransformString(this.pixelTransform);\n\n    this.useContainer(target, canvasTransform, layerState.opacity);\n    const context = this.context;\n    const canvas = context.canvas;\n\n    makeInverse(this.inversePixelTransform, this.pixelTransform);\n\n    // set scale transform for calculating tile positions on the canvas\n    composeTransform(\n      this.tempTransform,\n      width / 2,\n      height / 2,\n      canvasScale,\n      canvasScale,\n      0,\n      -width / 2,\n      -height / 2\n    );\n\n    if (canvas.width != width || canvas.height != height) {\n      canvas.width = width;\n      canvas.height = height;\n    } else if (!this.containerReused) {\n      context.clearRect(0, 0, width, height);\n    }\n\n    if (layerExtent) {\n      this.clipUnrotated(context, frameState, layerExtent);\n    }\n\n    assign(context, tileSource.getContextOptions());\n    this.preRender(context, frameState);\n\n    this.renderedTiles.length = 0;\n    /** @type {Array<number>} */\n    let zs = Object.keys(tilesToDrawByZ).map(Number);\n    zs.sort(numberSafeCompareFunction);\n\n    let clips, clipZs, currentClip;\n    if (\n      layerState.opacity === 1 &&\n      (!this.containerReused ||\n        tileSource.getOpaque(frameState.viewState.projection))\n    ) {\n      zs = zs.reverse();\n    } else {\n      clips = [];\n      clipZs = [];\n    }\n    for (let i = zs.length - 1; i >= 0; --i) {\n      const currentZ = zs[i];\n      const currentTilePixelSize = tileSource.getTilePixelSize(\n        currentZ,\n        pixelRatio,\n        projection\n      );\n      const currentResolution = tileGrid.getResolution(currentZ);\n      const currentScale = currentResolution / tileResolution;\n      const dx = currentTilePixelSize[0] * currentScale * canvasScale;\n      const dy = currentTilePixelSize[1] * currentScale * canvasScale;\n      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(\n        getTopLeft(canvasExtent),\n        currentZ\n      );\n      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n      const origin = applyTransform(this.tempTransform, [\n        (tilePixelRatio * (originTileExtent[0] - canvasExtent[0])) /\n          tileResolution,\n        (tilePixelRatio * (canvasExtent[3] - originTileExtent[3])) /\n          tileResolution,\n      ]);\n      const tileGutter =\n        tilePixelRatio * tileSource.getGutterForProjection(projection);\n      const tilesToDraw = tilesToDrawByZ[currentZ];\n      for (const tileCoordKey in tilesToDraw) {\n        const tile = /** @type {import(\"../../ImageTile.js\").default} */ (tilesToDraw[\n          tileCoordKey\n        ]);\n        const tileCoord = tile.tileCoord;\n\n        // Calculate integer positions and sizes so that tiles align\n        const floatX = origin[0] - (originTileCoord[1] - tileCoord[1]) * dx;\n        const nextX = Math.round(floatX + dx);\n        const floatY = origin[1] - (originTileCoord[2] - tileCoord[2]) * dy;\n        const nextY = Math.round(floatY + dy);\n        const x = Math.round(floatX);\n        const y = Math.round(floatY);\n        const w = nextX - x;\n        const h = nextY - y;\n        const transition = z === currentZ;\n\n        const inTransition =\n          transition && tile.getAlpha(getUid(this), frameState.time) !== 1;\n        if (!inTransition) {\n          if (clips) {\n            // Clip mask for regions in this tile that already filled by a higher z tile\n            context.save();\n            currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n            for (let i = 0, ii = clips.length; i < ii; ++i) {\n              if (z !== currentZ && currentZ < clipZs[i]) {\n                const clip = clips[i];\n                context.beginPath();\n                // counter-clockwise (outer ring) for current tile\n                context.moveTo(currentClip[0], currentClip[1]);\n                context.lineTo(currentClip[2], currentClip[3]);\n                context.lineTo(currentClip[4], currentClip[5]);\n                context.lineTo(currentClip[6], currentClip[7]);\n                // clockwise (inner ring) for higher z tile\n                context.moveTo(clip[6], clip[7]);\n                context.lineTo(clip[4], clip[5]);\n                context.lineTo(clip[2], clip[3]);\n                context.lineTo(clip[0], clip[1]);\n                context.clip();\n              }\n            }\n            clips.push(currentClip);\n            clipZs.push(currentZ);\n          } else {\n            context.clearRect(x, y, w, h);\n          }\n        }\n        this.drawTileImage(\n          tile,\n          frameState,\n          x,\n          y,\n          w,\n          h,\n          tileGutter,\n          transition,\n          layerState.opacity\n        );\n        if (clips && !inTransition) {\n          context.restore();\n        }\n        this.renderedTiles.push(tile);\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n      }\n    }\n\n    this.renderedRevision = sourceRevision;\n    this.renderedResolution = tileResolution;\n    this.extentChanged =\n      !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n    this.renderedExtent_ = canvasExtent;\n    this.renderedPixelRatio = pixelRatio;\n    this.renderedProjection = projection;\n\n    this.manageTilePyramid(\n      frameState,\n      tileSource,\n      tileGrid,\n      pixelRatio,\n      projection,\n      extent,\n      z,\n      tileLayer.getPreload()\n    );\n    this.scheduleExpireCache(frameState, tileSource);\n\n    this.postRender(context, frameState);\n\n    if (layerState.extent) {\n      context.restore();\n    }\n\n    if (canvasTransform !== canvas.style.transform) {\n      canvas.style.transform = canvasTransform;\n    }\n\n    return this.container;\n  }\n\n  /**\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   * @param {number} opacity Opacity.\n   */\n  drawTileImage(tile, frameState, x, y, w, h, gutter, transition, opacity) {\n    const image = this.getTileImage(tile);\n    if (!image) {\n      return;\n    }\n    const uid = getUid(this);\n    const tileAlpha = transition ? tile.getAlpha(uid, frameState.time) : 1;\n    const alpha = opacity * tileAlpha;\n    const alphaChanged = alpha !== this.context.globalAlpha;\n    if (alphaChanged) {\n      this.context.save();\n      this.context.globalAlpha = alpha;\n    }\n    this.context.drawImage(\n      image,\n      gutter,\n      gutter,\n      image.width - 2 * gutter,\n      image.height - 2 * gutter,\n      x,\n      y,\n      w,\n      h\n    );\n\n    if (alphaChanged) {\n      this.context.restore();\n    }\n    if (tileAlpha !== 1) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Image\n   */\n  getImage() {\n    const context = this.context;\n    return context ? context.canvas : null;\n  }\n\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n  getTileImage(tile) {\n    return tile.getImage();\n  }\n\n  /**\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @protected\n   */\n  scheduleExpireCache(frameState, tileSource) {\n    if (tileSource.canExpireCache()) {\n      /**\n       * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n       * @param {import(\"../../PluggableMap.js\").default} map Map.\n       * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n       */\n      const postRenderFunction = function (tileSource, map, frameState) {\n        const tileSourceKey = getUid(tileSource);\n        if (tileSourceKey in frameState.usedTiles) {\n          tileSource.expireCache(\n            frameState.viewState.projection,\n            frameState.usedTiles[tileSourceKey]\n          );\n        }\n      }.bind(null, tileSource);\n\n      frameState.postRenderFunctions.push(\n        /** @type {import(\"../../PluggableMap.js\").PostRenderFunction} */ (postRenderFunction)\n      );\n    }\n  }\n\n  /**\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import('../../Tile.js').default} tile Tile.\n   * @protected\n   */\n  updateUsedTiles(usedTiles, tileSource, tile) {\n    // FIXME should we use tilesToDrawByZ instead?\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in usedTiles)) {\n      usedTiles[tileSourceKey] = {};\n    }\n    usedTiles[tileSourceKey][tile.getKey()] = true;\n  }\n\n  /**\n   * Manage tile pyramid.\n   * This function performs a number of functions related to the tiles at the\n   * current zoom and lower zoom levels:\n   * - registers idle tiles in frameState.wantedTiles so that they are not\n   *   discarded by the tile queue\n   * - enqueues missing tiles\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @param {import(\"../../extent.js\").Extent} extent Extent.\n   * @param {number} currentZ Current Z.\n   * @param {number} preload Load low resolution tiles up to 'preload' levels.\n   * @param {function(import(\"../../Tile.js\").default)=} opt_tileCallback Tile callback.\n   * @protected\n   */\n  manageTilePyramid(\n    frameState,\n    tileSource,\n    tileGrid,\n    pixelRatio,\n    projection,\n    extent,\n    currentZ,\n    preload,\n    opt_tileCallback\n  ) {\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n    const tileQueue = frameState.tileQueue;\n    const minZoom = tileGrid.getMinZoom();\n    let tileCount = 0;\n    let tile, tileRange, tileResolution, x, y, z;\n    for (z = minZoom; z <= currentZ; ++z) {\n      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);\n      tileResolution = tileGrid.getResolution(z);\n      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          if (currentZ - z <= preload) {\n            ++tileCount;\n            tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n            if (tile.getState() == TileState.IDLE) {\n              wantedTiles[tile.getKey()] = true;\n              if (!tileQueue.isKeyQueued(tile.getKey())) {\n                tileQueue.enqueue([\n                  tile,\n                  tileSourceKey,\n                  tileGrid.getTileCoordCenter(tile.tileCoord),\n                  tileResolution,\n                ]);\n              }\n            }\n            if (opt_tileCallback !== undefined) {\n              opt_tileCallback(tile);\n            }\n          } else {\n            tileSource.useTile(z, x, y, projection);\n          }\n        }\n      }\n    }\n    tileSource.updateCacheSize(tileCount, projection);\n  }\n}\n\n/**\n * @function\n * @return {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default}\n */\nCanvasTileLayerRenderer.prototype.getLayer;\n\nexport default CanvasTileLayerRenderer;\n"],"mappings":";;;;;;;;;;;;;;;;;;;AAAA;;;AAGA,OAAOA,mBAAmB,MAAM,YAAY;AAC5C,OAAOC,SAAS,MAAM,oBAAoB;AAC1C,OAAOC,SAAS,MAAM,oBAAoB;AAC1C,SACEC,KAAK,IAAIC,cAAc,EACvBC,OAAO,IAAIC,gBAAgB,EAC3BC,WAAW,QACN,oBAAoB;AAC3B,SAAQC,MAAM,QAAO,cAAc;AACnC,SACEC,WAAW,EACXC,MAAM,EACNC,eAAe,EACfC,UAAU,QACL,iBAAiB;AACxB,SAAQC,qBAAqB,QAAO,wBAAwB;AAC5D,SAAQC,cAAc,QAAO,eAAe;AAC5C,SAAQC,MAAM,QAAO,eAAe;AACpC,SAAQC,yBAAyB,QAAO,gBAAgB;AAExD;;;;;AAKA,IAAAC,uBAAA,0BAAAC,MAAA;EAAsCC,SAAA,CAAAF,uBAAA,EAAAC,MAAA;EACpC;;;EAGA,SAAAD,wBAAYG,SAAS;IAArB,IAAAC,KAAA,GACEH,MAAA,CAAAI,IAAA,OAAMF,SAAS,CAAC;IAEhB;;;;IAIAC,KAAI,CAACE,aAAa,GAAG,IAAI;IAEzB;;;;IAIAF,KAAI,CAACG,eAAe,GAAG,IAAI;IAE3B;;;;IAIAH,KAAI,CAACI,kBAAkB;IAEvB;;;;IAIAJ,KAAI,CAACK,kBAAkB,GAAG,IAAI;IAE9B;;;;IAIAL,KAAI,CAACM,gBAAgB;IAErB;;;;IAIAN,KAAI,CAACO,aAAa,GAAG,EAAE;IAEvB;;;;IAIAP,KAAI,CAACQ,SAAS,GAAG,KAAK;IAEtB;;;;IAIAR,KAAI,CAACS,SAAS,GAAGrB,WAAW,EAAE;IAE9B;;;;IAIAY,KAAI,CAACU,aAAa,GAAG,IAAI9B,SAAS,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;;EAChD;EAEA;;;;;EAKAgB,uBAAA,CAAAe,SAAA,CAAAC,cAAc,GAAd,UAAeC,IAAI;IACjB,IAAMd,SAAS,GAAG,IAAI,CAACe,QAAQ,EAAE;IACjC,IAAMC,SAAS,GAAGF,IAAI,CAACG,QAAQ,EAAE;IACjC,IAAMC,sBAAsB,GAAGlB,SAAS,CAACmB,yBAAyB,EAAE;IACpE,OACEH,SAAS,IAAIlC,SAAS,CAACsC,MAAM,IAC7BJ,SAAS,IAAIlC,SAAS,CAACuC,KAAK,IAC3BL,SAAS,IAAIlC,SAAS,CAACwC,KAAK,IAAI,CAACJ,sBAAuB;EAE7D,CAAC;EAED;;;;;;;EAOArB,uBAAA,CAAAe,SAAA,CAAAW,OAAO,GAAP,UAAQC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,UAAU;IACzB,IAAMC,UAAU,GAAGD,UAAU,CAACC,UAAU;IACxC,IAAMC,UAAU,GAAGF,UAAU,CAACG,SAAS,CAACD,UAAU;IAClD,IAAM7B,SAAS,GAAG,IAAI,CAACe,QAAQ,EAAE;IACjC,IAAMgB,UAAU,GAAG/B,SAAS,CAACgC,SAAS,EAAE;IACxC,IAAIlB,IAAI,GAAGiB,UAAU,CAACR,OAAO,CAACC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEE,UAAU,EAAEC,UAAU,CAAC;IAC9D,IAAIf,IAAI,CAACG,QAAQ,EAAE,IAAInC,SAAS,CAACwC,KAAK,EAAE;MACtC,IAAI,CAACtB,SAAS,CAACmB,yBAAyB,EAAE,EAAE;QAC1C;QACAL,IAAI,CAACmB,QAAQ,CAACnD,SAAS,CAACsC,MAAM,CAAC;OAChC,MAAM,IAAIpB,SAAS,CAACkC,UAAU,EAAE,GAAG,CAAC,EAAE;QACrC;QACA,IAAI,CAACzB,SAAS,GAAG,IAAI;;;IAGzB,IAAI,CAAC,IAAI,CAACI,cAAc,CAACC,IAAI,CAAC,EAAE;MAC9BA,IAAI,GAAGA,IAAI,CAACqB,cAAc,EAAE;;IAE9B,OAAOrB,IAAI;EACb,CAAC;EAED;;;;;;EAMAjB,uBAAA,CAAAe,SAAA,CAAAwB,kBAAkB,GAAlB,UAAmBC,KAAK,EAAEC,IAAI,EAAExB,IAAI;IAClC,IAAI,IAAI,CAACD,cAAc,CAACC,IAAI,CAAC,EAAE;MAC7B,OAAOhB,MAAA,CAAAc,SAAA,CAAMwB,kBAAkB,CAAAlC,IAAA,OAACmC,KAAK,EAAEC,IAAI,EAAExB,IAAI,CAAC;;IAEpD,OAAO,KAAK;EACd,CAAC;EAED;;;;;EAKAjB,uBAAA,CAAAe,SAAA,CAAA2B,YAAY,GAAZ,UAAaZ,UAAU;IACrB,OAAO,CAAC,CAAC,IAAI,CAACZ,QAAQ,EAAE,CAACiB,SAAS,EAAE;EACtC,CAAC;EAED;;;;;;EAMAnC,uBAAA,CAAAe,SAAA,CAAA4B,WAAW,GAAX,UAAYb,UAAU,EAAEc,MAAM;IAC5B,IAAMC,UAAU,GAAGf,UAAU,CAACgB,gBAAgB,CAAChB,UAAU,CAACiB,UAAU,CAAC;IACrE,IAAMd,SAAS,GAAGH,UAAU,CAACG,SAAS;IACtC,IAAMD,UAAU,GAAGC,SAAS,CAACD,UAAU;IACvC,IAAMgB,cAAc,GAAGf,SAAS,CAACgB,UAAU;IAC3C,IAAMC,UAAU,GAAGjB,SAAS,CAACkB,MAAM;IACnC,IAAMC,QAAQ,GAAGnB,SAAS,CAACmB,QAAQ;IACnC,IAAMrB,UAAU,GAAGD,UAAU,CAACC,UAAU;IAExC,IAAM5B,SAAS,GAAG,IAAI,CAACe,QAAQ,EAAE;IACjC,IAAMgB,UAAU,GAAG/B,SAAS,CAACgC,SAAS,EAAE;IACxC,IAAMkB,cAAc,GAAGnB,UAAU,CAACoB,WAAW,EAAE;IAC/C,IAAMC,QAAQ,GAAGrB,UAAU,CAACsB,wBAAwB,CAACxB,UAAU,CAAC;IAChE,IAAML,CAAC,GAAG4B,QAAQ,CAACE,iBAAiB,CAACT,cAAc,EAAEd,UAAU,CAACwB,UAAU,CAAC;IAC3E,IAAMC,cAAc,GAAGJ,QAAQ,CAACK,aAAa,CAACjC,CAAC,CAAC;IAEhD,IAAIkC,MAAM,GAAG/B,UAAU,CAAC+B,MAAM;IAC9B,IAAMC,WAAW,GACfjB,UAAU,CAACgB,MAAM,IAAIhE,cAAc,CAACgD,UAAU,CAACgB,MAAM,EAAE7B,UAAU,CAAC;IACpE,IAAI8B,WAAW,EAAE;MACfD,MAAM,GAAGnE,eAAe,CACtBmE,MAAM,EACNhE,cAAc,CAACgD,UAAU,CAACgB,MAAM,EAAE7B,UAAU,CAAC,CAC9C;;IAGH,IAAM+B,cAAc,GAAG7B,UAAU,CAAC8B,iBAAiB,CAACjC,UAAU,CAAC;IAE/D;IACA,IAAIkC,KAAK,GAAGC,IAAI,CAACC,KAAK,CAACrC,UAAU,CAACsC,IAAI,CAAC,CAAC,CAAC,GAAGL,cAAc,CAAC;IAC3D,IAAIM,MAAM,GAAGH,IAAI,CAACC,KAAK,CAACrC,UAAU,CAACsC,IAAI,CAAC,CAAC,CAAC,GAAGL,cAAc,CAAC;IAE5D,IAAIX,QAAQ,EAAE;MACZ,IAAMgB,IAAI,GAAGF,IAAI,CAACC,KAAK,CAACD,IAAI,CAACI,IAAI,CAACL,KAAK,GAAGA,KAAK,GAAGI,MAAM,GAAGA,MAAM,CAAC,CAAC;MACnEJ,KAAK,GAAGG,IAAI;MACZC,MAAM,GAAGD,IAAI;;IAGf,IAAMG,EAAE,GAAIZ,cAAc,GAAGM,KAAK,GAAI,CAAC,GAAGF,cAAc;IACxD,IAAMS,EAAE,GAAIb,cAAc,GAAGU,MAAM,GAAI,CAAC,GAAGN,cAAc;IACzD,IAAMU,YAAY,GAAG,CACnBvB,UAAU,CAAC,CAAC,CAAC,GAAGqB,EAAE,EAClBrB,UAAU,CAAC,CAAC,CAAC,GAAGsB,EAAE,EAClBtB,UAAU,CAAC,CAAC,CAAC,GAAGqB,EAAE,EAClBrB,UAAU,CAAC,CAAC,CAAC,GAAGsB,EAAE,CACnB;IAED,IAAME,SAAS,GAAGnB,QAAQ,CAACoB,yBAAyB,CAACd,MAAM,EAAElC,CAAC,CAAC;IAE/D;;;IAGA,IAAMiD,cAAc,GAAG,EAAE;IACzBA,cAAc,CAACjD,CAAC,CAAC,GAAG,EAAE;IAEtB,IAAMkD,eAAe,GAAG,IAAI,CAACC,sBAAsB,CACjD5C,UAAU,EACVF,UAAU,EACV4C,cAAc,CACf;IAED,IAAM/D,SAAS,GAAG,IAAI,CAACA,SAAS;IAChC,IAAMkE,YAAY,GAAG,IAAI,CAACjE,aAAa;IACvC,IAAI,CAACF,SAAS,GAAG,KAAK;IACtB,KAAK,IAAIgB,CAAC,GAAG8C,SAAS,CAACM,IAAI,EAAEpD,CAAC,IAAI8C,SAAS,CAACO,IAAI,EAAE,EAAErD,CAAC,EAAE;MACrD,KAAK,IAAIC,CAAC,GAAG6C,SAAS,CAACQ,IAAI,EAAErD,CAAC,IAAI6C,SAAS,CAACS,IAAI,EAAE,EAAEtD,CAAC,EAAE;QACrD,IAAMZ,IAAI,GAAG,IAAI,CAACS,OAAO,CAACC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,UAAU,CAAC;QAC9C,IAAI,IAAI,CAACd,cAAc,CAACC,IAAI,CAAC,EAAE;UAC7B,IAAMmE,GAAG,GAAGtF,MAAM,CAAC,IAAI,CAAC;UACxB,IAAImB,IAAI,CAACG,QAAQ,EAAE,IAAInC,SAAS,CAACsC,MAAM,EAAE;YACvCqD,cAAc,CAACjD,CAAC,CAAC,CAACV,IAAI,CAACoE,SAAS,CAACC,QAAQ,EAAE,CAAC,GAAGrE,IAAI;YACnD,IAAMsE,YAAY,GAAGtE,IAAI,CAACsE,YAAY,CAACH,GAAG,CAAC;YAC3C,IACE,CAAC,IAAI,CAACxE,SAAS,KACd2E,YAAY,IAAI,IAAI,CAAC5E,aAAa,CAAC6E,OAAO,CAACvE,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EACzD;cACA,IAAI,CAACL,SAAS,GAAG,IAAI;;;UAGzB,IAAIK,IAAI,CAACwE,QAAQ,CAACL,GAAG,EAAEtD,UAAU,CAAC4D,IAAI,CAAC,KAAK,CAAC,EAAE;YAC7C;YACA;;;QAIJ,IAAMC,cAAc,GAAGpC,QAAQ,CAACqC,0BAA0B,CACxD3E,IAAI,CAACoE,SAAS,EACdN,YAAY,EACZlE,SAAS,CACV;QAED,IAAIgF,OAAO,GAAG,KAAK;QACnB,IAAIF,cAAc,EAAE;UAClBE,OAAO,GAAGhB,eAAe,CAAClD,CAAC,GAAG,CAAC,EAAEgE,cAAc,CAAC;;QAElD,IAAI,CAACE,OAAO,EAAE;UACZtC,QAAQ,CAACuC,+BAA+B,CACtC7E,IAAI,CAACoE,SAAS,EACdR,eAAe,EACfE,YAAY,EACZlE,SAAS,CACV;;;;IAKP,IAAMkF,WAAW,GAAGpC,cAAc,GAAGX,cAAc;IAEnD;IACA3D,gBAAgB,CACd,IAAI,CAAC2G,cAAc,EACnBlE,UAAU,CAACsC,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,EACtBtC,UAAU,CAACsC,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,EACtB,CAAC,GAAGL,cAAc,EAClB,CAAC,GAAGA,cAAc,EAClBX,QAAQ,EACR,CAACa,KAAK,GAAG,CAAC,EACV,CAACI,MAAM,GAAG,CAAC,CACZ;IAED,IAAM4B,eAAe,GAAGrG,qBAAqB,CAAC,IAAI,CAACoG,cAAc,CAAC;IAElE,IAAI,CAACE,YAAY,CAACtD,MAAM,EAAEqD,eAAe,EAAEpD,UAAU,CAACsD,OAAO,CAAC;IAC9D,IAAMC,OAAO,GAAG,IAAI,CAACA,OAAO;IAC5B,IAAMC,MAAM,GAAGD,OAAO,CAACC,MAAM;IAE7B/G,WAAW,CAAC,IAAI,CAACgH,qBAAqB,EAAE,IAAI,CAACN,cAAc,CAAC;IAE5D;IACA3G,gBAAgB,CACd,IAAI,CAACkH,aAAa,EAClBtC,KAAK,GAAG,CAAC,EACTI,MAAM,GAAG,CAAC,EACV0B,WAAW,EACXA,WAAW,EACX,CAAC,EACD,CAAC9B,KAAK,GAAG,CAAC,EACV,CAACI,MAAM,GAAG,CAAC,CACZ;IAED,IAAIgC,MAAM,CAACpC,KAAK,IAAIA,KAAK,IAAIoC,MAAM,CAAChC,MAAM,IAAIA,MAAM,EAAE;MACpDgC,MAAM,CAACpC,KAAK,GAAGA,KAAK;MACpBoC,MAAM,CAAChC,MAAM,GAAGA,MAAM;KACvB,MAAM,IAAI,CAAC,IAAI,CAACmC,eAAe,EAAE;MAChCJ,OAAO,CAACK,SAAS,CAAC,CAAC,EAAE,CAAC,EAAExC,KAAK,EAAEI,MAAM,CAAC;;IAGxC,IAAIP,WAAW,EAAE;MACf,IAAI,CAAC4C,aAAa,CAACN,OAAO,EAAEtE,UAAU,EAAEgC,WAAW,CAAC;;IAGtDvE,MAAM,CAAC6G,OAAO,EAAElE,UAAU,CAACyE,iBAAiB,EAAE,CAAC;IAC/C,IAAI,CAACC,SAAS,CAACR,OAAO,EAAEtE,UAAU,CAAC;IAEnC,IAAI,CAACnB,aAAa,CAACkG,MAAM,GAAG,CAAC;IAC7B;IACA,IAAIC,EAAE,GAAGC,MAAM,CAACC,IAAI,CAACpC,cAAc,CAAC,CAACqC,GAAG,CAACC,MAAM,CAAC;IAChDJ,EAAE,CAACK,IAAI,CAACpH,yBAAyB,CAAC;IAElC,IAAIqH,KAAK,EAAEC,MAAM,EAAEC,WAAW;IAC9B,IACEzE,UAAU,CAACsD,OAAO,KAAK,CAAC,KACvB,CAAC,IAAI,CAACK,eAAe,IACpBtE,UAAU,CAACqF,SAAS,CAACzF,UAAU,CAACG,SAAS,CAACD,UAAU,CAAC,CAAC,EACxD;MACA8E,EAAE,GAAGA,EAAE,CAACU,OAAO,EAAE;KAClB,MAAM;MACLJ,KAAK,GAAG,EAAE;MACVC,MAAM,GAAG,EAAE;;IAEb,KAAK,IAAII,CAAC,GAAGX,EAAE,CAACD,MAAM,GAAG,CAAC,EAAEY,CAAC,IAAI,CAAC,EAAE,EAAEA,CAAC,EAAE;MACvC,IAAMC,QAAQ,GAAGZ,EAAE,CAACW,CAAC,CAAC;MACtB,IAAME,oBAAoB,GAAGzF,UAAU,CAAC0F,gBAAgB,CACtDF,QAAQ,EACR3F,UAAU,EACVC,UAAU,CACX;MACD,IAAM6F,iBAAiB,GAAGtE,QAAQ,CAACK,aAAa,CAAC8D,QAAQ,CAAC;MAC1D,IAAMI,YAAY,GAAGD,iBAAiB,GAAGlE,cAAc;MACvD,IAAMoE,IAAE,GAAGJ,oBAAoB,CAAC,CAAC,CAAC,GAAGG,YAAY,GAAG/B,WAAW;MAC/D,IAAMiC,IAAE,GAAGL,oBAAoB,CAAC,CAAC,CAAC,GAAGG,YAAY,GAAG/B,WAAW;MAC/D,IAAMkC,eAAe,GAAG1E,QAAQ,CAAC2E,wBAAwB,CACvDvI,UAAU,CAAC8E,YAAY,CAAC,EACxBiD,QAAQ,CACT;MACD,IAAMS,gBAAgB,GAAG5E,QAAQ,CAAC6E,kBAAkB,CAACH,eAAe,CAAC;MACrE,IAAMI,QAAM,GAAGlJ,cAAc,CAAC,IAAI,CAACoH,aAAa,EAAE,CAC/CxC,cAAc,IAAIoE,gBAAgB,CAAC,CAAC,CAAC,GAAG1D,YAAY,CAAC,CAAC,CAAC,CAAC,GACvDd,cAAc,EACfI,cAAc,IAAIU,YAAY,CAAC,CAAC,CAAC,GAAG0D,gBAAgB,CAAC,CAAC,CAAC,CAAC,GACvDxE,cAAc,CACjB,CAAC;MACF,IAAM2E,UAAU,GACdvE,cAAc,GAAG7B,UAAU,CAACqG,sBAAsB,CAACvG,UAAU,CAAC;MAChE,IAAMwG,WAAW,GAAG5D,cAAc,CAAC8C,QAAQ,CAAC;MAC5C,KAAK,IAAMe,YAAY,IAAID,WAAW,EAAE;QACtC,IAAMvH,IAAI,GAAG,mDAAqDuH,WAAW,CAC3EC,YAAY,CACZ;QACF,IAAMpD,SAAS,GAAGpE,IAAI,CAACoE,SAAS;QAEhC;QACA,IAAMqD,MAAM,GAAGL,QAAM,CAAC,CAAC,CAAC,GAAG,CAACJ,eAAe,CAAC,CAAC,CAAC,GAAG5C,SAAS,CAAC,CAAC,CAAC,IAAI0C,IAAE;QACnE,IAAMY,KAAK,GAAGzE,IAAI,CAACC,KAAK,CAACuE,MAAM,GAAGX,IAAE,CAAC;QACrC,IAAMa,MAAM,GAAGP,QAAM,CAAC,CAAC,CAAC,GAAG,CAACJ,eAAe,CAAC,CAAC,CAAC,GAAG5C,SAAS,CAAC,CAAC,CAAC,IAAI2C,IAAE;QACnE,IAAMa,KAAK,GAAG3E,IAAI,CAACC,KAAK,CAACyE,MAAM,GAAGZ,IAAE,CAAC;QACrC,IAAMpG,CAAC,GAAGsC,IAAI,CAACC,KAAK,CAACuE,MAAM,CAAC;QAC5B,IAAM7G,CAAC,GAAGqC,IAAI,CAACC,KAAK,CAACyE,MAAM,CAAC;QAC5B,IAAME,CAAC,GAAGH,KAAK,GAAG/G,CAAC;QACnB,IAAMmH,CAAC,GAAGF,KAAK,GAAGhH,CAAC;QACnB,IAAMmH,UAAU,GAAGrH,CAAC,KAAK+F,QAAQ;QAEjC,IAAMnC,YAAY,GAChByD,UAAU,IAAI/H,IAAI,CAACwE,QAAQ,CAAC3F,MAAM,CAAC,IAAI,CAAC,EAAEgC,UAAU,CAAC4D,IAAI,CAAC,KAAK,CAAC;QAClE,IAAI,CAACH,YAAY,EAAE;UACjB,IAAI6B,KAAK,EAAE;YACT;YACAhB,OAAO,CAAC6C,IAAI,EAAE;YACd3B,WAAW,GAAG,CAAC1F,CAAC,EAAEC,CAAC,EAAED,CAAC,GAAGkH,CAAC,EAAEjH,CAAC,EAAED,CAAC,GAAGkH,CAAC,EAAEjH,CAAC,GAAGkH,CAAC,EAAEnH,CAAC,EAAEC,CAAC,GAAGkH,CAAC,CAAC;YACtD,KAAK,IAAIG,GAAC,GAAG,CAAC,EAAEC,EAAE,GAAG/B,KAAK,CAACP,MAAM,EAAEqC,GAAC,GAAGC,EAAE,EAAE,EAAED,GAAC,EAAE;cAC9C,IAAIvH,CAAC,KAAK+F,QAAQ,IAAIA,QAAQ,GAAGL,MAAM,CAAC6B,GAAC,CAAC,EAAE;gBAC1C,IAAME,IAAI,GAAGhC,KAAK,CAAC8B,GAAC,CAAC;gBACrB9C,OAAO,CAACiD,SAAS,EAAE;gBACnB;gBACAjD,OAAO,CAACkD,MAAM,CAAChC,WAAW,CAAC,CAAC,CAAC,EAAEA,WAAW,CAAC,CAAC,CAAC,CAAC;gBAC9ClB,OAAO,CAACmD,MAAM,CAACjC,WAAW,CAAC,CAAC,CAAC,EAAEA,WAAW,CAAC,CAAC,CAAC,CAAC;gBAC9ClB,OAAO,CAACmD,MAAM,CAACjC,WAAW,CAAC,CAAC,CAAC,EAAEA,WAAW,CAAC,CAAC,CAAC,CAAC;gBAC9ClB,OAAO,CAACmD,MAAM,CAACjC,WAAW,CAAC,CAAC,CAAC,EAAEA,WAAW,CAAC,CAAC,CAAC,CAAC;gBAC9C;gBACAlB,OAAO,CAACkD,MAAM,CAACF,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,CAAC;gBAChChD,OAAO,CAACmD,MAAM,CAACH,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,CAAC;gBAChChD,OAAO,CAACmD,MAAM,CAACH,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,CAAC;gBAChChD,OAAO,CAACmD,MAAM,CAACH,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,CAAC;gBAChChD,OAAO,CAACgD,IAAI,EAAE;;;YAGlBhC,KAAK,CAACoC,IAAI,CAAClC,WAAW,CAAC;YACvBD,MAAM,CAACmC,IAAI,CAAC9B,QAAQ,CAAC;WACtB,MAAM;YACLtB,OAAO,CAACK,SAAS,CAAC7E,CAAC,EAAEC,CAAC,EAAEiH,CAAC,EAAEC,CAAC,CAAC;;;QAGjC,IAAI,CAACU,aAAa,CAChBxI,IAAI,EACJa,UAAU,EACVF,CAAC,EACDC,CAAC,EACDiH,CAAC,EACDC,CAAC,EACDT,UAAU,EACVU,UAAU,EACVnG,UAAU,CAACsD,OAAO,CACnB;QACD,IAAIiB,KAAK,IAAI,CAAC7B,YAAY,EAAE;UAC1Ba,OAAO,CAACsD,OAAO,EAAE;;QAEnB,IAAI,CAAC/I,aAAa,CAAC6I,IAAI,CAACvI,IAAI,CAAC;QAC7B,IAAI,CAAC0I,eAAe,CAAC7H,UAAU,CAAC8H,SAAS,EAAE1H,UAAU,EAAEjB,IAAI,CAAC;;;IAIhE,IAAI,CAACP,gBAAgB,GAAG2C,cAAc;IACtC,IAAI,CAACwG,kBAAkB,GAAGlG,cAAc;IACxC,IAAI,CAACrD,aAAa,GAChB,CAAC,IAAI,CAACC,eAAe,IAAI,CAACd,MAAM,CAAC,IAAI,CAACc,eAAe,EAAEkE,YAAY,CAAC;IACtE,IAAI,CAAClE,eAAe,GAAGkE,YAAY;IACnC,IAAI,CAACjE,kBAAkB,GAAGuB,UAAU;IACpC,IAAI,CAACtB,kBAAkB,GAAGuB,UAAU;IAEpC,IAAI,CAAC8H,iBAAiB,CACpBhI,UAAU,EACVI,UAAU,EACVqB,QAAQ,EACRxB,UAAU,EACVC,UAAU,EACV6B,MAAM,EACNlC,CAAC,EACDxB,SAAS,CAACkC,UAAU,EAAE,CACvB;IACD,IAAI,CAAC0H,mBAAmB,CAACjI,UAAU,EAAEI,UAAU,CAAC;IAEhD,IAAI,CAAC8H,UAAU,CAAC5D,OAAO,EAAEtE,UAAU,CAAC;IAEpC,IAAIe,UAAU,CAACgB,MAAM,EAAE;MACrBuC,OAAO,CAACsD,OAAO,EAAE;;IAGnB,IAAIzD,eAAe,KAAKI,MAAM,CAAC4D,KAAK,CAACC,SAAS,EAAE;MAC9C7D,MAAM,CAAC4D,KAAK,CAACC,SAAS,GAAGjE,eAAe;;IAG1C,OAAO,IAAI,CAACkE,SAAS;EACvB,CAAC;EAED;;;;;;;;;;;EAWAnK,uBAAA,CAAAe,SAAA,CAAA0I,aAAa,GAAb,UAAcxI,IAAI,EAAEa,UAAU,EAAEF,CAAC,EAAEC,CAAC,EAAEiH,CAAC,EAAEC,CAAC,EAAEqB,MAAM,EAAEpB,UAAU,EAAE7C,OAAO;IACrE,IAAMkE,KAAK,GAAG,IAAI,CAACC,YAAY,CAACrJ,IAAI,CAAC;IACrC,IAAI,CAACoJ,KAAK,EAAE;MACV;;IAEF,IAAMjF,GAAG,GAAGtF,MAAM,CAAC,IAAI,CAAC;IACxB,IAAMyK,SAAS,GAAGvB,UAAU,GAAG/H,IAAI,CAACwE,QAAQ,CAACL,GAAG,EAAEtD,UAAU,CAAC4D,IAAI,CAAC,GAAG,CAAC;IACtE,IAAM8E,KAAK,GAAGrE,OAAO,GAAGoE,SAAS;IACjC,IAAME,YAAY,GAAGD,KAAK,KAAK,IAAI,CAACpE,OAAO,CAACsE,WAAW;IACvD,IAAID,YAAY,EAAE;MAChB,IAAI,CAACrE,OAAO,CAAC6C,IAAI,EAAE;MACnB,IAAI,CAAC7C,OAAO,CAACsE,WAAW,GAAGF,KAAK;;IAElC,IAAI,CAACpE,OAAO,CAACuE,SAAS,CACpBN,KAAK,EACLD,MAAM,EACNA,MAAM,EACNC,KAAK,CAACpG,KAAK,GAAG,CAAC,GAAGmG,MAAM,EACxBC,KAAK,CAAChG,MAAM,GAAG,CAAC,GAAG+F,MAAM,EACzBxI,CAAC,EACDC,CAAC,EACDiH,CAAC,EACDC,CAAC,CACF;IAED,IAAI0B,YAAY,EAAE;MAChB,IAAI,CAACrE,OAAO,CAACsD,OAAO,EAAE;;IAExB,IAAIa,SAAS,KAAK,CAAC,EAAE;MACnBzI,UAAU,CAAC8I,OAAO,GAAG,IAAI;KAC1B,MAAM,IAAI5B,UAAU,EAAE;MACrB/H,IAAI,CAAC4J,aAAa,CAACzF,GAAG,CAAC;;EAE3B,CAAC;EAED;;;EAGApF,uBAAA,CAAAe,SAAA,CAAA+J,QAAQ,GAAR;IACE,IAAM1E,OAAO,GAAG,IAAI,CAACA,OAAO;IAC5B,OAAOA,OAAO,GAAGA,OAAO,CAACC,MAAM,GAAG,IAAI;EACxC,CAAC;EAED;;;;;;EAMArG,uBAAA,CAAAe,SAAA,CAAAuJ,YAAY,GAAZ,UAAarJ,IAAI;IACf,OAAOA,IAAI,CAAC6J,QAAQ,EAAE;EACxB,CAAC;EAED;;;;;EAKA9K,uBAAA,CAAAe,SAAA,CAAAgJ,mBAAmB,GAAnB,UAAoBjI,UAAU,EAAEI,UAAU;IACxC,IAAIA,UAAU,CAAC6I,cAAc,EAAE,EAAE;MAC/B;;;;;MAKA,IAAMC,kBAAkB,GAAG,UAAU9I,UAAU,EAAE+E,GAAG,EAAEnF,UAAU;QAC9D,IAAMmJ,aAAa,GAAGnL,MAAM,CAACoC,UAAU,CAAC;QACxC,IAAI+I,aAAa,IAAInJ,UAAU,CAAC8H,SAAS,EAAE;UACzC1H,UAAU,CAACgJ,WAAW,CACpBpJ,UAAU,CAACG,SAAS,CAACD,UAAU,EAC/BF,UAAU,CAAC8H,SAAS,CAACqB,aAAa,CAAC,CACpC;;MAEL,CAAC,CAACE,IAAI,CAAC,IAAI,EAAEjJ,UAAU,CAAC;MAExBJ,UAAU,CAACsJ,mBAAmB,CAAC5B,IAAI,EACjC,iEAAmEwB,kBAAmB,CACvF;;EAEL,CAAC;EAED;;;;;;EAMAhL,uBAAA,CAAAe,SAAA,CAAA4I,eAAe,GAAf,UAAgBC,SAAS,EAAE1H,UAAU,EAAEjB,IAAI;IACzC;IACA,IAAMgK,aAAa,GAAGnL,MAAM,CAACoC,UAAU,CAAC;IACxC,IAAI,EAAE+I,aAAa,IAAIrB,SAAS,CAAC,EAAE;MACjCA,SAAS,CAACqB,aAAa,CAAC,GAAG,EAAE;;IAE/BrB,SAAS,CAACqB,aAAa,CAAC,CAAChK,IAAI,CAACoK,MAAM,EAAE,CAAC,GAAG,IAAI;EAChD,CAAC;EAED;;;;;;;;;;;;;;;;;;EAkBArL,uBAAA,CAAAe,SAAA,CAAA+I,iBAAiB,GAAjB,UACEhI,UAAU,EACVI,UAAU,EACVqB,QAAQ,EACRxB,UAAU,EACVC,UAAU,EACV6B,MAAM,EACN6D,QAAQ,EACR4D,OAAO,EACPC,gBAAgB;IAEhB,IAAMN,aAAa,GAAGnL,MAAM,CAACoC,UAAU,CAAC;IACxC,IAAI,EAAE+I,aAAa,IAAInJ,UAAU,CAAC0J,WAAW,CAAC,EAAE;MAC9C1J,UAAU,CAAC0J,WAAW,CAACP,aAAa,CAAC,GAAG,EAAE;;IAE5C,IAAMO,WAAW,GAAG1J,UAAU,CAAC0J,WAAW,CAACP,aAAa,CAAC;IACzD,IAAMQ,SAAS,GAAG3J,UAAU,CAAC2J,SAAS;IACtC,IAAMC,OAAO,GAAGnI,QAAQ,CAACoI,UAAU,EAAE;IACrC,IAAIC,SAAS,GAAG,CAAC;IACjB,IAAI3K,IAAI,EAAEyD,SAAS,EAAEf,cAAc,EAAE/B,CAAC,EAAEC,CAAC,EAAEF,CAAC;IAC5C,KAAKA,CAAC,GAAG+J,OAAO,EAAE/J,CAAC,IAAI+F,QAAQ,EAAE,EAAE/F,CAAC,EAAE;MACpC+C,SAAS,GAAGnB,QAAQ,CAACoB,yBAAyB,CAACd,MAAM,EAAElC,CAAC,EAAE+C,SAAS,CAAC;MACpEf,cAAc,GAAGJ,QAAQ,CAACK,aAAa,CAACjC,CAAC,CAAC;MAC1C,KAAKC,CAAC,GAAG8C,SAAS,CAACM,IAAI,EAAEpD,CAAC,IAAI8C,SAAS,CAACO,IAAI,EAAE,EAAErD,CAAC,EAAE;QACjD,KAAKC,CAAC,GAAG6C,SAAS,CAACQ,IAAI,EAAErD,CAAC,IAAI6C,SAAS,CAACS,IAAI,EAAE,EAAEtD,CAAC,EAAE;UACjD,IAAI6F,QAAQ,GAAG/F,CAAC,IAAI2J,OAAO,EAAE;YAC3B,EAAEM,SAAS;YACX3K,IAAI,GAAGiB,UAAU,CAACR,OAAO,CAACC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEE,UAAU,EAAEC,UAAU,CAAC;YAC1D,IAAIf,IAAI,CAACG,QAAQ,EAAE,IAAInC,SAAS,CAAC4M,IAAI,EAAE;cACrCL,WAAW,CAACvK,IAAI,CAACoK,MAAM,EAAE,CAAC,GAAG,IAAI;cACjC,IAAI,CAACI,SAAS,CAACK,WAAW,CAAC7K,IAAI,CAACoK,MAAM,EAAE,CAAC,EAAE;gBACzCI,SAAS,CAACM,OAAO,CAAC,CAChB9K,IAAI,EACJgK,aAAa,EACb1H,QAAQ,CAACyI,kBAAkB,CAAC/K,IAAI,CAACoE,SAAS,CAAC,EAC3C1B,cAAc,CACf,CAAC;;;YAGN,IAAI4H,gBAAgB,KAAKU,SAAS,EAAE;cAClCV,gBAAgB,CAACtK,IAAI,CAAC;;WAEzB,MAAM;YACLiB,UAAU,CAACgK,OAAO,CAACvK,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEG,UAAU,CAAC;;;;;IAK/CE,UAAU,CAACiK,eAAe,CAACP,SAAS,EAAE5J,UAAU,CAAC;EACnD,CAAC;EACH,OAAAhC,uBAAC;AAAD,CAAC,CA3lBqCjB,mBAAmB;AA6lBzD;;;;AAIAiB,uBAAuB,CAACe,SAAS,CAACG,QAAQ;AAE1C,eAAelB,uBAAuB"},"metadata":{},"sourceType":"module","externalDependencies":[]}
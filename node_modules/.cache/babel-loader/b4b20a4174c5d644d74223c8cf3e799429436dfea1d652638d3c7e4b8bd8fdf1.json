{"ast":null,"code":"/**\n * @module ol/tilegrid/WMTS\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport TileGrid from './TileGrid.js';\nimport { find } from '../array.js';\nimport { get as getProjection } from '../proj.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"../extent.js\").Extent} [extent] Extent for the tile grid. No tiles\n * outside this extent will be requested by {@link module:ol/source/Tile} sources.\n * When no `origin` or `origins` are configured, the `origin` will be set to the\n * top-left corner of the extent.\n * @property {import(\"../coordinate.js\").Coordinate} [origin] The tile grid origin, i.e.\n * where the `x` and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left\n * to right and downwards. If not specified, `extent` or `origins` must be provided.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} [origins] Tile grid origins,\n * i.e. where the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If\n * given, the array length should match the length of the `resolutions` array, i.e.\n * each resolution can have a different origin. Tile coordinates increase left to\n * right and downwards. If not specified, `extent` or `origin` must be provided.\n * @property {!Array<number>} resolutions Resolutions. The array index of each\n * resolution needs to match the zoom level. This means that even if a `minZoom`\n * is configured, the resolutions array will have a length of `maxZoom + 1`\n * @property {!Array<string>} matrixIds matrix IDs. The length of this array needs\n * to match the length of the `resolutions` array.\n * @property {Array<import(\"../size.js\").Size>} [sizes] Number of tile rows and columns\n * of the grid for each zoom level. The values here are the `TileMatrixWidth` and\n * `TileMatrixHeight` advertised in the GetCapabilities response of the WMTS, and\n * define each zoom level's extent together with the `origin` or `origins`.\n * A grid `extent` can be configured in addition, and will further limit the extent for\n * which tile requests are made by sources. If the bottom-left corner of\n * an extent is used as `origin` or `origins`, then the `y` value must be\n * negative because OpenLayers tile coordinates use the top left as the origin.\n * @property {number|import(\"../size.js\").Size} [tileSize] Tile size.\n * @property {Array<import(\"../size.js\").Size>} [tileSizes] Tile sizes. The length of\n * this array needs to match the length of the `resolutions` array.\n */\n/**\n * @classdesc\n * Set the grid pattern for sources accessing WMTS tiled-image servers.\n * @api\n */\nvar WMTSTileGrid = /** @class */function (_super) {\n  __extends(WMTSTileGrid, _super);\n  /**\n   * @param {Options} options WMTS options.\n   */\n  function WMTSTileGrid(options) {\n    var _this = _super.call(this, {\n      extent: options.extent,\n      origin: options.origin,\n      origins: options.origins,\n      resolutions: options.resolutions,\n      tileSize: options.tileSize,\n      tileSizes: options.tileSizes,\n      sizes: options.sizes\n    }) || this;\n    /**\n     * @private\n     * @type {!Array<string>}\n     */\n    _this.matrixIds_ = options.matrixIds;\n    return _this;\n  }\n  /**\n   * @param {number} z Z.\n   * @return {string} MatrixId..\n   */\n  WMTSTileGrid.prototype.getMatrixId = function (z) {\n    return this.matrixIds_[z];\n  };\n  /**\n   * Get the list of matrix identifiers.\n   * @return {Array<string>} MatrixIds.\n   * @api\n   */\n  WMTSTileGrid.prototype.getMatrixIds = function () {\n    return this.matrixIds_;\n  };\n  return WMTSTileGrid;\n}(TileGrid);\nexport default WMTSTileGrid;\n/**\n * Create a tile grid from a WMTS capabilities matrix set and an\n * optional TileMatrixSetLimits.\n * @param {Object} matrixSet An object representing a matrixSet in the\n *     capabilities document.\n * @param {import(\"../extent.js\").Extent=} opt_extent An optional extent to restrict the tile\n *     ranges the server provides.\n * @param {Array<Object>=} opt_matrixLimits An optional object representing\n *     the available matrices for tileGrid.\n * @return {WMTSTileGrid} WMTS tileGrid instance.\n * @api\n */\nexport function createFromCapabilitiesMatrixSet(matrixSet, opt_extent, opt_matrixLimits) {\n  /** @type {!Array<number>} */\n  var resolutions = [];\n  /** @type {!Array<string>} */\n  var matrixIds = [];\n  /** @type {!Array<import(\"../coordinate.js\").Coordinate>} */\n  var origins = [];\n  /** @type {!Array<import(\"../size.js\").Size>} */\n  var tileSizes = [];\n  /** @type {!Array<import(\"../size.js\").Size>} */\n  var sizes = [];\n  var matrixLimits = opt_matrixLimits !== undefined ? opt_matrixLimits : [];\n  var supportedCRSPropName = 'SupportedCRS';\n  var matrixIdsPropName = 'TileMatrix';\n  var identifierPropName = 'Identifier';\n  var scaleDenominatorPropName = 'ScaleDenominator';\n  var topLeftCornerPropName = 'TopLeftCorner';\n  var tileWidthPropName = 'TileWidth';\n  var tileHeightPropName = 'TileHeight';\n  var code = matrixSet[supportedCRSPropName];\n  var projection = getProjection(code.replace(/urn:ogc:def:crs:(\\w+):(.*:)?(\\w+)$/, '$1:$3')) || getProjection(code);\n  var metersPerUnit = projection.getMetersPerUnit();\n  // swap origin x and y coordinates if axis orientation is lat/long\n  var switchOriginXY = projection.getAxisOrientation().substr(0, 2) == 'ne';\n  matrixSet[matrixIdsPropName].sort(function (a, b) {\n    return b[scaleDenominatorPropName] - a[scaleDenominatorPropName];\n  });\n  matrixSet[matrixIdsPropName].forEach(function (elt) {\n    var matrixAvailable;\n    // use of matrixLimits to filter TileMatrices from GetCapabilities\n    // TileMatrixSet from unavailable matrix levels.\n    if (matrixLimits.length > 0) {\n      matrixAvailable = find(matrixLimits, function (elt_ml) {\n        if (elt[identifierPropName] == elt_ml[matrixIdsPropName]) {\n          return true;\n        }\n        // Fallback for tileMatrix identifiers that don't get prefixed\n        // by their tileMatrixSet identifiers.\n        if (elt[identifierPropName].indexOf(':') === -1) {\n          return matrixSet[identifierPropName] + ':' + elt[identifierPropName] === elt_ml[matrixIdsPropName];\n        }\n        return false;\n      });\n    } else {\n      matrixAvailable = true;\n    }\n    if (matrixAvailable) {\n      matrixIds.push(elt[identifierPropName]);\n      var resolution = elt[scaleDenominatorPropName] * 0.28e-3 / metersPerUnit;\n      var tileWidth = elt[tileWidthPropName];\n      var tileHeight = elt[tileHeightPropName];\n      if (switchOriginXY) {\n        origins.push([elt[topLeftCornerPropName][1], elt[topLeftCornerPropName][0]]);\n      } else {\n        origins.push(elt[topLeftCornerPropName]);\n      }\n      resolutions.push(resolution);\n      tileSizes.push(tileWidth == tileHeight ? tileWidth : [tileWidth, tileHeight]);\n      sizes.push([elt['MatrixWidth'], elt['MatrixHeight']]);\n    }\n  });\n  return new WMTSTileGrid({\n    extent: opt_extent,\n    origins: origins,\n    resolutions: resolutions,\n    matrixIds: matrixIds,\n    tileSizes: tileSizes,\n    sizes: sizes\n  });\n}","map":{"version":3,"names":["TileGrid","find","get","getProjection","WMTSTileGrid","_super","__extends","options","_this","call","extent","origin","origins","resolutions","tileSize","tileSizes","sizes","matrixIds_","matrixIds","prototype","getMatrixId","z","getMatrixIds","createFromCapabilitiesMatrixSet","matrixSet","opt_extent","opt_matrixLimits","matrixLimits","undefined","supportedCRSPropName","matrixIdsPropName","identifierPropName","scaleDenominatorPropName","topLeftCornerPropName","tileWidthPropName","tileHeightPropName","code","projection","replace","metersPerUnit","getMetersPerUnit","switchOriginXY","getAxisOrientation","substr","sort","a","b","forEach","elt","matrixAvailable","length","elt_ml","indexOf","push","resolution","tileWidth","tileHeight"],"sources":["/Users/mariovicky/Skripsi_OpenLayers/node_modules/ol/src/tilegrid/WMTS.js"],"sourcesContent":["/**\n * @module ol/tilegrid/WMTS\n */\n\nimport TileGrid from './TileGrid.js';\nimport {find} from '../array.js';\nimport {get as getProjection} from '../proj.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../extent.js\").Extent} [extent] Extent for the tile grid. No tiles\n * outside this extent will be requested by {@link module:ol/source/Tile} sources.\n * When no `origin` or `origins` are configured, the `origin` will be set to the\n * top-left corner of the extent.\n * @property {import(\"../coordinate.js\").Coordinate} [origin] The tile grid origin, i.e.\n * where the `x` and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left\n * to right and downwards. If not specified, `extent` or `origins` must be provided.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} [origins] Tile grid origins,\n * i.e. where the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If\n * given, the array length should match the length of the `resolutions` array, i.e.\n * each resolution can have a different origin. Tile coordinates increase left to\n * right and downwards. If not specified, `extent` or `origin` must be provided.\n * @property {!Array<number>} resolutions Resolutions. The array index of each\n * resolution needs to match the zoom level. This means that even if a `minZoom`\n * is configured, the resolutions array will have a length of `maxZoom + 1`\n * @property {!Array<string>} matrixIds matrix IDs. The length of this array needs\n * to match the length of the `resolutions` array.\n * @property {Array<import(\"../size.js\").Size>} [sizes] Number of tile rows and columns\n * of the grid for each zoom level. The values here are the `TileMatrixWidth` and\n * `TileMatrixHeight` advertised in the GetCapabilities response of the WMTS, and\n * define each zoom level's extent together with the `origin` or `origins`.\n * A grid `extent` can be configured in addition, and will further limit the extent for\n * which tile requests are made by sources. If the bottom-left corner of\n * an extent is used as `origin` or `origins`, then the `y` value must be\n * negative because OpenLayers tile coordinates use the top left as the origin.\n * @property {number|import(\"../size.js\").Size} [tileSize] Tile size.\n * @property {Array<import(\"../size.js\").Size>} [tileSizes] Tile sizes. The length of\n * this array needs to match the length of the `resolutions` array.\n */\n\n/**\n * @classdesc\n * Set the grid pattern for sources accessing WMTS tiled-image servers.\n * @api\n */\nclass WMTSTileGrid extends TileGrid {\n  /**\n   * @param {Options} options WMTS options.\n   */\n  constructor(options) {\n    super({\n      extent: options.extent,\n      origin: options.origin,\n      origins: options.origins,\n      resolutions: options.resolutions,\n      tileSize: options.tileSize,\n      tileSizes: options.tileSizes,\n      sizes: options.sizes,\n    });\n\n    /**\n     * @private\n     * @type {!Array<string>}\n     */\n    this.matrixIds_ = options.matrixIds;\n  }\n\n  /**\n   * @param {number} z Z.\n   * @return {string} MatrixId..\n   */\n  getMatrixId(z) {\n    return this.matrixIds_[z];\n  }\n\n  /**\n   * Get the list of matrix identifiers.\n   * @return {Array<string>} MatrixIds.\n   * @api\n   */\n  getMatrixIds() {\n    return this.matrixIds_;\n  }\n}\n\nexport default WMTSTileGrid;\n\n/**\n * Create a tile grid from a WMTS capabilities matrix set and an\n * optional TileMatrixSetLimits.\n * @param {Object} matrixSet An object representing a matrixSet in the\n *     capabilities document.\n * @param {import(\"../extent.js\").Extent=} opt_extent An optional extent to restrict the tile\n *     ranges the server provides.\n * @param {Array<Object>=} opt_matrixLimits An optional object representing\n *     the available matrices for tileGrid.\n * @return {WMTSTileGrid} WMTS tileGrid instance.\n * @api\n */\nexport function createFromCapabilitiesMatrixSet(\n  matrixSet,\n  opt_extent,\n  opt_matrixLimits\n) {\n  /** @type {!Array<number>} */\n  const resolutions = [];\n  /** @type {!Array<string>} */\n  const matrixIds = [];\n  /** @type {!Array<import(\"../coordinate.js\").Coordinate>} */\n  const origins = [];\n  /** @type {!Array<import(\"../size.js\").Size>} */\n  const tileSizes = [];\n  /** @type {!Array<import(\"../size.js\").Size>} */\n  const sizes = [];\n\n  const matrixLimits = opt_matrixLimits !== undefined ? opt_matrixLimits : [];\n\n  const supportedCRSPropName = 'SupportedCRS';\n  const matrixIdsPropName = 'TileMatrix';\n  const identifierPropName = 'Identifier';\n  const scaleDenominatorPropName = 'ScaleDenominator';\n  const topLeftCornerPropName = 'TopLeftCorner';\n  const tileWidthPropName = 'TileWidth';\n  const tileHeightPropName = 'TileHeight';\n\n  const code = matrixSet[supportedCRSPropName];\n  const projection =\n    getProjection(\n      code.replace(/urn:ogc:def:crs:(\\w+):(.*:)?(\\w+)$/, '$1:$3')\n    ) || getProjection(code);\n  const metersPerUnit = projection.getMetersPerUnit();\n  // swap origin x and y coordinates if axis orientation is lat/long\n  const switchOriginXY = projection.getAxisOrientation().substr(0, 2) == 'ne';\n\n  matrixSet[matrixIdsPropName].sort(function (a, b) {\n    return b[scaleDenominatorPropName] - a[scaleDenominatorPropName];\n  });\n\n  matrixSet[matrixIdsPropName].forEach(function (elt) {\n    let matrixAvailable;\n    // use of matrixLimits to filter TileMatrices from GetCapabilities\n    // TileMatrixSet from unavailable matrix levels.\n    if (matrixLimits.length > 0) {\n      matrixAvailable = find(matrixLimits, function (elt_ml) {\n        if (elt[identifierPropName] == elt_ml[matrixIdsPropName]) {\n          return true;\n        }\n        // Fallback for tileMatrix identifiers that don't get prefixed\n        // by their tileMatrixSet identifiers.\n        if (elt[identifierPropName].indexOf(':') === -1) {\n          return (\n            matrixSet[identifierPropName] + ':' + elt[identifierPropName] ===\n            elt_ml[matrixIdsPropName]\n          );\n        }\n        return false;\n      });\n    } else {\n      matrixAvailable = true;\n    }\n\n    if (matrixAvailable) {\n      matrixIds.push(elt[identifierPropName]);\n      const resolution =\n        (elt[scaleDenominatorPropName] * 0.28e-3) / metersPerUnit;\n      const tileWidth = elt[tileWidthPropName];\n      const tileHeight = elt[tileHeightPropName];\n      if (switchOriginXY) {\n        origins.push([\n          elt[topLeftCornerPropName][1],\n          elt[topLeftCornerPropName][0],\n        ]);\n      } else {\n        origins.push(elt[topLeftCornerPropName]);\n      }\n      resolutions.push(resolution);\n      tileSizes.push(\n        tileWidth == tileHeight ? tileWidth : [tileWidth, tileHeight]\n      );\n      sizes.push([elt['MatrixWidth'], elt['MatrixHeight']]);\n    }\n  });\n\n  return new WMTSTileGrid({\n    extent: opt_extent,\n    origins: origins,\n    resolutions: resolutions,\n    matrixIds: matrixIds,\n    tileSizes: tileSizes,\n    sizes: sizes,\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
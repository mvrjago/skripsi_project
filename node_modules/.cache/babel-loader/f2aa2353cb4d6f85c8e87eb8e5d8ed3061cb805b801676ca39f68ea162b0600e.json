{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/renderer/canvas/ImageLayer\n */\nimport CanvasLayerRenderer from './Layer.js';\nimport ViewHint from '../../ViewHint.js';\nimport { ENABLE_RASTER_REPROJECTION } from '../../reproj/common.js';\nimport { assign } from '../../obj.js';\nimport { compose as composeTransform, makeInverse } from '../../transform.js';\nimport { containsExtent, intersects } from '../../extent.js';\nimport { createTransformString } from '../../render/canvas.js';\nimport { fromUserExtent } from '../../proj.js';\nimport { getIntersection, isEmpty } from '../../extent.js';\n/**\n * @classdesc\n * Canvas renderer for image layers.\n * @api\n */\nvar CanvasImageLayerRenderer = /** @class */function (_super) {\n  __extends(CanvasImageLayerRenderer, _super);\n  /**\n   * @param {import(\"../../layer/Image.js\").default} imageLayer Image layer.\n   */\n  function CanvasImageLayerRenderer(imageLayer) {\n    var _this = _super.call(this, imageLayer) || this;\n    /**\n     * @protected\n     * @type {?import(\"../../ImageBase.js\").default}\n     */\n    _this.image_ = null;\n    return _this;\n  }\n  /**\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   */\n  CanvasImageLayerRenderer.prototype.getImage = function () {\n    return !this.image_ ? null : this.image_.getImage();\n  };\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  CanvasImageLayerRenderer.prototype.prepareFrame = function (frameState) {\n    var layerState = frameState.layerStatesArray[frameState.layerIndex];\n    var pixelRatio = frameState.pixelRatio;\n    var viewState = frameState.viewState;\n    var viewResolution = viewState.resolution;\n    var imageSource = this.getLayer().getSource();\n    var hints = frameState.viewHints;\n    var renderedExtent = frameState.extent;\n    if (layerState.extent !== undefined) {\n      renderedExtent = getIntersection(renderedExtent, fromUserExtent(layerState.extent, viewState.projection));\n    }\n    if (!hints[ViewHint.ANIMATING] && !hints[ViewHint.INTERACTING] && !isEmpty(renderedExtent)) {\n      if (imageSource) {\n        var projection = viewState.projection;\n        if (!ENABLE_RASTER_REPROJECTION) {\n          var sourceProjection = imageSource.getProjection();\n          if (sourceProjection) {\n            projection = sourceProjection;\n          }\n        }\n        var image = imageSource.getImage(renderedExtent, viewResolution, pixelRatio, projection);\n        if (image && this.loadImage(image)) {\n          this.image_ = image;\n        }\n      } else {\n        this.image_ = null;\n      }\n    }\n    return !!this.image_;\n  };\n  /**\n   * Render the layer.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n  CanvasImageLayerRenderer.prototype.renderFrame = function (frameState, target) {\n    var image = this.image_;\n    var imageExtent = image.getExtent();\n    var imageResolution = image.getResolution();\n    var imagePixelRatio = image.getPixelRatio();\n    var layerState = frameState.layerStatesArray[frameState.layerIndex];\n    var pixelRatio = frameState.pixelRatio;\n    var viewState = frameState.viewState;\n    var viewCenter = viewState.center;\n    var viewResolution = viewState.resolution;\n    var size = frameState.size;\n    var scale = pixelRatio * imageResolution / (viewResolution * imagePixelRatio);\n    var width = Math.round(size[0] * pixelRatio);\n    var height = Math.round(size[1] * pixelRatio);\n    var rotation = viewState.rotation;\n    if (rotation) {\n      var size_1 = Math.round(Math.sqrt(width * width + height * height));\n      width = size_1;\n      height = size_1;\n    }\n    // set forward and inverse pixel transforms\n    composeTransform(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / pixelRatio, 1 / pixelRatio, rotation, -width / 2, -height / 2);\n    makeInverse(this.inversePixelTransform, this.pixelTransform);\n    var canvasTransform = createTransformString(this.pixelTransform);\n    this.useContainer(target, canvasTransform, layerState.opacity);\n    var context = this.context;\n    var canvas = context.canvas;\n    if (canvas.width != width || canvas.height != height) {\n      canvas.width = width;\n      canvas.height = height;\n    } else if (!this.containerReused) {\n      context.clearRect(0, 0, width, height);\n    }\n    // clipped rendering if layer extent is set\n    var clipped = false;\n    if (layerState.extent) {\n      var layerExtent = fromUserExtent(layerState.extent, viewState.projection);\n      clipped = !containsExtent(layerExtent, frameState.extent) && intersects(layerExtent, frameState.extent);\n      if (clipped) {\n        this.clipUnrotated(context, frameState, layerExtent);\n      }\n    }\n    var img = image.getImage();\n    var transform = composeTransform(this.tempTransform, width / 2, height / 2, scale, scale, 0, imagePixelRatio * (imageExtent[0] - viewCenter[0]) / imageResolution, imagePixelRatio * (viewCenter[1] - imageExtent[3]) / imageResolution);\n    this.renderedResolution = imageResolution * pixelRatio / imagePixelRatio;\n    var dx = transform[4];\n    var dy = transform[5];\n    var dw = img.width * transform[0];\n    var dh = img.height * transform[3];\n    assign(context, this.getLayer().getSource().getContextOptions());\n    this.preRender(context, frameState);\n    if (dw >= 0.5 && dh >= 0.5) {\n      var opacity = layerState.opacity;\n      var previousAlpha = void 0;\n      if (opacity !== 1) {\n        previousAlpha = this.context.globalAlpha;\n        this.context.globalAlpha = opacity;\n      }\n      this.context.drawImage(img, 0, 0, +img.width, +img.height, Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));\n      if (opacity !== 1) {\n        this.context.globalAlpha = previousAlpha;\n      }\n    }\n    this.postRender(context, frameState);\n    if (clipped) {\n      context.restore();\n    }\n    if (canvasTransform !== canvas.style.transform) {\n      canvas.style.transform = canvasTransform;\n    }\n    return this.container;\n  };\n  return CanvasImageLayerRenderer;\n}(CanvasLayerRenderer);\nexport default CanvasImageLayerRenderer;","map":{"version":3,"names":["CanvasLayerRenderer","ViewHint","ENABLE_RASTER_REPROJECTION","assign","compose","composeTransform","makeInverse","containsExtent","intersects","createTransformString","fromUserExtent","getIntersection","isEmpty","CanvasImageLayerRenderer","_super","__extends","imageLayer","_this","call","image_","prototype","getImage","prepareFrame","frameState","layerState","layerStatesArray","layerIndex","pixelRatio","viewState","viewResolution","resolution","imageSource","getLayer","getSource","hints","viewHints","renderedExtent","extent","undefined","projection","ANIMATING","INTERACTING","sourceProjection","getProjection","image","loadImage","renderFrame","target","imageExtent","getExtent","imageResolution","getResolution","imagePixelRatio","getPixelRatio","viewCenter","center","size","scale","width","Math","round","height","rotation","size_1","sqrt","pixelTransform","inversePixelTransform","canvasTransform","useContainer","opacity","context","canvas","containerReused","clearRect","clipped","layerExtent","clipUnrotated","img","transform","tempTransform","renderedResolution","dx","dy","dw","dh","getContextOptions","preRender","previousAlpha","globalAlpha","drawImage","postRender","restore","style","container"],"sources":["/Users/mariovicky/Skripsi_OpenLayers/node_modules/ol/src/renderer/canvas/ImageLayer.js"],"sourcesContent":["/**\n * @module ol/renderer/canvas/ImageLayer\n */\nimport CanvasLayerRenderer from './Layer.js';\nimport ViewHint from '../../ViewHint.js';\nimport {ENABLE_RASTER_REPROJECTION} from '../../reproj/common.js';\nimport {assign} from '../../obj.js';\nimport {compose as composeTransform, makeInverse} from '../../transform.js';\nimport {containsExtent, intersects} from '../../extent.js';\nimport {createTransformString} from '../../render/canvas.js';\nimport {fromUserExtent} from '../../proj.js';\nimport {getIntersection, isEmpty} from '../../extent.js';\n\n/**\n * @classdesc\n * Canvas renderer for image layers.\n * @api\n */\nclass CanvasImageLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {import(\"../../layer/Image.js\").default} imageLayer Image layer.\n   */\n  constructor(imageLayer) {\n    super(imageLayer);\n\n    /**\n     * @protected\n     * @type {?import(\"../../ImageBase.js\").default}\n     */\n    this.image_ = null;\n  }\n\n  /**\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   */\n  getImage() {\n    return !this.image_ ? null : this.image_.getImage();\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const viewResolution = viewState.resolution;\n\n    const imageSource = this.getLayer().getSource();\n\n    const hints = frameState.viewHints;\n\n    let renderedExtent = frameState.extent;\n    if (layerState.extent !== undefined) {\n      renderedExtent = getIntersection(\n        renderedExtent,\n        fromUserExtent(layerState.extent, viewState.projection)\n      );\n    }\n\n    if (\n      !hints[ViewHint.ANIMATING] &&\n      !hints[ViewHint.INTERACTING] &&\n      !isEmpty(renderedExtent)\n    ) {\n      if (imageSource) {\n        let projection = viewState.projection;\n        if (!ENABLE_RASTER_REPROJECTION) {\n          const sourceProjection = imageSource.getProjection();\n          if (sourceProjection) {\n            projection = sourceProjection;\n          }\n        }\n        const image = imageSource.getImage(\n          renderedExtent,\n          viewResolution,\n          pixelRatio,\n          projection\n        );\n        if (image && this.loadImage(image)) {\n          this.image_ = image;\n        }\n      } else {\n        this.image_ = null;\n      }\n    }\n\n    return !!this.image_;\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    const image = this.image_;\n    const imageExtent = image.getExtent();\n    const imageResolution = image.getResolution();\n    const imagePixelRatio = image.getPixelRatio();\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const viewCenter = viewState.center;\n    const viewResolution = viewState.resolution;\n    const size = frameState.size;\n    const scale =\n      (pixelRatio * imageResolution) / (viewResolution * imagePixelRatio);\n\n    let width = Math.round(size[0] * pixelRatio);\n    let height = Math.round(size[1] * pixelRatio);\n    const rotation = viewState.rotation;\n    if (rotation) {\n      const size = Math.round(Math.sqrt(width * width + height * height));\n      width = size;\n      height = size;\n    }\n\n    // set forward and inverse pixel transforms\n    composeTransform(\n      this.pixelTransform,\n      frameState.size[0] / 2,\n      frameState.size[1] / 2,\n      1 / pixelRatio,\n      1 / pixelRatio,\n      rotation,\n      -width / 2,\n      -height / 2\n    );\n    makeInverse(this.inversePixelTransform, this.pixelTransform);\n\n    const canvasTransform = createTransformString(this.pixelTransform);\n\n    this.useContainer(target, canvasTransform, layerState.opacity);\n\n    const context = this.context;\n    const canvas = context.canvas;\n\n    if (canvas.width != width || canvas.height != height) {\n      canvas.width = width;\n      canvas.height = height;\n    } else if (!this.containerReused) {\n      context.clearRect(0, 0, width, height);\n    }\n\n    // clipped rendering if layer extent is set\n    let clipped = false;\n    if (layerState.extent) {\n      const layerExtent = fromUserExtent(\n        layerState.extent,\n        viewState.projection\n      );\n      clipped =\n        !containsExtent(layerExtent, frameState.extent) &&\n        intersects(layerExtent, frameState.extent);\n      if (clipped) {\n        this.clipUnrotated(context, frameState, layerExtent);\n      }\n    }\n\n    const img = image.getImage();\n\n    const transform = composeTransform(\n      this.tempTransform,\n      width / 2,\n      height / 2,\n      scale,\n      scale,\n      0,\n      (imagePixelRatio * (imageExtent[0] - viewCenter[0])) / imageResolution,\n      (imagePixelRatio * (viewCenter[1] - imageExtent[3])) / imageResolution\n    );\n\n    this.renderedResolution = (imageResolution * pixelRatio) / imagePixelRatio;\n\n    const dx = transform[4];\n    const dy = transform[5];\n    const dw = img.width * transform[0];\n    const dh = img.height * transform[3];\n\n    assign(context, this.getLayer().getSource().getContextOptions());\n    this.preRender(context, frameState);\n    if (dw >= 0.5 && dh >= 0.5) {\n      const opacity = layerState.opacity;\n      let previousAlpha;\n      if (opacity !== 1) {\n        previousAlpha = this.context.globalAlpha;\n        this.context.globalAlpha = opacity;\n      }\n      this.context.drawImage(\n        img,\n        0,\n        0,\n        +img.width,\n        +img.height,\n        Math.round(dx),\n        Math.round(dy),\n        Math.round(dw),\n        Math.round(dh)\n      );\n      if (opacity !== 1) {\n        this.context.globalAlpha = previousAlpha;\n      }\n    }\n    this.postRender(context, frameState);\n\n    if (clipped) {\n      context.restore();\n    }\n\n    if (canvasTransform !== canvas.style.transform) {\n      canvas.style.transform = canvasTransform;\n    }\n\n    return this.container;\n  }\n}\n\nexport default CanvasImageLayerRenderer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
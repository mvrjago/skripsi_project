{"ast":null,"code":"/**\n * @module ol/source/VectorTile\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport EventType from '../events/EventType.js';\nimport Tile from '../VectorTile.js';\nimport TileCache from '../TileCache.js';\nimport TileState from '../TileState.js';\nimport UrlTile from './UrlTile.js';\nimport VectorRenderTile from '../VectorRenderTile.js';\nimport { buffer as bufferExtent, getIntersection, intersects } from '../extent.js';\nimport { createForProjection, createXYZ, extentFromProjection } from '../tilegrid.js';\nimport { equals } from '../array.js';\nimport { fromKey, getKeyZXY } from '../tilecoord.js';\nimport { loadFeaturesXhr } from '../featureloader.js';\nimport { toSize } from '../size.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least twice the number of tiles in the viewport.\n * @property {import(\"../extent.js\").Extent} [extent]\n * @property {import(\"../format/Feature.js\").default} [format] Feature format for tiles. Used and required by the default.\n * @property {boolean} [overlaps=true] This source may have overlapping geometries. Setting this\n * to `false` (e.g. for sources with polygons that represent administrative\n * boundaries or TopoJSON sources) allows the renderer to optimise fill and\n * stroke operations.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Projection of the tile grid.\n * @property {import(\"./State.js\").default} [state] Source state.\n * @property {typeof import(\"../VectorTile.js\").default} [tileClass] Class used to instantiate image tiles.\n * Default is {@link module:ol/VectorTile}.\n * @property {number} [maxZoom=22] Optional max zoom level. Not used if `tileGrid` is provided.\n * @property {number} [minZoom] Optional min zoom level. Not used if `tileGrid` is provided.\n * @property {number|import(\"../size.js\").Size} [tileSize=512] Optional tile size. Not used if `tileGrid` is provided.\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction]\n * Optional function to load a tile given a URL. Could look like this for pbf tiles:\n * ```js\n * function(tile, url) {\n *   tile.setLoader(function(extent, resolution, projection) {\n *     fetch(url).then(function(response) {\n *       response.arrayBuffer().then(function(data) {\n *         const format = tile.getFormat() // ol/format/MVT configured as source format\n *         const features = format.readFeatures(data, {\n *           extent: extent,\n *           featureProjection: projection\n *         });\n *         tile.setFeatures(features);\n *       });\n *     });\n *   });\n * }\n * ```\n * If you do not need extent, resolution and projection to get the features for a tile (e.g.\n * for GeoJSON tiles), your `tileLoadFunction` does not need a `setLoader()` call. Only make sure\n * to call `setFeatures()` on the tile:\n * ```js\n * const format = new GeoJSON({featureProjection: map.getView().getProjection()});\n * async function tileLoadFunction(tile, url) {\n *   const response = await fetch(url);\n *   const data = await response.json();\n *   tile.setFeatures(format.readFeatures(data));\n * }\n * ```\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be\n * used instead of defining each one separately in the `urls` option.\n * @property {number} [transition] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {Array<string>} [urls] An array of URL templates.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * When set to `false`, only one world\n * will be rendered. When set to `true`, tiles will be wrapped horizontally to\n * render multiple worlds.\n * @property {number} [zDirection=1] Indicate which resolution should be used\n * by a renderer if the view resolution does not match any resolution of the tile source.\n * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n * will be used. If -1, the nearest higher resolution will be used.\n */\n/**\n * @classdesc\n * Class for layer sources providing vector data divided into a tile grid, to be\n * used with {@link module:ol/layer/VectorTile~VectorTile}. Although this source receives tiles\n * with vector features from the server, it is not meant for feature editing.\n * Features are optimized for rendering, their geometries are clipped at or near\n * tile boundaries and simplified for a view resolution. See\n * {@link module:ol/source/Vector} for vector sources that are suitable for feature\n * editing.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @api\n */\nvar VectorTile = /** @class */function (_super) {\n  __extends(VectorTile, _super);\n  /**\n   * @param {!Options} options Vector tile options.\n   */\n  function VectorTile(options) {\n    var _this = this;\n    var projection = options.projection || 'EPSG:3857';\n    var extent = options.extent || extentFromProjection(projection);\n    var tileGrid = options.tileGrid || createXYZ({\n      extent: extent,\n      maxResolution: options.maxResolution,\n      maxZoom: options.maxZoom !== undefined ? options.maxZoom : 22,\n      minZoom: options.minZoom,\n      tileSize: options.tileSize || 512\n    });\n    _this = _super.call(this, {\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      cacheSize: options.cacheSize,\n      opaque: false,\n      projection: projection,\n      state: options.state,\n      tileGrid: tileGrid,\n      tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultLoadFunction,\n      tileUrlFunction: options.tileUrlFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX === undefined ? true : options.wrapX,\n      transition: options.transition,\n      zDirection: options.zDirection === undefined ? 1 : options.zDirection\n    }) || this;\n    /**\n     * @private\n     * @type {import(\"../format/Feature.js\").default}\n     */\n    _this.format_ = options.format ? options.format : null;\n    /**\n     * @type {Object<string, import(\"./VectorTile\").default>}\n     */\n    _this.loadingTiles_ = {};\n    /**\n     * @private\n     * @type {TileCache}\n     */\n    _this.sourceTileCache = new TileCache(_this.tileCache.highWaterMark);\n    /**\n     * @private\n     * @type {boolean}\n     */\n    _this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;\n    /**\n     * @protected\n     * @type {typeof import(\"../VectorTile.js\").default}\n     */\n    _this.tileClass = options.tileClass ? options.tileClass : Tile;\n    /**\n     * @private\n     * @type {Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n     */\n    _this.tileGrids_ = {};\n    return _this;\n  }\n  /**\n   * Get features whose bounding box intersects the provided extent. Only features for cached\n   * tiles for the last rendered zoom level are available in the source. So this method is only\n   * suitable for requesting tiles for extents that are currently rendered.\n   *\n   * Features are returned in random tile order and as they are included in the tiles. This means\n   * they can be clipped, duplicated across tiles, and simplified to the render resolution.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {Array<import(\"../Feature.js\").FeatureLike>} Features.\n   * @api\n   */\n  VectorTile.prototype.getFeaturesInExtent = function (extent) {\n    var features = [];\n    var tileCache = this.tileCache;\n    if (tileCache.getCount() === 0) {\n      return features;\n    }\n    var z = fromKey(tileCache.peekFirstKey())[0];\n    var tileGrid = this.tileGrid;\n    tileCache.forEach(function (tile) {\n      if (tile.tileCoord[0] !== z || tile.getState() !== TileState.LOADED) {\n        return;\n      }\n      var sourceTiles = tile.getSourceTiles();\n      for (var i = 0, ii = sourceTiles.length; i < ii; ++i) {\n        var sourceTile = sourceTiles[i];\n        var tileCoord = sourceTile.tileCoord;\n        if (intersects(extent, tileGrid.getTileCoordExtent(tileCoord))) {\n          var tileFeatures = sourceTile.getFeatures();\n          if (tileFeatures) {\n            for (var j = 0, jj = tileFeatures.length; j < jj; ++j) {\n              var candidate = tileFeatures[j];\n              var geometry = candidate.getGeometry();\n              if (intersects(extent, geometry.getExtent())) {\n                features.push(candidate);\n              }\n            }\n          }\n        }\n      }\n    });\n    return features;\n  };\n  /**\n   * @return {boolean} The source can have overlapping geometries.\n   */\n  VectorTile.prototype.getOverlaps = function () {\n    return this.overlaps_;\n  };\n  /**\n   * clear {@link module:ol/TileCache~TileCache} and delete all source tiles\n   * @api\n   */\n  VectorTile.prototype.clear = function () {\n    this.tileCache.clear();\n    this.sourceTileCache.clear();\n  };\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\n   */\n  VectorTile.prototype.expireCache = function (projection, usedTiles) {\n    _super.prototype.expireCache.call(this, projection, usedTiles);\n    this.sourceTileCache.expireCache({});\n  };\n  /**\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection\").default} projection Projection.\n   * @param {VectorRenderTile} tile Vector image tile.\n   * @return {Array<import(\"../VectorTile\").default>} Tile keys.\n   */\n  VectorTile.prototype.getSourceTiles = function (pixelRatio, projection, tile) {\n    var urlTileCoord = tile.wrappedTileCoord;\n    var tileGrid = this.getTileGridForProjection(projection);\n    var extent = tileGrid.getTileCoordExtent(urlTileCoord);\n    var z = urlTileCoord[0];\n    var resolution = tileGrid.getResolution(z);\n    // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n    bufferExtent(extent, -resolution, extent);\n    var sourceTileGrid = this.tileGrid;\n    var sourceExtent = sourceTileGrid.getExtent();\n    if (sourceExtent) {\n      getIntersection(extent, sourceExtent, extent);\n    }\n    var sourceZ = sourceTileGrid.getZForResolution(resolution, 1);\n    var minZoom = sourceTileGrid.getMinZoom();\n    var previousSourceTiles = tile.sourceTiles;\n    var sourceTiles, covered, loadedZ;\n    if (previousSourceTiles && previousSourceTiles.length > 0 && previousSourceTiles[0].tileCoord[0] === sourceZ) {\n      sourceTiles = previousSourceTiles;\n      covered = true;\n      loadedZ = sourceZ;\n    } else {\n      sourceTiles = [];\n      loadedZ = sourceZ + 1;\n      do {\n        --loadedZ;\n        covered = true;\n        sourceTileGrid.forEachTileCoord(extent, loadedZ, function (sourceTileCoord) {\n          var tileUrl = this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);\n          var sourceTile;\n          if (tileUrl !== undefined) {\n            if (this.sourceTileCache.containsKey(tileUrl)) {\n              sourceTile = this.sourceTileCache.get(tileUrl);\n              var state = sourceTile.getState();\n              if (state === TileState.LOADED || state === TileState.ERROR || state === TileState.EMPTY) {\n                sourceTiles.push(sourceTile);\n                return;\n              }\n            } else if (loadedZ === sourceZ) {\n              sourceTile = new this.tileClass(sourceTileCoord, TileState.IDLE, tileUrl, this.format_, this.tileLoadFunction);\n              sourceTile.extent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n              sourceTile.projection = projection;\n              sourceTile.resolution = sourceTileGrid.getResolution(sourceTileCoord[0]);\n              this.sourceTileCache.set(tileUrl, sourceTile);\n              sourceTile.addEventListener(EventType.CHANGE, this.handleTileChange.bind(this));\n              sourceTile.load();\n            }\n          }\n          covered = covered && sourceTile && sourceTile.getState() === TileState.LOADED;\n          if (!sourceTile) {\n            return;\n          }\n          if (sourceTile.getState() !== TileState.EMPTY && tile.getState() === TileState.IDLE) {\n            tile.loadingSourceTiles++;\n            sourceTile.addEventListener(EventType.CHANGE, function listenChange() {\n              var state = sourceTile.getState();\n              var sourceTileKey = sourceTile.getKey();\n              if (state === TileState.LOADED || state === TileState.ERROR) {\n                if (state === TileState.LOADED) {\n                  sourceTile.removeEventListener(EventType.CHANGE, listenChange);\n                  tile.loadingSourceTiles--;\n                  delete tile.errorSourceTileKeys[sourceTileKey];\n                } else if (state === TileState.ERROR) {\n                  tile.errorSourceTileKeys[sourceTileKey] = true;\n                }\n                var errorTileCount = Object.keys(tile.errorSourceTileKeys).length;\n                if (tile.loadingSourceTiles - errorTileCount === 0) {\n                  tile.hifi = errorTileCount === 0;\n                  tile.sourceZ = sourceZ;\n                  tile.setState(TileState.LOADED);\n                }\n              }\n            });\n          }\n        }.bind(this));\n        if (!covered) {\n          sourceTiles.length = 0;\n        }\n      } while (!covered && loadedZ > minZoom);\n    }\n    if (tile.getState() === TileState.IDLE) {\n      tile.setState(TileState.LOADING);\n    }\n    if (covered) {\n      tile.hifi = sourceZ === loadedZ;\n      tile.sourceZ = loadedZ;\n      if (tile.getState() < TileState.LOADED) {\n        tile.setState(TileState.LOADED);\n      } else if (!previousSourceTiles || !equals(sourceTiles, previousSourceTiles)) {\n        tile.sourceTiles = sourceTiles;\n      }\n    }\n    return sourceTiles;\n  };\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!VectorRenderTile} Tile.\n   */\n  VectorTile.prototype.getTile = function (z, x, y, pixelRatio, projection) {\n    var coordKey = getKeyZXY(z, x, y);\n    var key = this.getKey();\n    var tile;\n    if (this.tileCache.containsKey(coordKey)) {\n      tile = this.tileCache.get(coordKey);\n      if (tile.key === key) {\n        return tile;\n      }\n    }\n    var tileCoord = [z, x, y];\n    var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);\n    var sourceExtent = this.getTileGrid().getExtent();\n    var tileGrid = this.getTileGridForProjection(projection);\n    if (urlTileCoord && sourceExtent) {\n      var tileExtent = tileGrid.getTileCoordExtent(urlTileCoord);\n      // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n      bufferExtent(tileExtent, -tileGrid.getResolution(z), tileExtent);\n      if (!intersects(sourceExtent, tileExtent)) {\n        urlTileCoord = null;\n      }\n    }\n    var empty = true;\n    if (urlTileCoord !== null) {\n      var sourceTileGrid = this.tileGrid;\n      var resolution = tileGrid.getResolution(z);\n      var sourceZ = sourceTileGrid.getZForResolution(resolution, 1);\n      // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n      var extent = tileGrid.getTileCoordExtent(urlTileCoord);\n      bufferExtent(extent, -resolution, extent);\n      sourceTileGrid.forEachTileCoord(extent, sourceZ, function (sourceTileCoord) {\n        empty = empty && !this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);\n      }.bind(this));\n    }\n    var newTile = new VectorRenderTile(tileCoord, empty ? TileState.EMPTY : TileState.IDLE, urlTileCoord, this.getSourceTiles.bind(this, pixelRatio, projection));\n    newTile.key = key;\n    if (tile) {\n      newTile.interimTile = tile;\n      newTile.refreshInterimChain();\n      this.tileCache.replace(coordKey, newTile);\n    } else {\n      this.tileCache.set(coordKey, newTile);\n    }\n    return newTile;\n  };\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   */\n  VectorTile.prototype.getTileGridForProjection = function (projection) {\n    var code = projection.getCode();\n    var tileGrid = this.tileGrids_[code];\n    if (!tileGrid) {\n      // A tile grid that matches the tile size of the source tile grid is more\n      // likely to have 1:1 relationships between source tiles and rendered tiles.\n      var sourceTileGrid = this.tileGrid;\n      tileGrid = createForProjection(projection, undefined, sourceTileGrid ? sourceTileGrid.getTileSize(sourceTileGrid.getMinZoom()) : undefined);\n      this.tileGrids_[code] = tileGrid;\n    }\n    return tileGrid;\n  };\n  /**\n   * Get the tile pixel ratio for this source.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {number} Tile pixel ratio.\n   */\n  VectorTile.prototype.getTilePixelRatio = function (pixelRatio) {\n    return pixelRatio;\n  };\n  /**\n   * @param {number} z Z.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../size.js\").Size} Tile size.\n   */\n  VectorTile.prototype.getTilePixelSize = function (z, pixelRatio, projection) {\n    var tileGrid = this.getTileGridForProjection(projection);\n    var tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\n    return [Math.round(tileSize[0] * pixelRatio), Math.round(tileSize[1] * pixelRatio)];\n  };\n  /**\n   * Increases the cache size if needed\n   * @param {number} tileCount Minimum number of tiles needed.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   */\n  VectorTile.prototype.updateCacheSize = function (tileCount, projection) {\n    _super.prototype.updateCacheSize.call(this, tileCount * 2, projection);\n  };\n  return VectorTile;\n}(UrlTile);\nexport default VectorTile;\n/**\n * Sets the loader for a tile.\n * @param {import(\"../VectorTile.js\").default} tile Vector tile.\n * @param {string} url URL.\n */\nexport function defaultLoadFunction(tile, url) {\n  var loader = loadFeaturesXhr(url, tile.getFormat(), tile.onLoad.bind(tile), tile.onError.bind(tile));\n  tile.setLoader(loader);\n}","map":{"version":3,"names":["EventType","Tile","TileCache","TileState","UrlTile","VectorRenderTile","buffer","bufferExtent","getIntersection","intersects","createForProjection","createXYZ","extentFromProjection","equals","fromKey","getKeyZXY","loadFeaturesXhr","toSize","VectorTile","_super","__extends","options","_this","projection","extent","tileGrid","maxResolution","maxZoom","undefined","minZoom","tileSize","call","attributions","attributionsCollapsible","cacheSize","opaque","state","tileLoadFunction","defaultLoadFunction","tileUrlFunction","url","urls","wrapX","transition","zDirection","format_","format","loadingTiles_","sourceTileCache","tileCache","highWaterMark","overlaps_","overlaps","tileClass","tileGrids_","prototype","getFeaturesInExtent","features","getCount","z","peekFirstKey","forEach","tile","tileCoord","getState","LOADED","sourceTiles","getSourceTiles","i","ii","length","sourceTile","getTileCoordExtent","tileFeatures","getFeatures","j","jj","candidate","geometry","getGeometry","getExtent","push","getOverlaps","clear","expireCache","usedTiles","pixelRatio","urlTileCoord","wrappedTileCoord","getTileGridForProjection","resolution","getResolution","sourceTileGrid","sourceExtent","sourceZ","getZForResolution","getMinZoom","previousSourceTiles","covered","loadedZ","forEachTileCoord","sourceTileCoord","tileUrl","containsKey","get","ERROR","EMPTY","IDLE","set","addEventListener","CHANGE","handleTileChange","bind","load","loadingSourceTiles","listenChange","sourceTileKey","getKey","removeEventListener","errorSourceTileKeys","errorTileCount","Object","keys","hifi","setState","LOADING","getTile","x","y","coordKey","key","getTileCoordForTileUrlFunction","getTileGrid","tileExtent","empty","newTile","interimTile","refreshInterimChain","replace","code","getCode","getTileSize","getTilePixelRatio","getTilePixelSize","tmpSize","Math","round","updateCacheSize","tileCount","loader","getFormat","onLoad","onError","setLoader"],"sources":["/Users/mariovicky/Skripsi_OpenLayers/node_modules/ol/src/source/VectorTile.js"],"sourcesContent":["/**\n * @module ol/source/VectorTile\n */\n\nimport EventType from '../events/EventType.js';\nimport Tile from '../VectorTile.js';\nimport TileCache from '../TileCache.js';\nimport TileState from '../TileState.js';\nimport UrlTile from './UrlTile.js';\nimport VectorRenderTile from '../VectorRenderTile.js';\nimport {\n  buffer as bufferExtent,\n  getIntersection,\n  intersects,\n} from '../extent.js';\nimport {\n  createForProjection,\n  createXYZ,\n  extentFromProjection,\n} from '../tilegrid.js';\nimport {equals} from '../array.js';\nimport {fromKey, getKeyZXY} from '../tilecoord.js';\nimport {loadFeaturesXhr} from '../featureloader.js';\nimport {toSize} from '../size.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least twice the number of tiles in the viewport.\n * @property {import(\"../extent.js\").Extent} [extent]\n * @property {import(\"../format/Feature.js\").default} [format] Feature format for tiles. Used and required by the default.\n * @property {boolean} [overlaps=true] This source may have overlapping geometries. Setting this\n * to `false` (e.g. for sources with polygons that represent administrative\n * boundaries or TopoJSON sources) allows the renderer to optimise fill and\n * stroke operations.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Projection of the tile grid.\n * @property {import(\"./State.js\").default} [state] Source state.\n * @property {typeof import(\"../VectorTile.js\").default} [tileClass] Class used to instantiate image tiles.\n * Default is {@link module:ol/VectorTile}.\n * @property {number} [maxZoom=22] Optional max zoom level. Not used if `tileGrid` is provided.\n * @property {number} [minZoom] Optional min zoom level. Not used if `tileGrid` is provided.\n * @property {number|import(\"../size.js\").Size} [tileSize=512] Optional tile size. Not used if `tileGrid` is provided.\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction]\n * Optional function to load a tile given a URL. Could look like this for pbf tiles:\n * ```js\n * function(tile, url) {\n *   tile.setLoader(function(extent, resolution, projection) {\n *     fetch(url).then(function(response) {\n *       response.arrayBuffer().then(function(data) {\n *         const format = tile.getFormat() // ol/format/MVT configured as source format\n *         const features = format.readFeatures(data, {\n *           extent: extent,\n *           featureProjection: projection\n *         });\n *         tile.setFeatures(features);\n *       });\n *     });\n *   });\n * }\n * ```\n * If you do not need extent, resolution and projection to get the features for a tile (e.g.\n * for GeoJSON tiles), your `tileLoadFunction` does not need a `setLoader()` call. Only make sure\n * to call `setFeatures()` on the tile:\n * ```js\n * const format = new GeoJSON({featureProjection: map.getView().getProjection()});\n * async function tileLoadFunction(tile, url) {\n *   const response = await fetch(url);\n *   const data = await response.json();\n *   tile.setFeatures(format.readFeatures(data));\n * }\n * ```\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be\n * used instead of defining each one separately in the `urls` option.\n * @property {number} [transition] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {Array<string>} [urls] An array of URL templates.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * When set to `false`, only one world\n * will be rendered. When set to `true`, tiles will be wrapped horizontally to\n * render multiple worlds.\n * @property {number} [zDirection=1] Indicate which resolution should be used\n * by a renderer if the view resolution does not match any resolution of the tile source.\n * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n * will be used. If -1, the nearest higher resolution will be used.\n */\n\n/**\n * @classdesc\n * Class for layer sources providing vector data divided into a tile grid, to be\n * used with {@link module:ol/layer/VectorTile~VectorTile}. Although this source receives tiles\n * with vector features from the server, it is not meant for feature editing.\n * Features are optimized for rendering, their geometries are clipped at or near\n * tile boundaries and simplified for a view resolution. See\n * {@link module:ol/source/Vector} for vector sources that are suitable for feature\n * editing.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @api\n */\nclass VectorTile extends UrlTile {\n  /**\n   * @param {!Options} options Vector tile options.\n   */\n  constructor(options) {\n    const projection = options.projection || 'EPSG:3857';\n\n    const extent = options.extent || extentFromProjection(projection);\n\n    const tileGrid =\n      options.tileGrid ||\n      createXYZ({\n        extent: extent,\n        maxResolution: options.maxResolution,\n        maxZoom: options.maxZoom !== undefined ? options.maxZoom : 22,\n        minZoom: options.minZoom,\n        tileSize: options.tileSize || 512,\n      });\n\n    super({\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      cacheSize: options.cacheSize,\n      opaque: false,\n      projection: projection,\n      state: options.state,\n      tileGrid: tileGrid,\n      tileLoadFunction: options.tileLoadFunction\n        ? options.tileLoadFunction\n        : defaultLoadFunction,\n      tileUrlFunction: options.tileUrlFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX === undefined ? true : options.wrapX,\n      transition: options.transition,\n      zDirection: options.zDirection === undefined ? 1 : options.zDirection,\n    });\n\n    /**\n     * @private\n     * @type {import(\"../format/Feature.js\").default}\n     */\n    this.format_ = options.format ? options.format : null;\n\n    /**\n     * @type {Object<string, import(\"./VectorTile\").default>}\n     */\n    this.loadingTiles_ = {};\n\n    /**\n     * @private\n     * @type {TileCache}\n     */\n    this.sourceTileCache = new TileCache(this.tileCache.highWaterMark);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;\n\n    /**\n     * @protected\n     * @type {typeof import(\"../VectorTile.js\").default}\n     */\n    this.tileClass = options.tileClass ? options.tileClass : Tile;\n\n    /**\n     * @private\n     * @type {Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n     */\n    this.tileGrids_ = {};\n  }\n\n  /**\n   * Get features whose bounding box intersects the provided extent. Only features for cached\n   * tiles for the last rendered zoom level are available in the source. So this method is only\n   * suitable for requesting tiles for extents that are currently rendered.\n   *\n   * Features are returned in random tile order and as they are included in the tiles. This means\n   * they can be clipped, duplicated across tiles, and simplified to the render resolution.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {Array<import(\"../Feature.js\").FeatureLike>} Features.\n   * @api\n   */\n  getFeaturesInExtent(extent) {\n    const features = [];\n    const tileCache = this.tileCache;\n    if (tileCache.getCount() === 0) {\n      return features;\n    }\n    const z = fromKey(tileCache.peekFirstKey())[0];\n    const tileGrid = this.tileGrid;\n    tileCache.forEach(function (tile) {\n      if (tile.tileCoord[0] !== z || tile.getState() !== TileState.LOADED) {\n        return;\n      }\n      const sourceTiles = tile.getSourceTiles();\n      for (let i = 0, ii = sourceTiles.length; i < ii; ++i) {\n        const sourceTile = sourceTiles[i];\n        const tileCoord = sourceTile.tileCoord;\n        if (intersects(extent, tileGrid.getTileCoordExtent(tileCoord))) {\n          const tileFeatures = sourceTile.getFeatures();\n          if (tileFeatures) {\n            for (let j = 0, jj = tileFeatures.length; j < jj; ++j) {\n              const candidate = tileFeatures[j];\n              const geometry = candidate.getGeometry();\n              if (intersects(extent, geometry.getExtent())) {\n                features.push(candidate);\n              }\n            }\n          }\n        }\n      }\n    });\n    return features;\n  }\n\n  /**\n   * @return {boolean} The source can have overlapping geometries.\n   */\n  getOverlaps() {\n    return this.overlaps_;\n  }\n\n  /**\n   * clear {@link module:ol/TileCache~TileCache} and delete all source tiles\n   * @api\n   */\n  clear() {\n    this.tileCache.clear();\n    this.sourceTileCache.clear();\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\n   */\n  expireCache(projection, usedTiles) {\n    super.expireCache(projection, usedTiles);\n    this.sourceTileCache.expireCache({});\n  }\n\n  /**\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection\").default} projection Projection.\n   * @param {VectorRenderTile} tile Vector image tile.\n   * @return {Array<import(\"../VectorTile\").default>} Tile keys.\n   */\n  getSourceTiles(pixelRatio, projection, tile) {\n    const urlTileCoord = tile.wrappedTileCoord;\n    const tileGrid = this.getTileGridForProjection(projection);\n    const extent = tileGrid.getTileCoordExtent(urlTileCoord);\n    const z = urlTileCoord[0];\n    const resolution = tileGrid.getResolution(z);\n    // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n    bufferExtent(extent, -resolution, extent);\n    const sourceTileGrid = this.tileGrid;\n    const sourceExtent = sourceTileGrid.getExtent();\n    if (sourceExtent) {\n      getIntersection(extent, sourceExtent, extent);\n    }\n    const sourceZ = sourceTileGrid.getZForResolution(resolution, 1);\n    const minZoom = sourceTileGrid.getMinZoom();\n\n    const previousSourceTiles = tile.sourceTiles;\n    let sourceTiles, covered, loadedZ;\n    if (\n      previousSourceTiles &&\n      previousSourceTiles.length > 0 &&\n      previousSourceTiles[0].tileCoord[0] === sourceZ\n    ) {\n      sourceTiles = previousSourceTiles;\n      covered = true;\n      loadedZ = sourceZ;\n    } else {\n      sourceTiles = [];\n      loadedZ = sourceZ + 1;\n      do {\n        --loadedZ;\n        covered = true;\n        sourceTileGrid.forEachTileCoord(\n          extent,\n          loadedZ,\n          function (sourceTileCoord) {\n            const tileUrl = this.tileUrlFunction(\n              sourceTileCoord,\n              pixelRatio,\n              projection\n            );\n            let sourceTile;\n            if (tileUrl !== undefined) {\n              if (this.sourceTileCache.containsKey(tileUrl)) {\n                sourceTile = this.sourceTileCache.get(tileUrl);\n                const state = sourceTile.getState();\n                if (\n                  state === TileState.LOADED ||\n                  state === TileState.ERROR ||\n                  state === TileState.EMPTY\n                ) {\n                  sourceTiles.push(sourceTile);\n                  return;\n                }\n              } else if (loadedZ === sourceZ) {\n                sourceTile = new this.tileClass(\n                  sourceTileCoord,\n                  TileState.IDLE,\n                  tileUrl,\n                  this.format_,\n                  this.tileLoadFunction\n                );\n                sourceTile.extent = sourceTileGrid.getTileCoordExtent(\n                  sourceTileCoord\n                );\n                sourceTile.projection = projection;\n                sourceTile.resolution = sourceTileGrid.getResolution(\n                  sourceTileCoord[0]\n                );\n                this.sourceTileCache.set(tileUrl, sourceTile);\n                sourceTile.addEventListener(\n                  EventType.CHANGE,\n                  this.handleTileChange.bind(this)\n                );\n                sourceTile.load();\n              }\n            }\n            covered =\n              covered &&\n              sourceTile &&\n              sourceTile.getState() === TileState.LOADED;\n            if (!sourceTile) {\n              return;\n            }\n            if (\n              sourceTile.getState() !== TileState.EMPTY &&\n              tile.getState() === TileState.IDLE\n            ) {\n              tile.loadingSourceTiles++;\n              sourceTile.addEventListener(\n                EventType.CHANGE,\n                function listenChange() {\n                  const state = sourceTile.getState();\n                  const sourceTileKey = sourceTile.getKey();\n                  if (state === TileState.LOADED || state === TileState.ERROR) {\n                    if (state === TileState.LOADED) {\n                      sourceTile.removeEventListener(\n                        EventType.CHANGE,\n                        listenChange\n                      );\n                      tile.loadingSourceTiles--;\n                      delete tile.errorSourceTileKeys[sourceTileKey];\n                    } else if (state === TileState.ERROR) {\n                      tile.errorSourceTileKeys[sourceTileKey] = true;\n                    }\n                    const errorTileCount = Object.keys(tile.errorSourceTileKeys)\n                      .length;\n                    if (tile.loadingSourceTiles - errorTileCount === 0) {\n                      tile.hifi = errorTileCount === 0;\n                      tile.sourceZ = sourceZ;\n                      tile.setState(TileState.LOADED);\n                    }\n                  }\n                }\n              );\n            }\n          }.bind(this)\n        );\n        if (!covered) {\n          sourceTiles.length = 0;\n        }\n      } while (!covered && loadedZ > minZoom);\n    }\n\n    if (tile.getState() === TileState.IDLE) {\n      tile.setState(TileState.LOADING);\n    }\n    if (covered) {\n      tile.hifi = sourceZ === loadedZ;\n      tile.sourceZ = loadedZ;\n      if (tile.getState() < TileState.LOADED) {\n        tile.setState(TileState.LOADED);\n      } else if (\n        !previousSourceTiles ||\n        !equals(sourceTiles, previousSourceTiles)\n      ) {\n        tile.sourceTiles = sourceTiles;\n      }\n    }\n    return sourceTiles;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!VectorRenderTile} Tile.\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    const coordKey = getKeyZXY(z, x, y);\n    const key = this.getKey();\n    let tile;\n    if (this.tileCache.containsKey(coordKey)) {\n      tile = this.tileCache.get(coordKey);\n      if (tile.key === key) {\n        return tile;\n      }\n    }\n    const tileCoord = [z, x, y];\n    let urlTileCoord = this.getTileCoordForTileUrlFunction(\n      tileCoord,\n      projection\n    );\n    const sourceExtent = this.getTileGrid().getExtent();\n    const tileGrid = this.getTileGridForProjection(projection);\n    if (urlTileCoord && sourceExtent) {\n      const tileExtent = tileGrid.getTileCoordExtent(urlTileCoord);\n      // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n      bufferExtent(tileExtent, -tileGrid.getResolution(z), tileExtent);\n      if (!intersects(sourceExtent, tileExtent)) {\n        urlTileCoord = null;\n      }\n    }\n    let empty = true;\n    if (urlTileCoord !== null) {\n      const sourceTileGrid = this.tileGrid;\n      const resolution = tileGrid.getResolution(z);\n      const sourceZ = sourceTileGrid.getZForResolution(resolution, 1);\n      // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n      const extent = tileGrid.getTileCoordExtent(urlTileCoord);\n      bufferExtent(extent, -resolution, extent);\n      sourceTileGrid.forEachTileCoord(\n        extent,\n        sourceZ,\n        function (sourceTileCoord) {\n          empty =\n            empty &&\n            !this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);\n        }.bind(this)\n      );\n    }\n    const newTile = new VectorRenderTile(\n      tileCoord,\n      empty ? TileState.EMPTY : TileState.IDLE,\n      urlTileCoord,\n      this.getSourceTiles.bind(this, pixelRatio, projection)\n    );\n\n    newTile.key = key;\n    if (tile) {\n      newTile.interimTile = tile;\n      newTile.refreshInterimChain();\n      this.tileCache.replace(coordKey, newTile);\n    } else {\n      this.tileCache.set(coordKey, newTile);\n    }\n    return newTile;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   */\n  getTileGridForProjection(projection) {\n    const code = projection.getCode();\n    let tileGrid = this.tileGrids_[code];\n    if (!tileGrid) {\n      // A tile grid that matches the tile size of the source tile grid is more\n      // likely to have 1:1 relationships between source tiles and rendered tiles.\n      const sourceTileGrid = this.tileGrid;\n      tileGrid = createForProjection(\n        projection,\n        undefined,\n        sourceTileGrid\n          ? sourceTileGrid.getTileSize(sourceTileGrid.getMinZoom())\n          : undefined\n      );\n      this.tileGrids_[code] = tileGrid;\n    }\n    return tileGrid;\n  }\n\n  /**\n   * Get the tile pixel ratio for this source.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {number} Tile pixel ratio.\n   */\n  getTilePixelRatio(pixelRatio) {\n    return pixelRatio;\n  }\n\n  /**\n   * @param {number} z Z.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../size.js\").Size} Tile size.\n   */\n  getTilePixelSize(z, pixelRatio, projection) {\n    const tileGrid = this.getTileGridForProjection(projection);\n    const tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\n    return [\n      Math.round(tileSize[0] * pixelRatio),\n      Math.round(tileSize[1] * pixelRatio),\n    ];\n  }\n\n  /**\n   * Increases the cache size if needed\n   * @param {number} tileCount Minimum number of tiles needed.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   */\n  updateCacheSize(tileCount, projection) {\n    super.updateCacheSize(tileCount * 2, projection);\n  }\n}\n\nexport default VectorTile;\n\n/**\n * Sets the loader for a tile.\n * @param {import(\"../VectorTile.js\").default} tile Vector tile.\n * @param {string} url URL.\n */\nexport function defaultLoadFunction(tile, url) {\n  const loader = loadFeaturesXhr(\n    url,\n    tile.getFormat(),\n    tile.onLoad.bind(tile),\n    tile.onError.bind(tile)\n  );\n  tile.setLoader(loader);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
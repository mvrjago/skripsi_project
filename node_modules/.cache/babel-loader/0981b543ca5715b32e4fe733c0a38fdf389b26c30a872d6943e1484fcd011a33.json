{"ast":null,"code":"'use strict';\n\n// Load modules\nconst Hoek = require('hoek');\nconst Topo = require('topo');\nconst Any = require('../any');\nconst Errors = require('../../errors');\nconst Cast = require('../../cast');\n\n// Declare internals\n\nconst internals = {};\ninternals.Object = class extends Any {\n  constructor() {\n    super();\n    this._type = 'object';\n    this._inner.children = null;\n    this._inner.renames = [];\n    this._inner.dependencies = [];\n    this._inner.patterns = [];\n  }\n  _init() {\n    return arguments.length ? this.keys(...arguments) : this;\n  }\n  _base(value, state, options) {\n    let target = value;\n    const errors = [];\n    const finish = () => {\n      return {\n        value: target,\n        errors: errors.length ? errors : null\n      };\n    };\n    if (typeof value === 'string' && options.convert) {\n      value = internals.safeParse(value);\n    }\n    const type = this._flags.func ? 'function' : 'object';\n    if (!value || typeof value !== type || Array.isArray(value)) {\n      errors.push(this.createError(type + '.base', null, state, options));\n      return finish();\n    }\n\n    // Skip if there are no other rules to test\n\n    if (!this._inner.renames.length && !this._inner.dependencies.length && !this._inner.children &&\n    // null allows any keys\n    !this._inner.patterns.length) {\n      target = value;\n      return finish();\n    }\n\n    // Ensure target is a local copy (parsed) or shallow copy\n\n    if (target === value) {\n      if (type === 'object') {\n        target = Object.create(Object.getPrototypeOf(value));\n      } else {\n        target = function () {\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n          return value.apply(this, args);\n        };\n        target.prototype = Hoek.clone(value.prototype);\n      }\n      const valueKeys = Object.keys(value);\n      for (let i = 0; i < valueKeys.length; ++i) {\n        target[valueKeys[i]] = value[valueKeys[i]];\n      }\n    } else {\n      target = value;\n    }\n\n    // Rename keys\n\n    const renamed = {};\n    for (let i = 0; i < this._inner.renames.length; ++i) {\n      const rename = this._inner.renames[i];\n      if (rename.isRegExp) {\n        const targetKeys = Object.keys(target);\n        const matchedTargetKeys = [];\n        for (let j = 0; j < targetKeys.length; ++j) {\n          if (rename.from.test(targetKeys[j])) {\n            matchedTargetKeys.push(targetKeys[j]);\n          }\n        }\n        const allUndefined = matchedTargetKeys.every(key => target[key] === undefined);\n        if (rename.options.ignoreUndefined && allUndefined) {\n          continue;\n        }\n        if (!rename.options.multiple && renamed[rename.to]) {\n          errors.push(this.createError('object.rename.regex.multiple', {\n            from: matchedTargetKeys,\n            to: rename.to\n          }, state, options));\n          if (options.abortEarly) {\n            return finish();\n          }\n        }\n        if (Object.prototype.hasOwnProperty.call(target, rename.to) && !rename.options.override && !renamed[rename.to]) {\n          errors.push(this.createError('object.rename.regex.override', {\n            from: matchedTargetKeys,\n            to: rename.to\n          }, state, options));\n          if (options.abortEarly) {\n            return finish();\n          }\n        }\n        if (allUndefined) {\n          delete target[rename.to];\n        } else {\n          target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\n        }\n        renamed[rename.to] = true;\n        if (!rename.options.alias) {\n          for (let j = 0; j < matchedTargetKeys.length; ++j) {\n            delete target[matchedTargetKeys[j]];\n          }\n        }\n      } else {\n        if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\n          continue;\n        }\n        if (!rename.options.multiple && renamed[rename.to]) {\n          errors.push(this.createError('object.rename.multiple', {\n            from: rename.from,\n            to: rename.to\n          }, state, options));\n          if (options.abortEarly) {\n            return finish();\n          }\n        }\n        if (Object.prototype.hasOwnProperty.call(target, rename.to) && !rename.options.override && !renamed[rename.to]) {\n          errors.push(this.createError('object.rename.override', {\n            from: rename.from,\n            to: rename.to\n          }, state, options));\n          if (options.abortEarly) {\n            return finish();\n          }\n        }\n        if (target[rename.from] === undefined) {\n          delete target[rename.to];\n        } else {\n          target[rename.to] = target[rename.from];\n        }\n        renamed[rename.to] = true;\n        if (!rename.options.alias) {\n          delete target[rename.from];\n        }\n      }\n    }\n\n    // Validate schema\n\n    if (!this._inner.children &&\n    // null allows any keys\n    !this._inner.patterns.length && !this._inner.dependencies.length) {\n      return finish();\n    }\n    const unprocessed = new Set(Object.keys(target));\n    if (this._inner.children) {\n      const stripProps = [];\n      for (let i = 0; i < this._inner.children.length; ++i) {\n        const child = this._inner.children[i];\n        const key = child.key;\n        const item = target[key];\n        unprocessed.delete(key);\n        const localState = {\n          key,\n          path: state.path.concat(key),\n          parent: target,\n          reference: state.reference\n        };\n        const result = child.schema._validate(item, localState, options);\n        if (result.errors) {\n          errors.push(this.createError('object.child', {\n            key,\n            child: child.schema._getLabel(key),\n            reason: result.errors\n          }, localState, options));\n          if (options.abortEarly) {\n            return finish();\n          }\n        } else {\n          if (child.schema._flags.strip || result.value === undefined && result.value !== item) {\n            stripProps.push(key);\n            target[key] = result.finalValue;\n          } else if (result.value !== undefined) {\n            target[key] = result.value;\n          }\n        }\n      }\n      for (let i = 0; i < stripProps.length; ++i) {\n        delete target[stripProps[i]];\n      }\n    }\n\n    // Unknown keys\n\n    if (unprocessed.size && this._inner.patterns.length) {\n      for (const key of unprocessed) {\n        const localState = {\n          key,\n          path: state.path.concat(key),\n          parent: target,\n          reference: state.reference\n        };\n        const item = target[key];\n        for (let i = 0; i < this._inner.patterns.length; ++i) {\n          const pattern = this._inner.patterns[i];\n          if (pattern.regex ? pattern.regex.test(key) : !pattern.schema.validate(key).error) {\n            unprocessed.delete(key);\n            const result = pattern.rule._validate(item, localState, options);\n            if (result.errors) {\n              errors.push(this.createError('object.child', {\n                key,\n                child: pattern.rule._getLabel(key),\n                reason: result.errors\n              }, localState, options));\n              if (options.abortEarly) {\n                return finish();\n              }\n            }\n            target[key] = result.value;\n          }\n        }\n      }\n    }\n    if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\n      if (options.stripUnknown && this._flags.allowUnknown !== true || options.skipFunctions) {\n        const stripUnknown = options.stripUnknown ? options.stripUnknown === true ? true : !!options.stripUnknown.objects : false;\n        for (const key of unprocessed) {\n          if (stripUnknown) {\n            delete target[key];\n            unprocessed.delete(key);\n          } else if (typeof target[key] === 'function') {\n            unprocessed.delete(key);\n          }\n        }\n      }\n      if (this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown) {\n        for (const unprocessedKey of unprocessed) {\n          errors.push(this.createError('object.allowUnknown', {\n            child: unprocessedKey\n          }, {\n            key: unprocessedKey,\n            path: state.path.concat(unprocessedKey)\n          }, options, {}));\n        }\n      }\n    }\n\n    // Validate dependencies\n\n    for (let i = 0; i < this._inner.dependencies.length; ++i) {\n      const dep = this._inner.dependencies[i];\n      const err = internals[dep.type].call(this, dep.key !== null && target[dep.key], dep.peers, target, {\n        key: dep.key,\n        path: dep.key === null ? state.path : state.path.concat(dep.key)\n      }, options);\n      if (err instanceof Errors.Err) {\n        errors.push(err);\n        if (options.abortEarly) {\n          return finish();\n        }\n      }\n    }\n    return finish();\n  }\n  keys(schema) {\n    Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\n    Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\n    const obj = this.clone();\n    if (!schema) {\n      obj._inner.children = null;\n      return obj;\n    }\n    const children = Object.keys(schema);\n    if (!children.length) {\n      obj._inner.children = [];\n      return obj;\n    }\n    const topo = new Topo();\n    if (obj._inner.children) {\n      for (let i = 0; i < obj._inner.children.length; ++i) {\n        const child = obj._inner.children[i];\n\n        // Only add the key if we are not going to replace it later\n        if (!children.includes(child.key)) {\n          topo.add(child, {\n            after: child._refs,\n            group: child.key\n          });\n        }\n      }\n    }\n    for (let i = 0; i < children.length; ++i) {\n      const key = children[i];\n      const child = schema[key];\n      try {\n        const cast = Cast.schema(this._currentJoi, child);\n        topo.add({\n          key,\n          schema: cast\n        }, {\n          after: cast._refs,\n          group: key\n        });\n      } catch (castErr) {\n        if (castErr.hasOwnProperty('path')) {\n          castErr.path = key + '.' + castErr.path;\n        } else {\n          castErr.path = key;\n        }\n        throw castErr;\n      }\n    }\n    obj._inner.children = topo.nodes;\n    return obj;\n  }\n  append(schema) {\n    // Skip any changes\n    if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\n      return this;\n    }\n    return this.keys(schema);\n  }\n  unknown(allow) {\n    const value = allow !== false;\n    if (this._flags.allowUnknown === value) {\n      return this;\n    }\n    const obj = this.clone();\n    obj._flags.allowUnknown = value;\n    return obj;\n  }\n  length(limit) {\n    Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n    return this._test('length', limit, function (value, state, options) {\n      if (Object.keys(value).length === limit) {\n        return value;\n      }\n      return this.createError('object.length', {\n        limit\n      }, state, options);\n    });\n  }\n  min(limit) {\n    Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n    return this._test('min', limit, function (value, state, options) {\n      if (Object.keys(value).length >= limit) {\n        return value;\n      }\n      return this.createError('object.min', {\n        limit\n      }, state, options);\n    });\n  }\n  max(limit) {\n    Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n    return this._test('max', limit, function (value, state, options) {\n      if (Object.keys(value).length <= limit) {\n        return value;\n      }\n      return this.createError('object.max', {\n        limit\n      }, state, options);\n    });\n  }\n  pattern(pattern, schema) {\n    const isRegExp = pattern instanceof RegExp;\n    Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\n    Hoek.assert(schema !== undefined, 'Invalid rule');\n    if (isRegExp) {\n      pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined); // Future version should break this and forbid unsupported regex flags\n    }\n\n    try {\n      schema = Cast.schema(this._currentJoi, schema);\n    } catch (castErr) {\n      if (castErr.hasOwnProperty('path')) {\n        castErr.message = castErr.message + '(' + castErr.path + ')';\n      }\n      throw castErr;\n    }\n    const obj = this.clone();\n    if (isRegExp) {\n      obj._inner.patterns.push({\n        regex: pattern,\n        rule: schema\n      });\n    } else {\n      obj._inner.patterns.push({\n        schema: pattern,\n        rule: schema\n      });\n    }\n    return obj;\n  }\n  schema() {\n    return this._test('schema', null, function (value, state, options) {\n      if (value instanceof Any) {\n        return value;\n      }\n      return this.createError('object.schema', null, state, options);\n    });\n  }\n  with(key, peers) {\n    Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\n    return this._dependency('with', key, peers);\n  }\n  without(key, peers) {\n    Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\n    return this._dependency('without', key, peers);\n  }\n  xor() {\n    for (var _len2 = arguments.length, peers = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      peers[_key2] = arguments[_key2];\n    }\n    peers = Hoek.flatten(peers);\n    return this._dependency('xor', null, peers);\n  }\n  or() {\n    for (var _len3 = arguments.length, peers = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      peers[_key3] = arguments[_key3];\n    }\n    peers = Hoek.flatten(peers);\n    return this._dependency('or', null, peers);\n  }\n  and() {\n    for (var _len4 = arguments.length, peers = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      peers[_key4] = arguments[_key4];\n    }\n    peers = Hoek.flatten(peers);\n    return this._dependency('and', null, peers);\n  }\n  nand() {\n    for (var _len5 = arguments.length, peers = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      peers[_key5] = arguments[_key5];\n    }\n    peers = Hoek.flatten(peers);\n    return this._dependency('nand', null, peers);\n  }\n  requiredKeys() {\n    for (var _len6 = arguments.length, children = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      children[_key6] = arguments[_key6];\n    }\n    children = Hoek.flatten(children);\n    return this.applyFunctionToChildren(children, 'required');\n  }\n  optionalKeys() {\n    for (var _len7 = arguments.length, children = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      children[_key7] = arguments[_key7];\n    }\n    children = Hoek.flatten(children);\n    return this.applyFunctionToChildren(children, 'optional');\n  }\n  forbiddenKeys() {\n    for (var _len8 = arguments.length, children = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n      children[_key8] = arguments[_key8];\n    }\n    children = Hoek.flatten(children);\n    return this.applyFunctionToChildren(children, 'forbidden');\n  }\n  rename(from, to, options) {\n    Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\n    Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\n    Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\n    for (let i = 0; i < this._inner.renames.length; ++i) {\n      Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\n    }\n    const obj = this.clone();\n    obj._inner.renames.push({\n      from,\n      to,\n      options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\n      isRegExp: from instanceof RegExp\n    });\n    return obj;\n  }\n  applyFunctionToChildren(children, fn, args, root) {\n    children = [].concat(children);\n    Hoek.assert(children.length > 0, 'expected at least one children');\n    const groupedChildren = internals.groupChildren(children);\n    let obj;\n    if ('' in groupedChildren) {\n      obj = this[fn].apply(this, args);\n      delete groupedChildren[''];\n    } else {\n      obj = this.clone();\n    }\n    if (obj._inner.children) {\n      root = root ? root + '.' : '';\n      for (let i = 0; i < obj._inner.children.length; ++i) {\n        const child = obj._inner.children[i];\n        const group = groupedChildren[child.key];\n        if (group) {\n          obj._inner.children[i] = {\n            key: child.key,\n            _refs: child._refs,\n            schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\n          };\n          delete groupedChildren[child.key];\n        }\n      }\n    }\n    const remaining = Object.keys(groupedChildren);\n    Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\n    return obj;\n  }\n  _dependency(type, key, peers) {\n    peers = [].concat(peers);\n    for (let i = 0; i < peers.length; ++i) {\n      Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\n    }\n    const obj = this.clone();\n    obj._inner.dependencies.push({\n      type,\n      key,\n      peers\n    });\n    return obj;\n  }\n  describe(shallow) {\n    const description = super.describe();\n    if (description.rules) {\n      for (let i = 0; i < description.rules.length; ++i) {\n        const rule = description.rules[i];\n        // Coverage off for future-proof descriptions, only object().assert() is use right now\n        if ( /* $lab:coverage:off$ */rule.arg && typeof rule.arg === 'object' && rule.arg.schema && rule.arg.ref /* $lab:coverage:on$ */) {\n          rule.arg = {\n            schema: rule.arg.schema.describe(),\n            ref: rule.arg.ref.toString()\n          };\n        }\n      }\n    }\n    if (this._inner.children && !shallow) {\n      description.children = {};\n      for (let i = 0; i < this._inner.children.length; ++i) {\n        const child = this._inner.children[i];\n        description.children[child.key] = child.schema.describe();\n      }\n    }\n    if (this._inner.dependencies.length) {\n      description.dependencies = Hoek.clone(this._inner.dependencies);\n    }\n    if (this._inner.patterns.length) {\n      description.patterns = [];\n      for (let i = 0; i < this._inner.patterns.length; ++i) {\n        const pattern = this._inner.patterns[i];\n        if (pattern.regex) {\n          description.patterns.push({\n            regex: pattern.regex.toString(),\n            rule: pattern.rule.describe()\n          });\n        } else {\n          description.patterns.push({\n            schema: pattern.schema.describe(),\n            rule: pattern.rule.describe()\n          });\n        }\n      }\n    }\n    if (this._inner.renames.length > 0) {\n      description.renames = Hoek.clone(this._inner.renames);\n    }\n    return description;\n  }\n  assert(ref, schema, message) {\n    ref = Cast.ref(ref);\n    Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\n    message = message || 'pass the assertion test';\n    try {\n      schema = Cast.schema(this._currentJoi, schema);\n    } catch (castErr) {\n      if (castErr.hasOwnProperty('path')) {\n        castErr.message = castErr.message + '(' + castErr.path + ')';\n      }\n      throw castErr;\n    }\n    const key = ref.path[ref.path.length - 1];\n    const path = ref.path.join('.');\n    return this._test('assert', {\n      schema,\n      ref\n    }, function (value, state, options) {\n      const result = schema._validate(ref(value), null, options, value);\n      if (!result.errors) {\n        return value;\n      }\n      const localState = Hoek.merge({}, state);\n      localState.key = key;\n      localState.path = ref.path;\n      return this.createError('object.assert', {\n        ref: path,\n        message\n      }, localState, options);\n    });\n  }\n  type(constructor) {\n    let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : constructor.name;\n    Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\n    const typeData = {\n      name,\n      ctor: constructor\n    };\n    return this._test('type', typeData, function (value, state, options) {\n      if (value instanceof constructor) {\n        return value;\n      }\n      return this.createError('object.type', {\n        type: typeData.name\n      }, state, options);\n    });\n  }\n};\ninternals.safeParse = function (value) {\n  try {\n    return JSON.parse(value);\n  } catch (parseErr) {}\n  return value;\n};\ninternals.renameDefaults = {\n  alias: false,\n  // Keep old value in place\n  multiple: false,\n  // Allow renaming multiple keys into the same target\n  override: false // Overrides an existing key\n};\n\ninternals.groupChildren = function (children) {\n  children.sort();\n  const grouped = {};\n  for (let i = 0; i < children.length; ++i) {\n    const child = children[i];\n    Hoek.assert(typeof child === 'string', 'children must be strings');\n    const group = child.split('.')[0];\n    const childGroup = grouped[group] = grouped[group] || [];\n    childGroup.push(child.substring(group.length + 1));\n  }\n  return grouped;\n};\ninternals.keysToLabels = function (schema, keys) {\n  const children = schema._inner.children;\n  if (!children) {\n    return keys;\n  }\n  const findLabel = function (key) {\n    const matchingChild = children.find(child => child.key === key);\n    return matchingChild ? matchingChild.schema._getLabel(key) : key;\n  };\n  if (Array.isArray(keys)) {\n    return keys.map(findLabel);\n  }\n  return findLabel(keys);\n};\ninternals.with = function (value, peers, parent, state, options) {\n  if (value === undefined) {\n    return value;\n  }\n  for (let i = 0; i < peers.length; ++i) {\n    const peer = peers[i];\n    if (!Object.prototype.hasOwnProperty.call(parent, peer) || parent[peer] === undefined) {\n      return this.createError('object.with', {\n        main: state.key,\n        mainWithLabel: internals.keysToLabels(this, state.key),\n        peer,\n        peerWithLabel: internals.keysToLabels(this, peer)\n      }, state, options);\n    }\n  }\n  return value;\n};\ninternals.without = function (value, peers, parent, state, options) {\n  if (value === undefined) {\n    return value;\n  }\n  for (let i = 0; i < peers.length; ++i) {\n    const peer = peers[i];\n    if (Object.prototype.hasOwnProperty.call(parent, peer) && parent[peer] !== undefined) {\n      return this.createError('object.without', {\n        main: state.key,\n        mainWithLabel: internals.keysToLabels(this, state.key),\n        peer,\n        peerWithLabel: internals.keysToLabels(this, peer)\n      }, state, options);\n    }\n  }\n  return value;\n};\ninternals.xor = function (value, peers, parent, state, options) {\n  const present = [];\n  for (let i = 0; i < peers.length; ++i) {\n    const peer = peers[i];\n    if (Object.prototype.hasOwnProperty.call(parent, peer) && parent[peer] !== undefined) {\n      present.push(peer);\n    }\n  }\n  if (present.length === 1) {\n    return value;\n  }\n  const context = {\n    peers,\n    peersWithLabels: internals.keysToLabels(this, peers)\n  };\n  if (present.length === 0) {\n    return this.createError('object.missing', context, state, options);\n  }\n  return this.createError('object.xor', context, state, options);\n};\ninternals.or = function (value, peers, parent, state, options) {\n  for (let i = 0; i < peers.length; ++i) {\n    const peer = peers[i];\n    if (Object.prototype.hasOwnProperty.call(parent, peer) && parent[peer] !== undefined) {\n      return value;\n    }\n  }\n  return this.createError('object.missing', {\n    peers,\n    peersWithLabels: internals.keysToLabels(this, peers)\n  }, state, options);\n};\ninternals.and = function (value, peers, parent, state, options) {\n  const missing = [];\n  const present = [];\n  const count = peers.length;\n  for (let i = 0; i < count; ++i) {\n    const peer = peers[i];\n    if (!Object.prototype.hasOwnProperty.call(parent, peer) || parent[peer] === undefined) {\n      missing.push(peer);\n    } else {\n      present.push(peer);\n    }\n  }\n  const aon = missing.length === count || present.length === count;\n  if (!aon) {\n    return this.createError('object.and', {\n      present,\n      presentWithLabels: internals.keysToLabels(this, present),\n      missing,\n      missingWithLabels: internals.keysToLabels(this, missing)\n    }, state, options);\n  }\n};\ninternals.nand = function (value, peers, parent, state, options) {\n  const present = [];\n  for (let i = 0; i < peers.length; ++i) {\n    const peer = peers[i];\n    if (Object.prototype.hasOwnProperty.call(parent, peer) && parent[peer] !== undefined) {\n      present.push(peer);\n    }\n  }\n  const values = Hoek.clone(peers);\n  const main = values.splice(0, 1)[0];\n  const allPresent = present.length === peers.length;\n  return allPresent ? this.createError('object.nand', {\n    main,\n    mainWithLabel: internals.keysToLabels(this, main),\n    peers: values,\n    peersWithLabels: internals.keysToLabels(this, values)\n  }, state, options) : null;\n};\nmodule.exports = new internals.Object();","map":{"version":3,"names":["Hoek","require","Topo","Any","Errors","Cast","internals","Object","constructor","_type","_inner","children","renames","dependencies","patterns","_init","arguments","length","keys","_base","value","state","options","target","errors","finish","convert","safeParse","type","_flags","func","Array","isArray","push","createError","create","getPrototypeOf","_len","args","_key","apply","prototype","clone","valueKeys","i","renamed","rename","isRegExp","targetKeys","matchedTargetKeys","j","from","test","allUndefined","every","key","undefined","ignoreUndefined","multiple","to","abortEarly","hasOwnProperty","call","override","alias","unprocessed","Set","stripProps","child","item","delete","localState","path","concat","parent","reference","result","schema","_validate","_getLabel","reason","strip","finalValue","size","pattern","regex","validate","error","rule","stripUnknown","allowUnknown","skipFunctions","objects","unprocessedKey","dep","err","peers","Err","assert","obj","topo","includes","add","after","_refs","group","cast","_currentJoi","castErr","nodes","append","unknown","allow","limit","Number","isSafeInteger","_test","min","max","RegExp","source","ignoreCase","message","with","_dependency","without","xor","_len2","_key2","flatten","or","_len3","_key3","and","_len4","_key4","nand","_len5","_key5","requiredKeys","_len6","_key6","applyFunctionToChildren","optionalKeys","_len7","_key7","forbiddenKeys","_len8","_key8","applyToDefaults","renameDefaults","fn","root","groupedChildren","groupChildren","remaining","join","describe","shallow","description","rules","arg","ref","toString","isContext","depth","merge","name","typeData","ctor","JSON","parse","parseErr","sort","grouped","split","childGroup","substring","keysToLabels","findLabel","matchingChild","find","map","peer","main","mainWithLabel","peerWithLabel","present","context","peersWithLabels","missing","count","aon","presentWithLabels","missingWithLabels","values","splice","allPresent","module","exports"],"sources":["/Users/mariovicky/Skripsi_OpenLayers/node_modules/joi/lib/types/object/index.js"],"sourcesContent":["'use strict';\n\n// Load modules\n\nconst Hoek = require('hoek');\nconst Topo = require('topo');\nconst Any = require('../any');\nconst Errors = require('../../errors');\nconst Cast = require('../../cast');\n\n\n// Declare internals\n\nconst internals = {};\n\n\ninternals.Object = class extends Any {\n\n    constructor() {\n\n        super();\n        this._type = 'object';\n        this._inner.children = null;\n        this._inner.renames = [];\n        this._inner.dependencies = [];\n        this._inner.patterns = [];\n    }\n\n    _init(...args) {\n\n        return args.length ? this.keys(...args) : this;\n    }\n\n    _base(value, state, options) {\n\n        let target = value;\n        const errors = [];\n        const finish = () => {\n\n            return {\n                value: target,\n                errors: errors.length ? errors : null\n            };\n        };\n\n        if (typeof value === 'string' &&\n            options.convert) {\n\n            value = internals.safeParse(value);\n        }\n\n        const type = this._flags.func ? 'function' : 'object';\n        if (!value ||\n            typeof value !== type ||\n            Array.isArray(value)) {\n\n            errors.push(this.createError(type + '.base', null, state, options));\n            return finish();\n        }\n\n        // Skip if there are no other rules to test\n\n        if (!this._inner.renames.length &&\n            !this._inner.dependencies.length &&\n            !this._inner.children &&                    // null allows any keys\n            !this._inner.patterns.length) {\n\n            target = value;\n            return finish();\n        }\n\n        // Ensure target is a local copy (parsed) or shallow copy\n\n        if (target === value) {\n            if (type === 'object') {\n                target = Object.create(Object.getPrototypeOf(value));\n            }\n            else {\n                target = function (...args) {\n\n                    return value.apply(this, args);\n                };\n\n                target.prototype = Hoek.clone(value.prototype);\n            }\n\n            const valueKeys = Object.keys(value);\n            for (let i = 0; i < valueKeys.length; ++i) {\n                target[valueKeys[i]] = value[valueKeys[i]];\n            }\n        }\n        else {\n            target = value;\n        }\n\n        // Rename keys\n\n        const renamed = {};\n        for (let i = 0; i < this._inner.renames.length; ++i) {\n            const rename = this._inner.renames[i];\n\n            if (rename.isRegExp) {\n                const targetKeys = Object.keys(target);\n                const matchedTargetKeys = [];\n\n                for (let j = 0; j < targetKeys.length; ++j) {\n                    if (rename.from.test(targetKeys[j])) {\n                        matchedTargetKeys.push(targetKeys[j]);\n                    }\n                }\n\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\n                if (rename.options.ignoreUndefined && allUndefined) {\n                    continue;\n                }\n\n                if (!rename.options.multiple &&\n                    renamed[rename.to]) {\n\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\n                    if (options.abortEarly) {\n                        return finish();\n                    }\n                }\n\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\n                    !rename.options.override &&\n                    !renamed[rename.to]) {\n\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\n                    if (options.abortEarly) {\n                        return finish();\n                    }\n                }\n\n                if (allUndefined) {\n                    delete target[rename.to];\n                }\n                else {\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\n                }\n\n                renamed[rename.to] = true;\n\n                if (!rename.options.alias) {\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\n                        delete target[matchedTargetKeys[j]];\n                    }\n                }\n            }\n            else {\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\n                    continue;\n                }\n\n                if (!rename.options.multiple &&\n                    renamed[rename.to]) {\n\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\n                    if (options.abortEarly) {\n                        return finish();\n                    }\n                }\n\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\n                    !rename.options.override &&\n                    !renamed[rename.to]) {\n\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\n                    if (options.abortEarly) {\n                        return finish();\n                    }\n                }\n\n                if (target[rename.from] === undefined) {\n                    delete target[rename.to];\n                }\n                else {\n                    target[rename.to] = target[rename.from];\n                }\n\n                renamed[rename.to] = true;\n\n                if (!rename.options.alias) {\n                    delete target[rename.from];\n                }\n            }\n        }\n\n        // Validate schema\n\n        if (!this._inner.children &&            // null allows any keys\n            !this._inner.patterns.length &&\n            !this._inner.dependencies.length) {\n\n            return finish();\n        }\n\n        const unprocessed = new Set(Object.keys(target));\n\n        if (this._inner.children) {\n            const stripProps = [];\n\n            for (let i = 0; i < this._inner.children.length; ++i) {\n                const child = this._inner.children[i];\n                const key = child.key;\n                const item = target[key];\n\n                unprocessed.delete(key);\n\n                const localState = { key, path: state.path.concat(key), parent: target, reference: state.reference };\n                const result = child.schema._validate(item, localState, options);\n                if (result.errors) {\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\n\n                    if (options.abortEarly) {\n                        return finish();\n                    }\n                }\n                else {\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\n                        stripProps.push(key);\n                        target[key] = result.finalValue;\n                    }\n                    else if (result.value !== undefined) {\n                        target[key] = result.value;\n                    }\n                }\n            }\n\n            for (let i = 0; i < stripProps.length; ++i) {\n                delete target[stripProps[i]];\n            }\n        }\n\n        // Unknown keys\n\n        if (unprocessed.size && this._inner.patterns.length) {\n\n            for (const key of unprocessed) {\n                const localState = {\n                    key,\n                    path: state.path.concat(key),\n                    parent: target,\n                    reference: state.reference\n                };\n                const item = target[key];\n\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\n                    const pattern = this._inner.patterns[i];\n\n                    if (pattern.regex ?\n                        pattern.regex.test(key) :\n                        !pattern.schema.validate(key).error) {\n\n                        unprocessed.delete(key);\n\n                        const result = pattern.rule._validate(item, localState, options);\n                        if (result.errors) {\n                            errors.push(this.createError('object.child', {\n                                key,\n                                child: pattern.rule._getLabel(key),\n                                reason: result.errors\n                            }, localState, options));\n\n                            if (options.abortEarly) {\n                                return finish();\n                            }\n                        }\n\n                        target[key] = result.value;\n                    }\n                }\n            }\n        }\n\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\n                options.skipFunctions) {\n\n                const stripUnknown = options.stripUnknown\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\n                    : false;\n\n\n                for (const key of unprocessed) {\n                    if (stripUnknown) {\n                        delete target[key];\n                        unprocessed.delete(key);\n                    }\n                    else if (typeof target[key] === 'function') {\n                        unprocessed.delete(key);\n                    }\n                }\n            }\n\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\n\n                for (const unprocessedKey of unprocessed) {\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey }, {\n                        key: unprocessedKey,\n                        path: state.path.concat(unprocessedKey)\n                    }, options, {}));\n                }\n            }\n        }\n\n        // Validate dependencies\n\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\n            const dep = this._inner.dependencies[i];\n            const err = internals[dep.type].call(this, dep.key !== null && target[dep.key], dep.peers, target, { key: dep.key, path: dep.key === null ? state.path : state.path.concat(dep.key) }, options);\n            if (err instanceof Errors.Err) {\n                errors.push(err);\n                if (options.abortEarly) {\n                    return finish();\n                }\n            }\n        }\n\n        return finish();\n    }\n\n    keys(schema) {\n\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\n\n        const obj = this.clone();\n\n        if (!schema) {\n            obj._inner.children = null;\n            return obj;\n        }\n\n        const children = Object.keys(schema);\n\n        if (!children.length) {\n            obj._inner.children = [];\n            return obj;\n        }\n\n        const topo = new Topo();\n        if (obj._inner.children) {\n            for (let i = 0; i < obj._inner.children.length; ++i) {\n                const child = obj._inner.children[i];\n\n                // Only add the key if we are not going to replace it later\n                if (!children.includes(child.key)) {\n                    topo.add(child, { after: child._refs, group: child.key });\n                }\n            }\n        }\n\n        for (let i = 0; i < children.length; ++i) {\n            const key = children[i];\n            const child = schema[key];\n            try {\n                const cast = Cast.schema(this._currentJoi, child);\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\n            }\n            catch (castErr) {\n                if (castErr.hasOwnProperty('path')) {\n                    castErr.path = key + '.' + castErr.path;\n                }\n                else {\n                    castErr.path = key;\n                }\n                throw castErr;\n            }\n        }\n\n        obj._inner.children = topo.nodes;\n\n        return obj;\n    }\n\n    append(schema) {\n        // Skip any changes\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\n            return this;\n        }\n\n        return this.keys(schema);\n    }\n\n    unknown(allow) {\n\n        const value = allow !== false;\n\n        if (this._flags.allowUnknown === value) {\n            return this;\n        }\n\n        const obj = this.clone();\n        obj._flags.allowUnknown = value;\n        return obj;\n    }\n\n    length(limit) {\n\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\n        return this._test('length', limit, function (value, state, options) {\n\n            if (Object.keys(value).length === limit) {\n                return value;\n            }\n\n            return this.createError('object.length', { limit }, state, options);\n        });\n    }\n\n    min(limit) {\n\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\n        return this._test('min', limit, function (value, state, options) {\n\n            if (Object.keys(value).length >= limit) {\n                return value;\n            }\n\n            return this.createError('object.min', { limit }, state, options);\n        });\n    }\n\n    max(limit) {\n\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\n        return this._test('max', limit, function (value, state, options) {\n\n            if (Object.keys(value).length <= limit) {\n                return value;\n            }\n\n            return this.createError('object.max', { limit }, state, options);\n        });\n    }\n\n    pattern(pattern, schema) {\n\n        const isRegExp = pattern instanceof RegExp;\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\n        Hoek.assert(schema !== undefined, 'Invalid rule');\n\n        if (isRegExp) {\n            pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);         // Future version should break this and forbid unsupported regex flags\n        }\n\n        try {\n            schema = Cast.schema(this._currentJoi, schema);\n        }\n        catch (castErr) {\n            if (castErr.hasOwnProperty('path')) {\n                castErr.message = castErr.message + '(' + castErr.path + ')';\n            }\n\n            throw castErr;\n        }\n\n        const obj = this.clone();\n        if (isRegExp) {\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\n        }\n        else {\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\n        }\n        return obj;\n    }\n\n    schema() {\n\n        return this._test('schema', null, function (value, state, options) {\n\n            if (value instanceof Any) {\n                return value;\n            }\n\n            return this.createError('object.schema', null, state, options);\n        });\n    }\n\n    with(key, peers) {\n\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\n\n        return this._dependency('with', key, peers);\n    }\n\n    without(key, peers) {\n\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\n\n        return this._dependency('without', key, peers);\n    }\n\n    xor(...peers) {\n\n        peers = Hoek.flatten(peers);\n        return this._dependency('xor', null, peers);\n    }\n\n    or(...peers) {\n\n        peers = Hoek.flatten(peers);\n        return this._dependency('or', null, peers);\n    }\n\n    and(...peers) {\n\n        peers = Hoek.flatten(peers);\n        return this._dependency('and', null, peers);\n    }\n\n    nand(...peers) {\n\n        peers = Hoek.flatten(peers);\n        return this._dependency('nand', null, peers);\n    }\n\n    requiredKeys(...children) {\n\n        children = Hoek.flatten(children);\n        return this.applyFunctionToChildren(children, 'required');\n    }\n\n    optionalKeys(...children) {\n\n        children = Hoek.flatten(children);\n        return this.applyFunctionToChildren(children, 'optional');\n    }\n\n    forbiddenKeys(...children) {\n\n        children = Hoek.flatten(children);\n        return this.applyFunctionToChildren(children, 'forbidden');\n    }\n\n    rename(from, to, options) {\n\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\n\n        for (let i = 0; i < this._inner.renames.length; ++i) {\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\n        }\n\n        const obj = this.clone();\n\n        obj._inner.renames.push({\n            from,\n            to,\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\n            isRegExp: from instanceof RegExp\n        });\n\n        return obj;\n    }\n\n    applyFunctionToChildren(children, fn, args, root) {\n\n        children = [].concat(children);\n        Hoek.assert(children.length > 0, 'expected at least one children');\n\n        const groupedChildren = internals.groupChildren(children);\n        let obj;\n\n        if ('' in groupedChildren) {\n            obj = this[fn].apply(this, args);\n            delete groupedChildren[''];\n        }\n        else {\n            obj = this.clone();\n        }\n\n        if (obj._inner.children) {\n            root = root ? (root + '.') : '';\n\n            for (let i = 0; i < obj._inner.children.length; ++i) {\n                const child = obj._inner.children[i];\n                const group = groupedChildren[child.key];\n\n                if (group) {\n                    obj._inner.children[i] = {\n                        key: child.key,\n                        _refs: child._refs,\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\n                    };\n\n                    delete groupedChildren[child.key];\n                }\n            }\n        }\n\n        const remaining = Object.keys(groupedChildren);\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\n\n        return obj;\n    }\n\n    _dependency(type, key, peers) {\n\n        peers = [].concat(peers);\n        for (let i = 0; i < peers.length; ++i) {\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\n        }\n\n        const obj = this.clone();\n        obj._inner.dependencies.push({ type, key, peers });\n        return obj;\n    }\n\n    describe(shallow) {\n\n        const description = super.describe();\n\n        if (description.rules) {\n            for (let i = 0; i < description.rules.length; ++i) {\n                const rule = description.rules[i];\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\n                if (/* $lab:coverage:off$ */rule.arg &&\n                    typeof rule.arg === 'object' &&\n                    rule.arg.schema &&\n                    rule.arg.ref /* $lab:coverage:on$ */) {\n                    rule.arg = {\n                        schema: rule.arg.schema.describe(),\n                        ref: rule.arg.ref.toString()\n                    };\n                }\n            }\n        }\n\n        if (this._inner.children &&\n            !shallow) {\n\n            description.children = {};\n            for (let i = 0; i < this._inner.children.length; ++i) {\n                const child = this._inner.children[i];\n                description.children[child.key] = child.schema.describe();\n            }\n        }\n\n        if (this._inner.dependencies.length) {\n            description.dependencies = Hoek.clone(this._inner.dependencies);\n        }\n\n        if (this._inner.patterns.length) {\n            description.patterns = [];\n\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\n                const pattern = this._inner.patterns[i];\n                if (pattern.regex) {\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\n                }\n                else {\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\n                }\n            }\n        }\n\n        if (this._inner.renames.length > 0) {\n            description.renames = Hoek.clone(this._inner.renames);\n        }\n\n        return description;\n    }\n\n    assert(ref, schema, message) {\n\n        ref = Cast.ref(ref);\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\n        message = message || 'pass the assertion test';\n\n        try {\n            schema = Cast.schema(this._currentJoi, schema);\n        }\n        catch (castErr) {\n            if (castErr.hasOwnProperty('path')) {\n                castErr.message = castErr.message + '(' + castErr.path + ')';\n            }\n\n            throw castErr;\n        }\n\n        const key = ref.path[ref.path.length - 1];\n        const path = ref.path.join('.');\n\n        return this._test('assert', { schema, ref }, function (value, state, options) {\n\n            const result = schema._validate(ref(value), null, options, value);\n            if (!result.errors) {\n                return value;\n            }\n\n            const localState = Hoek.merge({}, state);\n            localState.key = key;\n            localState.path = ref.path;\n            return this.createError('object.assert', { ref: path, message }, localState, options);\n        });\n    }\n\n    type(constructor, name = constructor.name) {\n\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\n        const typeData = {\n            name,\n            ctor: constructor\n        };\n\n        return this._test('type', typeData, function (value, state, options) {\n\n            if (value instanceof constructor) {\n                return value;\n            }\n\n            return this.createError('object.type', { type: typeData.name }, state, options);\n        });\n    }\n};\n\ninternals.safeParse = function (value) {\n\n    try {\n        return JSON.parse(value);\n    }\n    catch (parseErr) {}\n\n    return value;\n};\n\n\ninternals.renameDefaults = {\n    alias: false,                   // Keep old value in place\n    multiple: false,                // Allow renaming multiple keys into the same target\n    override: false                 // Overrides an existing key\n};\n\n\ninternals.groupChildren = function (children) {\n\n    children.sort();\n\n    const grouped = {};\n\n    for (let i = 0; i < children.length; ++i) {\n        const child = children[i];\n        Hoek.assert(typeof child === 'string', 'children must be strings');\n        const group = child.split('.')[0];\n        const childGroup = grouped[group] = (grouped[group] || []);\n        childGroup.push(child.substring(group.length + 1));\n    }\n\n    return grouped;\n};\n\n\ninternals.keysToLabels = function (schema, keys) {\n\n    const children = schema._inner.children;\n\n    if (!children) {\n        return keys;\n    }\n\n    const findLabel = function (key) {\n\n        const matchingChild = children.find((child) => child.key === key);\n        return matchingChild ? matchingChild.schema._getLabel(key) : key;\n    };\n\n    if (Array.isArray(keys)) {\n        return keys.map(findLabel);\n    }\n\n    return findLabel(keys);\n};\n\n\ninternals.with = function (value, peers, parent, state, options) {\n\n    if (value === undefined) {\n        return value;\n    }\n\n    for (let i = 0; i < peers.length; ++i) {\n        const peer = peers[i];\n        if (!Object.prototype.hasOwnProperty.call(parent, peer) ||\n            parent[peer] === undefined) {\n\n            return this.createError('object.with', {\n                main: state.key,\n                mainWithLabel: internals.keysToLabels(this, state.key),\n                peer,\n                peerWithLabel: internals.keysToLabels(this, peer)\n            }, state, options);\n        }\n    }\n\n    return value;\n};\n\n\ninternals.without = function (value, peers, parent, state, options) {\n\n    if (value === undefined) {\n        return value;\n    }\n\n    for (let i = 0; i < peers.length; ++i) {\n        const peer = peers[i];\n        if (Object.prototype.hasOwnProperty.call(parent, peer) &&\n            parent[peer] !== undefined) {\n\n            return this.createError('object.without', {\n                main: state.key,\n                mainWithLabel: internals.keysToLabels(this, state.key),\n                peer,\n                peerWithLabel: internals.keysToLabels(this, peer)\n            }, state, options);\n        }\n    }\n\n    return value;\n};\n\n\ninternals.xor = function (value, peers, parent, state, options) {\n\n    const present = [];\n    for (let i = 0; i < peers.length; ++i) {\n        const peer = peers[i];\n        if (Object.prototype.hasOwnProperty.call(parent, peer) &&\n            parent[peer] !== undefined) {\n\n            present.push(peer);\n        }\n    }\n\n    if (present.length === 1) {\n        return value;\n    }\n\n    const context = { peers, peersWithLabels: internals.keysToLabels(this, peers) };\n\n    if (present.length === 0) {\n        return this.createError('object.missing', context, state, options);\n    }\n\n    return this.createError('object.xor', context, state, options);\n};\n\n\ninternals.or = function (value, peers, parent, state, options) {\n\n    for (let i = 0; i < peers.length; ++i) {\n        const peer = peers[i];\n        if (Object.prototype.hasOwnProperty.call(parent, peer) &&\n            parent[peer] !== undefined) {\n            return value;\n        }\n    }\n\n    return this.createError('object.missing', {\n        peers,\n        peersWithLabels: internals.keysToLabels(this, peers)\n    }, state, options);\n};\n\n\ninternals.and = function (value, peers, parent, state, options) {\n\n    const missing = [];\n    const present = [];\n    const count = peers.length;\n    for (let i = 0; i < count; ++i) {\n        const peer = peers[i];\n        if (!Object.prototype.hasOwnProperty.call(parent, peer) ||\n            parent[peer] === undefined) {\n\n            missing.push(peer);\n        }\n        else {\n            present.push(peer);\n        }\n    }\n\n    const aon = (missing.length === count || present.length === count);\n\n    if (!aon) {\n\n        return this.createError('object.and', {\n            present,\n            presentWithLabels: internals.keysToLabels(this, present),\n            missing,\n            missingWithLabels: internals.keysToLabels(this, missing)\n        }, state, options);\n    }\n};\n\n\ninternals.nand = function (value, peers, parent, state, options) {\n\n    const present = [];\n    for (let i = 0; i < peers.length; ++i) {\n        const peer = peers[i];\n        if (Object.prototype.hasOwnProperty.call(parent, peer) &&\n            parent[peer] !== undefined) {\n\n            present.push(peer);\n        }\n    }\n\n    const values = Hoek.clone(peers);\n    const main = values.splice(0, 1)[0];\n    const allPresent = (present.length === peers.length);\n    return allPresent ? this.createError('object.nand', {\n        main,\n        mainWithLabel: internals.keysToLabels(this, main),\n        peers: values,\n        peersWithLabels: internals.keysToLabels(this, values)\n    }, state, options) : null;\n};\n\n\nmodule.exports = new internals.Object();\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}
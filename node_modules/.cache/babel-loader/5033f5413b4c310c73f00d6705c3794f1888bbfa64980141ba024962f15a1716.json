{"ast":null,"code":"'use strict';\n\n/**\n * filesystem helpers module\n * @module utils/fs\n */\nconst fse = require('fs-extra');\nconst _ = require('lodash');\nconst path = require('path');\nfunction Fs() {}\nFs.prototype = Object.create(fse);\nFs.prototype.formatFileArray = formatFileArray;\nFs.prototype.loadModules = loadModules;\nFs.prototype.dirContent = dirContent;\nFs.prototype.resolvePaths = resolvePaths;\nFs.prototype.canRead = canRead;\nFs.prototype.fileName = fileName;\n\n/**\n * takes a file paths array and format it\n * then return an array of objects contains\n * all the available information about the files\n * @param {string[]} filesPath array of strings contains file paths\n * @returns {object[]} array of objects contains the files information\n * @instance\n */\nfunction formatFileArray(filesPath) {\n  return _.map(filesPath, filePath => {\n    return {\n      name: fileName(filePath),\n      path: filePath,\n      extension: path.extname(filePath).replace('.', '')\n    };\n  });\n}\n\n// load modules from the given paths array\nfunction _loadModules(filesPath) {\n  return _.map(filesPath, filePath => {\n    return {\n      path: filePath,\n      /* eslint global-require: off */\n      data: require(filePath)\n    };\n  });\n}\n// load and format modules\nfunction _loadModulesAndFormat(filesPath) {\n  // format the paths array to split information, e.g name, path, ext...etc\n  const formattedPathsArray = formatFileArray(filesPath);\n\n  // load all modules\n  const modules = _loadModules(filesPath);\n\n  // add the loaded modules data to the formatted array\n  _.forEach(modules, file => {\n    const formattedPath = _.find(formattedPathsArray, x => x.path === file.path);\n    formattedPath.data = file.data;\n  });\n  return formattedPathsArray;\n}\n\n/**\n * load modules with the given paths array\n * @param {string[]} filesPath array of strings contains file paths\n * @param {boolean} format true if you want to format the returned module data object\n * @returns {object[]} array of objects contains the files content and path\n * in addition to extension and name if the param format >> true\n * @instance\n */\nfunction loadModules(filesPath, format) {\n  let result = null;\n  const isArray = _.isArray(filesPath);\n  if (!isArray) {\n    filesPath = [filesPath];\n  }\n  if (format) {\n    result = _loadModulesAndFormat(filesPath);\n  } else {\n    result = _loadModules(filesPath);\n  }\n  if (!isArray) {\n    result = _.head(result);\n  }\n  return result;\n}\n\n/**\n * get the content of a given directory,\n * and return all sub folders and files\n * @param {string} location directory location\n * @return {object[]} array of objects contains\n * all the sub folders and files for the given directory\n * @instance\n */\nasync function dirContent(location) {\n  const content = await this.readdir(location);\n  const folders = [],\n    files = [];\n  _.forEach(content, x => {\n    if (_.indexOf(x, '.') > -1) {\n      files.push(x);\n    } else {\n      folders.push(x);\n    }\n  });\n  return {\n    folders,\n    files\n  };\n}\n\n/**\n * resolve an array of paths using a prefix\n * @param {string[]} paths string array contains paths to resolve\n * @param {string} prefix a prefix to resolve for all the given paths\n * @param {function} fn the handler function, will be called with each resolved path\n * @returns {string[]} array of strings represent the resolved paths\n * @instance\n */\nfunction resolvePaths(paths, prefix, fn) {\n  const resolved = [];\n  _.forEach(paths, (pathInfo, key) => {\n    const resolvedPath = path.resolve(prefix, pathInfo);\n    if (_.isFunction(fn)) {\n      fn(resolvedPath, key);\n    }\n    resolved.push(resolvedPath);\n  });\n  return resolved;\n}\n\n/**\n * check read permissions for the given file or directory path\n * @param {string} location file or directory path\n * @return {boolean} true if you have read access, otherwise false\n */\nasync function canRead(location) {\n  try {\n    await this.access(location, this.constants.R_OK);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * get the file name without the full path or the extension\n * @param {string} filePath file path\n * @return {string} the file name\n */\nfunction fileName(filePath) {\n  return path.basename(filePath, path.extname(filePath));\n}\nmodule.exports = new Fs();","map":{"version":3,"names":["fse","require","_","path","Fs","prototype","Object","create","formatFileArray","loadModules","dirContent","resolvePaths","canRead","fileName","filesPath","map","filePath","name","extension","extname","replace","_loadModules","data","_loadModulesAndFormat","formattedPathsArray","modules","forEach","file","formattedPath","find","x","format","result","isArray","head","location","content","readdir","folders","files","indexOf","push","paths","prefix","fn","resolved","pathInfo","key","resolvedPath","resolve","isFunction","access","constants","R_OK","e","basename","module","exports"],"sources":["/Users/mariovicky/Skripsi_OpenLayers/node_modules/arc.js/utils/fs.js"],"sourcesContent":["'use strict';\n\n/**\n * filesystem helpers module\n * @module utils/fs\n */\n\nconst fse = require('fs-extra');\nconst _ = require('lodash');\nconst path = require('path');\n\nfunction Fs () {}\n\nFs.prototype = Object.create(fse);\nFs.prototype.formatFileArray = formatFileArray;\nFs.prototype.loadModules = loadModules;\nFs.prototype.dirContent = dirContent;\nFs.prototype.resolvePaths = resolvePaths;\nFs.prototype.canRead = canRead;\nFs.prototype.fileName = fileName;\n\n/**\n * takes a file paths array and format it\n * then return an array of objects contains\n * all the available information about the files\n * @param {string[]} filesPath array of strings contains file paths\n * @returns {object[]} array of objects contains the files information\n * @instance\n */\nfunction formatFileArray (filesPath) {\n  return _.map(filesPath, (filePath) => {\n    return {\n      name: fileName(filePath),\n      path: filePath,\n      extension: path.extname(filePath).replace('.', '')\n    };\n  });\n}\n\n// load modules from the given paths array\nfunction _loadModules (filesPath) {\n  return _.map(filesPath, (filePath) => {\n    return {\n      path: filePath,\n      /* eslint global-require: off */\n      data: require(filePath)\n    };\n  });\n}\n// load and format modules\nfunction _loadModulesAndFormat (filesPath) {\n  // format the paths array to split information, e.g name, path, ext...etc\n  const formattedPathsArray = formatFileArray(filesPath);\n\n  // load all modules\n  const modules = _loadModules(filesPath);\n\n  // add the loaded modules data to the formatted array\n  _.forEach(modules, (file) => {\n    const formattedPath = _.find(\n      formattedPathsArray,\n      (x) => x.path === file.path\n    );\n    formattedPath.data = file.data;\n  });\n\n  return formattedPathsArray;\n\n}\n\n\n/**\n * load modules with the given paths array\n * @param {string[]} filesPath array of strings contains file paths\n * @param {boolean} format true if you want to format the returned module data object\n * @returns {object[]} array of objects contains the files content and path\n * in addition to extension and name if the param format >> true\n * @instance\n */\nfunction loadModules (filesPath, format) {\n\n  let result = null;\n  const isArray = _.isArray(filesPath);\n\n  if (!isArray) {\n    filesPath = [filesPath];\n  }\n\n  if (format) {\n    result = _loadModulesAndFormat(filesPath);\n  }\n  else {\n    result = _loadModules(filesPath);\n  }\n\n  if (!isArray) {\n    result = _.head(result);\n  }\n\n  return result;\n}\n\n\n/**\n * get the content of a given directory,\n * and return all sub folders and files\n * @param {string} location directory location\n * @return {object[]} array of objects contains\n * all the sub folders and files for the given directory\n * @instance\n */\nasync function dirContent (location) {\n  const content = await this.readdir(location);\n  const folders = [],\n    files = [];\n\n  _.forEach(content, (x) => {\n    if (_.indexOf(x, '.') > -1) {\n      files.push(x);\n    }\n    else {\n      folders.push(x);\n    }\n  });\n\n  return {\n    folders,\n    files\n  };\n}\n\n/**\n * resolve an array of paths using a prefix\n * @param {string[]} paths string array contains paths to resolve\n * @param {string} prefix a prefix to resolve for all the given paths\n * @param {function} fn the handler function, will be called with each resolved path\n * @returns {string[]} array of strings represent the resolved paths\n * @instance\n */\nfunction resolvePaths (paths, prefix, fn) {\n  const resolved = [];\n  _.forEach(paths, (pathInfo, key) => {\n    const resolvedPath = path.resolve(prefix, pathInfo);\n    if (_.isFunction(fn)) {\n      fn(resolvedPath, key);\n    }\n    resolved.push(resolvedPath);\n  });\n  return resolved;\n}\n\n/**\n * check read permissions for the given file or directory path\n * @param {string} location file or directory path\n * @return {boolean} true if you have read access, otherwise false\n */\nasync function canRead (location) {\n  try {\n    await this.access(location, this.constants.R_OK);\n    return true;\n  }\n  catch (e) {\n    return false;\n  }\n}\n\n/**\n * get the file name without the full path or the extension\n * @param {string} filePath file path\n * @return {string} the file name\n */\nfunction fileName (filePath) {\n  return path.basename(filePath, path.extname(filePath));\n}\n\nmodule.exports = new Fs();\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}
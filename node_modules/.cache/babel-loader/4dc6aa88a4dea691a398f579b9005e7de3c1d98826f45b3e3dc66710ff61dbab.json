{"ast":null,"code":"/**\n * @module ol/geom/flat/segments\n */\n/**\n * This function calls `callback` for each segment of the flat coordinates\n * array. If the callback returns a truthy value the function returns that\n * value immediately. Otherwise the function returns `false`.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {function(import(\"../../coordinate.js\").Coordinate, import(\"../../coordinate.js\").Coordinate): T} callback Function\n *     called for each segment.\n * @return {T|boolean} Value.\n * @template T\n */\nexport function forEach(flatCoordinates, offset, end, stride, callback) {\n  var point1 = [flatCoordinates[offset], flatCoordinates[offset + 1]];\n  var point2 = [];\n  var ret;\n  for (; offset + stride < end; offset += stride) {\n    point2[0] = flatCoordinates[offset + stride];\n    point2[1] = flatCoordinates[offset + stride + 1];\n    ret = callback(point1, point2);\n    if (ret) {\n      return ret;\n    }\n    point1[0] = point2[0];\n    point1[1] = point2[1];\n  }\n  return false;\n}","map":{"version":3,"names":["forEach","flatCoordinates","offset","end","stride","callback","point1","point2","ret"],"sources":["/Users/mariovicky/Skripsi_OpenLayers/node_modules/ol/src/geom/flat/segments.js"],"sourcesContent":["/**\n * @module ol/geom/flat/segments\n */\n\n/**\n * This function calls `callback` for each segment of the flat coordinates\n * array. If the callback returns a truthy value the function returns that\n * value immediately. Otherwise the function returns `false`.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {function(import(\"../../coordinate.js\").Coordinate, import(\"../../coordinate.js\").Coordinate): T} callback Function\n *     called for each segment.\n * @return {T|boolean} Value.\n * @template T\n */\nexport function forEach(flatCoordinates, offset, end, stride, callback) {\n  const point1 = [flatCoordinates[offset], flatCoordinates[offset + 1]];\n  const point2 = [];\n  let ret;\n  for (; offset + stride < end; offset += stride) {\n    point2[0] = flatCoordinates[offset + stride];\n    point2[1] = flatCoordinates[offset + stride + 1];\n    ret = callback(point1, point2);\n    if (ret) {\n      return ret;\n    }\n    point1[0] = point2[0];\n    point1[1] = point2[1];\n  }\n  return false;\n}\n"],"mappings":"AAAA;;;AAIA;;;;;;;;;;;;;AAaA,OAAM,SAAUA,OAAOA,CAACC,eAAe,EAAEC,MAAM,EAAEC,GAAG,EAAEC,MAAM,EAAEC,QAAQ;EACpE,IAAMC,MAAM,GAAG,CAACL,eAAe,CAACC,MAAM,CAAC,EAAED,eAAe,CAACC,MAAM,GAAG,CAAC,CAAC,CAAC;EACrE,IAAMK,MAAM,GAAG,EAAE;EACjB,IAAIC,GAAG;EACP,OAAON,MAAM,GAAGE,MAAM,GAAGD,GAAG,EAAED,MAAM,IAAIE,MAAM,EAAE;IAC9CG,MAAM,CAAC,CAAC,CAAC,GAAGN,eAAe,CAACC,MAAM,GAAGE,MAAM,CAAC;IAC5CG,MAAM,CAAC,CAAC,CAAC,GAAGN,eAAe,CAACC,MAAM,GAAGE,MAAM,GAAG,CAAC,CAAC;IAChDI,GAAG,GAAGH,QAAQ,CAACC,MAAM,EAAEC,MAAM,CAAC;IAC9B,IAAIC,GAAG,EAAE;MACP,OAAOA,GAAG;;IAEZF,MAAM,CAAC,CAAC,CAAC,GAAGC,MAAM,CAAC,CAAC,CAAC;IACrBD,MAAM,CAAC,CAAC,CAAC,GAAGC,MAAM,CAAC,CAAC,CAAC;;EAEvB,OAAO,KAAK;AACd"},"metadata":{},"sourceType":"module","externalDependencies":[]}
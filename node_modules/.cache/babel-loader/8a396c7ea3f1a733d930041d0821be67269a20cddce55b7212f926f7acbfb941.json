{"ast":null,"code":"/**\n * @module ol/source/Cluster\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport EventType from '../events/EventType.js';\nimport Feature from '../Feature.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport Point from '../geom/Point.js';\nimport VectorSource from './Vector.js';\nimport { add as addCoordinate, scale as scaleCoordinate } from '../coordinate.js';\nimport { assert } from '../asserts.js';\nimport { buffer, createEmpty, createOrUpdateFromCoordinate } from '../extent.js';\nimport { getUid } from '../util.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {number} [distance=20] Minimum distance in pixels between clusters.\n * @property {function(Feature):Point} [geometryFunction]\n * Function that takes an {@link module:ol/Feature} as argument and returns an\n * {@link module:ol/geom/Point} as cluster calculation point for the feature. When a\n * feature should not be considered for clustering, the function should return\n * `null`. The default, which works when the underyling source contains point\n * features only, is\n * ```js\n * function(feature) {\n *   return feature.getGeometry();\n * }\n * ```\n * See {@link module:ol/geom/Polygon~Polygon#getInteriorPoint} for a way to get a cluster\n * calculation point for polygons.\n * @property {VectorSource} [source] Source.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n */\n/**\n * @classdesc\n * Layer source to cluster vector data. Works out of the box with point\n * geometries. For other geometry types, or if not all geometries should be\n * considered for clustering, a custom `geometryFunction` can be defined.\n *\n * If the instance is disposed without also disposing the underlying\n * source `setSource(null)` has to be called to remove the listener reference\n * from the wrapped source.\n * @api\n */\nvar Cluster = /** @class */function (_super) {\n  __extends(Cluster, _super);\n  /**\n   * @param {Options} options Cluster options.\n   */\n  function Cluster(options) {\n    var _this = _super.call(this, {\n      attributions: options.attributions,\n      wrapX: options.wrapX\n    }) || this;\n    /**\n     * @type {number|undefined}\n     * @protected\n     */\n    _this.resolution = undefined;\n    /**\n     * @type {number}\n     * @protected\n     */\n    _this.distance = options.distance !== undefined ? options.distance : 20;\n    /**\n     * @type {Array<Feature>}\n     * @protected\n     */\n    _this.features = [];\n    /**\n     * @param {Feature} feature Feature.\n     * @return {Point} Cluster calculation point.\n     * @protected\n     */\n    _this.geometryFunction = options.geometryFunction || function (feature) {\n      var geometry = feature.getGeometry();\n      assert(geometry.getType() == GeometryType.POINT, 10); // The default `geometryFunction` can only handle `Point` geometries\n      return geometry;\n    };\n    _this.boundRefresh_ = _this.refresh.bind(_this);\n    _this.setSource(options.source || null);\n    return _this;\n  }\n  /**\n   * Remove all features from the source.\n   * @param {boolean=} opt_fast Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#removefeature} events.\n   * @api\n   */\n  Cluster.prototype.clear = function (opt_fast) {\n    this.features.length = 0;\n    _super.prototype.clear.call(this, opt_fast);\n  };\n  /**\n   * Get the distance in pixels between clusters.\n   * @return {number} Distance.\n   * @api\n   */\n  Cluster.prototype.getDistance = function () {\n    return this.distance;\n  };\n  /**\n   * Get a reference to the wrapped source.\n   * @return {VectorSource} Source.\n   * @api\n   */\n  Cluster.prototype.getSource = function () {\n    return this.source;\n  };\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   */\n  Cluster.prototype.loadFeatures = function (extent, resolution, projection) {\n    this.source.loadFeatures(extent, resolution, projection);\n    if (resolution !== this.resolution) {\n      this.clear();\n      this.resolution = resolution;\n      this.cluster();\n      this.addFeatures(this.features);\n    }\n  };\n  /**\n   * Set the distance in pixels between clusters.\n   * @param {number} distance The distance in pixels.\n   * @api\n   */\n  Cluster.prototype.setDistance = function (distance) {\n    this.distance = distance;\n    this.refresh();\n  };\n  /**\n   * Replace the wrapped source.\n   * @param {VectorSource} source The new source for this instance.\n   * @api\n   */\n  Cluster.prototype.setSource = function (source) {\n    if (this.source) {\n      this.source.removeEventListener(EventType.CHANGE, this.boundRefresh_);\n    }\n    this.source = source;\n    if (source) {\n      source.addEventListener(EventType.CHANGE, this.boundRefresh_);\n    }\n    this.refresh();\n  };\n  /**\n   * Handle the source changing.\n   */\n  Cluster.prototype.refresh = function () {\n    this.clear();\n    this.cluster();\n    this.addFeatures(this.features);\n  };\n  /**\n   * @protected\n   */\n  Cluster.prototype.cluster = function () {\n    if (this.resolution === undefined || !this.source) {\n      return;\n    }\n    var extent = createEmpty();\n    var mapDistance = this.distance * this.resolution;\n    var features = this.source.getFeatures();\n    /**\n     * @type {!Object<string, boolean>}\n     */\n    var clustered = {};\n    for (var i = 0, ii = features.length; i < ii; i++) {\n      var feature = features[i];\n      if (!(getUid(feature) in clustered)) {\n        var geometry = this.geometryFunction(feature);\n        if (geometry) {\n          var coordinates = geometry.getCoordinates();\n          createOrUpdateFromCoordinate(coordinates, extent);\n          buffer(extent, mapDistance, extent);\n          var neighbors = this.source.getFeaturesInExtent(extent);\n          neighbors = neighbors.filter(function (neighbor) {\n            var uid = getUid(neighbor);\n            if (!(uid in clustered)) {\n              clustered[uid] = true;\n              return true;\n            } else {\n              return false;\n            }\n          });\n          this.features.push(this.createCluster(neighbors));\n        }\n      }\n    }\n  };\n  /**\n   * @param {Array<Feature>} features Features\n   * @return {Feature} The cluster feature.\n   * @protected\n   */\n  Cluster.prototype.createCluster = function (features) {\n    var centroid = [0, 0];\n    for (var i = features.length - 1; i >= 0; --i) {\n      var geometry = this.geometryFunction(features[i]);\n      if (geometry) {\n        addCoordinate(centroid, geometry.getCoordinates());\n      } else {\n        features.splice(i, 1);\n      }\n    }\n    scaleCoordinate(centroid, 1 / features.length);\n    var cluster = new Feature(new Point(centroid));\n    cluster.set('features', features);\n    return cluster;\n  };\n  return Cluster;\n}(VectorSource);\nexport default Cluster;","map":{"version":3,"names":["EventType","Feature","GeometryType","Point","VectorSource","add","addCoordinate","scale","scaleCoordinate","assert","buffer","createEmpty","createOrUpdateFromCoordinate","getUid","Cluster","_super","__extends","options","_this","call","attributions","wrapX","resolution","undefined","distance","features","geometryFunction","feature","geometry","getGeometry","getType","POINT","boundRefresh_","refresh","bind","setSource","source","prototype","clear","opt_fast","length","getDistance","getSource","loadFeatures","extent","projection","cluster","addFeatures","setDistance","removeEventListener","CHANGE","addEventListener","mapDistance","getFeatures","clustered","i","ii","coordinates","getCoordinates","neighbors","getFeaturesInExtent","filter","neighbor","uid","push","createCluster","centroid","splice","set"],"sources":["/Users/mariovicky/Skripsi_OpenLayers/node_modules/ol/src/source/Cluster.js"],"sourcesContent":["/**\n * @module ol/source/Cluster\n */\n\nimport EventType from '../events/EventType.js';\nimport Feature from '../Feature.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport Point from '../geom/Point.js';\nimport VectorSource from './Vector.js';\nimport {add as addCoordinate, scale as scaleCoordinate} from '../coordinate.js';\nimport {assert} from '../asserts.js';\nimport {buffer, createEmpty, createOrUpdateFromCoordinate} from '../extent.js';\nimport {getUid} from '../util.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {number} [distance=20] Minimum distance in pixels between clusters.\n * @property {function(Feature):Point} [geometryFunction]\n * Function that takes an {@link module:ol/Feature} as argument and returns an\n * {@link module:ol/geom/Point} as cluster calculation point for the feature. When a\n * feature should not be considered for clustering, the function should return\n * `null`. The default, which works when the underyling source contains point\n * features only, is\n * ```js\n * function(feature) {\n *   return feature.getGeometry();\n * }\n * ```\n * See {@link module:ol/geom/Polygon~Polygon#getInteriorPoint} for a way to get a cluster\n * calculation point for polygons.\n * @property {VectorSource} [source] Source.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n */\n\n/**\n * @classdesc\n * Layer source to cluster vector data. Works out of the box with point\n * geometries. For other geometry types, or if not all geometries should be\n * considered for clustering, a custom `geometryFunction` can be defined.\n *\n * If the instance is disposed without also disposing the underlying\n * source `setSource(null)` has to be called to remove the listener reference\n * from the wrapped source.\n * @api\n */\nclass Cluster extends VectorSource {\n  /**\n   * @param {Options} options Cluster options.\n   */\n  constructor(options) {\n    super({\n      attributions: options.attributions,\n      wrapX: options.wrapX,\n    });\n\n    /**\n     * @type {number|undefined}\n     * @protected\n     */\n    this.resolution = undefined;\n\n    /**\n     * @type {number}\n     * @protected\n     */\n    this.distance = options.distance !== undefined ? options.distance : 20;\n\n    /**\n     * @type {Array<Feature>}\n     * @protected\n     */\n    this.features = [];\n\n    /**\n     * @param {Feature} feature Feature.\n     * @return {Point} Cluster calculation point.\n     * @protected\n     */\n    this.geometryFunction =\n      options.geometryFunction ||\n      function (feature) {\n        const geometry = feature.getGeometry();\n        assert(geometry.getType() == GeometryType.POINT, 10); // The default `geometryFunction` can only handle `Point` geometries\n        return geometry;\n      };\n\n    this.boundRefresh_ = this.refresh.bind(this);\n\n    this.setSource(options.source || null);\n  }\n\n  /**\n   * Remove all features from the source.\n   * @param {boolean=} opt_fast Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#removefeature} events.\n   * @api\n   */\n  clear(opt_fast) {\n    this.features.length = 0;\n    super.clear(opt_fast);\n  }\n\n  /**\n   * Get the distance in pixels between clusters.\n   * @return {number} Distance.\n   * @api\n   */\n  getDistance() {\n    return this.distance;\n  }\n\n  /**\n   * Get a reference to the wrapped source.\n   * @return {VectorSource} Source.\n   * @api\n   */\n  getSource() {\n    return this.source;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   */\n  loadFeatures(extent, resolution, projection) {\n    this.source.loadFeatures(extent, resolution, projection);\n    if (resolution !== this.resolution) {\n      this.clear();\n      this.resolution = resolution;\n      this.cluster();\n      this.addFeatures(this.features);\n    }\n  }\n\n  /**\n   * Set the distance in pixels between clusters.\n   * @param {number} distance The distance in pixels.\n   * @api\n   */\n  setDistance(distance) {\n    this.distance = distance;\n    this.refresh();\n  }\n\n  /**\n   * Replace the wrapped source.\n   * @param {VectorSource} source The new source for this instance.\n   * @api\n   */\n  setSource(source) {\n    if (this.source) {\n      this.source.removeEventListener(EventType.CHANGE, this.boundRefresh_);\n    }\n    this.source = source;\n    if (source) {\n      source.addEventListener(EventType.CHANGE, this.boundRefresh_);\n    }\n    this.refresh();\n  }\n\n  /**\n   * Handle the source changing.\n   */\n  refresh() {\n    this.clear();\n    this.cluster();\n    this.addFeatures(this.features);\n  }\n\n  /**\n   * @protected\n   */\n  cluster() {\n    if (this.resolution === undefined || !this.source) {\n      return;\n    }\n    const extent = createEmpty();\n    const mapDistance = this.distance * this.resolution;\n    const features = this.source.getFeatures();\n\n    /**\n     * @type {!Object<string, boolean>}\n     */\n    const clustered = {};\n\n    for (let i = 0, ii = features.length; i < ii; i++) {\n      const feature = features[i];\n      if (!(getUid(feature) in clustered)) {\n        const geometry = this.geometryFunction(feature);\n        if (geometry) {\n          const coordinates = geometry.getCoordinates();\n          createOrUpdateFromCoordinate(coordinates, extent);\n          buffer(extent, mapDistance, extent);\n\n          let neighbors = this.source.getFeaturesInExtent(extent);\n          neighbors = neighbors.filter(function (neighbor) {\n            const uid = getUid(neighbor);\n            if (!(uid in clustered)) {\n              clustered[uid] = true;\n              return true;\n            } else {\n              return false;\n            }\n          });\n          this.features.push(this.createCluster(neighbors));\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {Array<Feature>} features Features\n   * @return {Feature} The cluster feature.\n   * @protected\n   */\n  createCluster(features) {\n    const centroid = [0, 0];\n    for (let i = features.length - 1; i >= 0; --i) {\n      const geometry = this.geometryFunction(features[i]);\n      if (geometry) {\n        addCoordinate(centroid, geometry.getCoordinates());\n      } else {\n        features.splice(i, 1);\n      }\n    }\n    scaleCoordinate(centroid, 1 / features.length);\n\n    const cluster = new Feature(new Point(centroid));\n    cluster.set('features', features);\n    return cluster;\n  }\n}\n\nexport default Cluster;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}